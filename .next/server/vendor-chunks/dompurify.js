"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dompurify";
exports.ids = ["vendor-chunks/dompurify"];
exports.modules = {

/***/ "(ssr)/./node_modules/dompurify/dist/purify.es.js":
/*!**************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ purify)\n/* harmony export */ });\n/*! @license DOMPurify 3.0.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.5/LICENSE */ const { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!apply) {\n    apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n    };\n}\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!construct) {\n    construct = function construct(Func, args) {\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\nfunction unapply(func) {\n    return function(thisArg) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n    };\n}\nfunction unconstruct(func) {\n    return function() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n    };\n}\n/* Add properties to a lookup table */ function addToSet(set, array, transformCaseFunc) {\n    var _transformCaseFunc;\n    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/* Shallow clone an object */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        newObject[property] = value;\n    }\n    return newObject;\n}\n/* This method automatically checks if the prop is function\n * or getter and behaves accordingly. */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue(element) {\n        console.warn(\"fallback value for\", element);\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]); // SVG\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]); // List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]); // Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n});\nconst getGlobal = ()=> true ? null : 0;\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */ DOMPurify.version = \"3.0.5\";\n    /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */ DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== 9) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    const originalDocument = window1.document;\n    const currentScript = originalDocument.currentScript;\n    let { document } = window1;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\"); // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = {};\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = \"ALLOWED_TAGS\" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = \"ALLOWED_ATTR\" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = \"ALLOWED_NAMESPACES\" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = \"ADD_URI_SAFE_ATTR\" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n         : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = \"ADD_DATA_URI_TAGS\" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n         : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = \"FORBID_CONTENTS\" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = \"FORBID_TAGS\" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = \"FORBID_ATTR\" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = \"USE_PROFILES\" in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, [\n                ...text\n            ]);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                ALLOWED_TAGS = clone(ALLOWED_TAGS);\n            }\n            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                ALLOWED_ATTR = clone(ALLOWED_ATTR);\n            }\n            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            } // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            } // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        } // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    const HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"foreignobject\",\n        \"desc\",\n        \"title\",\n        \"annotation-xml\"\n    ]); // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            } // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            } // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            } // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            } // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            } // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        } // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        } // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            node.parentNode.removeChild(node);\n        } catch (_) {\n            node.remove();\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: node.getAttributeNode(name),\n                from: node\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: node\n            });\n        }\n        node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n        if (name === \"is\" && !ALLOWED_ATTR[name]) {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(node);\n                } catch (_) {}\n            } else {\n                try {\n                    node.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc;\n        let leadingWhitespace;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {}\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */ const _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== \"string\" || typeof elm.textContent !== \"string\" || typeof elm.removeChild !== \"function\" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== \"function\" || typeof elm.setAttribute !== \"function\" || typeof elm.namespaceURI !== \"string\" || typeof elm.insertBefore !== \"function\" || typeof elm.hasChildNodes !== \"function\");\n    };\n    /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */ const _isNode = function _isNode(object) {\n        return typeof Node === \"object\" ? object instanceof Node : object && typeof object === \"object\" && typeof object.nodeType === \"number\" && typeof object.nodeName === \"string\";\n    };\n    /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */ const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n            return;\n        }\n        arrayForEach(hooks[entryPoint], (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    };\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content;\n        /* Execute a hook if present */ _executeHook(\"beforeSanitizeElements\", currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHook(\"uponSanitizeElement\", currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            content = stringReplace(content, MUSTACHE_EXPR, \" \");\n            content = stringReplace(content, ERB_EXPR, \" \");\n            content = stringReplace(content, TMPLIT_EXPR, \" \");\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHook(\"afterSanitizeElements\", currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _basicCustomElementCheck\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   * @param {string} tagName name of the tag of the node to sanitize\n   */ const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf(\"-\") > 0;\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        let attr;\n        let value;\n        let lcName;\n        let l;\n        /* Execute a hook if present */ _executeHook(\"beforeSanitizeAttributes\", currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            attr = attributes[l];\n            const { name, namespaceURI } = attr;\n            value = name === \"value\" ? attr.value : stringTrim(attr.value);\n            lcName = transformCaseFunc(name);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHook(\"uponSanitizeAttribute\", currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Remove attribute */ _removeAttribute(name, currentNode);\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                value = stringReplace(value, MUSTACHE_EXPR, \" \");\n                value = stringReplace(value, ERB_EXPR, \" \");\n                value = stringReplace(value, TMPLIT_EXPR, \" \");\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                continue;\n            }\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ try {\n                if (namespaceURI) {\n                    currentNode.setAttributeNS(namespaceURI, name, value);\n                } else {\n                    /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                }\n                arrayPop(DOMPurify.removed);\n            } catch (_) {}\n        }\n        /* Execute a hook if present */ _executeHook(\"afterSanitizeAttributes\", currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode;\n        const shadowIterator = _createIterator(fragment);\n        /* Execute a hook if present */ _executeHook(\"beforeSanitizeShadowDOM\", fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHook(\"uponSanitizeShadowNode\", shadowNode, null);\n            /* Sanitize tags and elements */ if (_sanitizeElements(shadowNode)) {\n                continue;\n            }\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n            /* Check attributes, sanitize if necessary */ _sanitizeAttributes(shadowNode);\n        }\n        /* Execute a hook if present */ _executeHook(\"afterSanitizeShadowDOM\", fragment, null);\n    };\n    /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */ // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body;\n        let importedNode;\n        let currentNode;\n        let returnNode;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === 1 && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ if (_sanitizeElements(currentNode)) {\n                continue;\n            }\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n            /* Check attributes, sanitize if necessary */ _sanitizeAttributes(currentNode);\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, \" \");\n            serializedHTML = stringReplace(serializedHTML, ERB_EXPR, \" \");\n            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, \" \");\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */ DOMPurify.setConfig = function(cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */ DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */ DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */ DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   * @return {Function} removed(popped) hook\n   */ DOMPurify.removeHook = function(entryPoint) {\n        if (hooks[entryPoint]) {\n            return arrayPop(hooks[entryPoint]);\n        }\n    };\n    /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */ DOMPurify.removeHooks = function(entryPoint) {\n        if (hooks[entryPoint]) {\n            hooks[entryPoint] = [];\n        }\n    };\n    /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */ DOMPurify.removeAllHooks = function() {\n        hooks = {};\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\n //# sourceMappingURL=purify.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5TEFBeUwsR0FFekwsTUFBTSxFQUNKQSxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyxjQUFjLEVBQ2RDLHdCQUF3QixFQUN6QixHQUFHQztBQUNKLElBQUksRUFDRkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE1BQU0sRUFDUCxHQUFHSCxRQUFRLGdEQUFnRDtBQUU1RCxJQUFJLEVBQ0ZJLEtBQUssRUFDTEMsU0FBUyxFQUNWLEdBQUcsT0FBT0MsWUFBWSxlQUFlQTtBQUV0QyxJQUFJLENBQUNGLE9BQU87SUFDVkEsUUFBUSxTQUFTQSxNQUFNRyxHQUFHLEVBQUVDLFNBQVMsRUFBRUMsSUFBSTtRQUN6QyxPQUFPRixJQUFJSCxLQUFLLENBQUNJLFdBQVdDO0lBQzlCO0FBQ0Y7QUFFQSxJQUFJLENBQUNSLFFBQVE7SUFDWEEsU0FBUyxTQUFTQSxPQUFPUyxDQUFDO1FBQ3hCLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLElBQUksQ0FBQ1IsTUFBTTtJQUNUQSxPQUFPLFNBQVNBLEtBQUtRLENBQUM7UUFDcEIsT0FBT0E7SUFDVDtBQUNGO0FBRUEsSUFBSSxDQUFDTCxXQUFXO0lBQ2RBLFlBQVksU0FBU0EsVUFBVU0sSUFBSSxFQUFFRixJQUFJO1FBQ3ZDLE9BQU8sSUFBSUUsUUFBUUY7SUFDckI7QUFDRjtBQUVBLE1BQU1HLGVBQWVDLFFBQVFDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztBQUNwRCxNQUFNQyxXQUFXSixRQUFRQyxNQUFNQyxTQUFTLENBQUNHLEdBQUc7QUFDNUMsTUFBTUMsWUFBWU4sUUFBUUMsTUFBTUMsU0FBUyxDQUFDSyxJQUFJO0FBQzlDLE1BQU1DLG9CQUFvQlIsUUFBUVMsT0FBT1AsU0FBUyxDQUFDUSxXQUFXO0FBQzlELE1BQU1DLGlCQUFpQlgsUUFBUVMsT0FBT1AsU0FBUyxDQUFDVSxRQUFRO0FBQ3hELE1B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Qy9DLElBQUksQ0FBQ2tJLFFBQVE7WUFDWEssYUFBYSxDQUFDO1FBQ2hCO1FBRUEsTUFBTXVFLFFBQVF2TixrQkFBa0JzUDtRQUNoQyxNQUFNOUIsU0FBU3hOLGtCQUFrQjBOO1FBQ2pDLE9BQU9KLGtCQUFrQkMsT0FBT0MsUUFBUS9NO0lBQzFDO0lBQ0E7Ozs7OztHQU1DLEdBR0QrQyxVQUFVK0wsT0FBTyxHQUFHLFNBQVUzQyxVQUFVLEVBQUU0QyxZQUFZO1FBQ3BELElBQUksT0FBT0EsaUJBQWlCLFlBQVk7WUFDdEM7UUFDRjtRQUVBOUosS0FBSyxDQUFDa0gsV0FBVyxHQUFHbEgsS0FBSyxDQUFDa0gsV0FBVyxJQUFJLEVBQUU7UUFDM0M1TyxVQUFVMEgsS0FBSyxDQUFDa0gsV0FBVyxFQUFFNEM7SUFDL0I7SUFDQTs7Ozs7OztHQU9DLEdBR0RoTSxVQUFVaU0sVUFBVSxHQUFHLFNBQVU3QyxVQUFVO1FBQ3pDLElBQUlsSCxLQUFLLENBQUNrSCxXQUFXLEVBQUU7WUFDckIsT0FBTzlPLFNBQVM0SCxLQUFLLENBQUNrSCxXQUFXO1FBQ25DO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUdEcEosVUFBVWtNLFdBQVcsR0FBRyxTQUFVOUMsVUFBVTtRQUMxQyxJQUFJbEgsS0FBSyxDQUFDa0gsV0FBVyxFQUFFO1lBQ3JCbEgsS0FBSyxDQUFDa0gsV0FBVyxHQUFHLEVBQUU7UUFDeEI7SUFDRjtJQUNBOzs7O0dBSUMsR0FHRHBKLFVBQVVtTSxjQUFjLEdBQUc7UUFDekJqSyxRQUFRLENBQUM7SUFDWDtJQUVBLE9BQU9sQztBQUNUO0FBRUEsSUFBSW9NLFNBQVN0TTtBQUVnQixDQUM3QixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMuanM/MzUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IDMuMC41IHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8zLjAuNS9MSUNFTlNFICovXG5cbmNvbnN0IHtcbiAgZW50cmllcyxcbiAgc2V0UHJvdG90eXBlT2YsXG4gIGlzRnJvemVuLFxuICBnZXRQcm90b3R5cGVPZixcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59ID0gT2JqZWN0O1xubGV0IHtcbiAgZnJlZXplLFxuICBzZWFsLFxuICBjcmVhdGVcbn0gPSBPYmplY3Q7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xuXG5sZXQge1xuICBhcHBseSxcbiAgY29uc3RydWN0XG59ID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Q7XG5cbmlmICghYXBwbHkpIHtcbiAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW4sIHRoaXNWYWx1ZSwgYXJncykge1xuICAgIHJldHVybiBmdW4uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgfTtcbn1cblxuaWYgKCFmcmVlemUpIHtcbiAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuaWYgKCFzZWFsKSB7XG4gIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuaWYgKCFjb25zdHJ1Y3QpIHtcbiAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmMoLi4uYXJncyk7XG4gIH07XG59XG5cbmNvbnN0IGFycmF5Rm9yRWFjaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuY29uc3QgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xuY29uc3QgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG5jb25zdCBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG5jb25zdCBzdHJpbmdUb1N0cmluZyA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyk7XG5jb25zdCBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG5jb25zdCBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuY29uc3Qgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbmNvbnN0IHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5jb25zdCByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuY29uc3QgdHlwZUVycm9yQ3JlYXRlID0gdW5jb25zdHJ1Y3QoVHlwZUVycm9yKTtcbmZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiB1bmNvbnN0cnVjdChmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChmdW5jLCBhcmdzKTtcbiAgfTtcbn1cbi8qIEFkZCBwcm9wZXJ0aWVzIHRvIGEgbG9va3VwIHRhYmxlICovXG5cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXksIHRyYW5zZm9ybUNhc2VGdW5jKSB7XG4gIHZhciBfdHJhbnNmb3JtQ2FzZUZ1bmM7XG5cbiAgdHJhbnNmb3JtQ2FzZUZ1bmMgPSAoX3RyYW5zZm9ybUNhc2VGdW5jID0gdHJhbnNmb3JtQ2FzZUZ1bmMpICE9PSBudWxsICYmIF90cmFuc2Zvcm1DYXNlRnVuYyAhPT0gdm9pZCAwID8gX3RyYW5zZm9ybUNhc2VGdW5jIDogc3RyaW5nVG9Mb3dlckNhc2U7XG5cbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG5cbiAgbGV0IGwgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGwtLSkge1xuICAgIGxldCBlbGVtZW50ID0gYXJyYXlbbF07XG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsY0VsZW1lbnQgPSB0cmFuc2Zvcm1DYXNlRnVuYyhlbGVtZW50KTtcblxuICAgICAgaWYgKGxjRWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAvLyBDb25maWcgcHJlc2V0cyAoZS5nLiB0YWdzLmpzLCBhdHRycy5qcykgYXJlIGltbXV0YWJsZS5cbiAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICBhcnJheVtsXSA9IGxjRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG4vKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdCAqL1xuXG5mdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuXG4gIGZvciAoY29uc3QgW3Byb3BlcnR5LCB2YWx1ZV0gb2YgZW50cmllcyhvYmplY3QpKSB7XG4gICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbi8qIFRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uXG4gKiBvciBnZXR0ZXIgYW5kIGJlaGF2ZXMgYWNjb3JkaW5nbHkuICovXG5cbmZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcblxuICAgIGlmIChkZXNjKSB7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignZmFsbGJhY2sgdmFsdWUgZm9yJywgZWxlbWVudCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbn1cblxuY29uc3QgaHRtbCQxID0gZnJlZXplKFsnYScsICdhYmJyJywgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JpZycsICdibGluaycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2NvbnRlbnQnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWNvcmF0b3InLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VsZW1lbnQnLCAnZW0nLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9udCcsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRlcicsICduYXYnLCAnbm9icicsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzaGFkb3cnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYWNlcicsICdzcGFuJywgJ3N0cmlrZScsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndHInLCAndHJhY2snLCAndHQnLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJ10pOyAvLyBTVkdcblxuY29uc3Qgc3ZnJDEgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuY29uc3Qgc3ZnRmlsdGVycyA9IGZyZWV6ZShbJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVEcm9wU2hhZG93JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLCAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZSddKTsgLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4vLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbi8vIGFsbG93LWxpc3QuXG5cbmNvbnN0IHN2Z0Rpc2FsbG93ZWQgPSBmcmVlemUoWydhbmltYXRlJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2Rpc2NhcmQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGF0Y2gnLCAnaGF0Y2hwYXRoJywgJ21lc2gnLCAnbWVzaGdyYWRpZW50JywgJ21lc2hwYXRjaCcsICdtZXNocm93JywgJ21pc3NpbmctZ2x5cGgnLCAnc2NyaXB0JywgJ3NldCcsICdzb2xpZGNvbG9yJywgJ3Vua25vd24nLCAndXNlJ10pO1xuY29uc3QgbWF0aE1sJDEgPSBmcmVlemUoWydtYXRoJywgJ21lbmNsb3NlJywgJ21lcnJvcicsICdtZmVuY2VkJywgJ21mcmFjJywgJ21nbHlwaCcsICdtaScsICdtbGFiZWxlZHRyJywgJ21tdWx0aXNjcmlwdHMnLCAnbW4nLCAnbW8nLCAnbW92ZXInLCAnbXBhZGRlZCcsICdtcGhhbnRvbScsICdtcm9vdCcsICdtcm93JywgJ21zJywgJ21zcGFjZScsICdtc3FydCcsICdtc3R5bGUnLCAnbXN1YicsICdtc3VwJywgJ21zdWJzdXAnLCAnbXRhYmxlJywgJ210ZCcsICdtdGV4dCcsICdtdHInLCAnbXVuZGVyJywgJ211bmRlcm92ZXInLCAnbXByZXNjcmlwdHMnXSk7IC8vIFNpbWlsYXJseSB0byBTVkcsIHdlIHdhbnQgdG8ga25vdyBhbGwgTWF0aE1MIGVsZW1lbnRzLFxuLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG5cbmNvbnN0IG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5jb25zdCB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbmNvbnN0IGh0bWwgPSBmcmVlemUoWydhY2NlcHQnLCAnYWN0aW9uJywgJ2FsaWduJywgJ2FsdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLCAnYXV0b3BsYXknLCAnYmFja2dyb3VuZCcsICdiZ2NvbG9yJywgJ2JvcmRlcicsICdjYXB0dXJlJywgJ2NlbGxwYWRkaW5nJywgJ2NlbGxzcGFjaW5nJywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzcycsICdjbGVhcicsICdjb2xvcicsICdjb2xzJywgJ2NvbHNwYW4nLCAnY29udHJvbHMnLCAnY29udHJvbHNsaXN0JywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsICdkYXRldGltZScsICdkZWNvZGluZycsICdkZWZhdWx0JywgJ2RpcicsICdkaXNhYmxlZCcsICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLCAnZG93bmxvYWQnLCAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2ZhY2UnLCAnZm9yJywgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLCAnaWQnLCAnaW5wdXRtb2RlJywgJ2ludGVncml0eScsICdpc21hcCcsICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvb3AnLCAnbG93JywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbmFtZScsICdub25jZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAnb3B0aW11bScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3BsYXlzaW5saW5lJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3B1YmRhdGUnLCAncmFkaW9ncm91cCcsICdyZWFkb25seScsICdyZWwnLCAncmVxdWlyZWQnLCAncmV2JywgJ3JldmVyc2VkJywgJ3JvbGUnLCAncm93cycsICdyb3dzcGFuJywgJ3NwZWxsY2hlY2snLCAnc2NvcGUnLCAnc2VsZWN0ZWQnLCAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzcGFuJywgJ3NyY2xhbmcnLCAnc3RhcnQnLCAnc3JjJywgJ3NyY3NldCcsICdzdGVwJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFiaW5kZXgnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJywgJ3ZhbGlnbicsICd2YWx1ZScsICd3aWR0aCcsICd4bWxucycsICdzbG90J10pO1xuY29uc3Qgc3ZnID0gZnJlZXplKFsnYWNjZW50LWhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdrJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ2tlcm5pbmcnLCAna2V5cG9pbnRzJywgJ2tleXNwbGluZXMnLCAna2V5dGltZXMnLCAnbGFuZycsICdsZW5ndGhhZGp1c3QnLCAnbGV0dGVyLXNwYWNpbmcnLCAna2VybmVsbWF0cml4JywgJ2tlcm5lbHVuaXRsZW5ndGgnLCAnbGlnaHRpbmctY29sb3InLCAnbG9jYWwnLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdtYXJrZXJoZWlnaHQnLCAnbWFya2VydW5pdHMnLCAnbWFya2Vyd2lkdGgnLCAnbWFza2NvbnRlbnR1bml0cycsICdtYXNrdW5pdHMnLCAnbWF4JywgJ21hc2snLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21vZGUnLCAnbWluJywgJ25hbWUnLCAnbnVtb2N0YXZlcycsICdvZmZzZXQnLCAnb3BlcmF0b3InLCAnb3BhY2l0eScsICdvcmRlcicsICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ3BhaW50LW9yZGVyJywgJ3BhdGgnLCAncGF0aGxlbmd0aCcsICdwYXR0ZXJuY29udGVudHVuaXRzJywgJ3BhdHRlcm50cmFuc2Zvcm0nLCAncGF0dGVybnVuaXRzJywgJ3BvaW50cycsICdwcmVzZXJ2ZWFscGhhJywgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLCAncHJpbWl0aXZldW5pdHMnLCAncicsICdyeCcsICdyeScsICdyYWRpdXMnLCAncmVmeCcsICdyZWZ5JywgJ3JlcGVhdGNvdW50JywgJ3JlcGVhdGR1cicsICdyZXN0YXJ0JywgJ3Jlc3VsdCcsICdyb3RhdGUnLCAnc2NhbGUnLCAnc2VlZCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3BlY3VsYXJjb25zdGFudCcsICdzcGVjdWxhcmV4cG9uZW50JywgJ3NwcmVhZG1ldGhvZCcsICdzdGFydG9mZnNldCcsICdzdGRkZXZpYXRpb24nLCAnc3RpdGNodGlsZXMnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZS13aWR0aCcsICdzdHlsZScsICdzdXJmYWNlc2NhbGUnLCAnc3lzdGVtbGFuZ3VhZ2UnLCAndGFiaW5kZXgnLCAndGFyZ2V0eCcsICd0YXJnZXR5JywgJ3RyYW5zZm9ybScsICd0cmFuc2Zvcm0tb3JpZ2luJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd0ZXh0bGVuZ3RoJywgJ3R5cGUnLCAndTEnLCAndTInLCAndW5pY29kZScsICd2YWx1ZXMnLCAndmlld2JveCcsICd2aXNpYmlsaXR5JywgJ3ZlcnNpb24nLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3dyYXAnLCAnd3JpdGluZy1tb2RlJywgJ3hjaGFubmVsc2VsZWN0b3InLCAneWNoYW5uZWxzZWxlY3RvcicsICd4JywgJ3gxJywgJ3gyJywgJ3htbG5zJywgJ3knLCAneTEnLCAneTInLCAneicsICd6b29tYW5kcGFuJ10pO1xuY29uc3QgbWF0aE1sID0gZnJlZXplKFsnYWNjZW50JywgJ2FjY2VudHVuZGVyJywgJ2FsaWduJywgJ2JldmVsbGVkJywgJ2Nsb3NlJywgJ2NvbHVtbnNhbGlnbicsICdjb2x1bW5saW5lcycsICdjb2x1bW5zcGFuJywgJ2Rlbm9tYWxpZ24nLCAnZGVwdGgnLCAnZGlyJywgJ2Rpc3BsYXknLCAnZGlzcGxheXN0eWxlJywgJ2VuY29kaW5nJywgJ2ZlbmNlJywgJ2ZyYW1lJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2xhcmdlb3AnLCAnbGVuZ3RoJywgJ2xpbmV0aGlja25lc3MnLCAnbHNwYWNlJywgJ2xxdW90ZScsICdtYXRoYmFja2dyb3VuZCcsICdtYXRoY29sb3InLCAnbWF0aHNpemUnLCAnbWF0aHZhcmlhbnQnLCAnbWF4c2l6ZScsICdtaW5zaXplJywgJ21vdmFibGVsaW1pdHMnLCAnbm90YXRpb24nLCAnbnVtYWxpZ24nLCAnb3BlbicsICdyb3dhbGlnbicsICdyb3dsaW5lcycsICdyb3dzcGFjaW5nJywgJ3Jvd3NwYW4nLCAncnNwYWNlJywgJ3JxdW90ZScsICdzY3JpcHRsZXZlbCcsICdzY3JpcHRtaW5zaXplJywgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJywgJ3NlbGVjdGlvbicsICdzZXBhcmF0b3InLCAnc2VwYXJhdG9ycycsICdzdHJldGNoeScsICdzdWJzY3JpcHRzaGlmdCcsICdzdXBzY3JpcHRzaGlmdCcsICdzeW1tZXRyaWMnLCAndm9mZnNldCcsICd3aWR0aCcsICd4bWxucyddKTtcbmNvbnN0IHhtbCA9IGZyZWV6ZShbJ3hsaW5rOmhyZWYnLCAneG1sOmlkJywgJ3hsaW5rOnRpdGxlJywgJ3htbDpzcGFjZScsICd4bWxuczp4bGluayddKTtcblxuY29uc3QgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcblxuY29uc3QgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHdcXFddKnxbXFx3XFxXXSolPi9nbSk7XG5jb25zdCBUTVBMSVRfRVhQUiA9IHNlYWwoL1xcJHtbXFx3XFxXXSp9L2dtKTtcbmNvbnN0IERBVEFfQVRUUiA9IHNlYWwoL15kYXRhLVtcXC1cXHcuXFx1MDBCNy1cXHVGRkZGXS8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbmNvbnN0IEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG5jb25zdCBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98c21zfGNpZHx4bXBwKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbik7XG5jb25zdCBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbmNvbnN0IEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbik7XG5jb25zdCBET0NUWVBFX05BTUUgPSBzZWFsKC9eaHRtbCQvaSk7XG5cbnZhciBFWFBSRVNTSU9OUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBNVVNUQUNIRV9FWFBSOiBNVVNUQUNIRV9FWFBSLFxuICBFUkJfRVhQUjogRVJCX0VYUFIsXG4gIFRNUExJVF9FWFBSOiBUTVBMSVRfRVhQUixcbiAgREFUQV9BVFRSOiBEQVRBX0FUVFIsXG4gIEFSSUFfQVRUUjogQVJJQV9BVFRSLFxuICBJU19BTExPV0VEX1VSSTogSVNfQUxMT1dFRF9VUkksXG4gIElTX1NDUklQVF9PUl9EQVRBOiBJU19TQ1JJUFRfT1JfREFUQSxcbiAgQVRUUl9XSElURVNQQUNFOiBBVFRSX1dISVRFU1BBQ0UsXG4gIERPQ1RZUEVfTkFNRTogRE9DVFlQRV9OQU1FXG59KTtcblxuY29uc3QgZ2V0R2xvYmFsID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuLyoqXG4gKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIERvbid0IGV4cG9ydCB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUhXG4gKiBAcGFyYW0gez9UcnVzdGVkVHlwZVBvbGljeUZhY3Rvcnl9IHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gKiBAcGFyYW0ge0hUTUxTY3JpcHRFbGVtZW50fSBwdXJpZnlIb3N0RWxlbWVudCBUaGUgU2NyaXB0IGVsZW1lbnQgdXNlZCB0byBsb2FkIERPTVB1cmlmeSAodG8gZGV0ZXJtaW5lIHBvbGljeSBuYW1lIHN1ZmZpeCkuXG4gKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICogYXJlIG5vdCBzdXBwb3J0ZWQgb3IgY3JlYXRpbmcgdGhlIHBvbGljeSBmYWlsZWQpLlxuICovXG5cblxuY29uc3QgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBwdXJpZnlIb3N0RWxlbWVudCkge1xuICBpZiAodHlwZW9mIHRydXN0ZWRUeXBlcyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgLy8gYnkgYWRkaW5nIGEgZGF0YS10dC1wb2xpY3ktc3VmZml4IHRvIHRoZSBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBET01QdXJpZnkuXG4gIC8vIFBvbGljeSBjcmVhdGlvbiB3aXRoIGR1cGxpY2F0ZSBuYW1lcyB0aHJvd3MgaW4gVHJ1c3RlZCBUeXBlcy5cblxuXG4gIGxldCBzdWZmaXggPSBudWxsO1xuICBjb25zdCBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcblxuICBpZiAocHVyaWZ5SG9zdEVsZW1lbnQgJiYgcHVyaWZ5SG9zdEVsZW1lbnQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICBzdWZmaXggPSBwdXJpZnlIb3N0RWxlbWVudC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgfVxuXG4gIGNvbnN0IHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICBjcmVhdGVIVE1MKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVTY3JpcHRVUkwoc2NyaXB0VXJsKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHRVcmw7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFBvbGljeSBjcmVhdGlvbiBmYWlsZWQgKG1vc3QgbGlrZWx5IGFub3RoZXIgRE9NUHVyaWZ5IHNjcmlwdCBoYXNcbiAgICAvLyBhbHJlYWR5IHJ1bikuIFNraXAgY3JlYXRpbmcgdGhlIHBvbGljeSwgYXMgdGhpcyB3aWxsIG9ubHkgY2F1c2UgZXJyb3JzXG4gICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgIGNvbnNvbGUud2FybignVHJ1c3RlZFR5cGVzIHBvbGljeSAnICsgcG9saWN5TmFtZSArICcgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgbGV0IHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG5cbiAgY29uc3QgRE9NUHVyaWZ5ID0gcm9vdCA9PiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gIC8qKlxuICAgKiBWZXJzaW9uIGxhYmVsLCBleHBvc2VkIGZvciBlYXNpZXIgY2hlY2tzXG4gICAqIGlmIERPTVB1cmlmeSBpcyB1cCB0byBkYXRlIG9yIG5vdFxuICAgKi9cblxuXG4gIERPTVB1cmlmeS52ZXJzaW9uID0gJzMuMC41JztcbiAgLyoqXG4gICAqIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgRE9NUHVyaWZ5IHJlbW92ZWQgZHVyaW5nIHNhbml0YXRpb24uXG4gICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAqL1xuXG4gIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IDkpIHtcbiAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCB5b3UgY2FuIHBhc3MgeW91ciBvd24gV2luZG93XG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGNvbnN0IGN1cnJlbnRTY3JpcHQgPSBvcmlnaW5hbERvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gIGxldCB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IHdpbmRvdztcbiAgY29uc3Qge1xuICAgIERvY3VtZW50RnJhZ21lbnQsXG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICBOb2RlLFxuICAgIEVsZW1lbnQsXG4gICAgTm9kZUZpbHRlcixcbiAgICBOYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAsXG4gICAgSFRNTEZvcm1FbGVtZW50LFxuICAgIERPTVBhcnNlcixcbiAgICB0cnVzdGVkVHlwZXNcbiAgfSA9IHdpbmRvdztcbiAgY29uc3QgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuICBjb25zdCBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICBjb25zdCBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgY29uc3QgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICBjb25zdCBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7IC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gIC8vIGlzIGluaGVyaXRlZC5cblxuICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cbiAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuXG4gIGxldCB0cnVzdGVkVHlwZXNQb2xpY3k7XG4gIGxldCBlbXB0eUhUTUwgPSAnJztcbiAgY29uc3Qge1xuICAgIGltcGxlbWVudGF0aW9uLFxuICAgIGNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lXG4gIH0gPSBkb2N1bWVudDtcbiAgY29uc3Qge1xuICAgIGltcG9ydE5vZGVcbiAgfSA9IG9yaWdpbmFsRG9jdW1lbnQ7XG4gIGxldCBob29rcyA9IHt9O1xuICAvKipcbiAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgKi9cblxuICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZW50cmllcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09IHVuZGVmaW5lZDtcbiAgY29uc3Qge1xuICAgIE1VU1RBQ0hFX0VYUFIsXG4gICAgRVJCX0VYUFIsXG4gICAgVE1QTElUX0VYUFIsXG4gICAgREFUQV9BVFRSLFxuICAgIEFSSUFfQVRUUixcbiAgICBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICBBVFRSX1dISVRFU1BBQ0VcbiAgfSA9IEVYUFJFU1NJT05TO1xuICBsZXQge1xuICAgIElTX0FMTE9XRURfVVJJOiBJU19BTExPV0VEX1VSSSQxXG4gIH0gPSBFWFBSRVNTSU9OUztcbiAgLyoqXG4gICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICovXG5cbiAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG5cbiAgbGV0IEFMTE9XRURfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5odG1sJDEsIC4uLnN2ZyQxLCAuLi5zdmdGaWx0ZXJzLCAuLi5tYXRoTWwkMSwgLi4udGV4dF0pO1xuICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuXG4gIGxldCBBTExPV0VEX0FUVFIgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbLi4uaHRtbCwgLi4uc3ZnLCAuLi5tYXRoTWwsIC4uLnhtbF0pO1xuICAvKlxuICAgKiBDb25maWd1cmUgaG93IERPTVBVcmlmeSBzaG91bGQgaGFuZGxlIGN1c3RvbSBlbGVtZW50cyBhbmQgdGhlaXIgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIGN1c3RvbWl6ZWQgYnVpbHQtaW4gZWxlbWVudHMuXG4gICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IHRhZ05hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzKVxuICAgKiBAcHJvcGVydHkge1JlZ0V4cHxGdW5jdGlvbnxudWxsfSBhdHRyaWJ1dGVOYW1lQ2hlY2sgb25lIG9mIFtudWxsLCByZWdleFBhdHRlcm4sIHByZWRpY2F0ZV0uIERlZmF1bHQ6IGBudWxsYCAoZGlzYWxsb3cgYW55IGF0dHJpYnV0ZXMgbm90IG9uIHRoZSBhbGxvdyBsaXN0KVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyBhbGxvdyBjdXN0b20gZWxlbWVudHMgZGVyaXZlZCBmcm9tIGJ1aWx0LWlucyBpZiB0aGV5IHBhc3MgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLiBEZWZhdWx0OiBgZmFsc2VgLlxuICAgKi9cblxuICBsZXQgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBPYmplY3Quc2VhbChPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICB0YWdOYW1lQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYXR0cmlidXRlTmFtZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSkpO1xuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuXG4gIGxldCBGT1JCSURfVEFHUyA9IG51bGw7XG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIGF0dHJpYnV0ZXMgKG92ZXJyaWRlcyBBTExPV0VEX0FUVFIvQUREX0FUVFIpICovXG5cbiAgbGV0IEZPUkJJRF9BVFRSID0gbnVsbDtcbiAgLyogRGVjaWRlIGlmIEFSSUEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuXG4gIGxldCBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuXG4gIGxldCBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgdW5rbm93biBwcm90b2NvbHMgYXJlIG9rYXkgKi9cblxuICBsZXQgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIHNlbGYtY2xvc2luZyB0YWdzIGluIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQuXG4gICAqIFVzdWFsbHkgcmVtb3ZlZCBkdWUgdG8gYSBtWFNTIGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cblxuICBsZXQgQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSID0gdHJ1ZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgKi9cblxuICBsZXQgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBkb2N1bWVudCB3aXRoIDxodG1sPi4uLiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cblxuICBsZXQgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcbiAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG5cbiAgbGV0IFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG5cbiAgbGV0IEZPUkNFX0JPRFkgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpLlxuICAgKiBJZiBgV0hPTEVfRE9DVU1FTlRgIGlzIGVuYWJsZWQgYSBgSFRNTEh0bWxFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICovXG5cbiAgbGV0IFJFVFVSTl9ET00gPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cblxuICBsZXQgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuXG4gIGxldCBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG4gIC8qIE91dHB1dCBzaG91bGQgYmUgZnJlZSBmcm9tIERPTSBjbG9iYmVyaW5nIGF0dGFja3M/XG4gICAqIFRoaXMgc2FuaXRpemVzIG1hcmt1cHMgbmFtZWQgd2l0aCBjb2xsaWRpbmcsIGNsb2JiZXJhYmxlIGJ1aWx0LWluIERPTSBBUElzLlxuICAgKi9cblxuICBsZXQgU0FOSVRJWkVfRE9NID0gdHJ1ZTtcbiAgLyogQWNoaWV2ZSBmdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gYnkgaXNvbGF0aW5nIHRoZSBuYW1lc3BhY2Ugb2YgbmFtZWRcbiAgICogcHJvcGVydGllcyBhbmQgSlMgdmFyaWFibGVzLCBtaXRpZ2F0aW5nIGF0dGFja3MgdGhhdCBhYnVzZSB0aGUgSFRNTC9ET00gc3BlYyBydWxlcy5cbiAgICpcbiAgICogSFRNTC9ET00gc3BlYyBydWxlcyB0aGF0IGVuYWJsZSBET00gQ2xvYmJlcmluZzpcbiAgICogICAtIE5hbWVkIEFjY2VzcyBvbiBXaW5kb3cgKMKnNy4zLjMpXG4gICAqICAgLSBET00gVHJlZSBBY2Nlc3NvcnMgKMKnMy4xLjUpXG4gICAqICAgLSBGb3JtIEVsZW1lbnQgUGFyZW50LUNoaWxkIFJlbGF0aW9ucyAowqc0LjEwLjMpXG4gICAqICAgLSBJZnJhbWUgc3JjZG9jIC8gTmVzdGVkIFdpbmRvd1Byb3hpZXMgKMKnNC44LjUpXG4gICAqICAgLSBIVE1MQ29sbGVjdGlvbiAowqc0LjIuMTAuMilcbiAgICpcbiAgICogTmFtZXNwYWNlIGlzb2xhdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBwcmVmaXhpbmcgYGlkYCBhbmQgYG5hbWVgIGF0dHJpYnV0ZXNcbiAgICogd2l0aCBhIGNvbnN0YW50IHN0cmluZywgaS5lLiwgYHVzZXItY29udGVudC1gXG4gICAqL1xuXG4gIGxldCBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGZhbHNlO1xuICBjb25zdCBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggPSAndXNlci1jb250ZW50LSc7XG4gIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cblxuICBsZXQgS0VFUF9DT05URU5UID0gdHJ1ZTtcbiAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICogb2YgaW1wb3J0aW5nIGl0IGludG8gYSBuZXcgRG9jdW1lbnQgYW5kIHJldHVybmluZyBhIHNhbml0aXplZCBjb3B5ICovXG5cbiAgbGV0IElOX1BMQUNFID0gZmFsc2U7XG4gIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cblxuICBsZXQgVVNFX1BST0ZJTEVTID0ge307XG4gIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuXG4gIGxldCBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0ZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJywgJ2F1ZGlvJywgJ2NvbGdyb3VwJywgJ2Rlc2MnLCAnZm9yZWlnbm9iamVjdCcsICdoZWFkJywgJ2lmcmFtZScsICdtYXRoJywgJ21pJywgJ21uJywgJ21vJywgJ21zJywgJ210ZXh0JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAncGxhaW50ZXh0JywgJ3NjcmlwdCcsICdzdHlsZScsICdzdmcnLCAndGVtcGxhdGUnLCAndGhlYWQnLCAndGl0bGUnLCAndmlkZW8nLCAneG1wJ10pO1xuICAvKiBUYWdzIHRoYXQgYXJlIHNhZmUgZm9yIGRhdGE6IFVSSXMgKi9cblxuICBsZXQgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG4gIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG5cbiAgbGV0IFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG4gIGNvbnN0IE1BVEhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG4gIGNvbnN0IFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBjb25zdCBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG5cbiAgbGV0IE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFO1xuICBsZXQgSVNfRU1QVFlfSU5QVVQgPSBmYWxzZTtcbiAgLyogQWxsb3dlZCBYSFRNTCtYTUwgbmFtZXNwYWNlcyAqL1xuXG4gIGxldCBBTExPV0VEX05BTUVTUEFDRVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyA9IGFkZFRvU2V0KHt9LCBbTUFUSE1MX05BTUVTUEFDRSwgU1ZHX05BTUVTUEFDRSwgSFRNTF9OQU1FU1BBQ0VdLCBzdHJpbmdUb1N0cmluZyk7XG4gIC8qIFBhcnNpbmcgb2Ygc3RyaWN0IFhIVE1MIGRvY3VtZW50cyAqL1xuXG4gIGxldCBQQVJTRVJfTUVESUFfVFlQRTtcbiAgY29uc3QgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICBjb25zdCBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gIGxldCB0cmFuc2Zvcm1DYXNlRnVuYztcbiAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuXG4gIGxldCBDT05GSUcgPSBudWxsO1xuICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG5cbiAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuXG4gIGNvbnN0IGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gIGNvbnN0IGlzUmVnZXhPckZ1bmN0aW9uID0gZnVuY3Rpb24gaXNSZWdleE9yRnVuY3Rpb24odGVzdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRlc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfTtcbiAgLyoqXG4gICAqIF9wYXJzZUNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNmZyBvcHRpb25hbCBjb25maWcgbGl0ZXJhbFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG4gIGNvbnN0IF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZyhjZmcpIHtcbiAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuXG5cbiAgICBpZiAoIWNmZyB8fCB0eXBlb2YgY2ZnICE9PSAnb2JqZWN0Jykge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cblxuXG4gICAgY2ZnID0gY2xvbmUoY2ZnKTtcbiAgICBQQVJTRVJfTUVESUFfVFlQRSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFOyAvLyBIVE1MIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgYXJlIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydGluZyB0byBsb3dlcmNhc2UuIEtlZXBpbmcgWEhUTUwgYXMgaXMuXG5cbiAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IHN0cmluZ1RvU3RyaW5nIDogc3RyaW5nVG9Mb3dlckNhc2U7XG4gICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuXG4gICAgQUxMT1dFRF9UQUdTID0gJ0FMTE9XRURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICBBTExPV0VEX05BTUVTUEFDRVMgPSAnQUxMT1dFRF9OQU1FU1BBQ0VTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfTkFNRVNQQUNFUywgc3RyaW5nVG9TdHJpbmcpIDogREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVM7XG4gICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICBjZmcuQUREX1VSSV9TQUZFX0FUVFIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgdHJhbnNmb3JtQ2FzZUZ1bmMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7XG4gICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICBjZmcuQUREX0RBVEFfVVJJX1RBR1MsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgdHJhbnNmb3JtQ2FzZUZ1bmMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgOiBERUZBVUxUX0RBVEFfVVJJX1RBR1M7XG4gICAgRk9SQklEX0NPTlRFTlRTID0gJ0ZPUkJJRF9DT05URU5UUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTO1xuICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiB7fTtcbiAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDoge307XG4gICAgVVNFX1BST0ZJTEVTID0gJ1VTRV9QUk9GSUxFUycgaW4gY2ZnID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcblxuICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcblxuICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSBjZmcuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG5cbiAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICBTQU5JVElaRV9ET00gPSBjZmcuU0FOSVRJWkVfRE9NICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG5cbiAgICBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGNmZy5TQU5JVElaRV9OQU1FRF9QUk9QUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuXG4gICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgIElTX0FMTE9XRURfVVJJJDEgPSBjZmcuQUxMT1dFRF9VUklfUkVHRVhQIHx8IElTX0FMTE9XRURfVVJJO1xuICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG4gICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgfHwge307XG5cbiAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrO1xuICAgIH1cblxuICAgIGlmIChjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgaXNSZWdleE9yRnVuY3Rpb24oY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaykpIHtcbiAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2s7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgIH1cblxuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG5cblxuICAgIGlmIChVU0VfUFJPRklMRVMpIHtcbiAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4udGV4dF0pO1xuICAgICAgQUxMT1dFRF9BVFRSID0gW107XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnRmlsdGVycyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuXG5cbiAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICBpZiAoQUxMT1dFRF9UQUdTID09PSBERUZBVUxUX0FMTE9XRURfVEFHUykge1xuICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cblxuICAgIGlmIChjZmcuQUREX0FUVFIpIHtcbiAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEZPUkJJRF9DT05URU5UUywgY2ZnLkZPUkJJRF9DT05URU5UUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cbiAgICAvKiBBZGQgI3RleHQgaW4gY2FzZSBLRUVQX0NPTlRFTlQgaXMgc2V0IHRvIHRydWUgKi9cblxuXG4gICAgaWYgKEtFRVBfQ09OVEVOVCkge1xuICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuXG5cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICB9XG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuXG5cbiAgICBpZiAoQUxMT1dFRF9UQUdTLnRhYmxlKSB7XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsndGJvZHknXSk7XG4gICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWSkge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlSFRNTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlSFRNTFwiIGhvb2suJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZLmNyZWF0ZVNjcmlwdFVSTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlU2NyaXB0VVJMXCIgaG9vay4nKTtcbiAgICAgIH0gLy8gT3ZlcndyaXRlIGV4aXN0aW5nIFRydXN0ZWRUeXBlcyBwb2xpY3kuXG5cblxuICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZOyAvLyBTaWduIGxvY2FsIHZhcmlhYmxlcyByZXF1aXJlZCBieSBgc2FuaXRpemVgLlxuXG4gICAgICBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuaW5pdGlhbGl6ZWQgcG9saWN5LCBhdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIGludGVybmFsIGRvbXB1cmlmeSBwb2xpY3kuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGN1cnJlbnRTY3JpcHQpO1xuICAgICAgfSAvLyBJZiBjcmVhdGluZyB0aGUgaW50ZXJuYWwgcG9saWN5IHN1Y2NlZWRlZCBzaWduIGludGVybmFsIHZhcmlhYmxlcy5cblxuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICE9PSBudWxsICYmIHR5cGVvZiBlbXB0eUhUTUwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICAgIH1cbiAgICB9IC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAvLyBOb3QgYXZhaWxhYmxlIGluIElFOCwgU2FmYXJpIDUsIGV0Yy5cblxuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgZnJlZXplKGNmZyk7XG4gICAgfVxuXG4gICAgQ09ORklHID0gY2ZnO1xuICB9O1xuXG4gIGNvbnN0IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ21pJywgJ21vJywgJ21uJywgJ21zJywgJ210ZXh0J10pO1xuICBjb25zdCBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2ZvcmVpZ25vYmplY3QnLCAnZGVzYycsICd0aXRsZScsICdhbm5vdGF0aW9uLXhtbCddKTsgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAvLyBuYW1lc3BhY2UuIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGVtIGV4cGxpY2l0bHlcbiAgLy8gc28gdGhhdCB0aGV5IGRvbid0IGdldCBlcnJvbmVvdXNseSBkZWxldGVkIGZyb21cbiAgLy8gSFRNTCBuYW1lc3BhY2UuXG5cbiAgY29uc3QgQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyA9IGFkZFRvU2V0KHt9LCBbJ3RpdGxlJywgJ3N0eWxlJywgJ2ZvbnQnLCAnYScsICdzY3JpcHQnXSk7XG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG5cbiAgY29uc3QgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2ZyQxKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdEaXNhbGxvd2VkKTtcbiAgY29uc3QgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCQxKTtcbiAgYWRkVG9TZXQoQUxMX01BVEhNTF9UQUdTLCBtYXRoTWxEaXNhbGxvd2VkKTtcbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIGZhbHNlIGlmIHRoZSBlbGVtZW50IGhhcyBhXG4gICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgKiAgcmV0dXJuLiBSZXR1cm4gdHJ1ZSBvdGhlcndpc2UuXG4gICAqL1xuXG4gIGNvbnN0IF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpOyAvLyBJbiBKU0RPTSwgaWYgd2UncmUgaW5zaWRlIHNoYWRvdyBET00sIHRoZW4gcGFyZW50Tm9kZVxuICAgIC8vIGNhbiBiZSBudWxsLiBXZSBqdXN0IHNpbXVsYXRlIHBhcmVudCBpbiB0aGlzIGNhc2UuXG5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgbmFtZXNwYWNlVVJJOiBOQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgY29uc3QgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcblxuICAgIGlmICghQUxMT1dFRF9OQU1FU1BBQ0VTW2VsZW1lbnQubmFtZXNwYWNlVVJJXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgIH0gLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIE1hdGhNTCB0byBTVkcgaXMgdmlhYFxuICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgIC8vIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzLlxuXG5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfSAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG5cblxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgIC8vIGlzIHZpYSA8bWF0aD4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJztcbiAgICAgIH0gLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBNYXRoTUwgaXMgdmlhXG4gICAgICAvLyA8bWF0aD4gYW5kIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzXG5cblxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgIH0gLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIE1hdGhNTFxuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBNYXRoTUwgbmFtZXNwYWNlLlxuXG5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBIVE1MIGlzIHZpYVxuICAgICAgLy8gSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHMsIGFuZCBmcm9tIE1hdGhNTCB0byBIVE1MXG4gICAgICAvLyBpcyB2aWEgTWF0aE1MIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSAmJiAhSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gV2UgZGlzYWxsb3cgdGFncyB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgTWF0aE1MXG4gICAgICAvLyBvciBTVkcgYW5kIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gSFRNTCBuYW1lc3BhY2VcblxuXG4gICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9IC8vIEZvciBYSFRNTCBhbmQgWE1MIGRvY3VtZW50cyB0aGF0IHN1cHBvcnQgY3VzdG9tIG5hbWVzcGFjZXNcblxuXG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAvLyBIVE1MLCBTVkcsIE1hdGhNTCBvciBhbGxvd2VkIHZpYSBBTExPV0VEX05BTUVTUEFDRVMpLlxuICAgIC8vIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9mb3JjZVJlbW92ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG5cblxuICBjb25zdCBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgZWxlbWVudDogbm9kZVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIGFuIEF0dHJpYnV0ZSBuYW1lXG4gICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgKi9cblxuXG4gIGNvbnN0IF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgIGF0dHJpYnV0ZTogbm9kZS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpLFxuICAgICAgICBmcm9tOiBub2RlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBmcm9tOiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgLy8gV2Ugdm9pZCBhdHRyaWJ1dGUgdmFsdWVzIGZvciB1bnJlbW92YWJsZSBcImlzXCJcIiBhdHRyaWJ1dGVzXG5cbiAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJiAhQUxMT1dFRF9BVFRSW25hbWVdKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTSB8fCBSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKG5vZGUpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogX2luaXREb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnR5IGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG5cblxuICBjb25zdCBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICBsZXQgZG9jO1xuICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZTtcblxuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICBjb25zdCBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgIC8qXG4gICAgICogVXNlIHRoZSBET01QYXJzZXIgQVBJIGJ5IGRlZmF1bHQsIGZhbGxiYWNrIGxhdGVyIGlmIG5lZWRzIGJlXG4gICAgICogRE9NUGFyc2VyIG5vdCB3b3JrIGZvciBzdmcgd2hlbiBoYXMgbXVsdGlwbGUgcm9vdCBlbGVtZW50LlxuICAgICAqL1xuXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cblxuXG4gICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGRvYyA9IGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KE5BTUVTUEFDRSwgJ3RlbXBsYXRlJywgbnVsbCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyBlbXB0eUhUTUwgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChfKSB7Ly8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICB9XG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG5cblxuICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVRhZ05hbWUuY2FsbChkb2MsIFdIT0xFX0RPQ1VNRU5UID8gJ2h0bWwnIDogJ2JvZHknKVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgfTtcbiAgLyoqXG4gICAqIF9jcmVhdGVJdGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0gIHtEb2N1bWVudH0gcm9vdCBkb2N1bWVudC9mcmFnbWVudCB0byBjcmVhdGUgaXRlcmF0b3IgZm9yXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfSBpdGVyYXRvciBpbnN0YW5jZVxuICAgKi9cblxuXG4gIGNvbnN0IF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICB9O1xuICAvKipcbiAgICogX2lzQ2xvYmJlcmVkXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IGVsbSBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICovXG5cblxuICBjb25zdCBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgcmV0dXJuIGVsbSBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCAmJiAodHlwZW9mIGVsbS5ub2RlTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsbS5hdHRyaWJ1dGVzIGluc3RhbmNlb2YgTmFtZWROb2RlTWFwKSB8fCB0eXBlb2YgZWxtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLm5hbWVzcGFjZVVSSSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5oYXNDaGlsZE5vZGVzICE9PSAnZnVuY3Rpb24nKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc05vZGVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gb2JqIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuXG5cbiAgY29uc3QgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBOb2RlID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH07XG4gIC8qKlxuICAgKiBfZXhlY3V0ZUhvb2tcbiAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgIE5hbWUgb2YgdGhlIGhvb2sncyBlbnRyeSBwb2ludFxuICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgYWRkaXRpb25hbCBob29rIHBhcmFtZXRlcnNcbiAgICovXG5cblxuICBjb25zdCBfZXhlY3V0ZUhvb2sgPSBmdW5jdGlvbiBfZXhlY3V0ZUhvb2soZW50cnlQb2ludCwgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rID0+IHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogX3Nhbml0aXplRWxlbWVudHNcbiAgICpcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgdGV4dENvbnRlbnRcbiAgICogQHByb3RlY3QgcmVtb3ZlQ2hpbGRcbiAgICpcbiAgICogQHBhcmFtICAge05vZGV9IGN1cnJlbnROb2RlIHRvIGNoZWNrIGZvciBwZXJtaXNzaW9uIHRvIGV4aXN0XG4gICAqIEByZXR1cm4gIHtCb29sZWFufSB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgKi9cblxuXG4gIGNvbnN0IF9zYW5pdGl6ZUVsZW1lbnRzID0gZnVuY3Rpb24gX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpIHtcbiAgICBsZXQgY29udGVudDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cblxuXG4gICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG5cblxuICAgIGNvbnN0IHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuXG4gICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgIHRhZ05hbWUsXG4gICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgfSk7XG4gICAgLyogRGV0ZWN0IG1YU1MgYXR0ZW1wdHMgYWJ1c2luZyBuYW1lc3BhY2UgY29uZnVzaW9uICovXG5cblxuICAgIGlmIChjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiYgIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cblxuXG4gICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYSBjdXN0b20gZWxlbWVudCB0byBoYW5kbGUgKi9cbiAgICAgIGlmICghRk9SQklEX1RBR1NbdGFnTmFtZV0gJiYgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdGFnTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh0YWdOYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyogS2VlcCBjb250ZW50IGV4Y2VwdCBmb3IgYmFkLWxpc3RlZCBlbGVtZW50cyAqL1xuXG5cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIENoZWNrIHdoZXRoZXIgZWxlbWVudCBoYXMgYSB2YWxpZCBuYW1lc3BhY2UgKi9cblxuXG4gICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgb2xkZXIgYnJvd3NlcnMgZG9uJ3QgZ2V0IGZhbGxiYWNrLXRhZyBtWFNTICovXG5cblxuICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcgfHwgdGFnTmFtZSA9PT0gJ25vZnJhbWVzJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZHxmcmFtZXMpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuXG5cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIE1VU1RBQ0hFX0VYUFIsICcgJyk7XG4gICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiwgJyAnKTtcbiAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIFRNUExJVF9FWFBSLCAnICcpO1xuXG4gICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuXG5cbiAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cblxuICBjb25zdCBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cblxuXG4gICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIsIGxjTmFtZSkpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgIGlmICggLy8gRmlyc3QgY29uZGl0aW9uIGRvZXMgYSB2ZXJ5IGJhc2ljIGNoZWNrIGlmIGEpIGl0J3MgYmFzaWNhbGx5IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgdGFnbmFtZSBBTkRcbiAgICAgIC8vIGIpIGlmIHRoZSB0YWdOYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICAvLyBhbmQgYykgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrXG4gICAgICBfYmFzaWNDdXN0b21FbGVtZW50VGVzdChsY1RhZykgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgbGNUYWcpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayhsY1RhZykpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2ssIGxjTmFtZSkgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKGxjTmFtZSkpIHx8IC8vIEFsdGVybmF0aXZlLCBzZWNvbmQgY29uZGl0aW9uIGNoZWNrcyBpZiBpdCdzIGFuIGBpc2AtYXR0cmlidXRlLCBBTkRcbiAgICAgIC8vIHRoZSB2YWx1ZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVja1xuICAgICAgbGNOYW1lID09PSAnaXMnICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLCB2YWx1ZSkgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKHZhbHVlKSkpIDsgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIENoZWNrIHZhbHVlIGlzIHNhZmUuIEZpcnN0LCBpcyBhdHRyIGluZXJ0PyBJZiBzbywgaXMgc2FmZSAqL1xuXG4gICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFLCAnJykpKSA7IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIDtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogX2Jhc2ljQ3VzdG9tRWxlbWVudENoZWNrXG4gICAqIGNoZWNrcyBpZiBhdCBsZWFzdCBvbmUgZGFzaCBpcyBpbmNsdWRlZCBpbiB0YWdOYW1lLCBhbmQgaXQncyBub3QgdGhlIGZpcnN0IGNoYXJcbiAgICogZm9yIG1vcmUgc29waGlzdGljYXRlZCBjaGVja2luZyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy92YWxpZGF0ZS1lbGVtZW50LW5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbmFtZSBvZiB0aGUgdGFnIG9mIHRoZSBub2RlIHRvIHNhbml0aXplXG4gICAqL1xuXG5cbiAgY29uc3QgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QgPSBmdW5jdGlvbiBfYmFzaWNDdXN0b21FbGVtZW50VGVzdCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIHRvIHNhbml0aXplXG4gICAqL1xuXG5cbiAgY29uc3QgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICBsZXQgYXR0cjtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGxjTmFtZTtcbiAgICBsZXQgbDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gY3VycmVudE5vZGU7XG4gICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhdHRyaWJ1dGVzOyBpZiBub3Qgd2UgbWlnaHQgaGF2ZSBhIHRleHQgbm9kZSAqL1xuXG4gICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaG9va0V2ZW50ID0ge1xuICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgIH07XG4gICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG5cbiAgICB3aGlsZSAobC0tKSB7XG4gICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbmFtZXNwYWNlVVJJXG4gICAgICB9ID0gYXR0cjtcbiAgICAgIHZhbHVlID0gbmFtZSA9PT0gJ3ZhbHVlJyA/IGF0dHIudmFsdWUgOiBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cbiAgICAgIGhvb2tFdmVudC5hdHRyTmFtZSA9IGxjTmFtZTtcbiAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICBob29rRXZlbnQuZm9yY2VLZWVwQXR0ciA9IHVuZGVmaW5lZDsgLy8gQWxsb3dzIGRldmVsb3BlcnMgdG8gc2VlIHRoaXMgaXMgYSBwcm9wZXJ0eSB0aGV5IGNhbiBzZXRcblxuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVBdHRyaWJ1dGUnLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTtcblxuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG5cbiAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIFJlbW92ZSBhdHRyaWJ1dGUgKi9cblxuXG4gICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuXG5cbiAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG5cblxuICAgICAgaWYgKCFBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgJiYgcmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG5cblxuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIE1VU1RBQ0hFX0VYUFIsICcgJyk7XG4gICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgRVJCX0VYUFIsICcgJyk7XG4gICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgVE1QTElUX0VYUFIsICcgJyk7XG4gICAgICB9XG4gICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cblxuXG4gICAgICBjb25zdCBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcblxuICAgICAgaWYgKCFfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBGdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gdmlhIG5hbWVzcGFjZSBpc29sYXRpb24sXG4gICAgICAgKiBQcmVmaXggaWQgYW5kIG5hbWUgYXR0cmlidXRlcyB3aXRoIGB1c2VyLWNvbnRlbnQtYFxuICAgICAgICovXG5cblxuICAgICAgaWYgKFNBTklUSVpFX05BTUVEX1BST1BTICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyB2YWx1ZVxuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTsgLy8gUHJlZml4IHRoZSB2YWx1ZSBhbmQgbGF0ZXIgcmUtY3JlYXRlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FuaXRpemVkIHZhbHVlXG5cblxuICAgICAgICB2YWx1ZSA9IFNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCArIHZhbHVlO1xuICAgICAgfVxuICAgICAgLyogSGFuZGxlIGF0dHJpYnV0ZXMgdGhhdCByZXF1aXJlIFRydXN0ZWQgVHlwZXMgKi9cblxuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAobmFtZXNwYWNlVVJJKSA7IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAodHJ1c3RlZFR5cGVzLmdldEF0dHJpYnV0ZVR5cGUobGNUYWcsIGxjTmFtZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRIVE1MJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRTY3JpcHRVUkwnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlU2NyaXB0VVJMKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogSGFuZGxlIGludmFsaWQgZGF0YS0qIGF0dHJpYnV0ZSBzZXQgYnkgdHJ5LWNhdGNoaW5nIGl0ICovXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cblxuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gIH07XG4gIC8qKlxuICAgKiBfc2FuaXRpemVTaGFkb3dET01cbiAgICpcbiAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAqL1xuXG5cbiAgY29uc3QgX3Nhbml0aXplU2hhZG93RE9NID0gZnVuY3Rpb24gX3Nhbml0aXplU2hhZG93RE9NKGZyYWdtZW50KSB7XG4gICAgbGV0IHNoYWRvd05vZGU7XG5cbiAgICBjb25zdCBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuXG5cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuXG4gICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZVNoYWRvd05vZGUnLCBzaGFkb3dOb2RlLCBudWxsKTtcbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG5cblxuICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogRGVlcCBzaGFkb3cgRE9NIGRldGVjdGVkICovXG5cblxuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzLCBzYW5pdGl6ZSBpZiBuZWNlc3NhcnkgKi9cblxuXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cblxuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNhbml0aXplXG4gICAqIFB1YmxpYyBtZXRob2QgcHJvdmlkaW5nIGNvcmUgc2FuaXRhdGlvbiBmdW5jdGlvbmFsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IGRpcnR5IHN0cmluZyBvciBET00gbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cblxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHkpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgaW1wb3J0ZWROb2RlO1xuICAgIGxldCBjdXJyZW50Tm9kZTtcbiAgICBsZXQgcmV0dXJuTm9kZTtcbiAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgIERPIE5PVCByZXR1cm4gZWFybHksIGFzIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdyb25nIHR5cGUgaWZcbiAgICAgIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgYSBET00gb2JqZWN0IHJhdGhlciB0aGFuIGEgc3RyaW5nICovXG5cbiAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcblxuICAgIGlmIChJU19FTVBUWV9JTlBVVCkge1xuICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgIH1cbiAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG5cblxuICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgaWYgKHR5cGVvZiBkaXJ0eS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJ0eSA9IGRpcnR5LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZXR1cm4gZGlydHkgSFRNTCBpZiBET01QdXJpZnkgY2Fubm90IHJ1biAqL1xuXG5cbiAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cblxuXG4gICAgaWYgKCFTRVRfQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICB9XG4gICAgLyogQ2xlYW4gdXAgcmVtb3ZlZCBlbGVtZW50cyAqL1xuXG5cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cblxuICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBJTl9QTEFDRSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgLyogRG8gc29tZSBlYXJseSBwcmUtc2FuaXRpemF0aW9uIHRvIGF2b2lkIHVuc2FmZSByb290IG5vZGVzICovXG4gICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGRpcnR5Lm5vZGVOYW1lKTtcblxuICAgICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgncm9vdCBub2RlIGlzIGZvcmJpZGRlbiBhbmQgY2Fubm90IGJlIHNhbml0aXplZCBpbi1wbGFjZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgZWxlbWVudHMgYmVpbmcgc3RyaXBwZWQgYnkgdGhlIHBhcnNlciAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcblxuICAgICAgaWYgKGltcG9ydGVkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBFeGl0IGRpcmVjdGx5IGlmIHdlIGhhdmUgbm90aGluZyB0byBkbyAqL1xuICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIH1cbiAgICAgIC8qIEluaXRpYWxpemUgdGhlIGRvY3VtZW50IHRvIHdvcmsgb24gKi9cblxuXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7XG4gICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9ET00gPyBudWxsIDogUkVUVVJOX1RSVVNURURfVFlQRSA/IGVtcHR5SFRNTCA6ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuXG5cbiAgICBpZiAoYm9keSAmJiBGT1JDRV9CT0RZKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cblxuXG4gICAgY29uc3Qgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcbiAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cblxuXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogU2hhZG93IERPTSBkZXRlY3RlZCwgc2FuaXRpemUgaXQgKi9cblxuXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG5cblxuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgfVxuICAgIC8qIElmIHdlIHNhbml0aXplZCBgZGlydHlgIGluLXBsYWNlLCByZXR1cm4gaXQuICovXG5cblxuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cblxuXG4gICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICB3aGlsZSAoYm9keS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBTExPV0VEX0FUVFIuc2hhZG93cm9vdCB8fCBBTExPV0VEX0FUVFIuc2hhZG93cm9vdG1vZGUpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgIGluIHRoZW9yeSBidXQgd2Ugd291bGQgcmF0aGVyIG5vdCByaXNrIGFub3RoZXIgYXR0YWNrIHZlY3Rvci5cbiAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVybk5vZGU7XG4gICAgfVxuXG4gICAgbGV0IHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuICAgIC8qIFNlcmlhbGl6ZSBkb2N0eXBlIGlmIGFsbG93ZWQgKi9cblxuICAgIGlmIChXSE9MRV9ET0NVTUVOVCAmJiBBTExPV0VEX1RBR1NbJyFkb2N0eXBlJ10gJiYgYm9keS5vd25lckRvY3VtZW50ICYmIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlICYmIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgJiYgcmVnRXhwVGVzdChET0NUWVBFX05BTUUsIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUpKSB7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICB9XG4gICAgLyogU2FuaXRpemUgZmluYWwgc3RyaW5nIHRlbXBsYXRlLXNhZmUgKi9cblxuXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBNVVNUQUNIRV9FWFBSLCAnICcpO1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiwgJyAnKTtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgVE1QTElUX0VYUFIsICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gIH07XG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHNldCB0aGUgY29uZmlndXJhdGlvbiBvbmNlXG4gICAqIHNldENvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuXG5cbiAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICBfcGFyc2VDb25maWcoY2ZnKTtcblxuICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogY2xlYXJDb25maWdcbiAgICpcbiAgICovXG5cblxuICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgQ09ORklHID0gbnVsbDtcbiAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyB2YWxpZC5cbiAgICogVXNlcyBsYXN0IHNldCBjb25maWcsIGlmIGFueS4gT3RoZXJ3aXNlLCB1c2VzIGNvbmZpZyBkZWZhdWx0cy5cbiAgICogaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gICAqL1xuXG5cbiAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICBpZiAoIUNPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZEhvb2tcbiAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byBhZGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG5cblxuICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGhvb2tGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gaG9va3NbZW50cnlQb2ludF0gfHwgW107XG4gICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlSG9va1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhIERPTVB1cmlmeSBob29rIGF0IGEgZ2l2ZW4gZW50cnlQb2ludFxuICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZW1vdmVkKHBvcHBlZCkgaG9va1xuICAgKi9cblxuXG4gIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgIHJldHVybiBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmVtb3ZlSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9va3MgdG8gcmVtb3ZlXG4gICAqL1xuXG5cbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2tzID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmVtb3ZlQWxsSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rc1xuICAgKlxuICAgKi9cblxuXG4gIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBob29rcyA9IHt9O1xuICB9O1xuXG4gIHJldHVybiBET01QdXJpZnk7XG59XG5cbnZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuZXhwb3J0IHsgcHVyaWZ5IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJlbnRyaWVzIiwic2V0UHJvdG90eXBlT2YiLCJpc0Zyb3plbiIsImdldFByb3RvdHlwZU9mIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiT2JqZWN0IiwiZnJlZXplIiwic2VhbCIsImNyZWF0ZSIsImFwcGx5IiwiY29uc3RydWN0IiwiUmVmbGVjdCIsImZ1biIsInRoaXNWYWx1ZSIsImFyZ3MiLCJ4IiwiRnVuYyIsImFycmF5Rm9yRWFjaCIsInVuYXBwbHkiLCJBcnJheSIsInByb3RvdHlwZSIsImZvckVhY2giLCJhcnJheVBvcCIsInBvcCIsImFycmF5UHVzaCIsInB1c2giLCJzdHJpbmdUb0xvd2VyQ2FzZSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwic3RyaW5nVG9TdHJpbmciLCJ0b1N0cmluZyIsInN0cmluZ01hdGNoIiwibWF0Y2giLCJzdHJpbmdSZXBsYWNlIiwicmVwbGFjZSIsInN0cmluZ0luZGV4T2YiLCJpbmRleE9mIiwic3RyaW5nVHJpbSIsInRyaW0iLCJyZWdFeHBUZXN0IiwiUmVnRXhwIiwidGVzdCIsInR5cGVFcnJvckNyZWF0ZSIsInVuY29uc3RydWN0IiwiVHlwZUVycm9yIiwiZnVuYyIsInRoaXNBcmciLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX2tleSIsIl9sZW4yIiwiX2tleTIiLCJhZGRUb1NldCIsInNldCIsImFycmF5IiwidHJhbnNmb3JtQ2FzZUZ1bmMiLCJfdHJhbnNmb3JtQ2FzZUZ1bmMiLCJsIiwiZWxlbWVudCIsImxjRWxlbWVudCIsImNsb25lIiwib2JqZWN0IiwibmV3T2JqZWN0IiwicHJvcGVydHkiLCJ2YWx1ZSIsImxvb2t1cEdldHRlciIsInByb3AiLCJkZXNjIiwiZ2V0IiwiZmFsbGJhY2tWYWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiaHRtbCQxIiwic3ZnJDEiLCJzdmdGaWx0ZXJzIiwic3ZnRGlzYWxsb3dlZCIsIm1hdGhNbCQxIiwibWF0aE1sRGlzYWxsb3dlZCIsInRleHQiLCJodG1sIiwic3ZnIiwibWF0aE1sIiwieG1sIiwiTVVTVEFDSEVfRVhQUiIsIkVSQl9FWFBSIiwiVE1QTElUX0VYUFIiLCJEQVRBX0FUVFIiLCJBUklBX0FUVFIiLCJJU19BTExPV0VEX1VSSSIsIklTX1NDUklQVF9PUl9EQVRBIiwiQVRUUl9XSElURVNQQUNFIiwiRE9DVFlQRV9OQU1FIiwiRVhQUkVTU0lPTlMiLCJfX3Byb3RvX18iLCJnZXRHbG9iYWwiLCJ3aW5kb3ciLCJfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5IiwidHJ1c3RlZFR5cGVzIiwicHVyaWZ5SG9zdEVsZW1lbnQiLCJjcmVhdGVQb2xpY3kiLCJzdWZmaXgiLCJBVFRSX05BTUUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJwb2xpY3lOYW1lIiwiY3JlYXRlSFRNTCIsImNyZWF0ZVNjcmlwdFVSTCIsInNjcmlwdFVybCIsIl8iLCJjcmVhdGVET01QdXJpZnkiLCJ1bmRlZmluZWQiLCJET01QdXJpZnkiLCJyb290IiwidmVyc2lvbiIsInJlbW92ZWQiLCJkb2N1bWVudCIsIm5vZGVUeXBlIiwiaXNTdXBwb3J0ZWQiLCJvcmlnaW5hbERvY3VtZW50IiwiY3VycmVudFNjcmlwdCIsIkRvY3VtZW50RnJhZ21lbnQiLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiTm9kZSIsIkVsZW1lbnQiLCJOb2RlRmlsdGVyIiwiTmFtZWROb2RlTWFwIiwiTW96TmFtZWRBdHRyTWFwIiwiSFRNTEZvcm1FbGVtZW50IiwiRE9NUGFyc2VyIiwiRWxlbWVudFByb3RvdHlwZSIsImNsb25lTm9kZSIsImdldE5leHRTaWJsaW5nIiwiZ2V0Q2hpbGROb2RlcyIsImdldFBhcmVudE5vZGUiLCJ0ZW1wbGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZW50Iiwib3duZXJEb2N1bWVudCIsInRydXN0ZWRUeXBlc1BvbGljeSIsImVtcHR5SFRNTCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlTm9kZUl0ZXJhdG9yIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW1wb3J0Tm9kZSIsImhvb2tzIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiSVNfQUxMT1dFRF9VUkkkMSIsIkFMTE9XRURfVEFHUyIsIkRFRkFVTFRfQUxMT1dFRF9UQUdTIiwiQUxMT1dFRF9BVFRSIiwiREVGQVVMVF9BTExPV0VEX0FUVFIiLCJDVVNUT01fRUxFTUVOVF9IQU5ETElORyIsInRhZ05hbWVDaGVjayIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImF0dHJpYnV0ZU5hbWVDaGVjayIsImFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyIsIkZPUkJJRF9UQUdTIiwiRk9SQklEX0FUVFIiLCJBTExPV19BUklBX0FUVFIiLCJBTExPV19EQVRBX0FUVFIiLCJBTExPV19VTktOT1dOX1BST1RPQ09MUyIsIkFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiIsIlNBRkVfRk9SX1RFTVBMQVRFUyIsIldIT0xFX0RPQ1VNRU5UIiwiU0VUX0NPTkZJRyIsIkZPUkNFX0JPRFkiLCJSRVRVUk5fRE9NIiwiUkVUVVJOX0RPTV9GUkFHTUVOVCIsIlJFVFVSTl9UUlVTVEVEX1RZUEUiLCJTQU5JVElaRV9ET00iLCJTQU5JVElaRV9OQU1FRF9QUk9QUyIsIlNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCIsIktFRVBfQ09OVEVOVCIsIklOX1BMQUNFIiwiVVNFX1BST0ZJTEVTIiwiRk9SQklEX0NPTlRFTlRTIiwiREVGQVVMVF9GT1JCSURfQ09OVEVOVFMiLCJEQVRBX1VSSV9UQUdTIiwiREVGQVVMVF9EQVRBX1VSSV9UQUdTIiwiVVJJX1NBRkVfQVRUUklCVVRFUyIsIkRFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyIsIk1BVEhNTF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiSFRNTF9OQU1FU1BBQ0UiLCJOQU1FU1BBQ0UiLCJJU19FTVBUWV9JTlBVVCIsIkFMTE9XRURfTkFNRVNQQUNFUyIsIkRFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTIiwiUEFSU0VSX01FRElBX1RZUEUiLCJTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTIiwiREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSIsIkNPTkZJRyIsImZvcm1FbGVtZW50IiwiaXNSZWdleE9yRnVuY3Rpb24iLCJ0ZXN0VmFsdWUiLCJGdW5jdGlvbiIsIl9wYXJzZUNvbmZpZyIsImNmZyIsIkFERF9VUklfU0FGRV9BVFRSIiwiQUREX0RBVEFfVVJJX1RBR1MiLCJBTExPV0VEX1VSSV9SRUdFWFAiLCJBRERfVEFHUyIsIkFERF9BVFRSIiwidGFibGUiLCJ0Ym9keSIsIlRSVVNURURfVFlQRVNfUE9MSUNZIiwiTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTIiwiSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMiLCJDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTIiwiQUxMX1NWR19UQUdTIiwiQUxMX01BVEhNTF9UQUdTIiwiX2NoZWNrVmFsaWROYW1lc3BhY2UiLCJwYXJlbnQiLCJ0YWdOYW1lIiwibmFtZXNwYWNlVVJJIiwicGFyZW50VGFnTmFtZSIsIkJvb2xlYW4iLCJfZm9yY2VSZW1vdmUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwicmVtb3ZlIiwiX3JlbW92ZUF0dHJpYnV0ZSIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGVOb2RlIiwiZnJvbSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl9pbml0RG9jdW1lbnQiLCJkaXJ0eSIsImRvYyIsImxlYWRpbmdXaGl0ZXNwYWNlIiwibWF0Y2hlcyIsImRpcnR5UGF5bG9hZCIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNyZWF0ZURvY3VtZW50IiwiaW5uZXJIVE1MIiwiYm9keSIsImluc2VydEJlZm9yZSIsImNyZWF0ZVRleHROb2RlIiwiY2hpbGROb2RlcyIsImNhbGwiLCJfY3JlYXRlSXRlcmF0b3IiLCJTSE9XX0VMRU1FTlQiLCJTSE9XX0NPTU1FTlQiLCJTSE9XX1RFWFQiLCJfaXNDbG9iYmVyZWQiLCJlbG0iLCJub2RlTmFtZSIsInRleHRDb250ZW50IiwiYXR0cmlidXRlcyIsImhhc0NoaWxkTm9kZXMiLCJfaXNOb2RlIiwiX2V4ZWN1dGVIb29rIiwiZW50cnlQb2ludCIsImN1cnJlbnROb2RlIiwiZGF0YSIsImhvb2siLCJfc2FuaXRpemVFbGVtZW50cyIsImFsbG93ZWRUYWdzIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJfYmFzaWNDdXN0b21FbGVtZW50VGVzdCIsImNoaWxkQ291bnQiLCJpIiwiX2lzVmFsaWRBdHRyaWJ1dGUiLCJsY1RhZyIsImxjTmFtZSIsIl9zYW5pdGl6ZUF0dHJpYnV0ZXMiLCJhdHRyIiwiaG9va0V2ZW50IiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJrZWVwQXR0ciIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiZm9yY2VLZWVwQXR0ciIsImdldEF0dHJpYnV0ZVR5cGUiLCJzZXRBdHRyaWJ1dGVOUyIsIl9zYW5pdGl6ZVNoYWRvd0RPTSIsImZyYWdtZW50Iiwic2hhZG93Tm9kZSIsInNoYWRvd0l0ZXJhdG9yIiwibmV4dE5vZGUiLCJzYW5pdGl6ZSIsImltcG9ydGVkTm9kZSIsInJldHVybk5vZGUiLCJhcHBlbmRDaGlsZCIsImZpcnN0Q2hpbGQiLCJub2RlSXRlcmF0b3IiLCJzaGFkb3dyb290Iiwic2hhZG93cm9vdG1vZGUiLCJzZXJpYWxpemVkSFRNTCIsIm91dGVySFRNTCIsImRvY3R5cGUiLCJzZXRDb25maWciLCJjbGVhckNvbmZpZyIsImlzVmFsaWRBdHRyaWJ1dGUiLCJ0YWciLCJhZGRIb29rIiwiaG9va0Z1bmN0aW9uIiwicmVtb3ZlSG9vayIsInJlbW92ZUhvb2tzIiwicmVtb3ZlQWxsSG9va3MiLCJwdXJpZnkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dompurify/dist/purify.es.js\n");

/***/ })

};
;
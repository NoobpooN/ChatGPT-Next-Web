"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-client-axios";
exports.ids = ["vendor-chunks/openapi-client-axios"];
exports.modules = {

/***/ "(ssr)/./node_modules/openapi-client-axios/client.js":
/*!*****************************************************!*\
  !*** ./node_modules/openapi-client-axios/client.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __assign = (void 0) && (void 0).__assign || function() {\n    __assign = Object.assign || function(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __values = (void 0) && (void 0).__values || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (void 0) && (void 0).__read || function(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OpenAPIClientAxios = void 0;\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\nvar bath_es5_1 = __importDefault(__webpack_require__(/*! bath-es5 */ \"(ssr)/./node_modules/bath-es5/index.js\"));\nvar dereference_json_schema_1 = __webpack_require__(/*! dereference-json-schema */ \"(ssr)/./node_modules/dereference-json-schema/index.js\");\nvar client_1 = __webpack_require__(/*! ./types/client */ \"(ssr)/./node_modules/openapi-client-axios/types/client.js\");\nvar DefaultRunnerKey = \"default\";\n/**\n * Main class and the default export of the 'openapi-client-axios' module\n *\n * @export\n * @class OpenAPIClientAxios\n */ var OpenAPIClientAxios = /** @class */ function() {\n    /**\n     * Creates an instance of OpenAPIClientAxios.\n     *\n     * @param opts - constructor options\n     * @param {Document | string} opts.definition - the OpenAPI definition, file path or Document object\n     * @param {boolean} opts.quick - quick mode, skips validation and doesn't guarantee document is unchanged\n     * @param {boolean} opts.applyMethodCommonHeaders Should method (patch / post / put / etc.) specific default headers (from axios.defaults.headers.{method}) be applied to operation methods?\n     * @param {boolean} opts.axiosConfigDefaults - default axios config for the instance\n     * @memberof OpenAPIClientAxios\n     */ function OpenAPIClientAxios(opts) {\n        var _a;\n        var _this = this;\n        /**\n         * Returns the instance of OpenAPIClient\n         *\n         * @returns\n         * @memberof OpenAPIClientAxios\n         */ this.getClient = function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    if (!this.initialized) {\n                        return [\n                            2 /*return*/ ,\n                            this.init()\n                        ];\n                    }\n                    return [\n                        2 /*return*/ ,\n                        this.instance\n                    ];\n                });\n            });\n        };\n        /**\n         * Initializes OpenAPIClientAxios and creates a member axios client instance\n         *\n         * The init() method should be called right after creating a new instance of OpenAPIClientAxios\n         *\n         * @returns AxiosInstance\n         * @memberof OpenAPIClientAxios\n         */ this.init = function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            return [\n                                4 /*yield*/ ,\n                                this.loadDocument()\n                            ];\n                        case 1:\n                            _a.sent();\n                            // dereference the document into definition\n                            this.definition = (0, dereference_json_schema_1.dereferenceSync)(this.document);\n                            // create axios instance\n                            this.instance = this.createAxiosInstance();\n                            // we are now initialized\n                            this.initialized = true;\n                            return [\n                                2 /*return*/ ,\n                                this.instance\n                            ];\n                    }\n                });\n            });\n        };\n        /**\n         * Synchronous version of .init()\n         *\n         * Note: Only works when the input definition is a valid OpenAPI v3 object (URLs are not supported)\n         *\n         * @memberof OpenAPIClientAxios\n         */ this.initSync = function() {\n            if (typeof _this.inputDocument !== \"object\") {\n                throw new Error(\".initSync() can't be called with a non-object definition. Please use .init()\");\n            }\n            // set document\n            _this.document = _this.inputDocument;\n            // dereference the document into definition\n            _this.definition = (0, dereference_json_schema_1.dereferenceSync)(_this.document);\n            // create axios instance\n            _this.instance = _this.createAxiosInstance();\n            // we are now initialized\n            _this.initialized = true;\n            return _this.instance;\n        };\n        /**\n         * Creates a new axios instance with defaults and returns it\n         */ this.getAxiosInstance = function() {\n            var instance = axios_1.default.create(_this.axiosConfigDefaults);\n            return instance;\n        };\n        /**\n         * Creates a new axios instance, extends it and returns it\n         *\n         * @memberof OpenAPIClientAxios\n         */ this.createAxiosInstance = function() {\n            var e_1, _a;\n            // create axios instance\n            var instance = _this.getAxiosInstance();\n            // set baseURL to the one found in the definition servers (if not set in axios defaults)\n            var baseURL = _this.getBaseURL();\n            if (baseURL && !_this.axiosConfigDefaults.baseURL) {\n                instance.defaults.baseURL = baseURL;\n            }\n            // create methods for operationIds\n            var operations = _this.getOperations();\n            try {\n                for(var operations_1 = __values(operations), operations_1_1 = operations_1.next(); !operations_1_1.done; operations_1_1 = operations_1.next()){\n                    var operation = operations_1_1.value;\n                    var operationId = operation.operationId;\n                    if (operationId) {\n                        instance[_this.transformOperationName(operationId)] = _this.createOperationMethod(operation);\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (operations_1_1 && !operations_1_1.done && (_a = operations_1.return)) _a.call(operations_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            // create paths dictionary\n            // Example: api.paths['/pets/{id}'].get({ id: 1 });\n            instance.paths = {};\n            var _loop_1 = function(path) {\n                if (_this.definition.paths[path]) {\n                    if (!instance.paths[path]) {\n                        instance.paths[path] = {};\n                    }\n                    var methods = _this.definition.paths[path];\n                    var _loop_2 = function(m) {\n                        if (methods[m] && Object.values(client_1.HttpMethod).includes(m)) {\n                            var method_1 = m;\n                            var operation = _this.getOperations().find(function(op) {\n                                return op.method === method_1 && op.path === path;\n                            });\n                            instance.paths[path][method_1] = _this.createOperationMethod(operation);\n                        }\n                    };\n                    for(var m in methods){\n                        _loop_2(m);\n                    }\n                }\n            };\n            for(var path in _this.definition.paths){\n                _loop_1(path);\n            }\n            // add reference to parent class instance\n            instance.api = _this;\n            return instance;\n        };\n        /**\n         * Gets the API baseurl defined in the first OpenAPI specification servers property\n         *\n         * @returns string\n         * @memberof OpenAPIClientAxios\n         */ this.getBaseURL = function(operation) {\n            var e_2, _a, e_3, _b;\n            if (!_this.definition) {\n                return undefined;\n            }\n            if (operation) {\n                if (typeof operation === \"string\") {\n                    operation = _this.getOperation(operation);\n                }\n                if (operation.servers && operation.servers[0]) {\n                    return operation.servers[0].url;\n                }\n            }\n            // get the target server from this.defaultServer\n            var targetServer;\n            if (typeof _this.defaultServer === \"number\") {\n                if (_this.definition.servers && _this.definition.servers[_this.defaultServer]) {\n                    targetServer = _this.definition.servers[_this.defaultServer];\n                }\n            } else if (typeof _this.defaultServer === \"string\") {\n                try {\n                    for(var _c = __values(_this.definition.servers), _d = _c.next(); !_d.done; _d = _c.next()){\n                        var server = _d.value;\n                        if (server.description === _this.defaultServer) {\n                            targetServer = server;\n                            break;\n                        }\n                    }\n                } catch (e_2_1) {\n                    e_2 = {\n                        error: e_2_1\n                    };\n                } finally{\n                    try {\n                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                    } finally{\n                        if (e_2) throw e_2.error;\n                    }\n                }\n            } else if (_this.defaultServer.url) {\n                targetServer = _this.defaultServer;\n            }\n            // if no targetServer is found, return undefined\n            if (!targetServer) {\n                return undefined;\n            }\n            var baseURL = targetServer.url;\n            var baseURLVariableSet = targetServer.variables;\n            // get baseURL var names\n            var baseURLBuilder = (0, bath_es5_1.default)(baseURL);\n            // if there are no variables to resolve: return baseURL as is\n            if (!baseURLBuilder.names.length) {\n                return baseURL;\n            }\n            // object to place variables resolved from this.baseURLVariables\n            var baseURLVariablesResolved = {};\n            try {\n                // step through names and assign value from this.baseURLVariables or the default value\n                // note: any variables defined in baseURLVariables but not actually variables in baseURL are ignored\n                for(var _e = __values(baseURLBuilder.names), _f = _e.next(); !_f.done; _f = _e.next()){\n                    var name_1 = _f.value;\n                    var varValue = _this.baseURLVariables[name_1];\n                    if (varValue !== undefined && baseURLVariableSet[name_1].enum) {\n                        // if varValue exists assign to baseURLVariablesResolved object\n                        if (typeof varValue === \"number\") {\n                            // if number, get value from enum array\n                            var enumVal = baseURLVariableSet[name_1].enum[varValue];\n                            if (enumVal) {\n                                baseURLVariablesResolved[name_1] = enumVal;\n                            } else {\n                                // if supplied value out of range: throw error\n                                throw new Error(\"index \".concat(varValue, \" out of range for enum of baseURL variable: \").concat(name_1, \";               enum max index is \").concat(baseURLVariableSet[name_1].enum.length - 1));\n                            }\n                        } else if (typeof varValue === \"string\") {\n                            // if string, validate against enum array\n                            if (baseURLVariableSet[name_1].enum.includes(varValue)) {\n                                baseURLVariablesResolved[name_1] = varValue;\n                            } else {\n                                // if supplied value doesn't exist on enum: throw error\n                                throw new Error(\"\".concat(varValue, \" is not a valid entry for baseURL variable \").concat(name_1, \";                 variable must be of the following: \").concat(baseURLVariableSet[name_1].enum.join(\", \")));\n                            }\n                        }\n                    } else {\n                        // if varValue doesn't exist: get default\n                        baseURLVariablesResolved[name_1] = baseURLVariableSet[name_1].default;\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n            // return resolved baseURL\n            return baseURLBuilder.path(baseURLVariablesResolved);\n        };\n        /**\n         * Creates an axios config object for operation + arguments\n         * @memberof OpenAPIClientAxios\n         */ this.getAxiosConfigForOperation = function(operation, args) {\n            if (typeof operation === \"string\") {\n                operation = _this.getOperation(operation);\n            }\n            var request = _this.getRequestConfigForOperation(operation, args);\n            // construct axios request config\n            var axiosConfig = {\n                method: request.method,\n                url: request.path,\n                data: request.payload,\n                params: request.query,\n                headers: request.headers\n            };\n            // allow overriding baseURL with operation / path specific servers\n            var servers = operation.servers;\n            if (servers && servers[0]) {\n                axiosConfig.baseURL = servers[0].url;\n            }\n            // allow overriding any parameters in AxiosRequestConfig\n            var _a = __read(args, 3), config = _a[2];\n            return __assign(__assign(__assign({}, axiosConfig), config), {\n                params: __assign(__assign({}, axiosConfig === null || axiosConfig === void 0 ? void 0 : axiosConfig.params), config === null || config === void 0 ? void 0 : config.params),\n                headers: __assign(__assign({}, axiosConfig === null || axiosConfig === void 0 ? void 0 : axiosConfig.headers), config === null || config === void 0 ? void 0 : config.headers)\n            });\n        };\n        /**\n         * Creates a generic request config object for operation + arguments.\n         *\n         * This function contains the logic that handles operation method parameters.\n         *\n         * @memberof OpenAPIClientAxios\n         */ this.getRequestConfigForOperation = function(operation, args) {\n            var e_4, _a, e_5, _b, e_6, _c, e_7, _d;\n            var _e, _f;\n            if (typeof operation === \"string\") {\n                operation = _this.getOperation(operation);\n            }\n            var pathParams = {};\n            var searchParams = new URLSearchParams();\n            var query = {};\n            var headers = {};\n            var cookies = {};\n            var parameters = operation.parameters || [];\n            var setRequestParam = function(name, value, type) {\n                var e_8, _a;\n                switch(type){\n                    case client_1.ParamType.Path:\n                        pathParams[name] = value;\n                        break;\n                    case client_1.ParamType.Query:\n                        if (Array.isArray(value)) {\n                            try {\n                                for(var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()){\n                                    var valueItem = value_1_1.value;\n                                    searchParams.append(name, valueItem);\n                                }\n                            } catch (e_8_1) {\n                                e_8 = {\n                                    error: e_8_1\n                                };\n                            } finally{\n                                try {\n                                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);\n                                } finally{\n                                    if (e_8) throw e_8.error;\n                                }\n                            }\n                        } else {\n                            searchParams.append(name, value);\n                        }\n                        query[name] = value;\n                        break;\n                    case client_1.ParamType.Header:\n                        headers[name] = value;\n                        break;\n                    case client_1.ParamType.Cookie:\n                        cookies[name] = value;\n                        break;\n                }\n            };\n            var getParamType = function(paramName) {\n                var param = parameters.find(function(_a) {\n                    var name = _a.name;\n                    return name === paramName;\n                });\n                if (param) {\n                    return param.in;\n                }\n                // default all params to query if operation doesn't specify param\n                return client_1.ParamType.Query;\n            };\n            var getFirstOperationParam = function() {\n                var firstRequiredParam = parameters.find(function(_a) {\n                    var required = _a.required;\n                    return required === true;\n                });\n                if (firstRequiredParam) {\n                    return firstRequiredParam;\n                }\n                var firstParam = parameters[0];\n                if (firstParam) {\n                    return firstParam;\n                }\n            };\n            var _g = __read(args, 2), paramsArg = _g[0], payload = _g[1];\n            if (Array.isArray(paramsArg)) {\n                try {\n                    // ParamsArray\n                    for(var paramsArg_1 = __values(paramsArg), paramsArg_1_1 = paramsArg_1.next(); !paramsArg_1_1.done; paramsArg_1_1 = paramsArg_1.next()){\n                        var param = paramsArg_1_1.value;\n                        setRequestParam(param.name, param.value, param.in || getParamType(param.name));\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (paramsArg_1_1 && !paramsArg_1_1.done && (_a = paramsArg_1.return)) _a.call(paramsArg_1);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            } else if (typeof paramsArg === \"object\") {\n                // ParamsObject\n                for(var name_2 in paramsArg){\n                    if (paramsArg[name_2] !== undefined) {\n                        setRequestParam(name_2, paramsArg[name_2], getParamType(name_2));\n                    }\n                }\n            } else if (paramsArg) {\n                var firstParam = getFirstOperationParam();\n                if (!firstParam) {\n                    throw new Error(\"No parameters found for operation \".concat(operation.operationId));\n                }\n                setRequestParam(firstParam.name, paramsArg, firstParam.in);\n            }\n            // path parameters\n            var pathBuilder = (0, bath_es5_1.default)(operation.path);\n            try {\n                // make sure all path parameters are set\n                for(var _h = __values(pathBuilder.names), _j = _h.next(); !_j.done; _j = _h.next()){\n                    var name_3 = _j.value;\n                    var value = pathParams[name_3];\n                    pathParams[name_3] = \"\".concat(value);\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            var path = pathBuilder.path(pathParams);\n            // queryString parameter\n            var queryString = searchParams.toString();\n            // full url with query string\n            var url = \"\".concat(_this.getBaseURL(operation)).concat(path).concat(queryString ? \"?\".concat(queryString) : \"\");\n            // add default common headers\n            var defaultHeaders = _this.client.defaults.headers;\n            try {\n                for(var _k = __values(Object.entries((_e = defaultHeaders.common) !== null && _e !== void 0 ? _e : {})), _l = _k.next(); !_l.done; _l = _k.next()){\n                    var _m = __read(_l.value, 2), key = _m[0], val = _m[1];\n                    headers[key] = val;\n                }\n            } catch (e_6_1) {\n                e_6 = {\n                    error: e_6_1\n                };\n            } finally{\n                try {\n                    if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n                } finally{\n                    if (e_6) throw e_6.error;\n                }\n            }\n            // add method specific default headers\n            if (_this.applyMethodCommonHeaders) {\n                var methodHeaders = (_f = defaultHeaders[operation.method]) !== null && _f !== void 0 ? _f : {};\n                try {\n                    for(var _o = __values(Object.entries(methodHeaders)), _p = _o.next(); !_p.done; _p = _o.next()){\n                        var _q = __read(_p.value, 2), key = _q[0], val = _q[1];\n                        headers[key] = val;\n                    }\n                } catch (e_7_1) {\n                    e_7 = {\n                        error: e_7_1\n                    };\n                } finally{\n                    try {\n                        if (_p && !_p.done && (_d = _o.return)) _d.call(_o);\n                    } finally{\n                        if (e_7) throw e_7.error;\n                    }\n                }\n            }\n            // construct request config\n            var config = {\n                method: operation.method,\n                url: url,\n                path: path,\n                pathParams: pathParams,\n                query: query,\n                queryString: queryString,\n                headers: headers,\n                cookies: cookies,\n                payload: payload\n            };\n            return config;\n        };\n        /**\n         * Flattens operations into a simple array of Operation objects easy to work with\n         *\n         * @returns {Operation[]}\n         * @memberof OpenAPIBackend\n         */ this.getOperations = function() {\n            var _a;\n            var paths = ((_a = _this.definition) === null || _a === void 0 ? void 0 : _a.paths) || {};\n            return Object.entries(paths).flatMap(function(_a) {\n                var _b = __read(_a, 2), path = _b[0], pathObject = _b[1];\n                return Object.values(client_1.HttpMethod).map(function(method) {\n                    return {\n                        path: path,\n                        method: method,\n                        operation: pathObject[method]\n                    };\n                }).filter(function(_a) {\n                    var operation = _a.operation;\n                    return operation;\n                }).map(function(_a) {\n                    var _b;\n                    var operation = _a.operation, method = _a.method;\n                    var op = __assign(__assign({}, typeof operation === \"object\" ? operation : {}), {\n                        path: path,\n                        method: method\n                    });\n                    if (pathObject.parameters) {\n                        op.parameters = __spreadArray(__spreadArray([], __read(op.parameters || []), false), __read(pathObject.parameters), false);\n                    }\n                    if (pathObject.servers) {\n                        op.servers = __spreadArray(__spreadArray([], __read(op.servers || []), false), __read(pathObject.servers), false);\n                    }\n                    op.security = (_b = op.security) !== null && _b !== void 0 ? _b : _this.definition.security;\n                    return op;\n                });\n            });\n        };\n        /**\n         * Gets a single operation based on operationId\n         *\n         * @param {string} operationId\n         * @returns {Operation}\n         * @memberof OpenAPIBackend\n         */ this.getOperation = function(operationId) {\n            return _this.getOperations().find(function(op) {\n                return op.operationId === operationId;\n            });\n        };\n        /**\n         * Creates an axios method for an operation\n         * (...pathParams, data?, config?) => Promise<AxiosResponse>\n         *\n         * @param {Operation} operation\n         * @memberof OpenAPIClientAxios\n         */ this.createOperationMethod = function(operation) {\n            var originalOperationMethod = function() {\n                var args = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    args[_i] = arguments[_i];\n                }\n                return __awaiter(_this, void 0, void 0, function() {\n                    var axiosConfig, runner;\n                    return __generator(this, function(_a) {\n                        axiosConfig = this.getAxiosConfigForOperation(operation, args);\n                        runner = this.getRunner(operation.operationId);\n                        return [\n                            2 /*return*/ ,\n                            runner.runRequest(axiosConfig, operation, runner.context)\n                        ];\n                    });\n                });\n            };\n            return _this.transformOperationMethod(originalOperationMethod, operation);\n        };\n        var optsWithDefaults = __assign(__assign({\n            quick: false,\n            withServer: 0,\n            baseURLVariables: {},\n            transformOperationName: function(operationId) {\n                return operationId;\n            },\n            transformOperationMethod: function(operationMethod) {\n                return operationMethod;\n            },\n            axiosRunner: function(axiosConfig) {\n                return _this.client.request(axiosConfig);\n            },\n            applyMethodCommonHeaders: false\n        }, opts), {\n            axiosConfigDefaults: __assign({}, opts.axiosConfigDefaults || {})\n        });\n        this.inputDocument = optsWithDefaults.definition;\n        this.quick = optsWithDefaults.quick;\n        this.axiosConfigDefaults = optsWithDefaults.axiosConfigDefaults;\n        this.defaultServer = optsWithDefaults.withServer;\n        this.baseURLVariables = optsWithDefaults.baseURLVariables;\n        this.applyMethodCommonHeaders = optsWithDefaults.applyMethodCommonHeaders;\n        this.transformOperationName = optsWithDefaults.transformOperationName;\n        this.transformOperationMethod = optsWithDefaults.transformOperationMethod;\n        this.runners = (_a = {}, _a[DefaultRunnerKey] = {\n            runRequest: optsWithDefaults.axiosRunner\n        }, _a);\n    }\n    Object.defineProperty(OpenAPIClientAxios.prototype, \"client\", {\n        /**\n         * Returns the instance of OpenAPIClient\n         *\n         * @readonly\n         * @type {OpenAPIClient}\n         * @memberof OpenAPIClientAxios\n         */ get: function() {\n            return this.instance;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OpenAPIClientAxios.prototype.withServer = function(server, variables) {\n        if (variables === void 0) {\n            variables = {};\n        }\n        this.defaultServer = server;\n        this.baseURLVariables = variables;\n    };\n    /**\n     * Loads document from inputDocument\n     *\n     * Supports loading from a string (url) or an object (json)\n     *\n     * @memberof OpenAPIClientAxios\n     */ OpenAPIClientAxios.prototype.loadDocument = function() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function() {\n            var client, documentRes, yaml, err;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        if (!(typeof this.inputDocument === \"object\")) return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                        this.document = this.inputDocument;\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 1:\n                        client = this.getAxiosInstance();\n                        return [\n                            4 /*yield*/ ,\n                            client.get(this.inputDocument)\n                        ];\n                    case 2:\n                        documentRes = _b.sent();\n                        if (!(typeof documentRes.data === \"object\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        // json response\n                        this.document = documentRes.data;\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 3:\n                        if (!(typeof documentRes.data === \"string\" && ((_a = documentRes.headers[\"content-type\"]) === null || _a === void 0 ? void 0 : _a.match(/ya?ml/)))) return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve().then(function() {\n                                return __importStar(__webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\"));\n                            })\n                        ];\n                    case 4:\n                        yaml = _b.sent();\n                        this.document = yaml.load(documentRes.data);\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 5:\n                        err = new Error(\"Invalid response fetching OpenAPI definition: \".concat(documentRes));\n                        err.response = documentRes;\n                        throw err;\n                    case 6:\n                        return [\n                            2 /*return*/ ,\n                            this.document\n                        ];\n                }\n            });\n        });\n    };\n    /**\n     * By default OpenAPIClient will use axios as request runner. You can register a different runner,\n     * in case you want to switch over from axios. This allows transitioning from axios to your library of choice.\n     * @param runner - request runner to be registered, either for all operations, or just one operation.\n     * @param operationId - optional parameter. If provided, runner will be registered for a single operation. Else, it will be registered for all operations.\n     */ OpenAPIClientAxios.prototype.registerRunner = function(runner, operationId) {\n        this.runners[operationId !== null && operationId !== void 0 ? operationId : DefaultRunnerKey] = runner;\n    };\n    OpenAPIClientAxios.prototype.getRunner = function(operationId) {\n        var _a;\n        return (_a = this.runners[operationId]) !== null && _a !== void 0 ? _a : this.runners[DefaultRunnerKey];\n    };\n    return OpenAPIClientAxios;\n}();\nexports.OpenAPIClientAxios = OpenAPIClientAxios; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1jbGllbnQtYXhpb3MvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBVyxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFFBQVEsSUFBSztJQUN0Q0EsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVNDLENBQUM7UUFDbEMsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSUksS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUN6RE4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUNuQjtRQUNBLE9BQU9OO0lBQ1g7SUFDQSxPQUFPSCxTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFTjtBQUNoQztBQUNBLElBQUlPLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTWIsQ0FBQUEsT0FBT2MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT3BCLE9BQU9xQix3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBakIsT0FBTzJCLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVB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QUFZckYsSUFBSTt3QkFDMUMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQzNCLEtBQUs7d0JBQ0R1RixNQUFNLElBQUlySixNQUFNLGlEQUFpRHhCLE1BQU0sQ0FBQzJLO3dCQUN4RUUsSUFBSUcsUUFBUSxHQUFHTDt3QkFDZixNQUFNRTtvQkFDVixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJLElBQUksQ0FBQ3pKLFFBQVE7eUJBQUM7Z0JBQ2hEO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRGpCLG1CQUFtQnpFLFNBQVMsQ0FBQ3VQLGNBQWMsR0FBRyxTQUFVakIsTUFBTSxFQUFFM0gsV0FBVztRQUN2RSxJQUFJLENBQUNxSSxPQUFPLENBQUNySSxnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSUEsY0FBYzVCLGlCQUFpQixHQUFHdUo7SUFDcEc7SUFDQTdKLG1CQUFtQnpFLFNBQVMsQ0FBQ3VPLFNBQVMsR0FBRyxTQUFVNUgsV0FBVztRQUMxRCxJQUFJMUI7UUFDSixPQUFPLENBQUNBLEtBQUssSUFBSSxDQUFDK0osT0FBTyxDQUFDckksWUFBWSxNQUFNLFFBQVExQixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQUMrSixPQUFPLENBQUNqSyxpQkFBaUI7SUFDM0c7SUFDQSxPQUFPTjtBQUNYO0FBQ0FELDBCQUEwQixHQUFHQyxvQkFDN0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGNoYXQvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1jbGllbnQtYXhpb3MvY2xpZW50LmpzP2M3MzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wZW5BUElDbGllbnRBeGlvcyA9IHZvaWQgMDtcbnZhciBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG52YXIgYmF0aF9lczVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmF0aC1lczVcIikpO1xudmFyIGRlcmVmZXJlbmNlX2pzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiZGVyZWZlcmVuY2UtanNvbi1zY2hlbWFcIik7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi90eXBlcy9jbGllbnRcIik7XG52YXIgRGVmYXVsdFJ1bm5lcktleSA9ICdkZWZhdWx0Jztcbi8qKlxuICogTWFpbiBjbGFzcyBhbmQgdGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSAnb3BlbmFwaS1jbGllbnQtYXhpb3MnIG1vZHVsZVxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBPcGVuQVBJQ2xpZW50QXhpb3NcbiAqL1xudmFyIE9wZW5BUElDbGllbnRBeGlvcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE9wZW5BUElDbGllbnRBeGlvcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RG9jdW1lbnQgfCBzdHJpbmd9IG9wdHMuZGVmaW5pdGlvbiAtIHRoZSBPcGVuQVBJIGRlZmluaXRpb24sIGZpbGUgcGF0aCBvciBEb2N1bWVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMucXVpY2sgLSBxdWljayBtb2RlLCBza2lwcyB2YWxpZGF0aW9uIGFuZCBkb2Vzbid0IGd1YXJhbnRlZSBkb2N1bWVudCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuYXBwbHlNZXRob2RDb21tb25IZWFkZXJzIFNob3VsZCBtZXRob2QgKHBhdGNoIC8gcG9zdCAvIHB1dCAvIGV0Yy4pIHNwZWNpZmljIGRlZmF1bHQgaGVhZGVycyAoZnJvbSBheGlvcy5kZWZhdWx0cy5oZWFkZXJzLnttZXRob2R9KSBiZSBhcHBsaWVkIHRvIG9wZXJhdGlvbiBtZXRob2RzP1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5heGlvc0NvbmZpZ0RlZmF1bHRzIC0gZGVmYXVsdCBheGlvcyBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQVBJQ2xpZW50QXhpb3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVuQVBJQ2xpZW50QXhpb3Mob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBPcGVuQVBJQ2xpZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuQVBJQ2xpZW50QXhpb3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5pbml0KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5pbnN0YW5jZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBPcGVuQVBJQ2xpZW50QXhpb3MgYW5kIGNyZWF0ZXMgYSBtZW1iZXIgYXhpb3MgY2xpZW50IGluc3RhbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBpbml0KCkgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2Ugb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEF4aW9zSW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5BUElDbGllbnRBeGlvc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmxvYWREb2N1bWVudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVyZWZlcmVuY2UgdGhlIGRvY3VtZW50IGludG8gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gKDAsIGRlcmVmZXJlbmNlX2pzb25fc2NoZW1hXzEuZGVyZWZlcmVuY2VTeW5jKSh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBheGlvcyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IHRoaXMuY3JlYXRlQXhpb3NJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdyBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5pbnN0YW5jZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiAuaW5pdCgpXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IE9ubHkgd29ya3Mgd2hlbiB0aGUgaW5wdXQgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIE9wZW5BUEkgdjMgb2JqZWN0IChVUkxzIGFyZSBub3Qgc3VwcG9ydGVkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5pbnB1dERvY3VtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5pbml0U3luYygpIGNhbid0IGJlIGNhbGxlZCB3aXRoIGEgbm9uLW9iamVjdCBkZWZpbml0aW9uLiBQbGVhc2UgdXNlIC5pbml0KClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgZG9jdW1lbnRcbiAgICAgICAgICAgIF90aGlzLmRvY3VtZW50ID0gX3RoaXMuaW5wdXREb2N1bWVudDtcbiAgICAgICAgICAgIC8vIGRlcmVmZXJlbmNlIHRoZSBkb2N1bWVudCBpbnRvIGRlZmluaXRpb25cbiAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb24gPSAoMCwgZGVyZWZlcmVuY2VfanNvbl9zY2hlbWFfMS5kZXJlZmVyZW5jZVN5bmMpKF90aGlzLmRvY3VtZW50KTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBheGlvcyBpbnN0YW5jZVxuICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UgPSBfdGhpcy5jcmVhdGVBeGlvc0luc3RhbmNlKCk7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm93IGluaXRpYWxpemVkXG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGF4aW9zIGluc3RhbmNlIHdpdGggZGVmYXVsdHMgYW5kIHJldHVybnMgaXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXhpb3NJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGF4aW9zXzEuZGVmYXVsdC5jcmVhdGUoX3RoaXMuYXhpb3NDb25maWdEZWZhdWx0cyk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGF4aW9zIGluc3RhbmNlLCBleHRlbmRzIGl0IGFuZCByZXR1cm5zIGl0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuQVBJQ2xpZW50QXhpb3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlQXhpb3NJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGF4aW9zIGluc3RhbmNlXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfdGhpcy5nZXRBeGlvc0luc3RhbmNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgYmFzZVVSTCB0byB0aGUgb25lIGZvdW5kIGluIHRoZSBkZWZpbml0aW9uIHNlcnZlcnMgKGlmIG5vdCBzZXQgaW4gYXhpb3MgZGVmYXVsdHMpXG4gICAgICAgICAgICB2YXIgYmFzZVVSTCA9IF90aGlzLmdldEJhc2VVUkwoKTtcbiAgICAgICAgICAgIGlmIChiYXNlVVJMICYmICFfdGhpcy5heGlvc0NvbmZpZ0RlZmF1bHRzLmJhc2VVUkwpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kZWZhdWx0cy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBtZXRob2RzIGZvciBvcGVyYXRpb25JZHNcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gX3RoaXMuZ2V0T3BlcmF0aW9ucygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvcGVyYXRpb25zXzEgPSBfX3ZhbHVlcyhvcGVyYXRpb25zKSwgb3BlcmF0aW9uc18xXzEgPSBvcGVyYXRpb25zXzEubmV4dCgpOyAhb3BlcmF0aW9uc18xXzEuZG9uZTsgb3BlcmF0aW9uc18xXzEgPSBvcGVyYXRpb25zXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbklkID0gb3BlcmF0aW9uLm9wZXJhdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW190aGlzLnRyYW5zZm9ybU9wZXJhdGlvbk5hbWUob3BlcmF0aW9uSWQpXSA9IF90aGlzLmNyZWF0ZU9wZXJhdGlvbk1ldGhvZChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25zXzFfMSAmJiAhb3BlcmF0aW9uc18xXzEuZG9uZSAmJiAoX2EgPSBvcGVyYXRpb25zXzEucmV0dXJuKSkgX2EuY2FsbChvcGVyYXRpb25zXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGF0aHMgZGljdGlvbmFyeVxuICAgICAgICAgICAgLy8gRXhhbXBsZTogYXBpLnBhdGhzWycvcGV0cy97aWR9J10uZ2V0KHsgaWQ6IDEgfSk7XG4gICAgICAgICAgICBpbnN0YW5jZS5wYXRocyA9IHt9O1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZWZpbml0aW9uLnBhdGhzW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UucGF0aHNbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhdGhzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBfdGhpcy5kZWZpbml0aW9uLnBhdGhzW3BhdGhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kc1ttXSAmJiBPYmplY3QudmFsdWVzKGNsaWVudF8xLkh0dHBNZXRob2QpLmluY2x1ZGVzKG0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZF8xID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gX3RoaXMuZ2V0T3BlcmF0aW9ucygpLmZpbmQoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5tZXRob2QgPT09IG1ldGhvZF8xICYmIG9wLnBhdGggPT09IHBhdGg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhdGhzW3BhdGhdW21ldGhvZF8xXSA9IF90aGlzLmNyZWF0ZU9wZXJhdGlvbk1ldGhvZChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzIobSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcGF0aCBpbiBfdGhpcy5kZWZpbml0aW9uLnBhdGhzKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCByZWZlcmVuY2UgdG8gcGFyZW50IGNsYXNzIGluc3RhbmNlXG4gICAgICAgICAgICBpbnN0YW5jZS5hcGkgPSBfdGhpcztcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIEFQSSBiYXNldXJsIGRlZmluZWQgaW4gdGhlIGZpcnN0IE9wZW5BUEkgc3BlY2lmaWNhdGlvbiBzZXJ2ZXJzIHByb3BlcnR5XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEJhc2VVUkwgPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYjtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IF90aGlzLmdldE9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNlcnZlcnMgJiYgb3BlcmF0aW9uLnNlcnZlcnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5zZXJ2ZXJzWzBdLnVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHRhcmdldCBzZXJ2ZXIgZnJvbSB0aGlzLmRlZmF1bHRTZXJ2ZXJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTZXJ2ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLmRlZmF1bHRTZXJ2ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlZmluaXRpb24uc2VydmVycyAmJiBfdGhpcy5kZWZpbml0aW9uLnNlcnZlcnNbX3RoaXMuZGVmYXVsdFNlcnZlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2VydmVyID0gX3RoaXMuZGVmaW5pdGlvbi5zZXJ2ZXJzW190aGlzLmRlZmF1bHRTZXJ2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBfdGhpcy5kZWZhdWx0U2VydmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoX3RoaXMuZGVmaW5pdGlvbi5zZXJ2ZXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlci5kZXNjcmlwdGlvbiA9PT0gX3RoaXMuZGVmYXVsdFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5kZWZhdWx0U2VydmVyLnVybCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNlcnZlciA9IF90aGlzLmRlZmF1bHRTZXJ2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBubyB0YXJnZXRTZXJ2ZXIgaXMgZm91bmQsIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghdGFyZ2V0U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXNlVVJMID0gdGFyZ2V0U2VydmVyLnVybDtcbiAgICAgICAgICAgIHZhciBiYXNlVVJMVmFyaWFibGVTZXQgPSB0YXJnZXRTZXJ2ZXIudmFyaWFibGVzO1xuICAgICAgICAgICAgLy8gZ2V0IGJhc2VVUkwgdmFyIG5hbWVzXG4gICAgICAgICAgICB2YXIgYmFzZVVSTEJ1aWxkZXIgPSAoMCwgYmF0aF9lczVfMS5kZWZhdWx0KShiYXNlVVJMKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2YXJpYWJsZXMgdG8gcmVzb2x2ZTogcmV0dXJuIGJhc2VVUkwgYXMgaXNcbiAgICAgICAgICAgIGlmICghYmFzZVVSTEJ1aWxkZXIubmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvYmplY3QgdG8gcGxhY2UgdmFyaWFibGVzIHJlc29sdmVkIGZyb20gdGhpcy5iYXNlVVJMVmFyaWFibGVzXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFZhcmlhYmxlc1Jlc29sdmVkID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHN0ZXAgdGhyb3VnaCBuYW1lcyBhbmQgYXNzaWduIHZhbHVlIGZyb20gdGhpcy5iYXNlVVJMVmFyaWFibGVzIG9yIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gbm90ZTogYW55IHZhcmlhYmxlcyBkZWZpbmVkIGluIGJhc2VVUkxWYXJpYWJsZXMgYnV0IG5vdCBhY3R1YWxseSB2YXJpYWJsZXMgaW4gYmFzZVVSTCBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMoYmFzZVVSTEJ1aWxkZXIubmFtZXMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlID0gX3RoaXMuYmFzZVVSTFZhcmlhYmxlc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBiYXNlVVJMVmFyaWFibGVTZXRbbmFtZV8xXS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB2YXJWYWx1ZSBleGlzdHMgYXNzaWduIHRvIGJhc2VVUkxWYXJpYWJsZXNSZXNvbHZlZCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFyVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbnVtYmVyLCBnZXQgdmFsdWUgZnJvbSBlbnVtIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudW1WYWwgPSBiYXNlVVJMVmFyaWFibGVTZXRbbmFtZV8xXS5lbnVtW3ZhclZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW51bVZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVVJMVmFyaWFibGVzUmVzb2x2ZWRbbmFtZV8xXSA9IGVudW1WYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzdXBwbGllZCB2YWx1ZSBvdXQgb2YgcmFuZ2U6IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IFwiLmNvbmNhdCh2YXJWYWx1ZSwgXCIgb3V0IG9mIHJhbmdlIGZvciBlbnVtIG9mIGJhc2VVUkwgdmFyaWFibGU6IFwiKS5jb25jYXQobmFtZV8xLCBcIjsgICAgICAgICAgICAgICBlbnVtIG1heCBpbmRleCBpcyBcIikuY29uY2F0KGJhc2VVUkxWYXJpYWJsZVNldFtuYW1lXzFdLmVudW0ubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzdHJpbmcsIHZhbGlkYXRlIGFnYWluc3QgZW51bSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVVJMVmFyaWFibGVTZXRbbmFtZV8xXS5lbnVtLmluY2x1ZGVzKHZhclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVVJMVmFyaWFibGVzUmVzb2x2ZWRbbmFtZV8xXSA9IHZhclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc3VwcGxpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBvbiBlbnVtOiB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodmFyVmFsdWUsIFwiIGlzIG5vdCBhIHZhbGlkIGVudHJ5IGZvciBiYXNlVVJMIHZhcmlhYmxlIFwiKS5jb25jYXQobmFtZV8xLCBcIjsgICAgICAgICAgICAgICAgIHZhcmlhYmxlIG11c3QgYmUgb2YgdGhlIGZvbGxvd2luZzogXCIpLmNvbmNhdChiYXNlVVJMVmFyaWFibGVTZXRbbmFtZV8xXS5lbnVtLmpvaW4oJywgJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB2YXJWYWx1ZSBkb2Vzbid0IGV4aXN0OiBnZXQgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVSTFZhcmlhYmxlc1Jlc29sdmVkW25hbWVfMV0gPSBiYXNlVVJMVmFyaWFibGVTZXRbbmFtZV8xXS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIHJlc29sdmVkIGJhc2VVUkxcbiAgICAgICAgICAgIHJldHVybiBiYXNlVVJMQnVpbGRlci5wYXRoKGJhc2VVUkxWYXJpYWJsZXNSZXNvbHZlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGF4aW9zIGNvbmZpZyBvYmplY3QgZm9yIG9wZXJhdGlvbiArIGFyZ3VtZW50c1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEF4aW9zQ29uZmlnRm9yT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgYXJncykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gX3RoaXMuZ2V0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF90aGlzLmdldFJlcXVlc3RDb25maWdGb3JPcGVyYXRpb24ob3BlcmF0aW9uLCBhcmdzKTtcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBheGlvcyByZXF1ZXN0IGNvbmZpZ1xuICAgICAgICAgICAgdmFyIGF4aW9zQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnBhdGgsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdC5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gYWxsb3cgb3ZlcnJpZGluZyBiYXNlVVJMIHdpdGggb3BlcmF0aW9uIC8gcGF0aCBzcGVjaWZpYyBzZXJ2ZXJzXG4gICAgICAgICAgICB2YXIgc2VydmVycyA9IG9wZXJhdGlvbi5zZXJ2ZXJzO1xuICAgICAgICAgICAgaWYgKHNlcnZlcnMgJiYgc2VydmVyc1swXSkge1xuICAgICAgICAgICAgICAgIGF4aW9zQ29uZmlnLmJhc2VVUkwgPSBzZXJ2ZXJzWzBdLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsbG93IG92ZXJyaWRpbmcgYW55IHBhcmFtZXRlcnMgaW4gQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoYXJncywgMyksIGNvbmZpZyA9IF9hWzJdO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBheGlvc0NvbmZpZyksIGNvbmZpZyksIHsgcGFyYW1zOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXhpb3NDb25maWcgPT09IG51bGwgfHwgYXhpb3NDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aW9zQ29uZmlnLnBhcmFtcyksIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5wYXJhbXMpLCBoZWFkZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXhpb3NDb25maWcgPT09IG51bGwgfHwgYXhpb3NDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aW9zQ29uZmlnLmhlYWRlcnMpLCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaGVhZGVycykgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZ2VuZXJpYyByZXF1ZXN0IGNvbmZpZyBvYmplY3QgZm9yIG9wZXJhdGlvbiArIGFyZ3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBjb250YWlucyB0aGUgbG9naWMgdGhhdCBoYW5kbGVzIG9wZXJhdGlvbiBtZXRob2QgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5BUElDbGllbnRBeGlvc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRSZXF1ZXN0Q29uZmlnRm9yT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgYXJncykge1xuICAgICAgICAgICAgdmFyIGVfNCwgX2EsIGVfNSwgX2IsIGVfNiwgX2MsIGVfNywgX2Q7XG4gICAgICAgICAgICB2YXIgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gX3RoaXMuZ2V0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF0aFBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHt9O1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBjb29raWVzID0ge307XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IChvcGVyYXRpb24ucGFyYW1ldGVycyB8fCBbXSk7XG4gICAgICAgICAgICB2YXIgc2V0UmVxdWVzdFBhcmFtID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfOCwgX2E7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY2xpZW50XzEuUGFyYW1UeXBlLlBhdGg6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoUGFyYW1zW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjbGllbnRfMS5QYXJhbVR5cGUuUXVlcnk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2YWx1ZV8xID0gX192YWx1ZXModmFsdWUpLCB2YWx1ZV8xXzEgPSB2YWx1ZV8xLm5leHQoKTsgIXZhbHVlXzFfMS5kb25lOyB2YWx1ZV8xXzEgPSB2YWx1ZV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlSXRlbSA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzFfMSAmJiAhdmFsdWVfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVfMS5yZXR1cm4pKSBfYS5jYWxsKHZhbHVlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV84KSB0aHJvdyBlXzguZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjbGllbnRfMS5QYXJhbVR5cGUuSGVhZGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY2xpZW50XzEuUGFyYW1UeXBlLkNvb2tpZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0UGFyYW1UeXBlID0gZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtZXRlcnMuZmluZChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gcGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0uaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgYWxsIHBhcmFtcyB0byBxdWVyeSBpZiBvcGVyYXRpb24gZG9lc24ndCBzcGVjaWZ5IHBhcmFtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudF8xLlBhcmFtVHlwZS5RdWVyeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0Rmlyc3RPcGVyYXRpb25QYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RSZXF1aXJlZFBhcmFtID0gcGFyYW1ldGVycy5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBfYS5yZXF1aXJlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlcXVpcmVkUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UmVxdWlyZWRQYXJhbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGFyYW0gPSBwYXJhbWV0ZXJzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2cgPSBfX3JlYWQoYXJncywgMiksIHBhcmFtc0FyZyA9IF9nWzBdLCBwYXlsb2FkID0gX2dbMV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNBcmcpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyYW1zQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcGFyYW1zQXJnXzEgPSBfX3ZhbHVlcyhwYXJhbXNBcmcpLCBwYXJhbXNBcmdfMV8xID0gcGFyYW1zQXJnXzEubmV4dCgpOyAhcGFyYW1zQXJnXzFfMS5kb25lOyBwYXJhbXNBcmdfMV8xID0gcGFyYW1zQXJnXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNBcmdfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdFBhcmFtKHBhcmFtLm5hbWUsIHBhcmFtLnZhbHVlLCBwYXJhbS5pbiB8fCBnZXRQYXJhbVR5cGUocGFyYW0ubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zQXJnXzFfMSAmJiAhcGFyYW1zQXJnXzFfMS5kb25lICYmIChfYSA9IHBhcmFtc0FyZ18xLnJldHVybikpIF9hLmNhbGwocGFyYW1zQXJnXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zQXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFBhcmFtc09iamVjdFxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMiBpbiBwYXJhbXNBcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc0FyZ1tuYW1lXzJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RQYXJhbShuYW1lXzIsIHBhcmFtc0FyZ1tuYW1lXzJdLCBnZXRQYXJhbVR5cGUobmFtZV8yKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbXNBcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQYXJhbSA9IGdldEZpcnN0T3BlcmF0aW9uUGFyYW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGFyYW1ldGVycyBmb3VuZCBmb3Igb3BlcmF0aW9uIFwiLmNvbmNhdChvcGVyYXRpb24ub3BlcmF0aW9uSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UmVxdWVzdFBhcmFtKGZpcnN0UGFyYW0ubmFtZSwgcGFyYW1zQXJnLCBmaXJzdFBhcmFtLmluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhdGggcGFyYW1ldGVyc1xuICAgICAgICAgICAgdmFyIHBhdGhCdWlsZGVyID0gKDAsIGJhdGhfZXM1XzEuZGVmYXVsdCkob3BlcmF0aW9uLnBhdGgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHBhdGggcGFyYW1ldGVycyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2ggPSBfX3ZhbHVlcyhwYXRoQnVpbGRlci5uYW1lcyksIF9qID0gX2gubmV4dCgpOyAhX2ouZG9uZTsgX2ogPSBfaC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMyA9IF9qLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXRoUGFyYW1zW25hbWVfM107XG4gICAgICAgICAgICAgICAgICAgIHBhdGhQYXJhbXNbbmFtZV8zXSA9IFwiXCIuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9qICYmICFfai5kb25lICYmIChfYiA9IF9oLnJldHVybikpIF9iLmNhbGwoX2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhCdWlsZGVyLnBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICAvLyBxdWVyeVN0cmluZyBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gZnVsbCB1cmwgd2l0aCBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChfdGhpcy5nZXRCYXNlVVJMKG9wZXJhdGlvbikpLmNvbmNhdChwYXRoKS5jb25jYXQocXVlcnlTdHJpbmcgPyBcIj9cIi5jb25jYXQocXVlcnlTdHJpbmcpIDogJycpO1xuICAgICAgICAgICAgLy8gYWRkIGRlZmF1bHQgY29tbW9uIGhlYWRlcnNcbiAgICAgICAgICAgIHZhciBkZWZhdWx0SGVhZGVycyA9IF90aGlzLmNsaWVudC5kZWZhdWx0cy5oZWFkZXJzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IF9fdmFsdWVzKE9iamVjdC5lbnRyaWVzKChfZSA9IGRlZmF1bHRIZWFkZXJzLmNvbW1vbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30pKSwgX2wgPSBfay5uZXh0KCk7ICFfbC5kb25lOyBfbCA9IF9rLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX20gPSBfX3JlYWQoX2wudmFsdWUsIDIpLCBrZXkgPSBfbVswXSwgdmFsID0gX21bMV07XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9sICYmICFfbC5kb25lICYmIChfYyA9IF9rLnJldHVybikpIF9jLmNhbGwoX2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgbWV0aG9kIHNwZWNpZmljIGRlZmF1bHQgaGVhZGVyc1xuICAgICAgICAgICAgaWYgKF90aGlzLmFwcGx5TWV0aG9kQ29tbW9uSGVhZGVycykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzID0gKF9mID0gZGVmYXVsdEhlYWRlcnNbb3BlcmF0aW9uLm1ldGhvZF0pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9vID0gX192YWx1ZXMoT2JqZWN0LmVudHJpZXMobWV0aG9kSGVhZGVycykpLCBfcCA9IF9vLm5leHQoKTsgIV9wLmRvbmU7IF9wID0gX28ubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3EgPSBfX3JlYWQoX3AudmFsdWUsIDIpLCBrZXkgPSBfcVswXSwgdmFsID0gX3FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcCAmJiAhX3AuZG9uZSAmJiAoX2QgPSBfby5yZXR1cm4pKSBfZC5jYWxsKF9vKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHJlcXVlc3QgY29uZmlnXG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogb3BlcmF0aW9uLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHBhdGhQYXJhbXM6IHBhdGhQYXJhbXMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nOiBxdWVyeVN0cmluZyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNvb2tpZXM6IGNvb2tpZXMsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhdHRlbnMgb3BlcmF0aW9ucyBpbnRvIGEgc2ltcGxlIGFycmF5IG9mIE9wZXJhdGlvbiBvYmplY3RzIGVhc3kgdG8gd29yayB3aXRoXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRpb25bXX1cbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5BUElCYWNrZW5kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE9wZXJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSAoKF9hID0gX3RoaXMuZGVmaW5pdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGhzKSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwYXRocykuZmxhdE1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwYXRoID0gX2JbMF0sIHBhdGhPYmplY3QgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjbGllbnRfMS5IdHRwTWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuICh7IHBhdGg6IHBhdGgsIG1ldGhvZDogbWV0aG9kLCBvcGVyYXRpb246IHBhdGhPYmplY3RbbWV0aG9kXSB9KTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IF9hLm9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBfYS5vcGVyYXRpb24sIG1ldGhvZCA9IF9hLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gX19hc3NpZ24oX19hc3NpZ24oe30sICh0eXBlb2Ygb3BlcmF0aW9uID09PSAnb2JqZWN0JyA/IG9wZXJhdGlvbiA6IHt9KSksIHsgcGF0aDogcGF0aCwgbWV0aG9kOiBtZXRob2QgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoT2JqZWN0LnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBhcmFtZXRlcnMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCgob3AucGFyYW1ldGVycyB8fCBbXSkpLCBmYWxzZSksIF9fcmVhZChwYXRoT2JqZWN0LnBhcmFtZXRlcnMpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhPYmplY3Quc2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2VydmVycyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKChvcC5zZXJ2ZXJzIHx8IFtdKSksIGZhbHNlKSwgX19yZWFkKHBhdGhPYmplY3Quc2VydmVycyksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcC5zZWN1cml0eSA9IChfYiA9IG9wLnNlY3VyaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfdGhpcy5kZWZpbml0aW9uLnNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSBzaW5nbGUgb3BlcmF0aW9uIGJhc2VkIG9uIG9wZXJhdGlvbklkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRpb25JZFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0aW9ufVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUJhY2tlbmRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0T3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0T3BlcmF0aW9ucygpLmZpbmQoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5vcGVyYXRpb25JZCA9PT0gb3BlcmF0aW9uSWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBheGlvcyBtZXRob2QgZm9yIGFuIG9wZXJhdGlvblxuICAgICAgICAgKiAoLi4ucGF0aFBhcmFtcywgZGF0YT8sIGNvbmZpZz8pID0+IFByb21pc2U8QXhpb3NSZXNwb25zZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZU9wZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbE9wZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aW9zQ29uZmlnLCBydW5uZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aW9zQ29uZmlnID0gdGhpcy5nZXRBeGlvc0NvbmZpZ0Zvck9wZXJhdGlvbihvcGVyYXRpb24sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gdGhpcy5nZXRSdW5uZXIob3BlcmF0aW9uLm9wZXJhdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBydW5uZXIucnVuUmVxdWVzdChheGlvc0NvbmZpZywgb3BlcmF0aW9uLCBydW5uZXIuY29udGV4dCldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtT3BlcmF0aW9uTWV0aG9kKG9yaWdpbmFsT3BlcmF0aW9uTWV0aG9kLCBvcGVyYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0c1dpdGhEZWZhdWx0cyA9IF9fYXNzaWduKF9fYXNzaWduKHsgcXVpY2s6IGZhbHNlLCB3aXRoU2VydmVyOiAwLCBiYXNlVVJMVmFyaWFibGVzOiB7fSwgdHJhbnNmb3JtT3BlcmF0aW9uTmFtZTogZnVuY3Rpb24gKG9wZXJhdGlvbklkKSB7IHJldHVybiBvcGVyYXRpb25JZDsgfSwgdHJhbnNmb3JtT3BlcmF0aW9uTWV0aG9kOiBmdW5jdGlvbiAob3BlcmF0aW9uTWV0aG9kKSB7IHJldHVybiBvcGVyYXRpb25NZXRob2Q7IH0sIGF4aW9zUnVubmVyOiBmdW5jdGlvbiAoYXhpb3NDb25maWcpIHsgcmV0dXJuIF90aGlzLmNsaWVudC5yZXF1ZXN0KGF4aW9zQ29uZmlnKTsgfSwgYXBwbHlNZXRob2RDb21tb25IZWFkZXJzOiBmYWxzZSB9LCBvcHRzKSwgeyBheGlvc0NvbmZpZ0RlZmF1bHRzOiBfX2Fzc2lnbih7fSwgKG9wdHMuYXhpb3NDb25maWdEZWZhdWx0cyB8fCB7fSkpIH0pO1xuICAgICAgICB0aGlzLmlucHV0RG9jdW1lbnQgPSBvcHRzV2l0aERlZmF1bHRzLmRlZmluaXRpb247XG4gICAgICAgIHRoaXMucXVpY2sgPSBvcHRzV2l0aERlZmF1bHRzLnF1aWNrO1xuICAgICAgICB0aGlzLmF4aW9zQ29uZmlnRGVmYXVsdHMgPSBvcHRzV2l0aERlZmF1bHRzLmF4aW9zQ29uZmlnRGVmYXVsdHM7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcnZlciA9IG9wdHNXaXRoRGVmYXVsdHMud2l0aFNlcnZlcjtcbiAgICAgICAgdGhpcy5iYXNlVVJMVmFyaWFibGVzID0gb3B0c1dpdGhEZWZhdWx0cy5iYXNlVVJMVmFyaWFibGVzO1xuICAgICAgICB0aGlzLmFwcGx5TWV0aG9kQ29tbW9uSGVhZGVycyA9IG9wdHNXaXRoRGVmYXVsdHMuYXBwbHlNZXRob2RDb21tb25IZWFkZXJzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU9wZXJhdGlvbk5hbWUgPSBvcHRzV2l0aERlZmF1bHRzLnRyYW5zZm9ybU9wZXJhdGlvbk5hbWU7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtT3BlcmF0aW9uTWV0aG9kID0gb3B0c1dpdGhEZWZhdWx0cy50cmFuc2Zvcm1PcGVyYXRpb25NZXRob2Q7XG4gICAgICAgIHRoaXMucnVubmVycyA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbRGVmYXVsdFJ1bm5lcktleV0gPSB7IHJ1blJlcXVlc3Q6IG9wdHNXaXRoRGVmYXVsdHMuYXhpb3NSdW5uZXIgfSxcbiAgICAgICAgICAgIF9hKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wZW5BUElDbGllbnRBeGlvcy5wcm90b3R5cGUsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIE9wZW5BUElDbGllbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEB0eXBlIHtPcGVuQVBJQ2xpZW50fVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlbkFQSUNsaWVudEF4aW9zXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT3BlbkFQSUNsaWVudEF4aW9zLnByb3RvdHlwZS53aXRoU2VydmVyID0gZnVuY3Rpb24gKHNlcnZlciwgdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuYmFzZVVSTFZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWRzIGRvY3VtZW50IGZyb20gaW5wdXREb2N1bWVudFxuICAgICAqXG4gICAgICogU3VwcG9ydHMgbG9hZGluZyBmcm9tIGEgc3RyaW5nICh1cmwpIG9yIGFuIG9iamVjdCAoanNvbilcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBPcGVuQVBJQ2xpZW50QXhpb3NcbiAgICAgKi9cbiAgICBPcGVuQVBJQ2xpZW50QXhpb3MucHJvdG90eXBlLmxvYWREb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50LCBkb2N1bWVudFJlcywgeWFtbCwgZXJyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIHRoaXMuaW5wdXREb2N1bWVudCA9PT0gJ29iamVjdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQgPSB0aGlzLmlucHV0RG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50ID0gdGhpcy5nZXRBeGlvc0luc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnQuZ2V0KHRoaXMuaW5wdXREb2N1bWVudCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFJlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBkb2N1bWVudFJlcy5kYXRhID09PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganNvbiByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50UmVzLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRvY3VtZW50UmVzLmRhdGEgPT09ICdzdHJpbmcnICYmICgoX2EgPSBkb2N1bWVudFJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC95YT9tbC8pKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnanMteWFtbCcpKTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB5YW1sID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IHlhbWwubG9hZChkb2N1bWVudFJlcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZldGNoaW5nIE9wZW5BUEkgZGVmaW5pdGlvbjogXCIuY29uY2F0KGRvY3VtZW50UmVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucmVzcG9uc2UgPSBkb2N1bWVudFJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5kb2N1bWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBPcGVuQVBJQ2xpZW50IHdpbGwgdXNlIGF4aW9zIGFzIHJlcXVlc3QgcnVubmVyLiBZb3UgY2FuIHJlZ2lzdGVyIGEgZGlmZmVyZW50IHJ1bm5lcixcbiAgICAgKiBpbiBjYXNlIHlvdSB3YW50IHRvIHN3aXRjaCBvdmVyIGZyb20gYXhpb3MuIFRoaXMgYWxsb3dzIHRyYW5zaXRpb25pbmcgZnJvbSBheGlvcyB0byB5b3VyIGxpYnJhcnkgb2YgY2hvaWNlLlxuICAgICAqIEBwYXJhbSBydW5uZXIgLSByZXF1ZXN0IHJ1bm5lciB0byBiZSByZWdpc3RlcmVkLCBlaXRoZXIgZm9yIGFsbCBvcGVyYXRpb25zLCBvciBqdXN0IG9uZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbklkIC0gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiBwcm92aWRlZCwgcnVubmVyIHdpbGwgYmUgcmVnaXN0ZXJlZCBmb3IgYSBzaW5nbGUgb3BlcmF0aW9uLiBFbHNlLCBpdCB3aWxsIGJlIHJlZ2lzdGVyZWQgZm9yIGFsbCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIE9wZW5BUElDbGllbnRBeGlvcy5wcm90b3R5cGUucmVnaXN0ZXJSdW5uZXIgPSBmdW5jdGlvbiAocnVubmVyLCBvcGVyYXRpb25JZCkge1xuICAgICAgICB0aGlzLnJ1bm5lcnNbb3BlcmF0aW9uSWQgIT09IG51bGwgJiYgb3BlcmF0aW9uSWQgIT09IHZvaWQgMCA/IG9wZXJhdGlvbklkIDogRGVmYXVsdFJ1bm5lcktleV0gPSBydW5uZXI7XG4gICAgfTtcbiAgICBPcGVuQVBJQ2xpZW50QXhpb3MucHJvdG90eXBlLmdldFJ1bm5lciA9IGZ1bmN0aW9uIChvcGVyYXRpb25JZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnJ1bm5lcnNbb3BlcmF0aW9uSWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJ1bm5lcnNbRGVmYXVsdFJ1bm5lcktleV07XG4gICAgfTtcbiAgICByZXR1cm4gT3BlbkFQSUNsaWVudEF4aW9zO1xufSgpKTtcbmV4cG9ydHMuT3BlbkFQSUNsaWVudEF4aW9zID0gT3BlbkFQSUNsaWVudEF4aW9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX2NyZWF0ZUJpbmRpbmciLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJkb25lIiwidGhlbiIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib3AiLCJUeXBlRXJyb3IiLCJwb3AiLCJwdXNoIiwiX192YWx1ZXMiLCJfX3JlYWQiLCJyIiwiYXIiLCJlcnJvciIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwibCIsIkFycmF5Iiwic2xpY2UiLCJjb25jYXQiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwiT3BlbkFQSUNsaWVudEF4aW9zIiwiYXhpb3NfMSIsInJlcXVpcmUiLCJiYXRoX2VzNV8xIiwiZGVyZWZlcmVuY2VfanNvbl9zY2hlbWFfMSIsImNsaWVudF8xIiwiRGVmYXVsdFJ1bm5lcktleSIsIm9wdHMiLCJfYSIsIl90aGlzIiwiZ2V0Q2xpZW50IiwiaW5pdGlhbGl6ZWQiLCJpbml0IiwiaW5zdGFuY2UiLCJsb2FkRG9jdW1lbnQiLCJkZWZpbml0aW9uIiwiZGVyZWZlcmVuY2VTeW5jIiwiZG9jdW1lbnQiLCJjcmVhdGVBeGlvc0luc3RhbmNlIiwiaW5pdFN5bmMiLCJpbnB1dERvY3VtZW50IiwiRXJyb3IiLCJnZXRBeGlvc0luc3RhbmNlIiwiZGVmYXVsdCIsImF4aW9zQ29uZmlnRGVmYXVsdHMiLCJlXzEiLCJiYXNlVVJMIiwiZ2V0QmFzZVVSTCIsImRlZmF1bHRzIiwib3BlcmF0aW9ucyIsImdldE9wZXJhdGlvbnMiLCJvcGVyYXRpb25zXzEiLCJvcGVyYXRpb25zXzFfMSIsIm9wZXJhdGlvbiIsIm9wZXJhdGlvbklkIiwidHJhbnNmb3JtT3BlcmF0aW9uTmFtZSIsImNyZWF0ZU9wZXJhdGlvbk1ldGhvZCIsImVfMV8xIiwicmV0dXJuIiwicGF0aHMiLCJfbG9vcF8xIiwicGF0aCIsIm1ldGhvZHMiLCJfbG9vcF8yIiwidmFsdWVzIiwiSHR0cE1ldGhvZCIsImluY2x1ZGVzIiwibWV0aG9kXzEiLCJmaW5kIiwibWV0aG9kIiwiYXBpIiwiZV8yIiwiZV8zIiwiX2IiLCJnZXRPcGVyYXRpb24iLCJzZXJ2ZXJzIiwidXJsIiwidGFyZ2V0U2VydmVyIiwiZGVmYXVsdFNlcnZlciIsIl9jIiwiX2QiLCJzZXJ2ZXIiLCJkZXNjcmlwdGlvbiIsImVfMl8xIiwiYmFzZVVSTFZhcmlhYmxlU2V0IiwidmFyaWFibGVzIiwiYmFzZVVSTEJ1aWxkZXIiLCJuYW1lcyIsImJhc2VVUkxWYXJpYWJsZXNSZXNvbHZlZCIsIl9lIiwiX2YiLCJuYW1lXzEiLCJ2YXJWYWx1ZSIsImJhc2VVUkxWYXJpYWJsZXMiLCJlbnVtIiwiZW51bVZhbCIsImpvaW4iLCJlXzNfMSIsImdldEF4aW9zQ29uZmlnRm9yT3BlcmF0aW9uIiwiYXJncyIsInJlcXVlc3QiLCJnZXRSZXF1ZXN0Q29uZmlnRm9yT3BlcmF0aW9uIiwiYXhpb3NDb25maWciLCJkYXRhIiwicGF5bG9hZCIsInBhcmFtcyIsInF1ZXJ5IiwiaGVhZGVycyIsImNvbmZpZyIsImVfNCIsImVfNSIsImVfNiIsImVfNyIsInBhdGhQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJjb29raWVzIiwicGFyYW1ldGVycyIsInNldFJlcXVlc3RQYXJhbSIsIm5hbWUiLCJ0eXBlIiwiZV84IiwiUGFyYW1UeXBlIiwiUGF0aCIsIlF1ZXJ5IiwiaXNBcnJheSIsInZhbHVlXzEiLCJ2YWx1ZV8xXzEiLCJ2YWx1ZUl0ZW0iLCJhcHBlbmQiLCJlXzhfMSIsIkhlYWRlciIsIkNvb2tpZSIsImdldFBhcmFtVHlwZSIsInBhcmFtTmFtZSIsInBhcmFtIiwiaW4iLCJnZXRGaXJzdE9wZXJhdGlvblBhcmFtIiwiZmlyc3RSZXF1aXJlZFBhcmFtIiwicmVxdWlyZWQiLCJmaXJzdFBhcmFtIiwiX2ciLCJwYXJhbXNBcmciLCJwYXJhbXNBcmdfMSIsInBhcmFtc0FyZ18xXzEiLCJlXzRfMSIsIm5hbWVfMiIsInBhdGhCdWlsZGVyIiwiX2giLCJfaiIsIm5hbWVfMyIsImVfNV8xIiwicXVlcnlTdHJpbmciLCJ0b1N0cmluZyIsImRlZmF1bHRIZWFkZXJzIiwiY2xpZW50IiwiX2siLCJlbnRyaWVzIiwiY29tbW9uIiwiX2wiLCJfbSIsImtleSIsInZhbCIsImVfNl8xIiwiYXBwbHlNZXRob2RDb21tb25IZWFkZXJzIiwibWV0aG9kSGVhZGVycyIsIl9vIiwiX3AiLCJfcSIsImVfN18xIiwiZmxhdE1hcCIsInBhdGhPYmplY3QiLCJtYXAiLCJmaWx0ZXIiLCJzZWN1cml0eSIsIm9yaWdpbmFsT3BlcmF0aW9uTWV0aG9kIiwiX2kiLCJydW5uZXIiLCJnZXRSdW5uZXIiLCJydW5SZXF1ZXN0IiwiY29udGV4dCIsInRyYW5zZm9ybU9wZXJhdGlvbk1ldGhvZCIsIm9wdHNXaXRoRGVmYXVsdHMiLCJxdWljayIsIndpdGhTZXJ2ZXIiLCJvcGVyYXRpb25NZXRob2QiLCJheGlvc1J1bm5lciIsInJ1bm5lcnMiLCJkb2N1bWVudFJlcyIsInlhbWwiLCJlcnIiLCJtYXRjaCIsImxvYWQiLCJyZXNwb25zZSIsInJlZ2lzdGVyUnVubmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-client-axios/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/openapi-client-axios/index.js":
/*!****************************************************!*\
  !*** ./node_modules/openapi-client-axios/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/openapi-client-axios/client.js\");\nexports[\"default\"] = client_1.OpenAPIClientAxios;\n__exportStar(__webpack_require__(/*! ./client */ \"(ssr)/./node_modules/openapi-client-axios/client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/client */ \"(ssr)/./node_modules/openapi-client-axios/types/client.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1jbGllbnQtYXhpb3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsSUFBSUMsV0FBV0MsbUJBQU9BLENBQUMscUVBQVU7QUFDakNQLGtCQUFlLEdBQUdNLFNBQVNHLGtCQUFrQjtBQUM3Q1YsYUFBYVEsbUJBQU9BLENBQUMscUVBQVUsR0FBR1A7QUFDbENELGFBQWFRLG1CQUFPQSxDQUFDLGlGQUFnQixHQUFHUCxVQUN4QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9vcGVuYXBpLWNsaWVudC1heGlvcy9pbmRleC5qcz81YjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBjbGllbnRfMS5PcGVuQVBJQ2xpZW50QXhpb3M7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9jbGllbnRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJjbGllbnRfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiT3BlbkFQSUNsaWVudEF4aW9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-client-axios/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/openapi-client-axios/types/client.js":
/*!***********************************************************!*\
  !*** ./node_modules/openapi-client-axios/types/client.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ParamType = exports.HttpMethod = void 0;\n/**\n * OpenAPI allowed HTTP methods\n */ var HttpMethod;\n(function(HttpMethod) {\n    HttpMethod[\"Get\"] = \"get\";\n    HttpMethod[\"Put\"] = \"put\";\n    HttpMethod[\"Post\"] = \"post\";\n    HttpMethod[\"Patch\"] = \"patch\";\n    HttpMethod[\"Delete\"] = \"delete\";\n    HttpMethod[\"Options\"] = \"options\";\n    HttpMethod[\"Head\"] = \"head\";\n    HttpMethod[\"Trace\"] = \"trace\";\n})(HttpMethod = exports.HttpMethod || (exports.HttpMethod = {}));\n/**\n * OpenAPI parameters \"in\"\n */ var ParamType;\n(function(ParamType) {\n    ParamType[\"Query\"] = \"query\";\n    ParamType[\"Header\"] = \"header\";\n    ParamType[\"Path\"] = \"path\";\n    ParamType[\"Cookie\"] = \"cookie\";\n})(ParamType = exports.ParamType || (exports.ParamType = {})); //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1jbGllbnQtYXhpb3MvdHlwZXMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUM5Qzs7Q0FFQyxHQUNELElBQUlHO0FBQ0gsVUFBVUEsVUFBVTtJQUNqQkEsVUFBVSxDQUFDLE1BQU0sR0FBRztJQUNwQkEsVUFBVSxDQUFDLE1BQU0sR0FBRztJQUNwQkEsVUFBVSxDQUFDLE9BQU8sR0FBRztJQUNyQkEsVUFBVSxDQUFDLFFBQVEsR0FBRztJQUN0QkEsVUFBVSxDQUFDLFNBQVMsR0FBRztJQUN2QkEsVUFBVSxDQUFDLFVBQVUsR0FBRztJQUN4QkEsVUFBVSxDQUFDLE9BQU8sR0FBRztJQUNyQkEsVUFBVSxDQUFDLFFBQVEsR0FBRztBQUMxQixHQUFHQSxhQUFhSCxRQUFRRyxVQUFVLElBQUtILENBQUFBLGtCQUFrQixHQUFHLENBQUM7QUFDN0Q7O0NBRUMsR0FDRCxJQUFJRTtBQUNILFVBQVVBLFNBQVM7SUFDaEJBLFNBQVMsQ0FBQyxRQUFRLEdBQUc7SUFDckJBLFNBQVMsQ0FBQyxTQUFTLEdBQUc7SUFDdEJBLFNBQVMsQ0FBQyxPQUFPLEdBQUc7SUFDcEJBLFNBQVMsQ0FBQyxTQUFTLEdBQUc7QUFDMUIsR0FBR0EsWUFBWUYsUUFBUUUsU0FBUyxJQUFLRixDQUFBQSxpQkFBaUIsR0FBRyxDQUFDLEtBQzFELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRjaGF0Ly4vbm9kZV9tb2R1bGVzL29wZW5hcGktY2xpZW50LWF4aW9zL3R5cGVzL2NsaWVudC5qcz9lMjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJhbVR5cGUgPSBleHBvcnRzLkh0dHBNZXRob2QgPSB2b2lkIDA7XG4vKipcbiAqIE9wZW5BUEkgYWxsb3dlZCBIVFRQIG1ldGhvZHNcbiAqL1xudmFyIEh0dHBNZXRob2Q7XG4oZnVuY3Rpb24gKEh0dHBNZXRob2QpIHtcbiAgICBIdHRwTWV0aG9kW1wiR2V0XCJdID0gXCJnZXRcIjtcbiAgICBIdHRwTWV0aG9kW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgICBIdHRwTWV0aG9kW1wiUG9zdFwiXSA9IFwicG9zdFwiO1xuICAgIEh0dHBNZXRob2RbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbiAgICBIdHRwTWV0aG9kW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgICBIdHRwTWV0aG9kW1wiT3B0aW9uc1wiXSA9IFwib3B0aW9uc1wiO1xuICAgIEh0dHBNZXRob2RbXCJIZWFkXCJdID0gXCJoZWFkXCI7XG4gICAgSHR0cE1ldGhvZFtcIlRyYWNlXCJdID0gXCJ0cmFjZVwiO1xufSkoSHR0cE1ldGhvZCA9IGV4cG9ydHMuSHR0cE1ldGhvZCB8fCAoZXhwb3J0cy5IdHRwTWV0aG9kID0ge30pKTtcbi8qKlxuICogT3BlbkFQSSBwYXJhbWV0ZXJzIFwiaW5cIlxuICovXG52YXIgUGFyYW1UeXBlO1xuKGZ1bmN0aW9uIChQYXJhbVR5cGUpIHtcbiAgICBQYXJhbVR5cGVbXCJRdWVyeVwiXSA9IFwicXVlcnlcIjtcbiAgICBQYXJhbVR5cGVbXCJIZWFkZXJcIl0gPSBcImhlYWRlclwiO1xuICAgIFBhcmFtVHlwZVtcIlBhdGhcIl0gPSBcInBhdGhcIjtcbiAgICBQYXJhbVR5cGVbXCJDb29raWVcIl0gPSBcImNvb2tpZVwiO1xufSkoUGFyYW1UeXBlID0gZXhwb3J0cy5QYXJhbVR5cGUgfHwgKGV4cG9ydHMuUGFyYW1UeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQYXJhbVR5cGUiLCJIdHRwTWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-client-axios/types/client.js\n");

/***/ })

};
;
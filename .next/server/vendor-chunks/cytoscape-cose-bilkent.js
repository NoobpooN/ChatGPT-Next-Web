"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-cose-bilkent";
exports.ids = ["vendor-chunks/cytoscape-cose-bilkent"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/./node_modules/cose-base/cose-base.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_0__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_707__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_707__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_707__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_707__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_707__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_707__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_707__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_707__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_707__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_707__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_707__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_707__(__nested_webpack_require_707__.s = 1);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_3720__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_3720__(0).layoutBase.LayoutConstants;\n            var FDLayoutConstants = __nested_webpack_require_3720__(0).layoutBase.FDLayoutConstants;\n            var CoSEConstants = __nested_webpack_require_3720__(0).CoSEConstants;\n            var CoSELayout = __nested_webpack_require_3720__(0).CoSELayout;\n            var CoSENode = __nested_webpack_require_3720__(0).CoSENode;\n            var PointD = __nested_webpack_require_3720__(0).layoutBase.PointD;\n            var DimensionD = __nested_webpack_require_3720__(0).layoutBase.DimensionD;\n            var defaults = {\n                // Called on `layoutready`\n                ready: function ready() {},\n                // Called on `layoutstop`\n                stop: function stop() {},\n                // 'draft', 'default' or 'proof\" \n                // - 'draft' fast cooling rate \n                // - 'default' moderate cooling rate \n                // - \"proof\" slow cooling rate\n                quality: \"default\",\n                // include labels in node dimensions\n                nodeDimensionsIncludeLabels: false,\n                // number of ticks per frame; higher is faster but more jerky\n                refresh: 30,\n                // Whether to fit the network view after when done\n                fit: true,\n                // Padding on fit\n                padding: 10,\n                // Whether to enable incremental mode\n                randomize: true,\n                // Node repulsion (non overlapping) multiplier\n                nodeRepulsion: 4500,\n                // Ideal edge (non nested) length\n                idealEdgeLength: 50,\n                // Divisor to compute edge forces\n                edgeElasticity: 0.45,\n                // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                nestingFactor: 0.1,\n                // Gravity force (constant)\n                gravity: 0.25,\n                // Maximum number of iterations to perform\n                numIter: 2500,\n                // For enabling tiling\n                tile: true,\n                // Type of layout animation. The option set is {'during', 'end', false}\n                animate: \"end\",\n                // Duration for animate:end\n                animationDuration: 500,\n                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingVertical: 10,\n                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingHorizontal: 10,\n                // Gravity range (constant) for compounds\n                gravityRangeCompound: 1.5,\n                // Gravity force (constant) for compounds\n                gravityCompound: 1.0,\n                // Gravity range (constant)\n                gravityRange: 3.8,\n                // Initial cooling factor for incremental layout\n                initialEnergyOnIncremental: 0.5\n            };\n            function extend(defaults, options) {\n                var obj = {};\n                for(var i in defaults){\n                    obj[i] = defaults[i];\n                }\n                for(var i in options){\n                    obj[i] = options[i];\n                }\n                return obj;\n            }\n            ;\n            function _CoSELayout(_options) {\n                this.options = extend(defaults, _options);\n                getUserOptions(this.options);\n            }\n            var getUserOptions = function getUserOptions(options) {\n                if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n                if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n                if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                if (options.quality == \"draft\") LayoutConstants.QUALITY = 0;\n                else if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                else LayoutConstants.QUALITY = 1;\n                CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                CoSEConstants.TILE = options.tile;\n                CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n            };\n            _CoSELayout.prototype.run = function() {\n                var ready;\n                var frameId;\n                var options = this.options;\n                var idToLNode = this.idToLNode = {};\n                var layout = this.layout = new CoSELayout();\n                var self = this;\n                self.stopped = false;\n                this.cy = this.options.cy;\n                this.cy.trigger({\n                    type: \"layoutstart\",\n                    layout: this\n                });\n                var gm = layout.newGraphManager();\n                this.gm = gm;\n                var nodes = this.options.eles.nodes();\n                var edges = this.options.eles.edges();\n                this.root = gm.addRoot();\n                this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    var sourceNode = this.idToLNode[edge.data(\"source\")];\n                    var targetNode = this.idToLNode[edge.data(\"target\")];\n                    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                        e1.id = edge.id();\n                    }\n                }\n                var getPositions = function getPositions(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var theId = ele.data(\"id\");\n                    var lNode = self.idToLNode[theId];\n                    return {\n                        x: lNode.getRect().getCenterX(),\n                        y: lNode.getRect().getCenterY()\n                    };\n                };\n                /*\n   * Reposition nodes in iterations animatedly\n   */ var iterateAnimated = function iterateAnimated() {\n                    // Thigs to perform after nodes are repositioned on screen\n                    var afterReposition = function afterReposition() {\n                        if (options.fit) {\n                            options.cy.fit(options.eles, options.padding);\n                        }\n                        if (!ready) {\n                            ready = true;\n                            self.cy.one(\"layoutready\", options.ready);\n                            self.cy.trigger({\n                                type: \"layoutready\",\n                                layout: self\n                            });\n                        }\n                    };\n                    var ticksPerFrame = self.options.refresh;\n                    var isDone;\n                    for(var i = 0; i < ticksPerFrame && !isDone; i++){\n                        isDone = self.stopped || self.layout.tick();\n                    }\n                    // If layout is done\n                    if (isDone) {\n                        // If the layout is not a sublayout and it is successful perform post layout.\n                        if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n                            layout.doPostLayout();\n                        }\n                        // If layout has a tilingPostLayout function property call it.\n                        if (layout.tilingPostLayout) {\n                            layout.tilingPostLayout();\n                        }\n                        layout.isLayoutFinished = true;\n                        self.options.eles.nodes().positions(getPositions);\n                        afterReposition();\n                        // trigger layoutstop when the layout stops (e.g. finishes)\n                        self.cy.one(\"layoutstop\", self.options.stop);\n                        self.cy.trigger({\n                            type: \"layoutstop\",\n                            layout: self\n                        });\n                        if (frameId) {\n                            cancelAnimationFrame(frameId);\n                        }\n                        ready = false;\n                        return;\n                    }\n                    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n                    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n                    // use position of their ancestors or dummy ancestors\n                    options.eles.nodes().positions(function(ele, i) {\n                        if (typeof ele === \"number\") {\n                            ele = i;\n                        }\n                        // If ele is a compound node, then its position will be defined by its children\n                        if (!ele.isParent()) {\n                            var theId = ele.id();\n                            var pNode = animationData[theId];\n                            var temp = ele;\n                            // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n                            while(pNode == null){\n                                pNode = animationData[temp.data(\"parent\")] || animationData[\"DummyCompound_\" + temp.data(\"parent\")];\n                                animationData[theId] = pNode;\n                                temp = temp.parent()[0];\n                                if (temp == undefined) {\n                                    break;\n                                }\n                            }\n                            if (pNode != null) {\n                                return {\n                                    x: pNode.x,\n                                    y: pNode.y\n                                };\n                            } else {\n                                return {\n                                    x: ele.position(\"x\"),\n                                    y: ele.position(\"y\")\n                                };\n                            }\n                        }\n                    });\n                    afterReposition();\n                    frameId = requestAnimationFrame(iterateAnimated);\n                };\n                /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */ layout.addListener(\"layoutstarted\", function() {\n                    if (self.options.animate === \"during\") {\n                        frameId = requestAnimationFrame(iterateAnimated);\n                    }\n                });\n                layout.runLayout(); // Run cose layout\n                /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */ if (this.options.animate !== \"during\") {\n                    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n                    ready = false;\n                }\n                return this; // chaining\n            };\n            //Get the top most ones of a list of nodes\n            _CoSELayout.prototype.getTopMostNodes = function(nodes) {\n                var nodesMap = {};\n                for(var i = 0; i < nodes.length; i++){\n                    nodesMap[nodes[i].id()] = true;\n                }\n                var roots = nodes.filter(function(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var parent = ele.parent()[0];\n                    while(parent != null){\n                        if (nodesMap[parent.id()]) {\n                            return false;\n                        }\n                        parent = parent.parent()[0];\n                    }\n                    return true;\n                });\n                return roots;\n            };\n            _CoSELayout.prototype.processChildrenList = function(parent, children, layout) {\n                var size = children.length;\n                for(var i = 0; i < size; i++){\n                    var theChild = children[i];\n                    var children_of_children = theChild.children();\n                    var theNode;\n                    var dimensions = theChild.layoutDimensions({\n                        nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n                    });\n                    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                    } else {\n                        theNode = parent.add(new CoSENode(this.graphManager));\n                    }\n                    // Attach id to the layout node\n                    theNode.id = theChild.data(\"id\");\n                    // Attach the paddings of cy node to layout node\n                    theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                    //Attach the label properties to compound if labels will be included in node dimensions  \n                    if (this.options.nodeDimensionsIncludeLabels) {\n                        if (theChild.isParent()) {\n                            var labelWidth = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).w;\n                            var labelHeight = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).h;\n                            var labelPos = theChild.css(\"text-halign\");\n                            theNode.labelWidth = labelWidth;\n                            theNode.labelHeight = labelHeight;\n                            theNode.labelPos = labelPos;\n                        }\n                    }\n                    // Map the layout node\n                    this.idToLNode[theChild.data(\"id\")] = theNode;\n                    if (isNaN(theNode.rect.x)) {\n                        theNode.rect.x = 0;\n                    }\n                    if (isNaN(theNode.rect.y)) {\n                        theNode.rect.y = 0;\n                    }\n                    if (children_of_children != null && children_of_children.length > 0) {\n                        var theNewGraph;\n                        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                        this.processChildrenList(theNewGraph, children_of_children, layout);\n                    }\n                }\n            };\n            /**\n * @brief : called on continuous layouts to stop them before they finish\n */ _CoSELayout.prototype.stop = function() {\n                this.stopped = true;\n                return this; // chaining\n            };\n            var register = function register(cytoscape1) {\n                //  var Layout = getLayout( cytoscape );\n                cytoscape1(\"layout\", \"cose-bilkent\", _CoSELayout);\n            };\n            // auto reg for globals\n            if (typeof cytoscape !== \"undefined\") {\n                register(cytoscape);\n            }\n            module1.exports = register;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLDhEQUFXO1NBQ3hDLEVBS3FEO0FBQzNELEdBQUcsUUFBTSxTQUFTRyw2QkFBNkI7SUFDL0MsT0FBZ0IsTUFBSCxHQUFJLFNBQVNDLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNULE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU00sZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNWCxTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS00sT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1gsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVRLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLUCxRQUFPVSxDQUFDLEdBQUc7WUFDdEIsTUFBTSxHQUNOLE1BQU0sR0FBSyxtQ0FBbUM7WUFDOUMsTUFBTSxHQUFLLE9BQU9WLFFBQU9ELE9BQU87UUFDaEMsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLE1BQU0sR0FDTixNQUFNLEdBQUksa0RBQWtEO1FBQzVELE1BQU0sR0FBSVEsOEJBQW1CQSxDQUFDSyxDQUFDLEdBQUdQO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksMEJBQTBCO1FBQ3BDLE1BQU0sR0FBSUUsOEJBQW1CQSxDQUFDTSxDQUFDLEdBQUdQO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUkseUVBQXlFO1FBQ25GLE1BQU0sR0FBSUMsOEJBQW1CQSxDQUFDRSxDQUFDLEdBQUcsU0FBU0ssS0FBSztZQUFJLE9BQU9BO1FBQU87UUFDbEUsTUFBTSxHQUNOLE1BQU0sR0FBSSw2Q0FBNkM7UUFDdkQsTUFBTSxHQUFJUCw4QkFBbUJBLENBQUNRLENBQUMsR0FBRyxTQUFTaEIsUUFBTyxFQUFFaUIsSUFBSSxFQUFFQyxNQUFNO1lBQ2hFLE1BQU0sR0FBSyxJQUFHLENBQUNWLDhCQUFtQkEsQ0FBQ1csQ0FBQyxDQUFDbkIsVUFBU2lCLE9BQU87Z0JBQ3JELE1BQU0sR0FBTUcsT0FBT0MsY0FBYyxDQUFDckIsVUFBU2lCLE1BQU07b0JBQ2pELE1BQU0sR0FBT0ssY0FBYztvQkFDM0IsTUFBTSxHQUFPQyxZQUFZO29CQUN6QixNQUFNLEdBQU9DLEtBQUtOO2dCQUNOO1lBQ1osTUFBTSxHQUFLO1FBQ1gsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLE1BQU0sR0FBSSx1RUFBdUU7UUFDakYsTUFBTSxHQUFJViw4QkFBbUJBLENBQUNpQixDQUFDLEdBQUcsU0FBU3hCLE9BQU07WUFDakQsTUFBTSxHQUFLLElBQUlpQixTQUFTakIsV0FBVUEsUUFBT3lCLFVBQVUsR0FDbkQsTUFBTSxHQUFNLFNBQVNDO2dCQUFlLE9BQU8xQixPQUFNLENBQUMsVUFBVTtZQUFFLElBQzlELE1BQU0sR0FBTSxTQUFTMkI7Z0JBQXFCLE9BQU8zQjtZQUFRO1lBQ3pELE1BQU0sR0FBS08sOEJBQW1CQSxDQUFDUSxDQUFDLENBQUNFLFFBQVEsS0FBS0E7WUFDOUMsTUFBTSxHQUFLLE9BQU9BO1FBQ2xCLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSVYsOEJBQW1CQSxDQUFDVyxDQUFDLEdBQUcsU0FBU1UsTUFBTSxFQUFFQyxRQUFRO1lBQUksT0FBT1YsT0FBT1csU0FBUyxDQUFDQyxjQUFjLENBQUNwQixJQUFJLENBQUNpQixRQUFRQztRQUFXO1FBQzlILE1BQU0sR0FDTixNQUFNLEdBQUksMEJBQTBCO1FBQ3BDLE1BQU0sR0FBSXRCLDhCQUFtQkEsQ0FBQ3lCLENBQUMsR0FBRztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksT0FBT3pCLDhCQUFtQkEsQ0FBQ0EsOEJBQW1CQSxDQUFDMEIsQ0FBQyxHQUFHO0lBQzdELE1BQU0sR0FBRyxFQUVDO1FBQ1YsS0FBSyxHQUNMLEdBQUcsR0FBSSxTQUFTakMsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdLO1FBRWpCLEdBQUcsR0FBRztRQUNOLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU0osT0FBTSxFQUFFRCxRQUFPLEVBQUVRLCtCQUFtQjtZQUVwRDtZQUdBLElBQUkyQixrQkFBa0IzQiwrQkFBbUJBLENBQUMsR0FBRzRCLFVBQVUsQ0FBQ0QsZUFBZTtZQUN2RSxJQUFJRSxvQkFBb0I3QiwrQkFBbUJBLENBQUMsR0FBRzRCLFVBQVUsQ0FBQ0MsaUJBQWlCO1lBQzNFLElBQUlDLGdCQUFnQjlCLCtCQUFtQkEsQ0FBQyxHQUFHOEIsYUFBYTtZQUN4RCxJQUFJQyxhQUFhL0IsK0JBQW1CQSxDQUFDLEdBQUcrQixVQUFVO1lBQ2xELElBQUlDLFdBQVdoQywrQkFBbUJBLENBQUMsR0FBR2dDLFFBQVE7WUFDOUMsSUFBSUMsU0FBU2pDLCtCQUFtQkEsQ0FBQyxHQUFHNEIsVUFBVSxDQUFDSyxNQUFNO1lBQ3JELElBQUlDLGFBQWFsQywrQkFBbUJBLENBQUMsR0FBRzRCLFVBQVUsQ0FBQ00sVUFBVTtZQUU3RCxJQUFJQyxXQUFXO2dCQUNiLDBCQUEwQjtnQkFDMUJDLE9BQU8sU0FBU0EsU0FBUztnQkFDekIseUJBQXlCO2dCQUN6QkMsTUFBTSxTQUFTQSxRQUFRO2dCQUN2QixpQ0FBaUM7Z0JBQ2pDLCtCQUErQjtnQkFDL0IscUNBQXFDO2dCQUNyQyw4QkFBOEI7Z0JBQzlCQyxTQUFTO2dCQUNULG9DQUFvQztnQkFDcENDLDZCQUE2QjtnQkFDN0IsNkRBQTZEO2dCQUM3REMsU0FBUztnQkFDVCxrREFBa0Q7Z0JBQ2xEQyxLQUFLO2dCQUNMLGlCQUFpQjtnQkFDakJDLFNBQVM7Z0JBQ1QscUNBQXFDO2dCQUNyQ0MsV0FBVztnQkFDWCw4Q0FBOEM7Z0JBQzlDQyxlQUFlO2dCQUNmLGlDQUFpQztnQkFDakNDLGlCQUFpQjtnQkFDakIsaUNBQWlDO2dCQUNqQ0MsZ0JBQWdCO2dCQUNoQiw0RUFBNEU7Z0JBQzVFQyxlQUFlO2dCQUNmLDJCQUEyQjtnQkFDM0JDLFNBQVM7Z0JBQ1QsMENBQTBDO2dCQUMxQ0MsU0FBUztnQkFDVCxzQkFBc0I7Z0JBQ3RCQyxNQUFNO2dCQUNOLHVFQUF1RTtnQkFDdkVDLFNBQVM7Z0JBQ1QsMkJBQTJCO2dCQUMzQkMsbUJBQW1CO2dCQUNuQix5SUFBeUk7Z0JBQ3pJQyx1QkFBdUI7Z0JBQ3ZCLDJJQUEySTtnQkFDM0lDLHlCQUF5QjtnQkFDekIseUNBQXlDO2dCQUN6Q0Msc0JBQXNCO2dCQUN0Qix5Q0FBeUM7Z0JBQ3pDQyxpQkFBaUI7Z0JBQ2pCLDJCQUEyQjtnQkFDM0JDLGNBQWM7Z0JBQ2QsZ0RBQWdEO2dCQUNoREMsNEJBQTRCO1lBQzlCO1lBRUEsU0FBU0MsT0FBT3hCLFFBQVEsRUFBRXlCLE9BQU87Z0JBQy9CLElBQUlDLE1BQU0sQ0FBQztnQkFFWCxJQUFLLElBQUkzRCxLQUFLaUMsU0FBVTtvQkFDdEIwQixHQUFHLENBQUMzRCxFQUFFLEdBQUdpQyxRQUFRLENBQUNqQyxFQUFFO2dCQUN0QjtnQkFFQSxJQUFLLElBQUlBLEtBQUswRCxRQUFTO29CQUNyQkMsR0FBRyxDQUFDM0QsRUFBRSxHQUFHMEQsT0FBTyxDQUFDMUQsRUFBRTtnQkFDckI7Z0JBRUEsT0FBTzJEO1lBQ1Q7O1lBRUEsU0FBU0MsWUFBWUMsUUFBUTtnQkFDM0IsSUFBSSxDQUFDSCxPQUFPLEdBQUdELE9BQU94QixVQUFVNEI7Z0JBQ2hDQyxlQUFlLElBQUksQ0FBQ0osT0FBTztZQUM3QjtZQUVBLElBQUlJLGlCQUFpQixTQUFTQSxlQUFlSixPQUFPO2dCQUNsRCxJQUFJQSxRQUFRaEIsYUFBYSxJQUFJLE1BQU1kLGNBQWNtQywwQkFBMEIsR0FBR3BDLGtCQUFrQm9DLDBCQUEwQixHQUFHTCxRQUFRaEIsYUFBYTtnQkFDbEosSUFBSWdCLFFBQVFmLGVBQWUsSUFBSSxNQUFNZixjQUFjb0MsbUJBQW1CLEdBQUdyQyxrQkFBa0JxQyxtQkFBbUIsR0FBR04sUUFBUWYsZUFBZTtnQkFDeEksSUFBSWUsUUFBUWQsY0FBYyxJQUFJLE1BQU1oQixjQUFjcUMsdUJBQXVCLEdBQUd0QyxrQkFBa0JzQyx1QkFBdUIsR0FBR1AsUUFBUWQsY0FBYztnQkFDOUksSUFBSWMsUUFBUWIsYUFBYSxJQUFJLE1BQU1qQixjQUFjc0Msa0NBQWtDLEdBQUd2QyxrQkFBa0J1QyxrQ0FBa0MsR0FBR1IsUUFBUWIsYUFBYTtnQkFDbEssSUFBSWEsUUFBUVosT0FBTyxJQUFJLE1BQU1sQixjQUFjdUMsd0JBQXdCLEdBQUd4QyxrQkFBa0J3Qyx3QkFBd0IsR0FBR1QsUUFBUVosT0FBTztnQkFDbEksSUFBSVksUUFBUVgsT0FBTyxJQUFJLE1BQU1uQixjQUFjd0MsY0FBYyxHQUFHekMsa0JBQWtCeUMsY0FBYyxHQUFHVixRQUFRWCxPQUFPO2dCQUM5RyxJQUFJVyxRQUFRSCxZQUFZLElBQUksTUFBTTNCLGNBQWN5Qyw0QkFBNEIsR0FBRzFDLGtCQUFrQjBDLDRCQUE0QixHQUFHWCxRQUFRSCxZQUFZO2dCQUNwSixJQUFJRyxRQUFRSixlQUFlLElBQUksTUFBTTFCLGNBQWMwQyxpQ0FBaUMsR0FBRzNDLGtCQUFrQjJDLGlDQUFpQyxHQUFHWixRQUFRSixlQUFlO2dCQUNwSyxJQUFJSSxRQUFRTCxvQkFBb0IsSUFBSSxNQUFNekIsY0FBYzJDLHFDQUFxQyxHQUFHNUMsa0JBQWtCNEMscUNBQXFDLEdBQUdiLFFBQVFMLG9CQUFvQjtnQkFDdEwsSUFBSUssUUFBUUYsMEJBQTBCLElBQUksTUFBTTVCLGNBQWM0QyxrQ0FBa0MsR0FBRzdDLGtCQUFrQjZDLGtDQUFrQyxHQUFHZCxRQUFRRiwwQkFBMEI7Z0JBRTVMLElBQUlFLFFBQVF0QixPQUFPLElBQUksU0FBU1gsZ0JBQWdCZ0QsT0FBTyxHQUFHO3FCQUFPLElBQUlmLFFBQVF0QixPQUFPLElBQUksU0FBU1gsZ0JBQWdCZ0QsT0FBTyxHQUFHO3FCQUFPaEQsZ0JBQWdCZ0QsT0FBTyxHQUFHO2dCQUU1SjdDLGNBQWM4Qyw4QkFBOEIsR0FBRy9DLGtCQUFrQitDLDhCQUE4QixHQUFHakQsZ0JBQWdCaUQsOEJBQThCLEdBQUdoQixRQUFRckIsMkJBQTJCO2dCQUN0TFQsY0FBYytDLG1CQUFtQixHQUFHaEQsa0JBQWtCZ0QsbUJBQW1CLEdBQUdsRCxnQkFBZ0JrRCxtQkFBbUIsR0FBRyxDQUFDakIsUUFBUWpCLFNBQVM7Z0JBQ3BJYixjQUFjZ0QsT0FBTyxHQUFHakQsa0JBQWtCaUQsT0FBTyxHQUFHbkQsZ0JBQWdCbUQsT0FBTyxHQUFHbEIsUUFBUVQsT0FBTztnQkFDN0ZyQixjQUFjaUQsSUFBSSxHQUFHbkIsUUFBUVYsSUFBSTtnQkFDakNwQixjQUFja0QsdUJBQXVCLEdBQUcsT0FBT3BCLFFBQVFQLHFCQUFxQixLQUFLLGFBQWFPLFFBQVFQLHFCQUFxQixDQUFDakQsSUFBSSxLQUFLd0QsUUFBUVAscUJBQXFCO2dCQUNsS3ZCLGNBQWNtRCx5QkFBeUIsR0FBRyxPQUFPckIsUUFBUU4sdUJBQXVCLEtBQUssYUFBYU0sUUFBUU4sdUJBQXVCLENBQUNsRCxJQUFJLEtBQUt3RCxRQUFRTix1QkFBdUI7WUFDNUs7WUFFQVEsWUFBWXZDLFNBQVMsQ0FBQzJELEdBQUcsR0FBRztnQkFDMUIsSUFBSTlDO2dCQUNKLElBQUkrQztnQkFDSixJQUFJdkIsVUFBVSxJQUFJLENBQUNBLE9BQU87Z0JBQzFCLElBQUl3QixZQUFZLElBQUksQ0FBQ0EsU0FBUyxHQUFHLENBQUM7Z0JBQ2xDLElBQUlDLFNBQVMsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSXREO2dCQUMvQixJQUFJdUQsT0FBTyxJQUFJO2dCQUVmQSxLQUFLQyxPQUFPLEdBQUc7Z0JBRWYsSUFBSSxDQUFDQyxFQUFFLEdBQUcsSUFBSSxDQUFDNUIsT0FBTyxDQUFDNEIsRUFBRTtnQkFFekIsSUFBSSxDQUFDQSxFQUFFLENBQUNDLE9BQU8sQ0FBQztvQkFBRUMsTUFBTTtvQkFBZUwsUUFBUSxJQUFJO2dCQUFDO2dCQUVwRCxJQUFJTSxLQUFLTixPQUFPTyxlQUFlO2dCQUMvQixJQUFJLENBQUNELEVBQUUsR0FBR0E7Z0JBRVYsSUFBSUUsUUFBUSxJQUFJLENBQUNqQyxPQUFPLENBQUNrQyxJQUFJLENBQUNELEtBQUs7Z0JBQ25DLElBQUlFLFFBQVEsSUFBSSxDQUFDbkMsT0FBTyxDQUFDa0MsSUFBSSxDQUFDQyxLQUFLO2dCQUVuQyxJQUFJLENBQUN6RyxJQUFJLEdBQUdxRyxHQUFHSyxPQUFPO2dCQUN0QixJQUFJLENBQUNDLG1CQUFtQixDQUFDLElBQUksQ0FBQzNHLElBQUksRUFBRSxJQUFJLENBQUM0RyxlQUFlLENBQUNMLFFBQVFSO2dCQUVqRSxJQUFLLElBQUluRixJQUFJLEdBQUdBLElBQUk2RixNQUFNSSxNQUFNLEVBQUVqRyxJQUFLO29CQUNyQyxJQUFJa0csT0FBT0wsS0FBSyxDQUFDN0YsRUFBRTtvQkFDbkIsSUFBSW1HLGFBQWEsSUFBSSxDQUFDakIsU0FBUyxDQUFDZ0IsS0FBS0UsSUFBSSxDQUFDLFVBQVU7b0JBQ3BELElBQUlDLGFBQWEsSUFBSSxDQUFDbkIsU0FBUyxDQUFDZ0IsS0FBS0UsSUFBSSxDQUFDLFVBQVU7b0JBQ3BELElBQUlELGVBQWVFLGNBQWNGLFdBQVdHLGVBQWUsQ0FBQ0QsWUFBWUosTUFBTSxJQUFJLEdBQUc7d0JBQ25GLElBQUlNLEtBQUtkLEdBQUdlLEdBQUcsQ0FBQ3JCLE9BQU9zQixPQUFPLElBQUlOLFlBQVlFO3dCQUM5Q0UsR0FBR0csRUFBRSxHQUFHUixLQUFLUSxFQUFFO29CQUNqQjtnQkFDRjtnQkFFQSxJQUFJQyxlQUFlLFNBQVNBLGFBQWFDLEdBQUcsRUFBRTVHLENBQUM7b0JBQzdDLElBQUksT0FBTzRHLFFBQVEsVUFBVTt3QkFDM0JBLE1BQU01RztvQkFDUjtvQkFDQSxJQUFJNkcsUUFBUUQsSUFBSVIsSUFBSSxDQUFDO29CQUNyQixJQUFJVSxRQUFRMUIsS0FBS0YsU0FBUyxDQUFDMkIsTUFBTTtvQkFFakMsT0FBTzt3QkFDTEUsR0FBR0QsTUFBTUUsT0FBTyxHQUFHQyxVQUFVO3dCQUM3QkMsR0FBR0osTUFBTUUsT0FBTyxHQUFHRyxVQUFVO29CQUMvQjtnQkFDRjtnQkFFQTs7R0FFQyxHQUNELElBQUlDLGtCQUFrQixTQUFTQTtvQkFDN0IsMERBQTBEO29CQUMxRCxJQUFJQyxrQkFBa0IsU0FBU0E7d0JBQzdCLElBQUkzRCxRQUFRbkIsR0FBRyxFQUFFOzRCQUNmbUIsUUFBUTRCLEVBQUUsQ0FBQy9DLEdBQUcsQ0FBQ21CLFFBQVFrQyxJQUFJLEVBQUVsQyxRQUFRbEIsT0FBTzt3QkFDOUM7d0JBRUEsSUFBSSxDQUFDTixPQUFPOzRCQUNWQSxRQUFROzRCQUNSa0QsS0FBS0UsRUFBRSxDQUFDZ0MsR0FBRyxDQUFDLGVBQWU1RCxRQUFReEIsS0FBSzs0QkFDeENrRCxLQUFLRSxFQUFFLENBQUNDLE9BQU8sQ0FBQztnQ0FBRUMsTUFBTTtnQ0FBZUwsUUFBUUM7NEJBQUs7d0JBQ3REO29CQUNGO29CQUVBLElBQUltQyxnQkFBZ0JuQyxLQUFLMUIsT0FBTyxDQUFDcEIsT0FBTztvQkFDeEMsSUFBSWtGO29CQUVKLElBQUssSUFBSXhILElBQUksR0FBR0EsSUFBSXVILGlCQUFpQixDQUFDQyxRQUFReEgsSUFBSzt3QkFDakR3SCxTQUFTcEMsS0FBS0MsT0FBTyxJQUFJRCxLQUFLRCxNQUFNLENBQUNzQyxJQUFJO29CQUMzQztvQkFFQSxvQkFBb0I7b0JBQ3BCLElBQUlELFFBQVE7d0JBQ1YsNkVBQTZFO3dCQUM3RSxJQUFJckMsT0FBT3VDLGtCQUFrQixNQUFNLENBQUN2QyxPQUFPd0MsV0FBVyxFQUFFOzRCQUN0RHhDLE9BQU95QyxZQUFZO3dCQUNyQjt3QkFFQSw4REFBOEQ7d0JBQzlELElBQUl6QyxPQUFPMEMsZ0JBQWdCLEVBQUU7NEJBQzNCMUMsT0FBTzBDLGdCQUFnQjt3QkFDekI7d0JBRUExQyxPQUFPMkMsZ0JBQWdCLEdBQUc7d0JBRTFCMUMsS0FBSzFCLE9BQU8sQ0FBQ2tDLElBQUksQ0FBQ0QsS0FBSyxHQUFHb0MsU0FBUyxDQUFDcEI7d0JBRXBDVTt3QkFFQSwyREFBMkQ7d0JBQzNEakMsS0FBS0UsRUFBRSxDQUFDZ0MsR0FBRyxDQUFDLGNBQWNsQyxLQUFLMUIsT0FBTyxDQUFDdkIsSUFBSTt3QkFDM0NpRCxLQUFLRSxFQUFFLENBQUNDLE9BQU8sQ0FBQzs0QkFBRUMsTUFBTTs0QkFBY0wsUUFBUUM7d0JBQUs7d0JBRW5ELElBQUlILFNBQVM7NEJBQ1grQyxxQkFBcUIvQzt3QkFDdkI7d0JBRUEvQyxRQUFRO3dCQUNSO29CQUNGO29CQUVBLElBQUkrRixnQkFBZ0I3QyxLQUFLRCxNQUFNLENBQUMrQyxnQkFBZ0IsSUFBSSw4RkFBOEY7b0JBRWxKLGlKQUFpSjtvQkFDakoscURBQXFEO29CQUNyRHhFLFFBQVFrQyxJQUFJLENBQUNELEtBQUssR0FBR29DLFNBQVMsQ0FBQyxTQUFVbkIsR0FBRyxFQUFFNUcsQ0FBQzt3QkFDN0MsSUFBSSxPQUFPNEcsUUFBUSxVQUFVOzRCQUMzQkEsTUFBTTVHO3dCQUNSO3dCQUNBLCtFQUErRTt3QkFDL0UsSUFBSSxDQUFDNEcsSUFBSXVCLFFBQVEsSUFBSTs0QkFDbkIsSUFBSXRCLFFBQVFELElBQUlGLEVBQUU7NEJBQ2xCLElBQUkwQixRQUFRSCxhQUFhLENBQUNwQixNQUFNOzRCQUNoQyxJQUFJd0IsT0FBT3pCOzRCQUNYLDJHQUEyRzs0QkFDM0csTUFBT3dCLFNBQVMsS0FBTTtnQ0FDcEJBLFFBQVFILGFBQWEsQ0FBQ0ksS0FBS2pDLElBQUksQ0FBQyxVQUFVLElBQUk2QixhQUFhLENBQUMsbUJBQW1CSSxLQUFLakMsSUFBSSxDQUFDLFVBQVU7Z0NBQ25HNkIsYUFBYSxDQUFDcEIsTUFBTSxHQUFHdUI7Z0NBQ3ZCQyxPQUFPQSxLQUFLQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO2dDQUN2QixJQUFJRCxRQUFRRSxXQUFXO29DQUNyQjtnQ0FDRjs0QkFDRjs0QkFDQSxJQUFJSCxTQUFTLE1BQU07Z0NBQ2pCLE9BQU87b0NBQ0xyQixHQUFHcUIsTUFBTXJCLENBQUM7b0NBQ1ZHLEdBQUdrQixNQUFNbEIsQ0FBQztnQ0FDWjs0QkFDRixPQUFPO2dDQUNMLE9BQU87b0NBQ0xILEdBQUdILElBQUk0QixRQUFRLENBQUM7b0NBQ2hCdEIsR0FBR04sSUFBSTRCLFFBQVEsQ0FBQztnQ0FDbEI7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7b0JBRUFuQjtvQkFFQXBDLFVBQVV3RCxzQkFBc0JyQjtnQkFDbEM7Z0JBRUE7O0VBRUEsR0FDQWpDLE9BQU91RCxXQUFXLENBQUMsaUJBQWlCO29CQUNsQyxJQUFJdEQsS0FBSzFCLE9BQU8sQ0FBQ1QsT0FBTyxLQUFLLFVBQVU7d0JBQ3JDZ0MsVUFBVXdELHNCQUFzQnJCO29CQUNsQztnQkFDRjtnQkFFQWpDLE9BQU93RCxTQUFTLElBQUksa0JBQWtCO2dCQUV0Qzs7R0FFQyxHQUNELElBQUksSUFBSSxDQUFDakYsT0FBTyxDQUFDVCxPQUFPLEtBQUssVUFBVTtvQkFDckNtQyxLQUFLMUIsT0FBTyxDQUFDa0MsSUFBSSxDQUFDRCxLQUFLLEdBQUdpRCxHQUFHLENBQUMsV0FBV0MsZUFBZSxDQUFDekQsTUFBTUEsS0FBSzFCLE9BQU8sRUFBRWlELGVBQWUsa0ZBQWtGO29CQUM5S3pFLFFBQVE7Z0JBQ1Y7Z0JBRUEsT0FBTyxJQUFJLEVBQUUsV0FBVztZQUMxQjtZQUVBLDBDQUEwQztZQUMxQzBCLFlBQVl2QyxTQUFTLENBQUMyRSxlQUFlLEdBQUcsU0FBVUwsS0FBSztnQkFDckQsSUFBSW1ELFdBQVcsQ0FBQztnQkFDaEIsSUFBSyxJQUFJOUksSUFBSSxHQUFHQSxJQUFJMkYsTUFBTU0sTUFBTSxFQUFFakcsSUFBSztvQkFDckM4SSxRQUFRLENBQUNuRCxLQUFLLENBQUMzRixFQUFFLENBQUMwRyxFQUFFLEdBQUcsR0FBRztnQkFDNUI7Z0JBQ0EsSUFBSXFDLFFBQVFwRCxNQUFNcUQsTUFBTSxDQUFDLFNBQVVwQyxHQUFHLEVBQUU1RyxDQUFDO29CQUN2QyxJQUFJLE9BQU80RyxRQUFRLFVBQVU7d0JBQzNCQSxNQUFNNUc7b0JBQ1I7b0JBQ0EsSUFBSXNJLFNBQVMxQixJQUFJMEIsTUFBTSxFQUFFLENBQUMsRUFBRTtvQkFDNUIsTUFBT0EsVUFBVSxLQUFNO3dCQUNyQixJQUFJUSxRQUFRLENBQUNSLE9BQU81QixFQUFFLEdBQUcsRUFBRTs0QkFDekIsT0FBTzt3QkFDVDt3QkFDQTRCLFNBQVNBLE9BQU9BLE1BQU0sRUFBRSxDQUFDLEVBQUU7b0JBQzdCO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBRUEsT0FBT1M7WUFDVDtZQUVBbkYsWUFBWXZDLFNBQVMsQ0FBQzBFLG1CQUFtQixHQUFHLFNBQVV1QyxNQUFNLEVBQUVXLFFBQVEsRUFBRTlELE1BQU07Z0JBQzVFLElBQUkrRCxPQUFPRCxTQUFTaEQsTUFBTTtnQkFDMUIsSUFBSyxJQUFJakcsSUFBSSxHQUFHQSxJQUFJa0osTUFBTWxKLElBQUs7b0JBQzdCLElBQUltSixXQUFXRixRQUFRLENBQUNqSixFQUFFO29CQUMxQixJQUFJb0osdUJBQXVCRCxTQUFTRixRQUFRO29CQUM1QyxJQUFJSTtvQkFFSixJQUFJQyxhQUFhSCxTQUFTSSxnQkFBZ0IsQ0FBQzt3QkFDekNsSCw2QkFBNkIsSUFBSSxDQUFDcUIsT0FBTyxDQUFDckIsMkJBQTJCO29CQUN2RTtvQkFFQSxJQUFJOEcsU0FBU0ssVUFBVSxNQUFNLFFBQVFMLFNBQVNNLFdBQVcsTUFBTSxNQUFNO3dCQUNuRUosVUFBVWYsT0FBTzlCLEdBQUcsQ0FBQyxJQUFJMUUsU0FBU3FELE9BQU91RSxZQUFZLEVBQUUsSUFBSTNILE9BQU9vSCxTQUFTWCxRQUFRLENBQUMsT0FBT2MsV0FBV0ssQ0FBQyxHQUFHLEdBQUdSLFNBQVNYLFFBQVEsQ0FBQyxPQUFPYyxXQUFXTSxDQUFDLEdBQUcsSUFBSSxJQUFJNUgsV0FBVzZILFdBQVdQLFdBQVdLLENBQUMsR0FBR0UsV0FBV1AsV0FBV00sQ0FBQztvQkFDM04sT0FBTzt3QkFDTFAsVUFBVWYsT0FBTzlCLEdBQUcsQ0FBQyxJQUFJMUUsU0FBUyxJQUFJLENBQUM0SCxZQUFZO29CQUNyRDtvQkFDQSwrQkFBK0I7b0JBQy9CTCxRQUFRM0MsRUFBRSxHQUFHeUMsU0FBUy9DLElBQUksQ0FBQztvQkFDM0IsZ0RBQWdEO29CQUNoRGlELFFBQVFTLFdBQVcsR0FBR0MsU0FBU1osU0FBU2EsR0FBRyxDQUFDO29CQUM1Q1gsUUFBUVksVUFBVSxHQUFHRixTQUFTWixTQUFTYSxHQUFHLENBQUM7b0JBQzNDWCxRQUFRYSxZQUFZLEdBQUdILFNBQVNaLFNBQVNhLEdBQUcsQ0FBQztvQkFDN0NYLFFBQVFjLGFBQWEsR0FBR0osU0FBU1osU0FBU2EsR0FBRyxDQUFDO29CQUU5Qyx5RkFBeUY7b0JBQ3pGLElBQUksSUFBSSxDQUFDdEcsT0FBTyxDQUFDckIsMkJBQTJCLEVBQUU7d0JBQzVDLElBQUk4RyxTQUFTaEIsUUFBUSxJQUFJOzRCQUN2QixJQUFJaUMsYUFBYWpCLFNBQVNrQixXQUFXLENBQUM7Z0NBQUVDLGVBQWU7Z0NBQU1DLGNBQWM7NEJBQU0sR0FBR1osQ0FBQzs0QkFDckYsSUFBSWEsY0FBY3JCLFNBQVNrQixXQUFXLENBQUM7Z0NBQUVDLGVBQWU7Z0NBQU1DLGNBQWM7NEJBQU0sR0FBR1gsQ0FBQzs0QkFDdEYsSUFBSWEsV0FBV3RCLFNBQVNhLEdBQUcsQ0FBQzs0QkFDNUJYLFFBQVFlLFVBQVUsR0FBR0E7NEJBQ3JCZixRQUFRbUIsV0FBVyxHQUFHQTs0QkFDdEJuQixRQUFRb0IsUUFBUSxHQUFHQTt3QkFDckI7b0JBQ0Y7b0JBRUEsc0JBQXNCO29CQUN0QixJQUFJLENBQUN2RixTQUFTLENBQUNpRSxTQUFTL0MsSUFBSSxDQUFDLE1BQU0sR0FBR2lEO29CQUV0QyxJQUFJcUIsTUFBTXJCLFFBQVFzQixJQUFJLENBQUM1RCxDQUFDLEdBQUc7d0JBQ3pCc0MsUUFBUXNCLElBQUksQ0FBQzVELENBQUMsR0FBRztvQkFDbkI7b0JBRUEsSUFBSTJELE1BQU1yQixRQUFRc0IsSUFBSSxDQUFDekQsQ0FBQyxHQUFHO3dCQUN6Qm1DLFFBQVFzQixJQUFJLENBQUN6RCxDQUFDLEdBQUc7b0JBQ25CO29CQUVBLElBQUlrQyx3QkFBd0IsUUFBUUEscUJBQXFCbkQsTUFBTSxHQUFHLEdBQUc7d0JBQ25FLElBQUkyRTt3QkFDSkEsY0FBY3pGLE9BQU8wRixlQUFlLEdBQUdyRSxHQUFHLENBQUNyQixPQUFPMkYsUUFBUSxJQUFJekI7d0JBQzlELElBQUksQ0FBQ3RELG1CQUFtQixDQUFDNkUsYUFBYXhCLHNCQUFzQmpFO29CQUM5RDtnQkFDRjtZQUNGO1lBRUE7O0NBRUMsR0FDRHZCLFlBQVl2QyxTQUFTLENBQUNjLElBQUksR0FBRztnQkFDM0IsSUFBSSxDQUFDa0QsT0FBTyxHQUFHO2dCQUVmLE9BQU8sSUFBSSxFQUFFLFdBQVc7WUFDMUI7WUFFQSxJQUFJMEYsV0FBVyxTQUFTQSxTQUFTQyxVQUFTO2dCQUN4Qyx3Q0FBd0M7Z0JBRXhDQSxXQUFVLFVBQVUsZ0JBQWdCcEg7WUFDdEM7WUFFQSx1QkFBdUI7WUFDdkIsSUFBSSxPQUFPb0gsY0FBYyxhQUFhO2dCQUNwQ0QsU0FBU0M7WUFDWDtZQUVBekwsUUFBT0QsT0FBTyxHQUFHeUw7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRjaGF0Ly4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1jb3NlLWJpbGtlbnQvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC5qcz8wYTE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJjb3NlLWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlQ29zZUJpbGtlbnRcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUNvc2VCaWxrZW50XCJdID0gZmFjdG9yeShyb290W1wiY29zZUJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkNvU0VDb25zdGFudHM7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRUxheW91dDtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRU5vZGU7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkRpbWVuc2lvbkQ7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyAnZHJhZnQnLCAnZGVmYXVsdCcgb3IgJ3Byb29mXCIgXG4gIC8vIC0gJ2RyYWZ0JyBmYXN0IGNvb2xpbmcgcmF0ZSBcbiAgLy8gLSAnZGVmYXVsdCcgbW9kZXJhdGUgY29vbGluZyByYXRlIFxuICAvLyAtIFwicHJvb2ZcIiBzbG93IGNvb2xpbmcgcmF0ZVxuICBxdWFsaXR5OiAnZGVmYXVsdCcsXG4gIC8vIGluY2x1ZGUgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9uc1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gIHJlZnJlc2g6IDMwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDEwLFxuICAvLyBXaGV0aGVyIHRvIGVuYWJsZSBpbmNyZW1lbnRhbCBtb2RlXG4gIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiA0NTAwLFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiA1MCxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiAwLjQ1LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDAuMSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDAuMjUsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAyNTAwLFxuICAvLyBGb3IgZW5hYmxpbmcgdGlsaW5nXG4gIHRpbGU6IHRydWUsXG4gIC8vIFR5cGUgb2YgbGF5b3V0IGFuaW1hdGlvbi4gVGhlIG9wdGlvbiBzZXQgaXMgeydkdXJpbmcnLCAnZW5kJywgZmFsc2V9XG4gIGFuaW1hdGU6ICdlbmQnLFxuICAvLyBEdXJhdGlvbiBmb3IgYW5pbWF0ZTplbmRcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiAxMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSBob3Jpem9udGFsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogMTAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlSYW5nZUNvbXBvdW5kOiAxLjUsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlDb21wb3VuZDogMS4wLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudClcbiAgZ3Jhdml0eVJhbmdlOiAzLjgsXG4gIC8vIEluaXRpYWwgY29vbGluZyBmYWN0b3IgZm9yIGluY3JlbWVudGFsIGxheW91dFxuICBpbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDogMC41XG59O1xuXG5mdW5jdGlvbiBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gZGVmYXVsdHMpIHtcbiAgICBvYmpbaV0gPSBkZWZhdWx0c1tpXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIG9ialtpXSA9IG9wdGlvbnNbaV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gX0NvU0VMYXlvdXQoX29wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBfb3B0aW9ucyk7XG4gIGdldFVzZXJPcHRpb25zKHRoaXMub3B0aW9ucyk7XG59XG5cbnZhciBnZXRVc2VyT3B0aW9ucyA9IGZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubm9kZVJlcHVsc2lvbiAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSBvcHRpb25zLm5vZGVSZXB1bHNpb247XG4gIGlmIChvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gIGlmIChvcHRpb25zLmVkZ2VFbGFzdGljaXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAnZHJhZnQnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDA7ZWxzZSBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZWFkeTtcbiAgdmFyIGZyYW1lSWQ7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgaWRUb0xOb2RlID0gdGhpcy5pZFRvTE5vZGUgPSB7fTtcbiAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0ID0gbmV3IENvU0VMYXlvdXQoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuc3RvcHBlZCA9IGZhbHNlO1xuXG4gIHRoaXMuY3kgPSB0aGlzLm9wdGlvbnMuY3k7XG5cbiAgdGhpcy5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiB0aGlzIH0pO1xuXG4gIHZhciBnbSA9IGxheW91dC5uZXdHcmFwaE1hbmFnZXIoKTtcbiAgdGhpcy5nbSA9IGdtO1xuXG4gIHZhciBub2RlcyA9IHRoaXMub3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMub3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG5cbiAgdGhpcy5yb290ID0gZ20uYWRkUm9vdCgpO1xuICB0aGlzLnByb2Nlc3NDaGlsZHJlbkxpc3QodGhpcy5yb290LCB0aGlzLmdldFRvcE1vc3ROb2Rlcyhub2RlcyksIGxheW91dCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZU5vZGUgPSB0aGlzLmlkVG9MTm9kZVtlZGdlLmRhdGEoXCJzb3VyY2VcIildO1xuICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5pZFRvTE5vZGVbZWRnZS5kYXRhKFwidGFyZ2V0XCIpXTtcbiAgICBpZiAoc291cmNlTm9kZSAhPT0gdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlLmdldEVkZ2VzQmV0d2Vlbih0YXJnZXROb2RlKS5sZW5ndGggPT0gMCkge1xuICAgICAgdmFyIGUxID0gZ20uYWRkKGxheW91dC5uZXdFZGdlKCksIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgdmFyIGxOb2RlID0gc2VsZi5pZFRvTE5vZGVbdGhlSWRdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxOb2RlLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksXG4gICAgICB5OiBsTm9kZS5nZXRSZWN0KCkuZ2V0Q2VudGVyWSgpXG4gICAgfTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXBvc2l0aW9uIG5vZGVzIGluIGl0ZXJhdGlvbnMgYW5pbWF0ZWRseVxuICAgKi9cbiAgdmFyIGl0ZXJhdGVBbmltYXRlZCA9IGZ1bmN0aW9uIGl0ZXJhdGVBbmltYXRlZCgpIHtcbiAgICAvLyBUaGlncyB0byBwZXJmb3JtIGFmdGVyIG5vZGVzIGFyZSByZXBvc2l0aW9uZWQgb24gc2NyZWVuXG4gICAgdmFyIGFmdGVyUmVwb3NpdGlvbiA9IGZ1bmN0aW9uIGFmdGVyUmVwb3NpdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICBvcHRpb25zLmN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmN5Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBzZWxmIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGlja3NQZXJGcmFtZSA9IHNlbGYub3B0aW9ucy5yZWZyZXNoO1xuICAgIHZhciBpc0RvbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzUGVyRnJhbWUgJiYgIWlzRG9uZTsgaSsrKSB7XG4gICAgICBpc0RvbmUgPSBzZWxmLnN0b3BwZWQgfHwgc2VsZi5sYXlvdXQudGljaygpO1xuICAgIH1cblxuICAgIC8vIElmIGxheW91dCBpcyBkb25lXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBub3QgYSBzdWJsYXlvdXQgYW5kIGl0IGlzIHN1Y2Nlc3NmdWwgcGVyZm9ybSBwb3N0IGxheW91dC5cbiAgICAgIGlmIChsYXlvdXQuY2hlY2tMYXlvdXRTdWNjZXNzKCkgJiYgIWxheW91dC5pc1N1YkxheW91dCkge1xuICAgICAgICBsYXlvdXQuZG9Qb3N0TGF5b3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGxheW91dCBoYXMgYSB0aWxpbmdQb3N0TGF5b3V0IGZ1bmN0aW9uIHByb3BlcnR5IGNhbGwgaXQuXG4gICAgICBpZiAobGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBzZWxmLm9wdGlvbnMuZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhnZXRQb3NpdGlvbnMpO1xuXG4gICAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICAgIHNlbGYuY3kub25lKCdsYXlvdXRzdG9wJywgc2VsZi5vcHRpb25zLnN0b3ApO1xuICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IHNlbGYgfSk7XG5cbiAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgfVxuXG4gICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25EYXRhID0gc2VsZi5sYXlvdXQuZ2V0UG9zaXRpb25zRGF0YSgpOyAvLyBHZXQgcG9zaXRpb25zIG9mIGxheW91dCBub2RlcyBub3RlIHRoYXQgYWxsIG5vZGVzIG1heSBub3QgYmUgbGF5b3V0IG5vZGVzIGJlY2F1c2Ugb2YgdGlsaW5nXG5cbiAgICAvLyBQb3NpdGlvbiBub2RlcywgZm9yIHRoZSBub2RlcyB3aG9zZSBpZCBkb2VzIG5vdCBpbmNsdWRlZCBpbiBkYXRhIChiZWNhdXNlIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBwYXJlbnRzIGFuZCBpbmNsdWRlZCBpbiBkdW1teSBjb21wb3VuZHMpXG4gICAgLy8gdXNlIHBvc2l0aW9uIG9mIHRoZWlyIGFuY2VzdG9ycyBvciBkdW1teSBhbmNlc3RvcnNcbiAgICBvcHRpb25zLmVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZWxlID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGVsZSBpcyBhIGNvbXBvdW5kIG5vZGUsIHRoZW4gaXRzIHBvc2l0aW9uIHdpbGwgYmUgZGVmaW5lZCBieSBpdHMgY2hpbGRyZW5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgdmFyIHRoZUlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGhlSWRdO1xuICAgICAgICB2YXIgdGVtcCA9IGVsZTtcbiAgICAgICAgLy8gSWYgcE5vZGUgaXMgdW5kZWZpbmVkIHNlYXJjaCB1bnRpbCBmaW5kaW5nIHBvc2l0aW9uIGRhdGEgb2YgaXRzIGZpcnN0IGFuY2VzdG9yIChJdCBtYXkgYmUgZHVtbXkgYXMgd2VsbClcbiAgICAgICAgd2hpbGUgKHBOb2RlID09IG51bGwpIHtcbiAgICAgICAgICBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGVtcC5kYXRhKCdwYXJlbnQnKV0gfHwgYW5pbWF0aW9uRGF0YVsnRHVtbXlDb21wb3VuZF8nICsgdGVtcC5kYXRhKCdwYXJlbnQnKV07XG4gICAgICAgICAgYW5pbWF0aW9uRGF0YVt0aGVJZF0gPSBwTm9kZTtcbiAgICAgICAgICB0ZW1wID0gdGVtcC5wYXJlbnQoKVswXTtcbiAgICAgICAgICBpZiAodGVtcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwTm9kZS54LFxuICAgICAgICAgICAgeTogcE5vZGUueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGVsZS5wb3NpdGlvbigneCcpLFxuICAgICAgICAgICAgeTogZWxlLnBvc2l0aW9uKCd5JylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaXRlcmF0ZUFuaW1hdGVkKTtcbiAgfTtcblxuICAvKlxuICAqIExpc3RlbiAnbGF5b3V0c3RhcnRlZCcgZXZlbnQgYW5kIHN0YXJ0IGFuaW1hdGVkIGl0ZXJhdGlvbiBpZiBhbmltYXRlIG9wdGlvbiBpcyAnZHVyaW5nJ1xuICAqL1xuICBsYXlvdXQuYWRkTGlzdGVuZXIoJ2xheW91dHN0YXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYub3B0aW9ucy5hbmltYXRlID09PSAnZHVyaW5nJykge1xuICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpdGVyYXRlQW5pbWF0ZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGF5b3V0LnJ1bkxheW91dCgpOyAvLyBSdW4gY29zZSBsYXlvdXRcblxuICAvKlxuICAgKiBJZiBhbmltYXRlIG9wdGlvbiBpcyBub3QgJ2R1cmluZycgKCdlbmQnIG9yIGZhbHNlKSBwZXJmb3JtIHRoZXNlIGhlcmUgKElmIGl0IGlzICdkdXJpbmcnIHNpbWlsYXIgdGhpbmdzIGFyZSBhbHJlYWR5IHBlcmZvcm1lZClcbiAgICovXG4gIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gXCJkdXJpbmdcIikge1xuICAgIHNlbGYub3B0aW9ucy5lbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5sYXlvdXRQb3NpdGlvbnMoc2VsZiwgc2VsZi5vcHRpb25zLCBnZXRQb3NpdGlvbnMpOyAvLyBVc2UgbGF5b3V0IHBvc2l0aW9ucyB0byByZXBvc2l0aW9uIHRoZSBub2RlcyBpdCBjb25zaWRlcnMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgcmVhZHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy9HZXQgdGhlIHRvcCBtb3N0IG9uZXMgb2YgYSBsaXN0IG9mIG5vZGVzXG5fQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0VG9wTW9zdE5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBub2Rlc01hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZXNNYXBbbm9kZXNbaV0uaWQoKV0gPSB0cnVlO1xuICB9XG4gIHZhciByb290cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGVsZSA9IGk7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KClbMF07XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobm9kZXNNYXBbcGFyZW50LmlkKCldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiByb290cztcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5wcm9jZXNzQ2hpbGRyZW5MaXN0ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCkge1xuICB2YXIgc2l6ZSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSB0aGVDaGlsZC5jaGlsZHJlbigpO1xuICAgIHZhciB0aGVOb2RlO1xuXG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGVDaGlsZC5sYXlvdXREaW1lbnNpb25zKHtcbiAgICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogdGhpcy5vcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgIH0pO1xuXG4gICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQodGhlQ2hpbGQucG9zaXRpb24oJ3gnKSAtIGRpbWVuc2lvbnMudyAvIDIsIHRoZUNoaWxkLnBvc2l0aW9uKCd5JykgLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlcikpO1xuICAgIH1cbiAgICAvLyBBdHRhY2ggaWQgdG8gdGhlIGxheW91dCBub2RlXG4gICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAvLyBBdHRhY2ggdGhlIHBhZGRpbmdzIG9mIGN5IG5vZGUgdG8gbGF5b3V0IG5vZGVcbiAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ1RvcCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAvL0F0dGFjaCB0aGUgbGFiZWwgcHJvcGVydGllcyB0byBjb21wb3VuZCBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnMgIFxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAodGhlQ2hpbGQuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSB9KS53O1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UgfSkuaDtcbiAgICAgICAgdmFyIGxhYmVsUG9zID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxXaWR0aCA9IGxhYmVsV2lkdGg7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSBsYWJlbEhlaWdodDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvcyA9IGxhYmVsUG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICB0aGlzLmlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueCkpIHtcbiAgICAgIHRoZU5vZGUucmVjdC54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LnkpKSB7XG4gICAgICB0aGVOb2RlLnJlY3QueSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuX29mX2NoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW5fb2ZfY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRoZU5ld0dyYXBoO1xuICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgIHRoaXMucHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5fQ29TRUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGN5dG9zY2FwZSkge1xuICAvLyAgdmFyIExheW91dCA9IGdldExheW91dCggY3l0b3NjYXBlICk7XG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnY29zZS1iaWxrZW50JywgX0NvU0VMYXlvdXQpO1xufTtcblxuLy8gYXV0byByZWcgZm9yIGdsb2JhbHNcbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwidmFsdWUiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiTGF5b3V0Q29uc3RhbnRzIiwibGF5b3V0QmFzZSIsIkZETGF5b3V0Q29uc3RhbnRzIiwiQ29TRUNvbnN0YW50cyIsIkNvU0VMYXlvdXQiLCJDb1NFTm9kZSIsIlBvaW50RCIsIkRpbWVuc2lvbkQiLCJkZWZhdWx0cyIsInJlYWR5Iiwic3RvcCIsInF1YWxpdHkiLCJub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMiLCJyZWZyZXNoIiwiZml0IiwicGFkZGluZyIsInJhbmRvbWl6ZSIsIm5vZGVSZXB1bHNpb24iLCJpZGVhbEVkZ2VMZW5ndGgiLCJlZGdlRWxhc3RpY2l0eSIsIm5lc3RpbmdGYWN0b3IiLCJncmF2aXR5IiwibnVtSXRlciIsInRpbGUiLCJhbmltYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aWxpbmdQYWRkaW5nVmVydGljYWwiLCJ0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCIsImdyYXZpdHlSYW5nZUNvbXBvdW5kIiwiZ3Jhdml0eUNvbXBvdW5kIiwiZ3Jhdml0eVJhbmdlIiwiaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwiLCJleHRlbmQiLCJvcHRpb25zIiwib2JqIiwiX0NvU0VMYXlvdXQiLCJfb3B0aW9ucyIsImdldFVzZXJPcHRpb25zIiwiREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEgiLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9TUFJJTkdfU1RSRU5HVEgiLCJQRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SIiwiREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIIiwiTUFYX0lURVJBVElPTlMiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsIkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwiLCJRVUFMSVRZIiwiTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTIiwiREVGQVVMVF9JTkNSRU1FTlRBTCIsIkFOSU1BVEUiLCJUSUxFIiwiVElMSU5HX1BBRERJTkdfVkVSVElDQUwiLCJUSUxJTkdfUEFERElOR19IT1JJWk9OVEFMIiwicnVuIiwiZnJhbWVJZCIsImlkVG9MTm9kZSIsImxheW91dCIsInNlbGYiLCJzdG9wcGVkIiwiY3kiLCJ0cmlnZ2VyIiwidHlwZSIsImdtIiwibmV3R3JhcGhNYW5hZ2VyIiwibm9kZXMiLCJlbGVzIiwiZWRnZXMiLCJhZGRSb290IiwicHJvY2Vzc0NoaWxkcmVuTGlzdCIsImdldFRvcE1vc3ROb2RlcyIsImxlbmd0aCIsImVkZ2UiLCJzb3VyY2VOb2RlIiwiZGF0YSIsInRhcmdldE5vZGUiLCJnZXRFZGdlc0JldHdlZW4iLCJlMSIsImFkZCIsIm5ld0VkZ2UiLCJpZCIsImdldFBvc2l0aW9ucyIsImVsZSIsInRoZUlkIiwibE5vZGUiLCJ4IiwiZ2V0UmVjdCIsImdldENlbnRlclgiLCJ5IiwiZ2V0Q2VudGVyWSIsIml0ZXJhdGVBbmltYXRlZCIsImFmdGVyUmVwb3NpdGlvbiIsIm9uZSIsInRpY2tzUGVyRnJhbWUiLCJpc0RvbmUiLCJ0aWNrIiwiY2hlY2tMYXlvdXRTdWNjZXNzIiwiaXNTdWJMYXlvdXQiLCJkb1Bvc3RMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwiaXNMYXlvdXRGaW5pc2hlZCIsInBvc2l0aW9ucyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uRGF0YSIsImdldFBvc2l0aW9uc0RhdGEiLCJpc1BhcmVudCIsInBOb2RlIiwidGVtcCIsInBhcmVudCIsInVuZGVmaW5lZCIsInBvc2l0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWRkTGlzdGVuZXIiLCJydW5MYXlvdXQiLCJub3QiLCJsYXlvdXRQb3NpdGlvbnMiLCJub2Rlc01hcCIsInJvb3RzIiwiZmlsdGVyIiwiY2hpbGRyZW4iLCJzaXplIiwidGhlQ2hpbGQiLCJjaGlsZHJlbl9vZl9jaGlsZHJlbiIsInRoZU5vZGUiLCJkaW1lbnNpb25zIiwibGF5b3V0RGltZW5zaW9ucyIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsImdyYXBoTWFuYWdlciIsInciLCJoIiwicGFyc2VGbG9hdCIsInBhZGRpbmdMZWZ0IiwicGFyc2VJbnQiLCJjc3MiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImxhYmVsV2lkdGgiLCJib3VuZGluZ0JveCIsImluY2x1ZGVMYWJlbHMiLCJpbmNsdWRlTm9kZXMiLCJsYWJlbEhlaWdodCIsImxhYmVsUG9zIiwiaXNOYU4iLCJyZWN0IiwidGhlTmV3R3JhcGgiLCJnZXRHcmFwaE1hbmFnZXIiLCJuZXdHcmFwaCIsInJlZ2lzdGVyIiwiY3l0b3NjYXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n");

/***/ })

};
;
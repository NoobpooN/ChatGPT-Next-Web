"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rt-client";
exports.ids = ["vendor-chunks/rt-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/rt-client/dist/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rt-client/dist/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LowLevelRTClient: () => (/* binding */ LowLevelRTClient),\n/* harmony export */   MessageItemType: () => (/* binding */ MessageItemType),\n/* harmony export */   RTClient: () => (/* binding */ RTClient),\n/* harmony export */   RTError: () => (/* binding */ RTError),\n/* harmony export */   isFunctionCallItem: () => (/* binding */ isFunctionCallItem),\n/* harmony export */   isMessageItem: () => (/* binding */ isMessageItem)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(net__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(tls__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar MessageItemType = \"message\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar isRealtimeEvent = function(message) {\n    return typeof message === \"object\" && message !== null && \"type\" in message;\n};\nvar isServerMessageType = function(message) {\n    return isRealtimeEvent(message) && [\n        \"error\",\n        \"session.created\",\n        \"session.updated\",\n        \"input_audio_buffer.committed\",\n        \"input_audio_buffer.cleared\",\n        \"input_audio_buffer.speech_started\",\n        \"input_audio_buffer.speech_stopped\",\n        \"conversation.item.created\",\n        \"conversation.item.truncated\",\n        \"conversation.item.deleted\",\n        \"conversation.item.input_audio_transcription.completed\",\n        \"conversation.item.input_audio_transcription.failed\",\n        \"response.created\",\n        \"response.done\",\n        \"response.output_item.added\",\n        \"response.output_item.done\",\n        \"response.content_part.added\",\n        \"response.content_part.done\",\n        \"response.text.delta\",\n        \"response.text.done\",\n        \"response.audio_transcript.delta\",\n        \"response.audio_transcript.done\",\n        \"response.audio.delta\",\n        \"response.audio.done\",\n        \"response.function_call_arguments.delta\",\n        \"response.function_call_arguments.done\",\n        \"rate_limits.updated\"\n    ].includes(message.type);\n};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar bufferUtil = {\n    exports: {}\n};\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    const BINARY_TYPES = [\n        \"nodebuffer\",\n        \"arraybuffer\",\n        \"fragments\"\n    ];\n    const hasBlob = typeof Blob !== \"undefined\";\n    if (hasBlob) BINARY_TYPES.push(\"blob\");\n    constants = {\n        BINARY_TYPES,\n        EMPTY_BUFFER: Buffer.alloc(0),\n        GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n        hasBlob,\n        kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n        kListener: Symbol(\"kListener\"),\n        kStatusCode: Symbol(\"status-code\"),\n        kWebSocket: Symbol(\"websocket\"),\n        NOOP: ()=>{}\n    };\n    return constants;\n}\nvar hasRequiredBufferUtil;\nfunction requireBufferUtil() {\n    if (hasRequiredBufferUtil) return bufferUtil.exports;\n    hasRequiredBufferUtil = 1;\n    const { EMPTY_BUFFER } = requireConstants();\n    const FastBuffer = Buffer[Symbol.species];\n    /**\n\t * Merges an array of buffers into a new buffer.\n\t *\n\t * @param {Buffer[]} list The array of buffers to concat\n\t * @param {Number} totalLength The total length of buffers in the list\n\t * @return {Buffer} The resulting buffer\n\t * @public\n\t */ function concat(list, totalLength) {\n        if (list.length === 0) return EMPTY_BUFFER;\n        if (list.length === 1) return list[0];\n        const target = Buffer.allocUnsafe(totalLength);\n        let offset = 0;\n        for(let i = 0; i < list.length; i++){\n            const buf = list[i];\n            target.set(buf, offset);\n            offset += buf.length;\n        }\n        if (offset < totalLength) {\n            return new FastBuffer(target.buffer, target.byteOffset, offset);\n        }\n        return target;\n    }\n    /**\n\t * Masks a buffer using the given mask.\n\t *\n\t * @param {Buffer} source The buffer to mask\n\t * @param {Buffer} mask The mask to use\n\t * @param {Buffer} output The buffer where to store the result\n\t * @param {Number} offset The offset at which to start writing\n\t * @param {Number} length The number of bytes to mask.\n\t * @public\n\t */ function _mask(source, mask, output, offset, length) {\n        for(let i = 0; i < length; i++){\n            output[offset + i] = source[i] ^ mask[i & 3];\n        }\n    }\n    /**\n\t * Unmasks a buffer using the given mask.\n\t *\n\t * @param {Buffer} buffer The buffer to unmask\n\t * @param {Buffer} mask The mask to use\n\t * @public\n\t */ function _unmask(buffer, mask) {\n        for(let i = 0; i < buffer.length; i++){\n            buffer[i] ^= mask[i & 3];\n        }\n    }\n    /**\n\t * Converts a buffer to an `ArrayBuffer`.\n\t *\n\t * @param {Buffer} buf The buffer to convert\n\t * @return {ArrayBuffer} Converted buffer\n\t * @public\n\t */ function toArrayBuffer(buf) {\n        if (buf.length === buf.buffer.byteLength) {\n            return buf.buffer;\n        }\n        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n    }\n    /**\n\t * Converts `data` to a `Buffer`.\n\t *\n\t * @param {*} data The data to convert\n\t * @return {Buffer} The buffer\n\t * @throws {TypeError}\n\t * @public\n\t */ function toBuffer(data) {\n        toBuffer.readOnly = true;\n        if (Buffer.isBuffer(data)) return data;\n        let buf;\n        if (data instanceof ArrayBuffer) {\n            buf = new FastBuffer(data);\n        } else if (ArrayBuffer.isView(data)) {\n            buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            buf = Buffer.from(data);\n            toBuffer.readOnly = false;\n        }\n        return buf;\n    }\n    bufferUtil.exports = {\n        concat,\n        mask: _mask,\n        toArrayBuffer,\n        toBuffer,\n        unmask: _unmask\n    };\n    /* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {\n        try {\n            const bufferUtil$1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n            bufferUtil.exports.mask = function(source, mask, output, offset, length) {\n                if (length < 48) _mask(source, mask, output, offset, length);\n                else bufferUtil$1.mask(source, mask, output, offset, length);\n            };\n            bufferUtil.exports.unmask = function(buffer, mask) {\n                if (buffer.length < 32) _unmask(buffer, mask);\n                else bufferUtil$1.unmask(buffer, mask);\n            };\n        } catch (e) {\n        // Continue regardless of the error.\n        }\n    }\n    return bufferUtil.exports;\n}\nvar limiter;\nvar hasRequiredLimiter;\nfunction requireLimiter() {\n    if (hasRequiredLimiter) return limiter;\n    hasRequiredLimiter = 1;\n    const kDone = Symbol(\"kDone\");\n    const kRun = Symbol(\"kRun\");\n    /**\n\t * A very simple job queue with adjustable concurrency. Adapted from\n\t * https://github.com/STRML/async-limiter\n\t */ class Limiter {\n        /**\n\t   * Creates a new `Limiter`.\n\t   *\n\t   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n\t   *     to run concurrently\n\t   */ constructor(concurrency){\n            this[kDone] = ()=>{\n                this.pending--;\n                this[kRun]();\n            };\n            this.concurrency = concurrency || Infinity;\n            this.jobs = [];\n            this.pending = 0;\n        }\n        /**\n\t   * Adds a job to the queue.\n\t   *\n\t   * @param {Function} job The job to run\n\t   * @public\n\t   */ add(job) {\n            this.jobs.push(job);\n            this[kRun]();\n        }\n        /**\n\t   * Removes a job from the queue and runs it if possible.\n\t   *\n\t   * @private\n\t   */ [kRun]() {\n            if (this.pending === this.concurrency) return;\n            if (this.jobs.length) {\n                const job = this.jobs.shift();\n                this.pending++;\n                job(this[kDone]);\n            }\n        }\n    }\n    limiter = Limiter;\n    return limiter;\n}\nvar permessageDeflate;\nvar hasRequiredPermessageDeflate;\nfunction requirePermessageDeflate() {\n    if (hasRequiredPermessageDeflate) return permessageDeflate;\n    hasRequiredPermessageDeflate = 1;\n    const zlib = (zlib__WEBPACK_IMPORTED_MODULE_1___default());\n    const bufferUtil = requireBufferUtil();\n    const Limiter = requireLimiter();\n    const { kStatusCode } = requireConstants();\n    const FastBuffer = Buffer[Symbol.species];\n    const TRAILER = Buffer.from([\n        0x00,\n        0x00,\n        0xff,\n        0xff\n    ]);\n    const kPerMessageDeflate = Symbol(\"permessage-deflate\");\n    const kTotalLength = Symbol(\"total-length\");\n    const kCallback = Symbol(\"callback\");\n    const kBuffers = Symbol(\"buffers\");\n    const kError = Symbol(\"error\");\n    //\n    // We limit zlib concurrency, which prevents severe memory fragmentation\n    // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n    // and https://github.com/websockets/ws/issues/1202\n    //\n    // Intentionally global; it's the global thread pool that's an issue.\n    //\n    let zlibLimiter;\n    /**\n\t * permessage-deflate implementation.\n\t */ class PerMessageDeflate {\n        /**\n\t   * Creates a PerMessageDeflate instance.\n\t   *\n\t   * @param {Object} [options] Configuration options\n\t   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n\t   *     for, or request, a custom client window size\n\t   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n\t   *     acknowledge disabling of client context takeover\n\t   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n\t   *     calls to zlib\n\t   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n\t   *     use of a custom server window size\n\t   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n\t   *     disabling of server context takeover\n\t   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n\t   *     messages should not be compressed if context takeover is disabled\n\t   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n\t   *     deflate\n\t   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n\t   *     inflate\n\t   * @param {Boolean} [isServer=false] Create the instance in either server or\n\t   *     client mode\n\t   * @param {Number} [maxPayload=0] The maximum allowed message length\n\t   */ constructor(options, isServer, maxPayload){\n            this._maxPayload = maxPayload | 0;\n            this._options = options || {};\n            this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n            this._isServer = !!isServer;\n            this._deflate = null;\n            this._inflate = null;\n            this.params = null;\n            if (!zlibLimiter) {\n                const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n                zlibLimiter = new Limiter(concurrency);\n            }\n        }\n        /**\n\t   * @type {String}\n\t   */ static get extensionName() {\n            return \"permessage-deflate\";\n        }\n        /**\n\t   * Create an extension negotiation offer.\n\t   *\n\t   * @return {Object} Extension parameters\n\t   * @public\n\t   */ offer() {\n            const params = {};\n            if (this._options.serverNoContextTakeover) {\n                params.server_no_context_takeover = true;\n            }\n            if (this._options.clientNoContextTakeover) {\n                params.client_no_context_takeover = true;\n            }\n            if (this._options.serverMaxWindowBits) {\n                params.server_max_window_bits = this._options.serverMaxWindowBits;\n            }\n            if (this._options.clientMaxWindowBits) {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            } else if (this._options.clientMaxWindowBits == null) {\n                params.client_max_window_bits = true;\n            }\n            return params;\n        }\n        /**\n\t   * Accept an extension negotiation offer/response.\n\t   *\n\t   * @param {Array} configurations The extension negotiation offers/reponse\n\t   * @return {Object} Accepted configuration\n\t   * @public\n\t   */ accept(configurations) {\n            configurations = this.normalizeParams(configurations);\n            this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n            return this.params;\n        }\n        /**\n\t   * Releases all resources used by the extension.\n\t   *\n\t   * @public\n\t   */ cleanup() {\n            if (this._inflate) {\n                this._inflate.close();\n                this._inflate = null;\n            }\n            if (this._deflate) {\n                const callback = this._deflate[kCallback];\n                this._deflate.close();\n                this._deflate = null;\n                if (callback) {\n                    callback(new Error(\"The deflate stream was closed while data was being processed\"));\n                }\n            }\n        }\n        /**\n\t   *  Accept an extension negotiation offer.\n\t   *\n\t   * @param {Array} offers The extension negotiation offers\n\t   * @return {Object} Accepted configuration\n\t   * @private\n\t   */ acceptAsServer(offers) {\n            const opts = this._options;\n            const accepted = offers.find((params)=>{\n                if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                    return false;\n                }\n                return true;\n            });\n            if (!accepted) {\n                throw new Error(\"None of the extension offers can be accepted\");\n            }\n            if (opts.serverNoContextTakeover) {\n                accepted.server_no_context_takeover = true;\n            }\n            if (opts.clientNoContextTakeover) {\n                accepted.client_no_context_takeover = true;\n            }\n            if (typeof opts.serverMaxWindowBits === \"number\") {\n                accepted.server_max_window_bits = opts.serverMaxWindowBits;\n            }\n            if (typeof opts.clientMaxWindowBits === \"number\") {\n                accepted.client_max_window_bits = opts.clientMaxWindowBits;\n            } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n                delete accepted.client_max_window_bits;\n            }\n            return accepted;\n        }\n        /**\n\t   * Accept the extension negotiation response.\n\t   *\n\t   * @param {Array} response The extension negotiation response\n\t   * @return {Object} Accepted configuration\n\t   * @private\n\t   */ acceptAsClient(response) {\n            const params = response[0];\n            if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n                throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n            }\n            if (!params.client_max_window_bits) {\n                if (typeof this._options.clientMaxWindowBits === \"number\") {\n                    params.client_max_window_bits = this._options.clientMaxWindowBits;\n                }\n            } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n                throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n            }\n            return params;\n        }\n        /**\n\t   * Normalize parameters.\n\t   *\n\t   * @param {Array} configurations The extension negotiation offers/reponse\n\t   * @return {Array} The offers/response with normalized parameters\n\t   * @private\n\t   */ normalizeParams(configurations) {\n            configurations.forEach((params)=>{\n                Object.keys(params).forEach((key)=>{\n                    let value = params[key];\n                    if (value.length > 1) {\n                        throw new Error(`Parameter \"${key}\" must have only a single value`);\n                    }\n                    value = value[0];\n                    if (key === \"client_max_window_bits\") {\n                        if (value !== true) {\n                            const num = +value;\n                            if (!Number.isInteger(num) || num < 8 || num > 15) {\n                                throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                            }\n                            value = num;\n                        } else if (!this._isServer) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                    } else if (key === \"server_max_window_bits\") {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                        if (value !== true) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                    } else {\n                        throw new Error(`Unknown parameter \"${key}\"`);\n                    }\n                    params[key] = value;\n                });\n            });\n            return configurations;\n        }\n        /**\n\t   * Decompress data. Concurrency limited.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @public\n\t   */ decompress(data, fin, callback) {\n            zlibLimiter.add((done)=>{\n                this._decompress(data, fin, (err, result)=>{\n                    done();\n                    callback(err, result);\n                });\n            });\n        }\n        /**\n\t   * Compress data. Concurrency limited.\n\t   *\n\t   * @param {(Buffer|String)} data Data to compress\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @public\n\t   */ compress(data, fin, callback) {\n            zlibLimiter.add((done)=>{\n                this._compress(data, fin, (err, result)=>{\n                    done();\n                    callback(err, result);\n                });\n            });\n        }\n        /**\n\t   * Decompress data.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @private\n\t   */ _decompress(data, fin, callback) {\n            const endpoint = this._isServer ? \"client\" : \"server\";\n            if (!this._inflate) {\n                const key = `${endpoint}_max_window_bits`;\n                const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n                this._inflate = zlib.createInflateRaw({\n                    ...this._options.zlibInflateOptions,\n                    windowBits\n                });\n                this._inflate[kPerMessageDeflate] = this;\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                this._inflate.on(\"error\", inflateOnError);\n                this._inflate.on(\"data\", inflateOnData);\n            }\n            this._inflate[kCallback] = callback;\n            this._inflate.write(data);\n            if (fin) this._inflate.write(TRAILER);\n            this._inflate.flush(()=>{\n                const err = this._inflate[kError];\n                if (err) {\n                    this._inflate.close();\n                    this._inflate = null;\n                    callback(err);\n                    return;\n                }\n                const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n                if (this._inflate._readableState.endEmitted) {\n                    this._inflate.close();\n                    this._inflate = null;\n                } else {\n                    this._inflate[kTotalLength] = 0;\n                    this._inflate[kBuffers] = [];\n                    if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                        this._inflate.reset();\n                    }\n                }\n                callback(null, data);\n            });\n        }\n        /**\n\t   * Compress data.\n\t   *\n\t   * @param {(Buffer|String)} data Data to compress\n\t   * @param {Boolean} fin Specifies whether or not this is the last fragment\n\t   * @param {Function} callback Callback\n\t   * @private\n\t   */ _compress(data, fin, callback) {\n            const endpoint = this._isServer ? \"server\" : \"client\";\n            if (!this._deflate) {\n                const key = `${endpoint}_max_window_bits`;\n                const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n                this._deflate = zlib.createDeflateRaw({\n                    ...this._options.zlibDeflateOptions,\n                    windowBits\n                });\n                this._deflate[kTotalLength] = 0;\n                this._deflate[kBuffers] = [];\n                this._deflate.on(\"data\", deflateOnData);\n            }\n            this._deflate[kCallback] = callback;\n            this._deflate.write(data);\n            this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n                if (!this._deflate) {\n                    //\n                    // The deflate stream was closed while data was being processed.\n                    //\n                    return;\n                }\n                let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n                if (fin) {\n                    data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n                }\n                //\n                // Ensure that the callback will not be called again in\n                // `PerMessageDeflate#cleanup()`.\n                //\n                this._deflate[kCallback] = null;\n                this._deflate[kTotalLength] = 0;\n                this._deflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._deflate.reset();\n                }\n                callback(null, data);\n            });\n        }\n    }\n    permessageDeflate = PerMessageDeflate;\n    /**\n\t * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function deflateOnData(chunk) {\n        this[kBuffers].push(chunk);\n        this[kTotalLength] += chunk.length;\n    }\n    /**\n\t * The listener of the `zlib.InflateRaw` stream `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function inflateOnData(chunk) {\n        this[kTotalLength] += chunk.length;\n        if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n            this[kBuffers].push(chunk);\n            return;\n        }\n        this[kError] = new RangeError(\"Max payload size exceeded\");\n        this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n        this[kError][kStatusCode] = 1009;\n        this.removeListener(\"data\", inflateOnData);\n        this.reset();\n    }\n    /**\n\t * The listener of the `zlib.InflateRaw` stream `'error'` event.\n\t *\n\t * @param {Error} err The emitted error\n\t * @private\n\t */ function inflateOnError(err) {\n        //\n        // There is no need to call `Zlib#close()` as the handle is automatically\n        // closed when an error is emitted.\n        //\n        this[kPerMessageDeflate]._inflate = null;\n        err[kStatusCode] = 1007;\n        this[kCallback](err);\n    }\n    return permessageDeflate;\n}\nvar validation = {\n    exports: {}\n};\nvar hasRequiredValidation;\nfunction requireValidation() {\n    if (hasRequiredValidation) return validation.exports;\n    hasRequiredValidation = 1;\n    const { isUtf8 } = (buffer__WEBPACK_IMPORTED_MODULE_2___default());\n    const { hasBlob } = requireConstants();\n    //\n    // Allowed token characters:\n    //\n    // '!', '#', '$', '%', '&', ''', '*', '+', '-',\n    // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n    //\n    // tokenChars[32] === 0 // ' '\n    // tokenChars[33] === 1 // '!'\n    // tokenChars[34] === 0 // '\"'\n    // ...\n    //\n    // prettier-ignore\n    const tokenChars = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        1,\n        0,\n        1,\n        0 // 112 - 127\n    ];\n    /**\n\t * Checks if a status code is allowed in a close frame.\n\t *\n\t * @param {Number} code The status code\n\t * @return {Boolean} `true` if the status code is valid, else `false`\n\t * @public\n\t */ function isValidStatusCode(code) {\n        return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n    }\n    /**\n\t * Checks if a given buffer contains only correct UTF-8.\n\t * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n\t * Markus Kuhn.\n\t *\n\t * @param {Buffer} buf The buffer to check\n\t * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n\t * @public\n\t */ function _isValidUTF8(buf) {\n        const len = buf.length;\n        let i = 0;\n        while(i < len){\n            if ((buf[i] & 0x80) === 0) {\n                // 0xxxxxxx\n                i++;\n            } else if ((buf[i] & 0xe0) === 0xc0) {\n                // 110xxxxx 10xxxxxx\n                if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n                ) {\n                    return false;\n                }\n                i += 2;\n            } else if ((buf[i] & 0xf0) === 0xe0) {\n                // 1110xxxx 10xxxxxx 10xxxxxx\n                if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n                buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n                ) {\n                    return false;\n                }\n                i += 3;\n            } else if ((buf[i] & 0xf8) === 0xf0) {\n                // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n                buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n                ) {\n                    return false;\n                }\n                i += 4;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n\t * Determines whether a value is a `Blob`.\n\t *\n\t * @param {*} value The value to be tested\n\t * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n\t * @private\n\t */ function isBlob(value) {\n        return hasBlob && typeof value === \"object\" && typeof value.arrayBuffer === \"function\" && typeof value.type === \"string\" && typeof value.stream === \"function\" && (value[Symbol.toStringTag] === \"Blob\" || value[Symbol.toStringTag] === \"File\");\n    }\n    validation.exports = {\n        isBlob,\n        isValidStatusCode,\n        isValidUTF8: _isValidUTF8,\n        tokenChars\n    };\n    if (isUtf8) {\n        validation.exports.isValidUTF8 = function(buf) {\n            return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n        };\n    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n        try {\n            const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n            validation.exports.isValidUTF8 = function(buf) {\n                return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n            };\n        } catch (e) {\n        // Continue regardless of the error.\n        }\n    }\n    return validation.exports;\n}\nvar receiver;\nvar hasRequiredReceiver;\nfunction requireReceiver() {\n    if (hasRequiredReceiver) return receiver;\n    hasRequiredReceiver = 1;\n    const { Writable } = (stream__WEBPACK_IMPORTED_MODULE_0___default());\n    const PerMessageDeflate = requirePermessageDeflate();\n    const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = requireConstants();\n    const { concat, toArrayBuffer, unmask } = requireBufferUtil();\n    const { isValidStatusCode, isValidUTF8 } = requireValidation();\n    const FastBuffer = Buffer[Symbol.species];\n    const GET_INFO = 0;\n    const GET_PAYLOAD_LENGTH_16 = 1;\n    const GET_PAYLOAD_LENGTH_64 = 2;\n    const GET_MASK = 3;\n    const GET_DATA = 4;\n    const INFLATING = 5;\n    const DEFER_EVENT = 6;\n    /**\n\t * HyBi Receiver implementation.\n\t *\n\t * @extends Writable\n\t */ class Receiver extends Writable {\n        /**\n\t   * Creates a Receiver instance.\n\t   *\n\t   * @param {Object} [options] Options object\n\t   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n\t   * @param {Object} [options.extensions] An object containing the negotiated\n\t   *     extensions\n\t   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n\t   *     client or server mode\n\t   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   */ constructor(options = {}){\n            super();\n            this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n            this._binaryType = options.binaryType || BINARY_TYPES[0];\n            this._extensions = options.extensions || {};\n            this._isServer = !!options.isServer;\n            this._maxPayload = options.maxPayload | 0;\n            this._skipUTF8Validation = !!options.skipUTF8Validation;\n            this[kWebSocket] = undefined;\n            this._bufferedBytes = 0;\n            this._buffers = [];\n            this._compressed = false;\n            this._payloadLength = 0;\n            this._mask = undefined;\n            this._fragmented = 0;\n            this._masked = false;\n            this._fin = false;\n            this._opcode = 0;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragments = [];\n            this._errored = false;\n            this._loop = false;\n            this._state = GET_INFO;\n        }\n        /**\n\t   * Implements `Writable.prototype._write()`.\n\t   *\n\t   * @param {Buffer} chunk The chunk of data to write\n\t   * @param {String} encoding The character encoding of `chunk`\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ _write(chunk, encoding, cb) {\n            if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n            this._bufferedBytes += chunk.length;\n            this._buffers.push(chunk);\n            this.startLoop(cb);\n        }\n        /**\n\t   * Consumes `n` bytes from the buffered data.\n\t   *\n\t   * @param {Number} n The number of bytes to consume\n\t   * @return {Buffer} The consumed bytes\n\t   * @private\n\t   */ consume(n) {\n            this._bufferedBytes -= n;\n            if (n === this._buffers[0].length) return this._buffers.shift();\n            if (n < this._buffers[0].length) {\n                const buf = this._buffers[0];\n                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n                return new FastBuffer(buf.buffer, buf.byteOffset, n);\n            }\n            const dst = Buffer.allocUnsafe(n);\n            do {\n                const buf = this._buffers[0];\n                const offset = dst.length - n;\n                if (n >= buf.length) {\n                    dst.set(this._buffers.shift(), offset);\n                } else {\n                    dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                    this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n                }\n                n -= buf.length;\n            }while (n > 0);\n            return dst;\n        }\n        /**\n\t   * Starts the parsing loop.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ startLoop(cb) {\n            this._loop = true;\n            do {\n                switch(this._state){\n                    case GET_INFO:\n                        this.getInfo(cb);\n                        break;\n                    case GET_PAYLOAD_LENGTH_16:\n                        this.getPayloadLength16(cb);\n                        break;\n                    case GET_PAYLOAD_LENGTH_64:\n                        this.getPayloadLength64(cb);\n                        break;\n                    case GET_MASK:\n                        this.getMask();\n                        break;\n                    case GET_DATA:\n                        this.getData(cb);\n                        break;\n                    case INFLATING:\n                    case DEFER_EVENT:\n                        this._loop = false;\n                        return;\n                }\n            }while (this._loop);\n            if (!this._errored) cb();\n        }\n        /**\n\t   * Reads the first two bytes of a frame.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getInfo(cb) {\n            if (this._bufferedBytes < 2) {\n                this._loop = false;\n                return;\n            }\n            const buf = this.consume(2);\n            if ((buf[0] & 0x30) !== 0x00) {\n                const error = this.createError(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n                cb(error);\n                return;\n            }\n            const compressed = (buf[0] & 0x40) === 0x40;\n            if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n                const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                cb(error);\n                return;\n            }\n            this._fin = (buf[0] & 0x80) === 0x80;\n            this._opcode = buf[0] & 0x0f;\n            this._payloadLength = buf[1] & 0x7f;\n            if (this._opcode === 0x00) {\n                if (compressed) {\n                    const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                    cb(error);\n                    return;\n                }\n                if (!this._fragmented) {\n                    const error = this.createError(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                    cb(error);\n                    return;\n                }\n                this._opcode = this._fragmented;\n            } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n                if (this._fragmented) {\n                    const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                    cb(error);\n                    return;\n                }\n                this._compressed = compressed;\n            } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n                if (!this._fin) {\n                    const error = this.createError(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n                    cb(error);\n                    return;\n                }\n                if (compressed) {\n                    const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                    cb(error);\n                    return;\n                }\n                if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n                    const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n                    cb(error);\n                    return;\n                }\n            } else {\n                const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                cb(error);\n                return;\n            }\n            if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n            this._masked = (buf[1] & 0x80) === 0x80;\n            if (this._isServer) {\n                if (!this._masked) {\n                    const error = this.createError(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n                    cb(error);\n                    return;\n                }\n            } else if (this._masked) {\n                const error = this.createError(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n                cb(error);\n                return;\n            }\n            if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n            else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n            else this.haveLength(cb);\n        }\n        /**\n\t   * Gets extended payload length (7+16).\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getPayloadLength16(cb) {\n            if (this._bufferedBytes < 2) {\n                this._loop = false;\n                return;\n            }\n            this._payloadLength = this.consume(2).readUInt16BE(0);\n            this.haveLength(cb);\n        }\n        /**\n\t   * Gets extended payload length (7+64).\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getPayloadLength64(cb) {\n            if (this._bufferedBytes < 8) {\n                this._loop = false;\n                return;\n            }\n            const buf = this.consume(8);\n            const num = buf.readUInt32BE(0);\n            //\n            // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n            // if payload length is greater than this number.\n            //\n            if (num > Math.pow(2, 53 - 32) - 1) {\n                const error = this.createError(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n                cb(error);\n                return;\n            }\n            this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n            this.haveLength(cb);\n        }\n        /**\n\t   * Payload length has been read.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ haveLength(cb) {\n            if (this._payloadLength && this._opcode < 0x08) {\n                this._totalPayloadLength += this._payloadLength;\n                if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                    const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                    cb(error);\n                    return;\n                }\n            }\n            if (this._masked) this._state = GET_MASK;\n            else this._state = GET_DATA;\n        }\n        /**\n\t   * Reads mask bytes.\n\t   *\n\t   * @private\n\t   */ getMask() {\n            if (this._bufferedBytes < 4) {\n                this._loop = false;\n                return;\n            }\n            this._mask = this.consume(4);\n            this._state = GET_DATA;\n        }\n        /**\n\t   * Reads data bytes.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ getData(cb) {\n            let data = EMPTY_BUFFER;\n            if (this._payloadLength) {\n                if (this._bufferedBytes < this._payloadLength) {\n                    this._loop = false;\n                    return;\n                }\n                data = this.consume(this._payloadLength);\n                if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                    unmask(data, this._mask);\n                }\n            }\n            if (this._opcode > 0x07) {\n                this.controlMessage(data, cb);\n                return;\n            }\n            if (this._compressed) {\n                this._state = INFLATING;\n                this.decompress(data, cb);\n                return;\n            }\n            if (data.length) {\n                //\n                // This message is not compressed so its length is the sum of the payload\n                // length of all fragments.\n                //\n                this._messageLength = this._totalPayloadLength;\n                this._fragments.push(data);\n            }\n            this.dataMessage(cb);\n        }\n        /**\n\t   * Decompresses data.\n\t   *\n\t   * @param {Buffer} data Compressed data\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ decompress(data, cb) {\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n                if (err) return cb(err);\n                if (buf.length) {\n                    this._messageLength += buf.length;\n                    if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                        const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                        cb(error);\n                        return;\n                    }\n                    this._fragments.push(buf);\n                }\n                this.dataMessage(cb);\n                if (this._state === GET_INFO) this.startLoop(cb);\n            });\n        }\n        /**\n\t   * Handles a data message.\n\t   *\n\t   * @param {Function} cb Callback\n\t   * @private\n\t   */ dataMessage(cb) {\n            if (!this._fin) {\n                this._state = GET_INFO;\n                return;\n            }\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                let data;\n                if (this._binaryType === \"nodebuffer\") {\n                    data = concat(fragments, messageLength);\n                } else if (this._binaryType === \"arraybuffer\") {\n                    data = toArrayBuffer(concat(fragments, messageLength));\n                } else if (this._binaryType === \"blob\") {\n                    data = new Blob(fragments);\n                } else {\n                    data = fragments;\n                }\n                if (this._allowSynchronousEvents) {\n                    this.emit(\"message\", data, true);\n                    this._state = GET_INFO;\n                } else {\n                    this._state = DEFER_EVENT;\n                    setImmediate(()=>{\n                        this.emit(\"message\", data, true);\n                        this._state = GET_INFO;\n                        this.startLoop(cb);\n                    });\n                }\n            } else {\n                const buf = concat(fragments, messageLength);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                    cb(error);\n                    return;\n                }\n                if (this._state === INFLATING || this._allowSynchronousEvents) {\n                    this.emit(\"message\", buf, false);\n                    this._state = GET_INFO;\n                } else {\n                    this._state = DEFER_EVENT;\n                    setImmediate(()=>{\n                        this.emit(\"message\", buf, false);\n                        this._state = GET_INFO;\n                        this.startLoop(cb);\n                    });\n                }\n            }\n        }\n        /**\n\t   * Handles a control message.\n\t   *\n\t   * @param {Buffer} data Data to handle\n\t   * @return {(Error|RangeError|undefined)} A possible error\n\t   * @private\n\t   */ controlMessage(data, cb) {\n            if (this._opcode === 0x08) {\n                if (data.length === 0) {\n                    this._loop = false;\n                    this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n                    this.end();\n                } else {\n                    const code = data.readUInt16BE(0);\n                    if (!isValidStatusCode(code)) {\n                        const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                        cb(error);\n                        return;\n                    }\n                    const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                        const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                        cb(error);\n                        return;\n                    }\n                    this._loop = false;\n                    this.emit(\"conclude\", code, buf);\n                    this.end();\n                }\n                this._state = GET_INFO;\n                return;\n            }\n            if (this._allowSynchronousEvents) {\n                this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        }\n        /**\n\t   * Builds an error object.\n\t   *\n\t   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n\t   * @param {String} message The error message\n\t   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n\t   *     `message`\n\t   * @param {Number} statusCode The status code\n\t   * @param {String} errorCode The exposed error code\n\t   * @return {(Error|RangeError)} The error\n\t   * @private\n\t   */ createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n            this._loop = false;\n            this._errored = true;\n            const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n            Error.captureStackTrace(err, this.createError);\n            err.code = errorCode;\n            err[kStatusCode] = statusCode;\n            return err;\n        }\n    }\n    receiver = Receiver;\n    return receiver;\n}\nrequireReceiver();\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ var sender;\nvar hasRequiredSender;\nfunction requireSender() {\n    if (hasRequiredSender) return sender;\n    hasRequiredSender = 1;\n    const { randomFillSync } = (crypto__WEBPACK_IMPORTED_MODULE_3___default());\n    const PerMessageDeflate = requirePermessageDeflate();\n    const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();\n    const { isBlob, isValidStatusCode } = requireValidation();\n    const { mask: applyMask, toBuffer } = requireBufferUtil();\n    const kByteLength = Symbol(\"kByteLength\");\n    const maskBuffer = Buffer.alloc(4);\n    const RANDOM_POOL_SIZE = 8 * 1024;\n    let randomPool;\n    let randomPoolPointer = RANDOM_POOL_SIZE;\n    const DEFAULT = 0;\n    const DEFLATING = 1;\n    const GET_BLOB_DATA = 2;\n    /**\n\t * HyBi Sender implementation.\n\t */ class Sender {\n        /**\n\t   * Creates a Sender instance.\n\t   *\n\t   * @param {Duplex} socket The connection socket\n\t   * @param {Object} [extensions] An object containing the negotiated extensions\n\t   * @param {Function} [generateMask] The function used to generate the masking\n\t   *     key\n\t   */ constructor(socket, extensions, generateMask){\n            this._extensions = extensions || {};\n            if (generateMask) {\n                this._generateMask = generateMask;\n                this._maskBuffer = Buffer.alloc(4);\n            }\n            this._socket = socket;\n            this._firstFragment = true;\n            this._compress = false;\n            this._bufferedBytes = 0;\n            this._queue = [];\n            this._state = DEFAULT;\n            this.onerror = NOOP;\n            this[kWebSocket] = undefined;\n        }\n        /**\n\t   * Frames a piece of data according to the HyBi WebSocket protocol.\n\t   *\n\t   * @param {(Buffer|String)} data The data to frame\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @return {(Buffer|String)[]} The framed data\n\t   * @public\n\t   */ static frame(data, options) {\n            let mask;\n            let merge = false;\n            let offset = 2;\n            let skipMasking = false;\n            if (options.mask) {\n                mask = options.maskBuffer || maskBuffer;\n                if (options.generateMask) {\n                    options.generateMask(mask);\n                } else {\n                    if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                        /* istanbul ignore else  */ if (randomPool === undefined) {\n                            //\n                            // This is lazily initialized because server-sent frames must not\n                            // be masked so it may never be used.\n                            //\n                            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                        }\n                        randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                        randomPoolPointer = 0;\n                    }\n                    mask[0] = randomPool[randomPoolPointer++];\n                    mask[1] = randomPool[randomPoolPointer++];\n                    mask[2] = randomPool[randomPoolPointer++];\n                    mask[3] = randomPool[randomPoolPointer++];\n                }\n                skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n                offset = 6;\n            }\n            let dataLength;\n            if (typeof data === \"string\") {\n                if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                    dataLength = options[kByteLength];\n                } else {\n                    data = Buffer.from(data);\n                    dataLength = data.length;\n                }\n            } else {\n                dataLength = data.length;\n                merge = options.mask && options.readOnly && !skipMasking;\n            }\n            let payloadLength = dataLength;\n            if (dataLength >= 65536) {\n                offset += 8;\n                payloadLength = 127;\n            } else if (dataLength > 125) {\n                offset += 2;\n                payloadLength = 126;\n            }\n            const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n            target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n            if (options.rsv1) target[0] |= 0x40;\n            target[1] = payloadLength;\n            if (payloadLength === 126) {\n                target.writeUInt16BE(dataLength, 2);\n            } else if (payloadLength === 127) {\n                target[2] = target[3] = 0;\n                target.writeUIntBE(dataLength, 4, 6);\n            }\n            if (!options.mask) return [\n                target,\n                data\n            ];\n            target[1] |= 0x80;\n            target[offset - 4] = mask[0];\n            target[offset - 3] = mask[1];\n            target[offset - 2] = mask[2];\n            target[offset - 1] = mask[3];\n            if (skipMasking) return [\n                target,\n                data\n            ];\n            if (merge) {\n                applyMask(data, mask, target, offset, dataLength);\n                return [\n                    target\n                ];\n            }\n            applyMask(data, mask, data, 0, dataLength);\n            return [\n                target,\n                data\n            ];\n        }\n        /**\n\t   * Sends a close message to the other peer.\n\t   *\n\t   * @param {Number} [code] The status code component of the body\n\t   * @param {(String|Buffer)} [data] The message component of the body\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ close(code, data, mask, cb) {\n            let buf;\n            if (code === undefined) {\n                buf = EMPTY_BUFFER;\n            } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n                throw new TypeError(\"First argument must be a valid error code number\");\n            } else if (data === undefined || !data.length) {\n                buf = Buffer.allocUnsafe(2);\n                buf.writeUInt16BE(code, 0);\n            } else {\n                const length = Buffer.byteLength(data);\n                if (length > 123) {\n                    throw new RangeError(\"The message must not be greater than 123 bytes\");\n                }\n                buf = Buffer.allocUnsafe(2 + length);\n                buf.writeUInt16BE(code, 0);\n                if (typeof data === \"string\") {\n                    buf.write(data, 2);\n                } else {\n                    buf.set(data, 2);\n                }\n            }\n            const options = {\n                [kByteLength]: buf.length,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x08,\n                readOnly: false,\n                rsv1: false\n            };\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    buf,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(buf, options), cb);\n            }\n        }\n        /**\n\t   * Sends a ping message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ ping(data, mask, cb) {\n            let byteLength;\n            let readOnly;\n            if (typeof data === \"string\") {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (byteLength > 125) {\n                throw new RangeError(\"The data size must not be greater than 125 bytes\");\n            }\n            const options = {\n                [kByteLength]: byteLength,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x09,\n                readOnly,\n                rsv1: false\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        false,\n                        options,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, false, options, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(data, options), cb);\n            }\n        }\n        /**\n\t   * Sends a pong message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ pong(data, mask, cb) {\n            let byteLength;\n            let readOnly;\n            if (typeof data === \"string\") {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (byteLength > 125) {\n                throw new RangeError(\"The data size must not be greater than 125 bytes\");\n            }\n            const options = {\n                [kByteLength]: byteLength,\n                fin: true,\n                generateMask: this._generateMask,\n                mask,\n                maskBuffer: this._maskBuffer,\n                opcode: 0x0a,\n                readOnly,\n                rsv1: false\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        false,\n                        options,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, false, options, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.sendFrame(Sender.frame(data, options), cb);\n            }\n        }\n        /**\n\t   * Sends a data message to the other peer.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n\t   *     or text\n\t   * @param {Boolean} [options.compress=false] Specifies whether or not to\n\t   *     compress `data`\n\t   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n\t   *     last one\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Function} [cb] Callback\n\t   * @public\n\t   */ send(data, options, cb) {\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            let opcode = options.binary ? 2 : 1;\n            let rsv1 = options.compress;\n            let byteLength;\n            let readOnly;\n            if (typeof data === \"string\") {\n                byteLength = Buffer.byteLength(data);\n                readOnly = false;\n            } else if (isBlob(data)) {\n                byteLength = data.size;\n                readOnly = false;\n            } else {\n                data = toBuffer(data);\n                byteLength = data.length;\n                readOnly = toBuffer.readOnly;\n            }\n            if (this._firstFragment) {\n                this._firstFragment = false;\n                if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                    rsv1 = byteLength >= perMessageDeflate._threshold;\n                }\n                this._compress = rsv1;\n            } else {\n                rsv1 = false;\n                opcode = 0;\n            }\n            if (options.fin) this._firstFragment = true;\n            const opts = {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1\n            };\n            if (isBlob(data)) {\n                if (this._state !== DEFAULT) {\n                    this.enqueue([\n                        this.getBlobData,\n                        data,\n                        this._compress,\n                        opts,\n                        cb\n                    ]);\n                } else {\n                    this.getBlobData(data, this._compress, opts, cb);\n                }\n            } else if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        }\n        /**\n\t   * Gets the contents of a blob as binary data.\n\t   *\n\t   * @param {Blob} blob The blob\n\t   * @param {Boolean} [compress=false] Specifies whether or not to compress\n\t   *     the data\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ getBlobData(blob, compress, options, cb) {\n            this._bufferedBytes += options[kByteLength];\n            this._state = GET_BLOB_DATA;\n            blob.arrayBuffer().then((arrayBuffer)=>{\n                if (this._socket.destroyed) {\n                    const err = new Error(\"The socket was closed while the blob was being read\");\n                    //\n                    // `callCallbacks` is called in the next tick to ensure that errors\n                    // that might be thrown in the callbacks behave like errors thrown\n                    // outside the promise chain.\n                    //\n                    process.nextTick(callCallbacks, this, err, cb);\n                    return;\n                }\n                this._bufferedBytes -= options[kByteLength];\n                const data = toBuffer(arrayBuffer);\n                if (!compress) {\n                    this._state = DEFAULT;\n                    this.sendFrame(Sender.frame(data, options), cb);\n                    this.dequeue();\n                } else {\n                    this.dispatch(data, compress, options, cb);\n                }\n            }).catch((err)=>{\n                //\n                // `onError` is called in the next tick for the same reason that\n                // `callCallbacks` above is.\n                //\n                process.nextTick(onError, this, err, cb);\n            });\n        }\n        /**\n\t   * Dispatches a message.\n\t   *\n\t   * @param {(Buffer|String)} data The message to send\n\t   * @param {Boolean} [compress=false] Specifies whether or not to compress\n\t   *     `data`\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n\t   *     FIN bit\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n\t   *     `data`\n\t   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n\t   *     key\n\t   * @param {Number} options.opcode The opcode\n\t   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n\t   *     modified\n\t   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n\t   *     RSV1 bit\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ dispatch(data, compress, options, cb) {\n            if (!compress) {\n                this.sendFrame(Sender.frame(data, options), cb);\n                return;\n            }\n            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n            this._bufferedBytes += options[kByteLength];\n            this._state = DEFLATING;\n            perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n                if (this._socket.destroyed) {\n                    const err = new Error(\"The socket was closed while data was being compressed\");\n                    callCallbacks(this, err, cb);\n                    return;\n                }\n                this._bufferedBytes -= options[kByteLength];\n                this._state = DEFAULT;\n                options.readOnly = false;\n                this.sendFrame(Sender.frame(buf, options), cb);\n                this.dequeue();\n            });\n        }\n        /**\n\t   * Executes queued send operations.\n\t   *\n\t   * @private\n\t   */ dequeue() {\n            while(this._state === DEFAULT && this._queue.length){\n                const params = this._queue.shift();\n                this._bufferedBytes -= params[3][kByteLength];\n                Reflect.apply(params[0], this, params.slice(1));\n            }\n        }\n        /**\n\t   * Enqueues a send operation.\n\t   *\n\t   * @param {Array} params Send operation parameters.\n\t   * @private\n\t   */ enqueue(params) {\n            this._bufferedBytes += params[3][kByteLength];\n            this._queue.push(params);\n        }\n        /**\n\t   * Sends a frame.\n\t   *\n\t   * @param {Buffer[]} list The frame to send\n\t   * @param {Function} [cb] Callback\n\t   * @private\n\t   */ sendFrame(list, cb) {\n            if (list.length === 2) {\n                this._socket.cork();\n                this._socket.write(list[0]);\n                this._socket.write(list[1], cb);\n                this._socket.uncork();\n            } else {\n                this._socket.write(list[0], cb);\n            }\n        }\n    }\n    sender = Sender;\n    /**\n\t * Calls queued callbacks with an error.\n\t *\n\t * @param {Sender} sender The `Sender` instance\n\t * @param {Error} err The error to call the callbacks with\n\t * @param {Function} [cb] The first callback\n\t * @private\n\t */ function callCallbacks(sender, err, cb) {\n        if (typeof cb === \"function\") cb(err);\n        for(let i = 0; i < sender._queue.length; i++){\n            const params = sender._queue[i];\n            const callback = params[params.length - 1];\n            if (typeof callback === \"function\") callback(err);\n        }\n    }\n    /**\n\t * Handles a `Sender` error.\n\t *\n\t * @param {Sender} sender The `Sender` instance\n\t * @param {Error} err The error\n\t * @param {Function} [cb] The first pending callback\n\t * @private\n\t */ function onError(sender, err, cb) {\n        callCallbacks(sender, err, cb);\n        sender.onerror(err);\n    }\n    return sender;\n}\nrequireSender();\nvar eventTarget;\nvar hasRequiredEventTarget;\nfunction requireEventTarget() {\n    if (hasRequiredEventTarget) return eventTarget;\n    hasRequiredEventTarget = 1;\n    const { kForOnEventAttribute, kListener } = requireConstants();\n    const kCode = Symbol(\"kCode\");\n    const kData = Symbol(\"kData\");\n    const kError = Symbol(\"kError\");\n    const kMessage = Symbol(\"kMessage\");\n    const kReason = Symbol(\"kReason\");\n    const kTarget = Symbol(\"kTarget\");\n    const kType = Symbol(\"kType\");\n    const kWasClean = Symbol(\"kWasClean\");\n    /**\n\t * Class representing an event.\n\t */ class Event {\n        /**\n\t   * Create a new `Event`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @throws {TypeError} If the `type` argument is not specified\n\t   */ constructor(type){\n            this[kTarget] = null;\n            this[kType] = type;\n        }\n        /**\n\t   * @type {*}\n\t   */ get target() {\n            return this[kTarget];\n        }\n        /**\n\t   * @type {String}\n\t   */ get type() {\n            return this[kType];\n        }\n    }\n    Object.defineProperty(Event.prototype, \"target\", {\n        enumerable: true\n    });\n    Object.defineProperty(Event.prototype, \"type\", {\n        enumerable: true\n    });\n    /**\n\t * Class representing a close event.\n\t *\n\t * @extends Event\n\t */ class CloseEvent extends Event {\n        /**\n\t   * Create a new `CloseEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {Number} [options.code=0] The status code explaining why the\n\t   *     connection was closed\n\t   * @param {String} [options.reason=''] A human-readable string explaining why\n\t   *     the connection was closed\n\t   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n\t   *     connection was cleanly closed\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kCode] = options.code === undefined ? 0 : options.code;\n            this[kReason] = options.reason === undefined ? \"\" : options.reason;\n            this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get code() {\n            return this[kCode];\n        }\n        /**\n\t   * @type {String}\n\t   */ get reason() {\n            return this[kReason];\n        }\n        /**\n\t   * @type {Boolean}\n\t   */ get wasClean() {\n            return this[kWasClean];\n        }\n    }\n    Object.defineProperty(CloseEvent.prototype, \"code\", {\n        enumerable: true\n    });\n    Object.defineProperty(CloseEvent.prototype, \"reason\", {\n        enumerable: true\n    });\n    Object.defineProperty(CloseEvent.prototype, \"wasClean\", {\n        enumerable: true\n    });\n    /**\n\t * Class representing an error event.\n\t *\n\t * @extends Event\n\t */ class ErrorEvent extends Event {\n        /**\n\t   * Create a new `ErrorEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {*} [options.error=null] The error that generated this event\n\t   * @param {String} [options.message=''] The error message\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kError] = options.error === undefined ? null : options.error;\n            this[kMessage] = options.message === undefined ? \"\" : options.message;\n        }\n        /**\n\t   * @type {*}\n\t   */ get error() {\n            return this[kError];\n        }\n        /**\n\t   * @type {String}\n\t   */ get message() {\n            return this[kMessage];\n        }\n    }\n    Object.defineProperty(ErrorEvent.prototype, \"error\", {\n        enumerable: true\n    });\n    Object.defineProperty(ErrorEvent.prototype, \"message\", {\n        enumerable: true\n    });\n    /**\n\t * Class representing a message event.\n\t *\n\t * @extends Event\n\t */ class MessageEvent extends Event {\n        /**\n\t   * Create a new `MessageEvent`.\n\t   *\n\t   * @param {String} type The name of the event\n\t   * @param {Object} [options] A dictionary object that allows for setting\n\t   *     attributes via object members of the same name\n\t   * @param {*} [options.data=null] The message content\n\t   */ constructor(type, options = {}){\n            super(type);\n            this[kData] = options.data === undefined ? null : options.data;\n        }\n        /**\n\t   * @type {*}\n\t   */ get data() {\n            return this[kData];\n        }\n    }\n    Object.defineProperty(MessageEvent.prototype, \"data\", {\n        enumerable: true\n    });\n    /**\n\t * This provides methods for emulating the `EventTarget` interface. It's not\n\t * meant to be used directly.\n\t *\n\t * @mixin\n\t */ const EventTarget = {\n        /**\n\t   * Register an event listener.\n\t   *\n\t   * @param {String} type A string representing the event type to listen for\n\t   * @param {(Function|Object)} handler The listener to add\n\t   * @param {Object} [options] An options object specifies characteristics about\n\t   *     the event listener\n\t   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n\t   *     listener should be invoked at most once after being added. If `true`,\n\t   *     the listener would be automatically removed when invoked.\n\t   * @public\n\t   */ addEventListener (type, handler, options = {}) {\n            for (const listener of this.listeners(type)){\n                if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                    return;\n                }\n            }\n            let wrapper;\n            if (type === \"message\") {\n                wrapper = function onMessage(data, isBinary) {\n                    const event = new MessageEvent(\"message\", {\n                        data: isBinary ? data : data.toString()\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === \"close\") {\n                wrapper = function onClose(code, message) {\n                    const event = new CloseEvent(\"close\", {\n                        code,\n                        reason: message.toString(),\n                        wasClean: this._closeFrameReceived && this._closeFrameSent\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === \"error\") {\n                wrapper = function onError(error) {\n                    const event = new ErrorEvent(\"error\", {\n                        error,\n                        message: error.message\n                    });\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else if (type === \"open\") {\n                wrapper = function onOpen() {\n                    const event = new Event(\"open\");\n                    event[kTarget] = this;\n                    callListener(handler, this, event);\n                };\n            } else {\n                return;\n            }\n            wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n            wrapper[kListener] = handler;\n            if (options.once) {\n                this.once(type, wrapper);\n            } else {\n                this.on(type, wrapper);\n            }\n        },\n        /**\n\t   * Remove an event listener.\n\t   *\n\t   * @param {String} type A string representing the event type to remove\n\t   * @param {(Function|Object)} handler The listener to remove\n\t   * @public\n\t   */ removeEventListener (type, handler) {\n            for (const listener of this.listeners(type)){\n                if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                    this.removeListener(type, listener);\n                    break;\n                }\n            }\n        }\n    };\n    eventTarget = {\n        CloseEvent,\n        ErrorEvent,\n        Event,\n        EventTarget,\n        MessageEvent\n    };\n    /**\n\t * Call an event listener\n\t *\n\t * @param {(Function|Object)} listener The listener to call\n\t * @param {*} thisArg The value to use as `this`` when calling the listener\n\t * @param {Event} event The event to pass to the listener\n\t * @private\n\t */ function callListener(listener, thisArg, event) {\n        if (typeof listener === \"object\" && listener.handleEvent) {\n            listener.handleEvent.call(listener, event);\n        } else {\n            listener.call(thisArg, event);\n        }\n    }\n    return eventTarget;\n}\nvar extension;\nvar hasRequiredExtension;\nfunction requireExtension() {\n    if (hasRequiredExtension) return extension;\n    hasRequiredExtension = 1;\n    const { tokenChars } = requireValidation();\n    /**\n\t * Adds an offer to the map of extension offers or a parameter to the map of\n\t * parameters.\n\t *\n\t * @param {Object} dest The map of extension offers or parameters\n\t * @param {String} name The extension or parameter name\n\t * @param {(Object|Boolean|String)} elem The extension parameters or the\n\t *     parameter value\n\t * @private\n\t */ function push(dest, name, elem) {\n        if (dest[name] === undefined) dest[name] = [\n            elem\n        ];\n        else dest[name].push(elem);\n    }\n    /**\n\t * Parses the `Sec-WebSocket-Extensions` header into an object.\n\t *\n\t * @param {String} header The field value of the header\n\t * @return {Object} The parsed object\n\t * @public\n\t */ function parse(header) {\n        const offers = Object.create(null);\n        let params = Object.create(null);\n        let mustUnescape = false;\n        let isEscaping = false;\n        let inQuotes = false;\n        let extensionName;\n        let paramName;\n        let start = -1;\n        let code = -1;\n        let end = -1;\n        let i = 0;\n        for(; i < header.length; i++){\n            code = header.charCodeAt(i);\n            if (extensionName === undefined) {\n                if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                    if (end === -1 && start !== -1) end = i;\n                } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    const name = header.slice(start, end);\n                    if (code === 0x2c) {\n                        push(offers, name, params);\n                        params = Object.create(null);\n                    } else {\n                        extensionName = name;\n                    }\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (paramName === undefined) {\n                if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x20 || code === 0x09) {\n                    if (end === -1 && start !== -1) end = i;\n                } else if (code === 0x3b || code === 0x2c) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    push(params, header.slice(start, end), true);\n                    if (code === 0x2c) {\n                        push(offers, extensionName, params);\n                        params = Object.create(null);\n                        extensionName = undefined;\n                    }\n                    start = end = -1;\n                } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                    paramName = header.slice(start, i);\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else {\n                //\n                // The value of a quoted-string after unescaping must conform to the\n                // token ABNF, so only token characters are valid.\n                // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n                //\n                if (isEscaping) {\n                    if (tokenChars[code] !== 1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (start === -1) start = i;\n                    else if (!mustUnescape) mustUnescape = true;\n                    isEscaping = false;\n                } else if (inQuotes) {\n                    if (tokenChars[code] === 1) {\n                        if (start === -1) start = i;\n                    } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                        inQuotes = false;\n                        end = i;\n                    } else if (code === 0x5c /* '\\' */ ) {\n                        isEscaping = true;\n                    } else {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                    inQuotes = true;\n                } else if (end === -1 && tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                    if (end === -1) end = i;\n                } else if (code === 0x3b || code === 0x2c) {\n                    if (start === -1) {\n                        throw new SyntaxError(`Unexpected character at index ${i}`);\n                    }\n                    if (end === -1) end = i;\n                    let value = header.slice(start, end);\n                    if (mustUnescape) {\n                        value = value.replace(/\\\\/g, \"\");\n                        mustUnescape = false;\n                    }\n                    push(params, paramName, value);\n                    if (code === 0x2c) {\n                        push(offers, extensionName, params);\n                        params = Object.create(null);\n                        extensionName = undefined;\n                    }\n                    paramName = undefined;\n                    start = end = -1;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            }\n        }\n        if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n            throw new SyntaxError(\"Unexpected end of input\");\n        }\n        if (end === -1) end = i;\n        const token = header.slice(start, end);\n        if (extensionName === undefined) {\n            push(offers, token, params);\n        } else {\n            if (paramName === undefined) {\n                push(params, token, true);\n            } else if (mustUnescape) {\n                push(params, paramName, token.replace(/\\\\/g, \"\"));\n            } else {\n                push(params, paramName, token);\n            }\n            push(offers, extensionName, params);\n        }\n        return offers;\n    }\n    /**\n\t * Builds the `Sec-WebSocket-Extensions` header field value.\n\t *\n\t * @param {Object} extensions The map of extensions and parameters to format\n\t * @return {String} A string representing the given object\n\t * @public\n\t */ function format(extensions) {\n        return Object.keys(extensions).map((extension)=>{\n            let configurations = extensions[extension];\n            if (!Array.isArray(configurations)) configurations = [\n                configurations\n            ];\n            return configurations.map((params)=>{\n                return [\n                    extension\n                ].concat(Object.keys(params).map((k)=>{\n                    let values = params[k];\n                    if (!Array.isArray(values)) values = [\n                        values\n                    ];\n                    return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n                })).join(\"; \");\n            }).join(\", \");\n        }).join(\", \");\n    }\n    extension = {\n        format,\n        parse\n    };\n    return extension;\n}\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */ var websocket;\nvar hasRequiredWebsocket;\nfunction requireWebsocket() {\n    if (hasRequiredWebsocket) return websocket;\n    hasRequiredWebsocket = 1;\n    const EventEmitter = (events__WEBPACK_IMPORTED_MODULE_4___default());\n    const https = (https__WEBPACK_IMPORTED_MODULE_5___default());\n    const http = (http__WEBPACK_IMPORTED_MODULE_6___default());\n    const net = (net__WEBPACK_IMPORTED_MODULE_7___default());\n    const tls = (tls__WEBPACK_IMPORTED_MODULE_8___default());\n    const { randomBytes, createHash } = (crypto__WEBPACK_IMPORTED_MODULE_3___default());\n    const { URL: URL1 } = (url__WEBPACK_IMPORTED_MODULE_9___default());\n    const PerMessageDeflate = requirePermessageDeflate();\n    const Receiver = requireReceiver();\n    const Sender = requireSender();\n    const { isBlob } = requireValidation();\n    const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = requireConstants();\n    const { EventTarget: { addEventListener, removeEventListener } } = requireEventTarget();\n    const { format, parse } = requireExtension();\n    const { toBuffer } = requireBufferUtil();\n    const closeTimeout = 30 * 1000;\n    const kAborted = Symbol(\"kAborted\");\n    const protocolVersions = [\n        8,\n        13\n    ];\n    const readyStates = [\n        \"CONNECTING\",\n        \"OPEN\",\n        \"CLOSING\",\n        \"CLOSED\"\n    ];\n    const subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n    /**\n\t * Class representing a WebSocket.\n\t *\n\t * @extends EventEmitter\n\t */ class WebSocket extends EventEmitter {\n        /**\n\t   * Create a new `WebSocket`.\n\t   *\n\t   * @param {(String|URL)} address The URL to which to connect\n\t   * @param {(String|String[])} [protocols] The subprotocols\n\t   * @param {Object} [options] Connection options\n\t   */ constructor(address, protocols, options){\n            super();\n            this._binaryType = BINARY_TYPES[0];\n            this._closeCode = 1006;\n            this._closeFrameReceived = false;\n            this._closeFrameSent = false;\n            this._closeMessage = EMPTY_BUFFER;\n            this._closeTimer = null;\n            this._errorEmitted = false;\n            this._extensions = {};\n            this._paused = false;\n            this._protocol = \"\";\n            this._readyState = WebSocket.CONNECTING;\n            this._receiver = null;\n            this._sender = null;\n            this._socket = null;\n            if (address !== null) {\n                this._bufferedAmount = 0;\n                this._isServer = false;\n                this._redirects = 0;\n                if (protocols === undefined) {\n                    protocols = [];\n                } else if (!Array.isArray(protocols)) {\n                    if (typeof protocols === \"object\" && protocols !== null) {\n                        options = protocols;\n                        protocols = [];\n                    } else {\n                        protocols = [\n                            protocols\n                        ];\n                    }\n                }\n                initAsClient(this, address, protocols, options);\n            } else {\n                this._autoPong = options.autoPong;\n                this._isServer = true;\n            }\n        }\n        /**\n\t   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n\t   * instead of \"blob\".\n\t   *\n\t   * @type {String}\n\t   */ get binaryType() {\n            return this._binaryType;\n        }\n        set binaryType(type) {\n            if (!BINARY_TYPES.includes(type)) return;\n            this._binaryType = type;\n            //\n            // Allow to change `binaryType` on the fly.\n            //\n            if (this._receiver) this._receiver._binaryType = type;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get bufferedAmount() {\n            if (!this._socket) return this._bufferedAmount;\n            return this._socket._writableState.length + this._sender._bufferedBytes;\n        }\n        /**\n\t   * @type {String}\n\t   */ get extensions() {\n            return Object.keys(this._extensions).join();\n        }\n        /**\n\t   * @type {Boolean}\n\t   */ get isPaused() {\n            return this._paused;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onclose() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onerror() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onopen() {\n            return null;\n        }\n        /**\n\t   * @type {Function}\n\t   */ /* istanbul ignore next */ get onmessage() {\n            return null;\n        }\n        /**\n\t   * @type {String}\n\t   */ get protocol() {\n            return this._protocol;\n        }\n        /**\n\t   * @type {Number}\n\t   */ get readyState() {\n            return this._readyState;\n        }\n        /**\n\t   * @type {String}\n\t   */ get url() {\n            return this._url;\n        }\n        /**\n\t   * Set up the socket and the internal resources.\n\t   *\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Object} options Options object\n\t   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {Function} [options.generateMask] The function used to generate the\n\t   *     masking key\n\t   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   * @private\n\t   */ setSocket(socket, head, options) {\n            const receiver = new Receiver({\n                allowSynchronousEvents: options.allowSynchronousEvents,\n                binaryType: this.binaryType,\n                extensions: this._extensions,\n                isServer: this._isServer,\n                maxPayload: options.maxPayload,\n                skipUTF8Validation: options.skipUTF8Validation\n            });\n            const sender = new Sender(socket, this._extensions, options.generateMask);\n            this._receiver = receiver;\n            this._sender = sender;\n            this._socket = socket;\n            receiver[kWebSocket] = this;\n            sender[kWebSocket] = this;\n            socket[kWebSocket] = this;\n            receiver.on(\"conclude\", receiverOnConclude);\n            receiver.on(\"drain\", receiverOnDrain);\n            receiver.on(\"error\", receiverOnError);\n            receiver.on(\"message\", receiverOnMessage);\n            receiver.on(\"ping\", receiverOnPing);\n            receiver.on(\"pong\", receiverOnPong);\n            sender.onerror = senderOnError;\n            //\n            // These methods may not be available if `socket` is just a `Duplex`.\n            //\n            if (socket.setTimeout) socket.setTimeout(0);\n            if (socket.setNoDelay) socket.setNoDelay();\n            if (head.length > 0) socket.unshift(head);\n            socket.on(\"close\", socketOnClose);\n            socket.on(\"data\", socketOnData);\n            socket.on(\"end\", socketOnEnd);\n            socket.on(\"error\", socketOnError);\n            this._readyState = WebSocket.OPEN;\n            this.emit(\"open\");\n        }\n        /**\n\t   * Emit the `'close'` event.\n\t   *\n\t   * @private\n\t   */ emitClose() {\n            if (!this._socket) {\n                this._readyState = WebSocket.CLOSED;\n                this.emit(\"close\", this._closeCode, this._closeMessage);\n                return;\n            }\n            if (this._extensions[PerMessageDeflate.extensionName]) {\n                this._extensions[PerMessageDeflate.extensionName].cleanup();\n            }\n            this._receiver.removeAllListeners();\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n        }\n        /**\n\t   * Start a closing handshake.\n\t   *\n\t   *          +----------+   +-----------+   +----------+\n\t   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n\t   *    |     +----------+   +-----------+   +----------+     |\n\t   *          +----------+   +-----------+         |\n\t   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n\t   *          +----------+   +-----------+   |\n\t   *    |           |                        |   +---+        |\n\t   *                +------------------------+-->|fin| - - - -\n\t   *    |         +---+                      |   +---+\n\t   *     - - - - -|fin|<---------------------+\n\t   *              +---+\n\t   *\n\t   * @param {Number} [code] Status code explaining why the connection is closing\n\t   * @param {(String|Buffer)} [data] The reason why the connection is\n\t   *     closing\n\t   * @public\n\t   */ close(code, data) {\n            if (this.readyState === WebSocket.CLOSED) return;\n            if (this.readyState === WebSocket.CONNECTING) {\n                const msg = \"WebSocket was closed before the connection was established\";\n                abortHandshake(this, this._req, msg);\n                return;\n            }\n            if (this.readyState === WebSocket.CLOSING) {\n                if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                    this._socket.end();\n                }\n                return;\n            }\n            this._readyState = WebSocket.CLOSING;\n            this._sender.close(code, data, !this._isServer, (err)=>{\n                //\n                // This error is handled by the `'error'` listener on the socket. We only\n                // want to know if the close frame has been sent here.\n                //\n                if (err) return;\n                this._closeFrameSent = true;\n                if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                    this._socket.end();\n                }\n            });\n            setCloseTimer(this);\n        }\n        /**\n\t   * Pause the socket.\n\t   *\n\t   * @public\n\t   */ pause() {\n            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n                return;\n            }\n            this._paused = true;\n            this._socket.pause();\n        }\n        /**\n\t   * Send a ping.\n\t   *\n\t   * @param {*} [data] The data to send\n\t   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when the ping is sent\n\t   * @public\n\t   */ ping(data, mask, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n            }\n            if (typeof data === \"function\") {\n                cb = data;\n                data = mask = undefined;\n            } else if (typeof mask === \"function\") {\n                cb = mask;\n                mask = undefined;\n            }\n            if (typeof data === \"number\") data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            if (mask === undefined) mask = !this._isServer;\n            this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n        }\n        /**\n\t   * Send a pong.\n\t   *\n\t   * @param {*} [data] The data to send\n\t   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when the pong is sent\n\t   * @public\n\t   */ pong(data, mask, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n            }\n            if (typeof data === \"function\") {\n                cb = data;\n                data = mask = undefined;\n            } else if (typeof mask === \"function\") {\n                cb = mask;\n                mask = undefined;\n            }\n            if (typeof data === \"number\") data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            if (mask === undefined) mask = !this._isServer;\n            this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n        }\n        /**\n\t   * Resume the socket.\n\t   *\n\t   * @public\n\t   */ resume() {\n            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n                return;\n            }\n            this._paused = false;\n            if (!this._receiver._writableState.needDrain) this._socket.resume();\n        }\n        /**\n\t   * Send a data message.\n\t   *\n\t   * @param {*} data The message to send\n\t   * @param {Object} [options] Options object\n\t   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n\t   *     text\n\t   * @param {Boolean} [options.compress] Specifies whether or not to compress\n\t   *     `data`\n\t   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n\t   *     last one\n\t   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n\t   * @param {Function} [cb] Callback which is executed when data is written out\n\t   * @public\n\t   */ send(data, options, cb) {\n            if (this.readyState === WebSocket.CONNECTING) {\n                throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n            }\n            if (typeof options === \"function\") {\n                cb = options;\n                options = {};\n            }\n            if (typeof data === \"number\") data = data.toString();\n            if (this.readyState !== WebSocket.OPEN) {\n                sendAfterClose(this, data, cb);\n                return;\n            }\n            const opts = {\n                binary: typeof data !== \"string\",\n                mask: !this._isServer,\n                compress: true,\n                fin: true,\n                ...options\n            };\n            if (!this._extensions[PerMessageDeflate.extensionName]) {\n                opts.compress = false;\n            }\n            this._sender.send(data || EMPTY_BUFFER, opts, cb);\n        }\n        /**\n\t   * Forcibly close the connection.\n\t   *\n\t   * @public\n\t   */ terminate() {\n            if (this.readyState === WebSocket.CLOSED) return;\n            if (this.readyState === WebSocket.CONNECTING) {\n                const msg = \"WebSocket was closed before the connection was established\";\n                abortHandshake(this, this._req, msg);\n                return;\n            }\n            if (this._socket) {\n                this._readyState = WebSocket.CLOSING;\n                this._socket.destroy();\n            }\n        }\n    }\n    /**\n\t * @constant {Number} CONNECTING\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CONNECTING\")\n    });\n    /**\n\t * @constant {Number} CONNECTING\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CONNECTING\")\n    });\n    /**\n\t * @constant {Number} OPEN\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, \"OPEN\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"OPEN\")\n    });\n    /**\n\t * @constant {Number} OPEN\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"OPEN\")\n    });\n    /**\n\t * @constant {Number} CLOSING\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, \"CLOSING\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CLOSING\")\n    });\n    /**\n\t * @constant {Number} CLOSING\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CLOSING\")\n    });\n    /**\n\t * @constant {Number} CLOSED\n\t * @memberof WebSocket\n\t */ Object.defineProperty(WebSocket, \"CLOSED\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CLOSED\")\n    });\n    /**\n\t * @constant {Number} CLOSED\n\t * @memberof WebSocket.prototype\n\t */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n        enumerable: true,\n        value: readyStates.indexOf(\"CLOSED\")\n    });\n    [\n        \"binaryType\",\n        \"bufferedAmount\",\n        \"extensions\",\n        \"isPaused\",\n        \"protocol\",\n        \"readyState\",\n        \"url\"\n    ].forEach((property)=>{\n        Object.defineProperty(WebSocket.prototype, property, {\n            enumerable: true\n        });\n    });\n    //\n    // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n    // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n    //\n    [\n        \"open\",\n        \"error\",\n        \"close\",\n        \"message\"\n    ].forEach((method)=>{\n        Object.defineProperty(WebSocket.prototype, `on${method}`, {\n            enumerable: true,\n            get () {\n                for (const listener of this.listeners(method)){\n                    if (listener[kForOnEventAttribute]) return listener[kListener];\n                }\n                return null;\n            },\n            set (handler) {\n                for (const listener of this.listeners(method)){\n                    if (listener[kForOnEventAttribute]) {\n                        this.removeListener(method, listener);\n                        break;\n                    }\n                }\n                if (typeof handler !== \"function\") return;\n                this.addEventListener(method, handler, {\n                    [kForOnEventAttribute]: true\n                });\n            }\n        });\n    });\n    WebSocket.prototype.addEventListener = addEventListener;\n    WebSocket.prototype.removeEventListener = removeEventListener;\n    websocket = WebSocket;\n    /**\n\t * Initialize a WebSocket client.\n\t *\n\t * @param {WebSocket} websocket The client to initialize\n\t * @param {(String|URL)} address The URL to which to connect\n\t * @param {Array} protocols The subprotocols\n\t * @param {Object} [options] Connection options\n\t * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n\t *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n\t *     times in the same tick\n\t * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n\t *     automatically send a pong in response to a ping\n\t * @param {Function} [options.finishRequest] A function which can be used to\n\t *     customize the headers of each http request before it is sent\n\t * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n\t *     redirects\n\t * @param {Function} [options.generateMask] The function used to generate the\n\t *     masking key\n\t * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n\t *     handshake request\n\t * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n\t *     size\n\t * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n\t *     allowed\n\t * @param {String} [options.origin] Value of the `Origin` or\n\t *     `Sec-WebSocket-Origin` header\n\t * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n\t *     permessage-deflate\n\t * @param {Number} [options.protocolVersion=13] Value of the\n\t *     `Sec-WebSocket-Version` header\n\t * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t *     not to skip UTF-8 validation for text and close messages\n\t * @private\n\t */ function initAsClient(websocket, address, protocols, options) {\n        const opts = {\n            allowSynchronousEvents: true,\n            autoPong: true,\n            protocolVersion: protocolVersions[1],\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: true,\n            followRedirects: false,\n            maxRedirects: 10,\n            ...options,\n            socketPath: undefined,\n            hostname: undefined,\n            protocol: undefined,\n            timeout: undefined,\n            method: \"GET\",\n            host: undefined,\n            path: undefined,\n            port: undefined\n        };\n        websocket._autoPong = opts.autoPong;\n        if (!protocolVersions.includes(opts.protocolVersion)) {\n            throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n        }\n        let parsedUrl;\n        if (address instanceof URL1) {\n            parsedUrl = address;\n        } else {\n            try {\n                parsedUrl = new URL1(address);\n            } catch (e) {\n                throw new SyntaxError(`Invalid URL: ${address}`);\n            }\n        }\n        if (parsedUrl.protocol === \"http:\") {\n            parsedUrl.protocol = \"ws:\";\n        } else if (parsedUrl.protocol === \"https:\") {\n            parsedUrl.protocol = \"wss:\";\n        }\n        websocket._url = parsedUrl.href;\n        const isSecure = parsedUrl.protocol === \"wss:\";\n        const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n        let invalidUrlMessage;\n        if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n            invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n        } else if (isIpcUrl && !parsedUrl.pathname) {\n            invalidUrlMessage = \"The URL's pathname is empty\";\n        } else if (parsedUrl.hash) {\n            invalidUrlMessage = \"The URL contains a fragment identifier\";\n        }\n        if (invalidUrlMessage) {\n            const err = new SyntaxError(invalidUrlMessage);\n            if (websocket._redirects === 0) {\n                throw err;\n            } else {\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n        }\n        const defaultPort = isSecure ? 443 : 80;\n        const key = randomBytes(16).toString(\"base64\");\n        const request = isSecure ? https.request : http.request;\n        const protocolSet = new Set();\n        let perMessageDeflate;\n        opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n        opts.defaultPort = opts.defaultPort || defaultPort;\n        opts.port = parsedUrl.port || defaultPort;\n        opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n        opts.headers = {\n            ...opts.headers,\n            \"Sec-WebSocket-Version\": opts.protocolVersion,\n            \"Sec-WebSocket-Key\": key,\n            Connection: \"Upgrade\",\n            Upgrade: \"websocket\"\n        };\n        opts.path = parsedUrl.pathname + parsedUrl.search;\n        opts.timeout = opts.handshakeTimeout;\n        if (opts.perMessageDeflate) {\n            perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n            opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n                [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n            });\n        }\n        if (protocols.length) {\n            for (const protocol of protocols){\n                if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                    throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n                }\n                protocolSet.add(protocol);\n            }\n            opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n        }\n        if (opts.origin) {\n            if (opts.protocolVersion < 13) {\n                opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n            } else {\n                opts.headers.Origin = opts.origin;\n            }\n        }\n        if (parsedUrl.username || parsedUrl.password) {\n            opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n        }\n        if (isIpcUrl) {\n            const parts = opts.path.split(\":\");\n            opts.socketPath = parts[0];\n            opts.path = parts[1];\n        }\n        let req;\n        if (opts.followRedirects) {\n            if (websocket._redirects === 0) {\n                websocket._originalIpc = isIpcUrl;\n                websocket._originalSecure = isSecure;\n                websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n                const headers = options && options.headers;\n                //\n                // Shallow copy the user provided options so that headers can be changed\n                // without mutating the original object.\n                //\n                options = {\n                    ...options,\n                    headers: {}\n                };\n                if (headers) {\n                    for (const [key, value] of Object.entries(headers)){\n                        options.headers[key.toLowerCase()] = value;\n                    }\n                }\n            } else if (websocket.listenerCount(\"redirect\") === 0) {\n                const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n                if (!isSameHost || websocket._originalSecure && !isSecure) {\n                    //\n                    // Match curl 7.77.0 behavior and drop the following headers. These\n                    // headers are also dropped when following a redirect to a subdomain.\n                    //\n                    delete opts.headers.authorization;\n                    delete opts.headers.cookie;\n                    if (!isSameHost) delete opts.headers.host;\n                    opts.auth = undefined;\n                }\n            }\n            //\n            // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n            // If the `Authorization` header is set, then there is nothing to do as it\n            // will take precedence.\n            //\n            if (opts.auth && !options.headers.authorization) {\n                options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n            }\n            req = websocket._req = request(opts);\n            if (websocket._redirects) {\n                //\n                // Unlike what is done for the `'upgrade'` event, no early exit is\n                // triggered here if the user calls `websocket.close()` or\n                // `websocket.terminate()` from a listener of the `'redirect'` event. This\n                // is because the user can also call `request.destroy()` with an error\n                // before calling `websocket.close()` or `websocket.terminate()` and this\n                // would result in an error being emitted on the `request` object with no\n                // `'error'` event listeners attached.\n                //\n                websocket.emit(\"redirect\", websocket.url, req);\n            }\n        } else {\n            req = websocket._req = request(opts);\n        }\n        if (opts.timeout) {\n            req.on(\"timeout\", ()=>{\n                abortHandshake(websocket, req, \"Opening handshake has timed out\");\n            });\n        }\n        req.on(\"error\", (err)=>{\n            if (req === null || req[kAborted]) return;\n            req = websocket._req = null;\n            emitErrorAndClose(websocket, err);\n        });\n        req.on(\"response\", (res)=>{\n            const location = res.headers.location;\n            const statusCode = res.statusCode;\n            if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n                if (++websocket._redirects > opts.maxRedirects) {\n                    abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                    return;\n                }\n                req.abort();\n                let addr;\n                try {\n                    addr = new URL1(location, address);\n                } catch (e) {\n                    const err = new SyntaxError(`Invalid URL: ${location}`);\n                    emitErrorAndClose(websocket, err);\n                    return;\n                }\n                initAsClient(websocket, addr, protocols, options);\n            } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n                abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n            }\n        });\n        req.on(\"upgrade\", (res, socket, head)=>{\n            websocket.emit(\"upgrade\", res);\n            //\n            // The user may have closed the connection from a listener of the\n            // `'upgrade'` event.\n            //\n            if (websocket.readyState !== WebSocket.CONNECTING) return;\n            req = websocket._req = null;\n            const upgrade = res.headers.upgrade;\n            if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n                abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n                return;\n            }\n            const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n            if (res.headers[\"sec-websocket-accept\"] !== digest) {\n                abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n                return;\n            }\n            const serverProt = res.headers[\"sec-websocket-protocol\"];\n            let protError;\n            if (serverProt !== undefined) {\n                if (!protocolSet.size) {\n                    protError = \"Server sent a subprotocol but none was requested\";\n                } else if (!protocolSet.has(serverProt)) {\n                    protError = \"Server sent an invalid subprotocol\";\n                }\n            } else if (protocolSet.size) {\n                protError = \"Server sent no subprotocol\";\n            }\n            if (protError) {\n                abortHandshake(websocket, socket, protError);\n                return;\n            }\n            if (serverProt) websocket._protocol = serverProt;\n            const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n            if (secWebSocketExtensions !== undefined) {\n                if (!perMessageDeflate) {\n                    const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                let extensions;\n                try {\n                    extensions = parse(secWebSocketExtensions);\n                } catch (err) {\n                    const message = \"Invalid Sec-WebSocket-Extensions header\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                const extensionNames = Object.keys(extensions);\n                if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                    const message = \"Server indicated an extension that was not requested\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                try {\n                    perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n                } catch (err) {\n                    const message = \"Invalid Sec-WebSocket-Extensions header\";\n                    abortHandshake(websocket, socket, message);\n                    return;\n                }\n                websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n            }\n            websocket.setSocket(socket, head, {\n                allowSynchronousEvents: opts.allowSynchronousEvents,\n                generateMask: opts.generateMask,\n                maxPayload: opts.maxPayload,\n                skipUTF8Validation: opts.skipUTF8Validation\n            });\n        });\n        if (opts.finishRequest) {\n            opts.finishRequest(req, websocket);\n        } else {\n            req.end();\n        }\n    }\n    /**\n\t * Emit the `'error'` and `'close'` events.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {Error} The error to emit\n\t * @private\n\t */ function emitErrorAndClose(websocket, err) {\n        websocket._readyState = WebSocket.CLOSING;\n        //\n        // The following assignment is practically useless and is done only for\n        // consistency.\n        //\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n        websocket.emitClose();\n    }\n    /**\n\t * Create a `net.Socket` and initiate a connection.\n\t *\n\t * @param {Object} options Connection options\n\t * @return {net.Socket} The newly created socket used to start the connection\n\t * @private\n\t */ function netConnect(options) {\n        options.path = options.socketPath;\n        return net.connect(options);\n    }\n    /**\n\t * Create a `tls.TLSSocket` and initiate a connection.\n\t *\n\t * @param {Object} options Connection options\n\t * @return {tls.TLSSocket} The newly created socket used to start the connection\n\t * @private\n\t */ function tlsConnect(options) {\n        options.path = undefined;\n        if (!options.servername && options.servername !== \"\") {\n            options.servername = net.isIP(options.host) ? \"\" : options.host;\n        }\n        return tls.connect(options);\n    }\n    /**\n\t * Abort the handshake and emit an error.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n\t *     abort or the socket to destroy\n\t * @param {String} message The error message\n\t * @private\n\t */ function abortHandshake(websocket, stream, message) {\n        websocket._readyState = WebSocket.CLOSING;\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshake);\n        if (stream.setHeader) {\n            stream[kAborted] = true;\n            stream.abort();\n            if (stream.socket && !stream.socket.destroyed) {\n                //\n                // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n                // called after the request completed. See\n                // https://github.com/websockets/ws/issues/1869.\n                //\n                stream.socket.destroy();\n            }\n            process.nextTick(emitErrorAndClose, websocket, err);\n        } else {\n            stream.destroy(err);\n            stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n            stream.once(\"close\", websocket.emitClose.bind(websocket));\n        }\n    }\n    /**\n\t * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n\t * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @param {*} [data] The data to send\n\t * @param {Function} [cb] Callback\n\t * @private\n\t */ function sendAfterClose(websocket, data, cb) {\n        if (data) {\n            const length = isBlob(data) ? data.size : toBuffer(data).length;\n            //\n            // The `_bufferedAmount` property is used only when the peer is a client and\n            // the opening handshake fails. Under these circumstances, in fact, the\n            // `setSocket()` method is not called, so the `_socket` and `_sender`\n            // properties are set to `null`.\n            //\n            if (websocket._socket) websocket._sender._bufferedBytes += length;\n            else websocket._bufferedAmount += length;\n        }\n        if (cb) {\n            const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n            process.nextTick(cb, err);\n        }\n    }\n    /**\n\t * The listener of the `Receiver` `'conclude'` event.\n\t *\n\t * @param {Number} code The status code\n\t * @param {Buffer} reason The reason for closing\n\t * @private\n\t */ function receiverOnConclude(code, reason) {\n        const websocket = this[kWebSocket];\n        websocket._closeFrameReceived = true;\n        websocket._closeMessage = reason;\n        websocket._closeCode = code;\n        if (websocket._socket[kWebSocket] === undefined) return;\n        websocket._socket.removeListener(\"data\", socketOnData);\n        process.nextTick(resume, websocket._socket);\n        if (code === 1005) websocket.close();\n        else websocket.close(code, reason);\n    }\n    /**\n\t * The listener of the `Receiver` `'drain'` event.\n\t *\n\t * @private\n\t */ function receiverOnDrain() {\n        const websocket = this[kWebSocket];\n        if (!websocket.isPaused) websocket._socket.resume();\n    }\n    /**\n\t * The listener of the `Receiver` `'error'` event.\n\t *\n\t * @param {(RangeError|Error)} err The emitted error\n\t * @private\n\t */ function receiverOnError(err) {\n        const websocket = this[kWebSocket];\n        if (websocket._socket[kWebSocket] !== undefined) {\n            websocket._socket.removeListener(\"data\", socketOnData);\n            //\n            // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n            // https://github.com/websockets/ws/issues/1940.\n            //\n            process.nextTick(resume, websocket._socket);\n            websocket.close(err[kStatusCode]);\n        }\n        if (!websocket._errorEmitted) {\n            websocket._errorEmitted = true;\n            websocket.emit(\"error\", err);\n        }\n    }\n    /**\n\t * The listener of the `Receiver` `'finish'` event.\n\t *\n\t * @private\n\t */ function receiverOnFinish() {\n        this[kWebSocket].emitClose();\n    }\n    /**\n\t * The listener of the `Receiver` `'message'` event.\n\t *\n\t * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n\t * @param {Boolean} isBinary Specifies whether the message is binary or not\n\t * @private\n\t */ function receiverOnMessage(data, isBinary) {\n        this[kWebSocket].emit(\"message\", data, isBinary);\n    }\n    /**\n\t * The listener of the `Receiver` `'ping'` event.\n\t *\n\t * @param {Buffer} data The data included in the ping frame\n\t * @private\n\t */ function receiverOnPing(data) {\n        const websocket = this[kWebSocket];\n        if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n        websocket.emit(\"ping\", data);\n    }\n    /**\n\t * The listener of the `Receiver` `'pong'` event.\n\t *\n\t * @param {Buffer} data The data included in the pong frame\n\t * @private\n\t */ function receiverOnPong(data) {\n        this[kWebSocket].emit(\"pong\", data);\n    }\n    /**\n\t * Resume a readable stream\n\t *\n\t * @param {Readable} stream The readable stream\n\t * @private\n\t */ function resume(stream) {\n        stream.resume();\n    }\n    /**\n\t * The `Sender` error event handler.\n\t *\n\t * @param {Error} The error\n\t * @private\n\t */ function senderOnError(err) {\n        const websocket = this[kWebSocket];\n        if (websocket.readyState === WebSocket.CLOSED) return;\n        if (websocket.readyState === WebSocket.OPEN) {\n            websocket._readyState = WebSocket.CLOSING;\n            setCloseTimer(websocket);\n        }\n        //\n        // `socket.end()` is used instead of `socket.destroy()` to allow the other\n        // peer to finish sending queued data. There is no need to set a timer here\n        // because `CLOSING` means that it is already set or not needed.\n        //\n        this._socket.end();\n        if (!websocket._errorEmitted) {\n            websocket._errorEmitted = true;\n            websocket.emit(\"error\", err);\n        }\n    }\n    /**\n\t * Set a timer to destroy the underlying raw socket of a WebSocket.\n\t *\n\t * @param {WebSocket} websocket The WebSocket instance\n\t * @private\n\t */ function setCloseTimer(websocket) {\n        websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);\n    }\n    /**\n\t * The listener of the socket `'close'` event.\n\t *\n\t * @private\n\t */ function socketOnClose() {\n        const websocket = this[kWebSocket];\n        this.removeListener(\"close\", socketOnClose);\n        this.removeListener(\"data\", socketOnData);\n        this.removeListener(\"end\", socketOnEnd);\n        websocket._readyState = WebSocket.CLOSING;\n        let chunk;\n        //\n        // The close frame might not have been received or the `'end'` event emitted,\n        // for example, if the socket was destroyed due to an error. Ensure that the\n        // `receiver` stream is closed after writing any remaining buffered data to\n        // it. If the readable side of the socket is in flowing mode then there is no\n        // buffered data as everything has been already written and `readable.read()`\n        // will return `null`. If instead, the socket is paused, any possible buffered\n        // data will be read as a single chunk.\n        //\n        if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n            websocket._receiver.write(chunk);\n        }\n        websocket._receiver.end();\n        this[kWebSocket] = undefined;\n        clearTimeout(websocket._closeTimer);\n        if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n            websocket.emitClose();\n        } else {\n            websocket._receiver.on(\"error\", receiverOnFinish);\n            websocket._receiver.on(\"finish\", receiverOnFinish);\n        }\n    }\n    /**\n\t * The listener of the socket `'data'` event.\n\t *\n\t * @param {Buffer} chunk A chunk of data\n\t * @private\n\t */ function socketOnData(chunk) {\n        if (!this[kWebSocket]._receiver.write(chunk)) {\n            this.pause();\n        }\n    }\n    /**\n\t * The listener of the socket `'end'` event.\n\t *\n\t * @private\n\t */ function socketOnEnd() {\n        const websocket = this[kWebSocket];\n        websocket._readyState = WebSocket.CLOSING;\n        websocket._receiver.end();\n        this.end();\n    }\n    /**\n\t * The listener of the socket `'error'` event.\n\t *\n\t * @private\n\t */ function socketOnError() {\n        const websocket = this[kWebSocket];\n        this.removeListener(\"error\", socketOnError);\n        this.on(\"error\", NOOP);\n        if (websocket) {\n            websocket._readyState = WebSocket.CLOSING;\n            this.destroy();\n        }\n    }\n    return websocket;\n}\nvar websocketExports = requireWebsocket();\nvar WS = /*@__PURE__*/ getDefaultExportFromCjs(websocketExports);\nvar subprotocol;\nvar hasRequiredSubprotocol;\nfunction requireSubprotocol() {\n    if (hasRequiredSubprotocol) return subprotocol;\n    hasRequiredSubprotocol = 1;\n    const { tokenChars } = requireValidation();\n    /**\n\t * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n\t *\n\t * @param {String} header The field value of the header\n\t * @return {Set} The subprotocol names\n\t * @public\n\t */ function parse(header) {\n        const protocols = new Set();\n        let start = -1;\n        let end = -1;\n        let i = 0;\n        for(i; i < header.length; i++){\n            const code = header.charCodeAt(i);\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const protocol = header.slice(start, end);\n                if (protocols.has(protocol)) {\n                    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n                }\n                protocols.add(protocol);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n        if (start === -1 || end !== -1) {\n            throw new SyntaxError(\"Unexpected end of input\");\n        }\n        const protocol = header.slice(start, i);\n        if (protocols.has(protocol)) {\n            throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n        }\n        protocols.add(protocol);\n        return protocols;\n    }\n    subprotocol = {\n        parse\n    };\n    return subprotocol;\n}\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */ var websocketServer;\nvar hasRequiredWebsocketServer;\nfunction requireWebsocketServer() {\n    if (hasRequiredWebsocketServer) return websocketServer;\n    hasRequiredWebsocketServer = 1;\n    const EventEmitter = (events__WEBPACK_IMPORTED_MODULE_4___default());\n    const http = (http__WEBPACK_IMPORTED_MODULE_6___default());\n    const { createHash } = (crypto__WEBPACK_IMPORTED_MODULE_3___default());\n    const extension = requireExtension();\n    const PerMessageDeflate = requirePermessageDeflate();\n    const subprotocol = requireSubprotocol();\n    const WebSocket = requireWebsocket();\n    const { GUID, kWebSocket } = requireConstants();\n    const keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n    const RUNNING = 0;\n    const CLOSING = 1;\n    const CLOSED = 2;\n    /**\n\t * Class representing a WebSocket server.\n\t *\n\t * @extends EventEmitter\n\t */ class WebSocketServer extends EventEmitter {\n        /**\n\t   * Create a `WebSocketServer` instance.\n\t   *\n\t   * @param {Object} options Configuration options\n\t   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n\t   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n\t   *     multiple times in the same tick\n\t   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n\t   *     automatically send a pong in response to a ping\n\t   * @param {Number} [options.backlog=511] The maximum length of the queue of\n\t   *     pending connections\n\t   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n\t   *     track clients\n\t   * @param {Function} [options.handleProtocols] A hook to handle protocols\n\t   * @param {String} [options.host] The hostname where to bind the server\n\t   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n\t   *     size\n\t   * @param {Boolean} [options.noServer=false] Enable no server mode\n\t   * @param {String} [options.path] Accept only connections matching this path\n\t   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n\t   *     permessage-deflate\n\t   * @param {Number} [options.port] The port where to bind the server\n\t   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n\t   *     server to use\n\t   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n\t   *     not to skip UTF-8 validation for text and close messages\n\t   * @param {Function} [options.verifyClient] A hook to reject connections\n\t   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n\t   *     class to use. It must be the `WebSocket` class or class that extends it\n\t   * @param {Function} [callback] A listener for the `listening` event\n\t   */ constructor(options, callback){\n            super();\n            options = {\n                allowSynchronousEvents: true,\n                autoPong: true,\n                maxPayload: 100 * 1024 * 1024,\n                skipUTF8Validation: false,\n                perMessageDeflate: false,\n                handleProtocols: null,\n                clientTracking: true,\n                verifyClient: null,\n                noServer: false,\n                backlog: null,\n                server: null,\n                host: null,\n                path: null,\n                port: null,\n                WebSocket,\n                ...options\n            };\n            if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n                throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n            }\n            if (options.port != null) {\n                this._server = http.createServer((req, res)=>{\n                    const body = http.STATUS_CODES[426];\n                    res.writeHead(426, {\n                        \"Content-Length\": body.length,\n                        \"Content-Type\": \"text/plain\"\n                    });\n                    res.end(body);\n                });\n                this._server.listen(options.port, options.host, options.backlog, callback);\n            } else if (options.server) {\n                this._server = options.server;\n            }\n            if (this._server) {\n                const emitConnection = this.emit.bind(this, \"connection\");\n                this._removeListeners = addListeners(this._server, {\n                    listening: this.emit.bind(this, \"listening\"),\n                    error: this.emit.bind(this, \"error\"),\n                    upgrade: (req, socket, head)=>{\n                        this.handleUpgrade(req, socket, head, emitConnection);\n                    }\n                });\n            }\n            if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n            if (options.clientTracking) {\n                this.clients = new Set();\n                this._shouldEmitClose = false;\n            }\n            this.options = options;\n            this._state = RUNNING;\n        }\n        /**\n\t   * Returns the bound address, the address family name, and port of the server\n\t   * as reported by the operating system if listening on an IP socket.\n\t   * If the server is listening on a pipe or UNIX domain socket, the name is\n\t   * returned as a string.\n\t   *\n\t   * @return {(Object|String|null)} The address of the server\n\t   * @public\n\t   */ address() {\n            if (this.options.noServer) {\n                throw new Error('The server is operating in \"noServer\" mode');\n            }\n            if (!this._server) return null;\n            return this._server.address();\n        }\n        /**\n\t   * Stop the server from accepting new connections and emit the `'close'` event\n\t   * when all existing connections are closed.\n\t   *\n\t   * @param {Function} [cb] A one-time listener for the `'close'` event\n\t   * @public\n\t   */ close(cb) {\n            if (this._state === CLOSED) {\n                if (cb) {\n                    this.once(\"close\", ()=>{\n                        cb(new Error(\"The server is not running\"));\n                    });\n                }\n                process.nextTick(emitClose, this);\n                return;\n            }\n            if (cb) this.once(\"close\", cb);\n            if (this._state === CLOSING) return;\n            this._state = CLOSING;\n            if (this.options.noServer || this.options.server) {\n                if (this._server) {\n                    this._removeListeners();\n                    this._removeListeners = this._server = null;\n                }\n                if (this.clients) {\n                    if (!this.clients.size) {\n                        process.nextTick(emitClose, this);\n                    } else {\n                        this._shouldEmitClose = true;\n                    }\n                } else {\n                    process.nextTick(emitClose, this);\n                }\n            } else {\n                const server = this._server;\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n                //\n                // The HTTP/S server was created internally. Close it, and rely on its\n                // `'close'` event.\n                //\n                server.close(()=>{\n                    emitClose(this);\n                });\n            }\n        }\n        /**\n\t   * See if a given request should be handled by this server instance.\n\t   *\n\t   * @param {http.IncomingMessage} req Request object to inspect\n\t   * @return {Boolean} `true` if the request is valid, else `false`\n\t   * @public\n\t   */ shouldHandle(req) {\n            if (this.options.path) {\n                const index = req.url.indexOf(\"?\");\n                const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n                if (pathname !== this.options.path) return false;\n            }\n            return true;\n        }\n        /**\n\t   * Handle a HTTP Upgrade request.\n\t   *\n\t   * @param {http.IncomingMessage} req The request object\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Function} cb Callback\n\t   * @public\n\t   */ handleUpgrade(req, socket, head, cb) {\n            socket.on(\"error\", socketOnError);\n            const key = req.headers[\"sec-websocket-key\"];\n            const upgrade = req.headers.upgrade;\n            const version = +req.headers[\"sec-websocket-version\"];\n            if (req.method !== \"GET\") {\n                const message = \"Invalid HTTP method\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n                return;\n            }\n            if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n                const message = \"Invalid Upgrade header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (key === undefined || !keyRegex.test(key)) {\n                const message = \"Missing or invalid Sec-WebSocket-Key header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (version !== 8 && version !== 13) {\n                const message = \"Missing or invalid Sec-WebSocket-Version header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n            if (!this.shouldHandle(req)) {\n                abortHandshake(socket, 400);\n                return;\n            }\n            const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n            let protocols = new Set();\n            if (secWebSocketProtocol !== undefined) {\n                try {\n                    protocols = subprotocol.parse(secWebSocketProtocol);\n                } catch (err) {\n                    const message = \"Invalid Sec-WebSocket-Protocol header\";\n                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                    return;\n                }\n            }\n            const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n            const extensions = {};\n            if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n                const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n                try {\n                    const offers = extension.parse(secWebSocketExtensions);\n                    if (offers[PerMessageDeflate.extensionName]) {\n                        perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                        extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                    }\n                } catch (err) {\n                    const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                    return;\n                }\n            }\n            //\n            // Optionally call external client verification handler.\n            //\n            if (this.options.verifyClient) {\n                const info = {\n                    origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                    secure: !!(req.socket.authorized || req.socket.encrypted),\n                    req\n                };\n                if (this.options.verifyClient.length === 2) {\n                    this.options.verifyClient(info, (verified, code, message, headers)=>{\n                        if (!verified) {\n                            return abortHandshake(socket, code || 401, message, headers);\n                        }\n                        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                    });\n                    return;\n                }\n                if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n            }\n            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        }\n        /**\n\t   * Upgrade the connection to WebSocket.\n\t   *\n\t   * @param {Object} extensions The accepted extensions\n\t   * @param {String} key The value of the `Sec-WebSocket-Key` header\n\t   * @param {Set} protocols The subprotocols\n\t   * @param {http.IncomingMessage} req The request object\n\t   * @param {Duplex} socket The network socket between the server and client\n\t   * @param {Buffer} head The first packet of the upgraded stream\n\t   * @param {Function} cb Callback\n\t   * @throws {Error} If called more than once with the same socket\n\t   * @private\n\t   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n            //\n            // Destroy the socket if the client has already sent a FIN packet.\n            //\n            if (!socket.readable || !socket.writable) return socket.destroy();\n            if (socket[kWebSocket]) {\n                throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n            }\n            if (this._state > RUNNING) return abortHandshake(socket, 503);\n            const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n            const headers = [\n                \"HTTP/1.1 101 Switching Protocols\",\n                \"Upgrade: websocket\",\n                \"Connection: Upgrade\",\n                `Sec-WebSocket-Accept: ${digest}`\n            ];\n            const ws = new this.options.WebSocket(null, undefined, this.options);\n            if (protocols.size) {\n                //\n                // Optionally call external protocol selection handler.\n                //\n                const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n                if (protocol) {\n                    headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                    ws._protocol = protocol;\n                }\n            }\n            if (extensions[PerMessageDeflate.extensionName]) {\n                const params = extensions[PerMessageDeflate.extensionName].params;\n                const value = extension.format({\n                    [PerMessageDeflate.extensionName]: [\n                        params\n                    ]\n                });\n                headers.push(`Sec-WebSocket-Extensions: ${value}`);\n                ws._extensions = extensions;\n            }\n            //\n            // Allow external modification/inspection of handshake headers.\n            //\n            this.emit(\"headers\", headers, req);\n            socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n            socket.removeListener(\"error\", socketOnError);\n            ws.setSocket(socket, head, {\n                allowSynchronousEvents: this.options.allowSynchronousEvents,\n                maxPayload: this.options.maxPayload,\n                skipUTF8Validation: this.options.skipUTF8Validation\n            });\n            if (this.clients) {\n                this.clients.add(ws);\n                ws.on(\"close\", ()=>{\n                    this.clients.delete(ws);\n                    if (this._shouldEmitClose && !this.clients.size) {\n                        process.nextTick(emitClose, this);\n                    }\n                });\n            }\n            cb(ws, req);\n        }\n    }\n    websocketServer = WebSocketServer;\n    /**\n\t * Add event listeners on an `EventEmitter` using a map of <event, listener>\n\t * pairs.\n\t *\n\t * @param {EventEmitter} server The event emitter\n\t * @param {Object.<String, Function>} map The listeners to add\n\t * @return {Function} A function that will remove the added listeners when\n\t *     called\n\t * @private\n\t */ function addListeners(server, map) {\n        for (const event of Object.keys(map))server.on(event, map[event]);\n        return function removeListeners() {\n            for (const event of Object.keys(map)){\n                server.removeListener(event, map[event]);\n            }\n        };\n    }\n    /**\n\t * Emit a `'close'` event on an `EventEmitter`.\n\t *\n\t * @param {EventEmitter} server The event emitter\n\t * @private\n\t */ function emitClose(server) {\n        server._state = CLOSED;\n        server.emit(\"close\");\n    }\n    /**\n\t * Handle socket errors.\n\t *\n\t * @private\n\t */ function socketOnError() {\n        this.destroy();\n    }\n    /**\n\t * Close the connection when preconditions are not fulfilled.\n\t *\n\t * @param {Duplex} socket The socket of the upgrade request\n\t * @param {Number} code The HTTP response status code\n\t * @param {String} [message] The HTTP response body\n\t * @param {Object} [headers] Additional HTTP response headers\n\t * @private\n\t */ function abortHandshake(socket, code, message, headers) {\n        //\n        // The socket is writable unless the user destroyed or ended it before calling\n        // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n        // error. Handling this does not make much sense as the worst that can happen\n        // is that some of the data written by the user might be discarded due to the\n        // call to `socket.end()` below, which triggers an `'error'` event that in\n        // turn causes the socket to be destroyed.\n        //\n        message = message || http.STATUS_CODES[code];\n        headers = {\n            Connection: \"close\",\n            \"Content-Type\": \"text/html\",\n            \"Content-Length\": Buffer.byteLength(message),\n            ...headers\n        };\n        socket.once(\"finish\", socket.destroy);\n        socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n    }\n    /**\n\t * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n\t * one listener for it, otherwise call `abortHandshake()`.\n\t *\n\t * @param {WebSocketServer} server The WebSocket server\n\t * @param {http.IncomingMessage} req The request object\n\t * @param {Duplex} socket The socket of the upgrade request\n\t * @param {Number} code The HTTP response status code\n\t * @param {String} message The HTTP response body\n\t * @private\n\t */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n        if (server.listenerCount(\"wsClientError\")) {\n            const err = new Error(message);\n            Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n            server.emit(\"wsClientError\", err, socket, req);\n        } else {\n            abortHandshake(socket, code, message);\n        }\n    }\n    return websocketServer;\n}\nrequireWebsocketServer();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar WebSocket = WS;\nvar sendMessage = function(socket, message) {\n    return new Promise(function(resolve, reject) {\n        socket.send(message, function(error) {\n            if (error) {\n                reject(error);\n            } else {\n                resolve();\n            }\n        });\n    });\n};\nfunction getWebsocket(settings) {\n    return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    if (!(settings.policy != undefined)) return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        settings.policy(settings)\n                    ];\n                case 1:\n                    settings = _a.sent();\n                    _a.label = 2;\n                case 2:\n                    return [\n                        2 /*return*/ ,\n                        new WebSocket(settings.uri, settings.protocols, {\n                            headers: settings.headers\n                        })\n                    ];\n            }\n        });\n    });\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar validationSuccess = function(message) {\n    return {\n        success: true,\n        message: message\n    };\n};\nvar validationError = function(error) {\n    return {\n        success: false,\n        error: error\n    };\n};\nvar isValidatorSuccess = function(result) {\n    return result.success;\n};\nvar WebSocketClient = /** @class */ function() {\n    function WebSocketClient(settings, handler) {\n        var _this = this;\n        this.closedPromise = undefined;\n        this.messageQueue = [];\n        this.receiverQueue = [];\n        this.done = false;\n        this.validate = handler.validate;\n        this.serialize = handler.serialize;\n        this.connectedPromise = new Promise(function(resolve, reject) {\n            return __awaiter(_this, void 0, void 0, function() {\n                var _a;\n                var _this = this;\n                return __generator(this, function(_b) {\n                    switch(_b.label){\n                        case 0:\n                            _a = this;\n                            return [\n                                4 /*yield*/ ,\n                                getWebsocket(settings)\n                            ];\n                        case 1:\n                            _a.socket = _b.sent();\n                            this.socket.onopen = function() {\n                                _this.socket.onmessage = _this.getMessageHandler();\n                                _this.closedPromise = new Promise(function(resolve) {\n                                    _this.socket.onclose = _this.getClosedHandler(resolve);\n                                });\n                                _this.socket.onerror = _this.handleError;\n                                resolve();\n                            };\n                            this.socket.onerror = function(event) {\n                                _this.error = event.error;\n                                reject(event);\n                            };\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        });\n    }\n    WebSocketClient.prototype.handleError = function(event) {\n        this.error = event.error;\n        while(this.receiverQueue.length > 0){\n            var _a = __read(this.receiverQueue.shift(), 2);\n            _a[0];\n            var reject = _a[1];\n            reject(event.error);\n        }\n    };\n    WebSocketClient.prototype.getClosedHandler = function(closeResolve) {\n        var _this = this;\n        return function(_) {\n            _this.done = true;\n            while(_this.receiverQueue.length > 0){\n                var _a = __read(_this.receiverQueue.shift(), 2), resolve = _a[0], reject = _a[1];\n                if (_this.error) {\n                    reject(_this.error);\n                } else {\n                    resolve({\n                        value: undefined,\n                        done: true\n                    });\n                }\n            }\n            closeResolve();\n        };\n    };\n    WebSocketClient.prototype.getMessageHandler = function() {\n        var self = this;\n        return function(event) {\n            var result = self.validate(event);\n            if (isValidatorSuccess(result)) {\n                var message = result.message;\n                if (self.receiverQueue.length > 0) {\n                    var _a = __read(self.receiverQueue.shift(), 2), resolve = _a[0];\n                    _a[1];\n                    resolve({\n                        value: message,\n                        done: false\n                    });\n                } else {\n                    self.messageQueue.push(message);\n                }\n            } else {\n                self.error = result.error;\n                self.socket.close(1000, \"Unexpected message received\");\n            }\n        };\n    };\n    WebSocketClient.prototype[Symbol.asyncIterator] = function() {\n        var _this = this;\n        return {\n            next: function() {\n                if (_this.error) {\n                    return Promise.reject(_this.error);\n                } else if (_this.done) {\n                    return Promise.resolve({\n                        value: undefined,\n                        done: true\n                    });\n                } else if (_this.messageQueue.length > 0) {\n                    var message = _this.messageQueue.shift();\n                    return Promise.resolve({\n                        value: message,\n                        done: false\n                    });\n                } else {\n                    return new Promise(function(resolve, reject) {\n                        _this.receiverQueue.push([\n                            resolve,\n                            reject\n                        ]);\n                    });\n                }\n            }\n        };\n    };\n    WebSocketClient.prototype.send = function(message) {\n        return __awaiter(this, void 0, void 0, function() {\n            var serialized;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.connectedPromise\n                        ];\n                    case 1:\n                        _a.sent();\n                        if (this.error) {\n                            throw this.error;\n                        }\n                        serialized = this.serialize(message);\n                        return [\n                            2 /*return*/ ,\n                            sendMessage(this.socket, serialized)\n                        ];\n                }\n            });\n        });\n    };\n    WebSocketClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.connectedPromise\n                        ];\n                    case 1:\n                        _a.sent();\n                        if (this.done) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        }\n                        this.socket.close();\n                        return [\n                            4 /*yield*/ ,\n                            this.closedPromise\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return WebSocketClient;\n}();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isKeyCredential(credential) {\n    return typeof credential === \"object\" && credential !== null && \"key\" in credential && typeof credential.key === \"string\";\n}\nfunction isTokenCredential(credential) {\n    return typeof credential === \"object\" && credential !== null && \"getToken\" in credential && typeof credential.getToken === \"function\";\n}\nvar isCredential = function(credential) {\n    return isKeyCredential(credential) || isTokenCredential(credential);\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar isRTOpenAIOptions = function(options) {\n    return typeof options === \"object\" && options !== null && \"model\" in options && typeof options.model === \"string\";\n};\nvar isRTAzureOpenAIOptions = function(options) {\n    return typeof options === \"object\" && options !== null && \"deployment\" in options && typeof options.deployment === \"string\";\n};\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction getUserAgent() {\n    return \"ms-rtclient/0.5.0\";\n}\nfunction openAISettings(credential, options) {\n    var uri = new URL(\"wss://api.openai.com/v1/realtime\");\n    uri.searchParams.set(\"model\", options.model);\n    return {\n        uri: uri,\n        headers: {\n            Authorization: \"Bearer \".concat(credential.key),\n            \"openai-beta\": \"realtime=v1\",\n            \"User-Agent\": \"openai-node\"\n        }\n    };\n}\nfunction azureOpenAISettings(uri, credential, options) {\n    var _this = this;\n    var _a;\n    var requestId = (_a = options.requestId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n    var scopes = [\n        \"https://cognitiveservices.azure.com/.default\"\n    ];\n    uri.searchParams.set(\"api-version\", \"2024-10-01-preview\");\n    uri.searchParams.set(\"deployment\", options.deployment);\n    uri.pathname = \"openai/realtime\";\n    return {\n        uri: uri,\n        headers: {\n            \"User-Agent\": getUserAgent(),\n            \"x-ms-client-request-id\": requestId\n        },\n        policy: function(settings) {\n            return __awaiter(_this, void 0, void 0, function() {\n                var token;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (!isKeyCredential(credential)) return [\n                                3 /*break*/ ,\n                                1\n                            ];\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                \"api-key\": credential.key\n                            });\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        case 1:\n                            return [\n                                4 /*yield*/ ,\n                                credential.getToken(scopes)\n                            ];\n                        case 2:\n                            token = _a.sent();\n                            settings.headers = __assign(__assign({}, settings.headers), {\n                                Authorization: \"Bearer \".concat(token.token),\n                                requestId: requestId\n                            });\n                            _a.label = 3;\n                        case 3:\n                            return [\n                                2 /*return*/ ,\n                                settings\n                            ];\n                    }\n                });\n            });\n        }\n    };\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar MessageQueue = /** @class */ function() {\n    function MessageQueue(receiveDelegate) {\n        this.receiveDelegate = receiveDelegate;\n        this.messages = [];\n        this.waitingReceivers = [];\n        this.isPolling = false;\n        this.pollPromise = null;\n    }\n    MessageQueue.prototype.pushBack = function(message) {\n        this.messages.push(message);\n    };\n    MessageQueue.prototype.findAndRemove = function(predicate) {\n        var index = this.messages.findIndex(predicate);\n        if (index === -1) {\n            return null;\n        }\n        return this.messages.splice(index, 1)[0];\n    };\n    MessageQueue.prototype.pollReceive = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                if (this.isPolling) {\n                    return [\n                        2 /*return*/ \n                    ];\n                }\n                this.isPolling = true;\n                this.pollPromise = this.doPollReceive();\n                return [\n                    2 /*return*/ ,\n                    this.pollPromise\n                ];\n            });\n        });\n    };\n    MessageQueue.prototype.doPollReceive = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message, error_1;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        _a.trys.push([\n                            0,\n                            4,\n                            5,\n                            6\n                        ]);\n                        _a.label = 1;\n                    case 1:\n                        if (!this.isPolling) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.receiveDelegate()\n                        ];\n                    case 2:\n                        message = _a.sent();\n                        if (message === null) {\n                            this.notifyEndOfStream();\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        }\n                        this.notifyReceiver(message);\n                        if (this.waitingReceivers.length === 0) {\n                            return [\n                                3 /*break*/ ,\n                                3\n                            ];\n                        }\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 3:\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        error_1 = _a.sent();\n                        this.notifyError(error_1);\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 5:\n                        this.isPolling = false;\n                        this.pollPromise = null;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    MessageQueue.prototype.notifyError = function(error) {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 3);\n            _a[0];\n            var _b = __read(_a[1], 2);\n            _b[0];\n            var reject = _b[1];\n            _a[2];\n            reject(error);\n        }\n    };\n    MessageQueue.prototype.notifyEndOfStream = function() {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 3);\n            _a[0];\n            var _b = __read(_a[1], 2), resolve = _b[0];\n            _b[1];\n            _a[2];\n            resolve(null);\n        }\n    };\n    MessageQueue.prototype.notifyReceiver = function(message) {\n        var index = this.waitingReceivers.findIndex(function(_a) {\n            var _b = __read(_a, 3), predicate = _b[0], _c = __read(_b[1], 2);\n            _c[0];\n            _c[1];\n            _b[2];\n            return predicate(message);\n        });\n        if (index === -1) {\n            this.pushBack(message);\n            return;\n        }\n        var _a = __read(this.waitingReceivers.splice(index, 1)[0], 3);\n        _a[0];\n        var _b = __read(_a[1], 2), resolve = _b[0];\n        _b[1];\n        _a[2];\n        resolve(message);\n    };\n    MessageQueue.prototype.queuedMessageCount = function() {\n        return this.messages.length;\n    };\n    MessageQueue.prototype.receive = function(predicate, abort) {\n        var _this = this;\n        var foundMessage = this.findAndRemove(predicate);\n        if (foundMessage !== null) {\n            return Promise.resolve(foundMessage);\n        }\n        return new Promise(function(resolve, reject) {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            this.waitingReceivers.push([\n                                predicate,\n                                [\n                                    resolve,\n                                    reject\n                                ],\n                                abort || new AbortController()\n                            ]);\n                            return [\n                                4 /*yield*/ ,\n                                this.pollReceive()\n                            ];\n                        case 1:\n                            _a.sent();\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        });\n    };\n    return MessageQueue;\n}();\nvar MessageQueueWithError = /** @class */ function(_super) {\n    __extends(MessageQueueWithError, _super);\n    function MessageQueueWithError(receiveDelegate, errorPredicate) {\n        var _this = _super.call(this, receiveDelegate) || this;\n        _this.errorPredicate = errorPredicate;\n        _this.error = undefined;\n        return _this;\n    }\n    MessageQueueWithError.prototype.notifyErrorMessage = function(message) {\n        while(this.waitingReceivers.length > 0){\n            var _a = __read(this.waitingReceivers.shift(), 2);\n            _a[0];\n            var _b = __read(_a[1], 2), resolve = _b[0];\n            _b[1];\n            resolve(message);\n        }\n    };\n    MessageQueueWithError.prototype.notifyReceiver = function(message) {\n        if (this.errorPredicate(message)) {\n            this.error = message;\n            this.notifyErrorMessage(message);\n            return;\n        }\n        var index = this.waitingReceivers.findIndex(function(_a) {\n            var _b = __read(_a, 3), predicate = _b[0], _c = __read(_b[1], 2);\n            _c[0];\n            _c[1];\n            _b[2];\n            return predicate(message);\n        });\n        if (index === -1) {\n            this.pushBack(message);\n            return;\n        }\n        var _a = __read(this.waitingReceivers.splice(index, 1)[0], 3);\n        _a[0];\n        var _b = __read(_a[1], 2), resolve = _b[0];\n        _b[1];\n        _a[2];\n        resolve(message);\n    };\n    MessageQueueWithError.prototype.receive = function(predicate) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (this.error !== undefined) {\n                            return [\n                                2 /*return*/ ,\n                                this.error\n                            ];\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            _super.prototype.receive.call(this, function(message) {\n                                return predicate(message) || _this.errorPredicate(message);\n                            })\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            message\n                        ];\n                }\n            });\n        });\n    };\n    return MessageQueueWithError;\n}(MessageQueue);\nvar SharedEndQueue = /** @class */ function() {\n    function SharedEndQueue(receiveDelegate, errorPredicate, endPredicate) {\n        this.receiveDelegate = receiveDelegate;\n        this.errorPredicate = errorPredicate;\n        this.endPredicate = endPredicate;\n        this.queue = [];\n        this.lock = Promise.resolve();\n    }\n    SharedEndQueue.prototype.receive = function(predicate) {\n        return __awaiter(this, void 0, void 0, function() {\n            var release, i, message, message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.acquireLock()\n                        ];\n                    case 1:\n                        release = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([\n                            2,\n                            ,\n                            6,\n                            7\n                        ]);\n                        for(i = 0; i < this.queue.length; i++){\n                            message = this.queue[i];\n                            if (predicate(message)) {\n                                this.queue.splice(i, 1);\n                                return [\n                                    2 /*return*/ ,\n                                    message\n                                ];\n                            } else if (this.endPredicate(message)) {\n                                return [\n                                    2 /*return*/ ,\n                                    message\n                                ];\n                            }\n                        }\n                        _a.label = 3;\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            this.receiveDelegate()\n                        ];\n                    case 4:\n                        message = _a.sent();\n                        if (message === null || this.errorPredicate(message) || predicate(message)) {\n                            return [\n                                2 /*return*/ ,\n                                message\n                            ];\n                        }\n                        if (this.endPredicate(message)) {\n                            this.queue.push(message);\n                            return [\n                                2 /*return*/ ,\n                                message\n                            ];\n                        }\n                        this.queue.push(message);\n                        return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                    case 5:\n                        return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                    case 6:\n                        release();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    SharedEndQueue.prototype.acquireLock = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var release, newLock, oldLock;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        newLock = new Promise(function(resolve) {\n                            release = resolve;\n                        });\n                        oldLock = this.lock;\n                        this.lock = newLock;\n                        return [\n                            4 /*yield*/ ,\n                            oldLock\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            release\n                        ];\n                }\n            });\n        });\n    };\n    return SharedEndQueue;\n}();\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nfunction getRandomValues(array) {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n        return crypto.getRandomValues(array);\n    } else if (false) {} else {\n        throw new Error(\"No secure random number generator available.\");\n    }\n}\nfunction generateId(prefix, length) {\n    var array = new Uint8Array(length);\n    getRandomValues(array);\n    var base64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array), false))).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n    return \"\".concat(prefix, \"-\").concat(base64).slice(0, length);\n}\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar LowLevelRTClient = /** @class */ function() {\n    function LowLevelRTClient(uriOrCredential, credentialOrOptions, options) {\n        var settings = function() {\n            if (isKeyCredential(uriOrCredential) && isRTOpenAIOptions(credentialOrOptions)) {\n                return openAISettings(uriOrCredential, credentialOrOptions);\n            } else if (isCredential(credentialOrOptions) && isRTAzureOpenAIOptions(options)) {\n                return azureOpenAISettings(uriOrCredential, credentialOrOptions, options);\n            } else {\n                throw new Error(\"Invalid combination of arguments to initialize the Realtime client\");\n            }\n        }();\n        this.requestId = settings.requestId;\n        this.client = this.getWebsocket(settings);\n    }\n    LowLevelRTClient.prototype.getWebsocket = function(settings) {\n        var handler = {\n            validate: function(event) {\n                if (typeof event.data !== \"string\") {\n                    return validationError(new Error(\"Invalid message type\"));\n                }\n                try {\n                    var data = JSON.parse(event.data);\n                    if (isServerMessageType(data)) {\n                        return validationSuccess(data);\n                    }\n                    return validationError(new Error(\"Invalid message type\"));\n                } catch (error) {\n                    return validationError(new Error(\"Invalid JSON message\"));\n                }\n            },\n            serialize: function(message) {\n                return JSON.stringify(message);\n            }\n        };\n        return new WebSocketClient(settings, handler);\n    };\n    LowLevelRTClient.prototype.messages = function() {\n        return __asyncGenerator(this, arguments, function messages_1() {\n            var _a, _b, _c, message, e_1_1;\n            var _d, e_1, _e, _f;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        _g.trys.push([\n                            0,\n                            7,\n                            8,\n                            13\n                        ]);\n                        _a = true, _b = __asyncValues(this.client);\n                        _g.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            __await(_b.next())\n                        ];\n                    case 2:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                        _f = _c.value;\n                        _a = false;\n                        message = _f;\n                        return [\n                            4 /*yield*/ ,\n                            __await(message)\n                        ];\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            _g.sent()\n                        ];\n                    case 4:\n                        _g.sent();\n                        _g.label = 5;\n                    case 5:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 7:\n                        e_1_1 = _g.sent();\n                        e_1 = {\n                            error: e_1_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 8:\n                        _g.trys.push([\n                            8,\n                            ,\n                            11,\n                            12\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(_e.call(_b))\n                        ];\n                    case 9:\n                        _g.sent();\n                        _g.label = 10;\n                    case 10:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    LowLevelRTClient.prototype.send = function(message) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send(message)\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    LowLevelRTClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.close()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return LowLevelRTClient;\n}();\nvar RTError = /** @class */ function(_super) {\n    __extends(RTError, _super);\n    function RTError(errorDetails) {\n        var _this = _super.call(this, errorDetails.message) || this;\n        _this.errorDetails = errorDetails;\n        Object.setPrototypeOf(_this, RTError.prototype);\n        return _this;\n    }\n    Object.defineProperty(RTError.prototype, \"code\", {\n        get: function() {\n            return this.errorDetails.code;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTError.prototype, \"param\", {\n        get: function() {\n            return this.errorDetails.param;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTError.prototype, \"eventId\", {\n        get: function() {\n            return this.errorDetails.event_id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return RTError;\n}(Error);\nvar RTInputAudioItem = /** @class */ function() {\n    function RTInputAudioItem(id, audioStartMillis, hasTranscription, queue) {\n        this.id = id;\n        this.audioStartMillis = audioStartMillis;\n        this.hasTranscription = hasTranscription;\n        this.queue = queue;\n        this.type = \"input_audio\";\n        this.audioEndMillis = undefined;\n        this.transcription = undefined;\n        this.waitPromise = null;\n    }\n    RTInputAudioItem.create = function(id, audioStartMillis, hasTranscription, queue) {\n        return new RTInputAudioItem(id, audioStartMillis, hasTranscription, queue);\n    };\n    RTInputAudioItem.prototype.wait = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var itemIdValidMessage, message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        itemIdValidMessage = function(message) {\n                            return [\n                                \"input_audio_buffer.speech_stopped\",\n                                \"conversation.item.input_audio_transcription.completed\",\n                                \"conversation.item.input_audio_transcription.failed\"\n                            ].includes(message.type);\n                        };\n                        _a.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            this.queue.receive(function(m) {\n                                return itemIdValidMessage(m) && m.item_id == _this.id || m.type === \"conversation.item.created\" && m.item.id == _this.id;\n                            })\n                        ];\n                    case 2:\n                        message = _a.sent();\n                        if (message === null) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"input_audio_buffer.speech_stopped\") {\n                            this.audioEndMillis = message.audio_end_ms;\n                            if (!this.hasTranscription) {\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                        } else if (message.type === \"conversation.item.created\" && !this.hasTranscription) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"conversation.item.input_audio_transcription.completed\") {\n                            this.transcription = message.transcript;\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else if (message.type === \"conversation.item.input_audio_transcription.failed\") {\n                            throw new RTError(message.error);\n                        }\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 3:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTInputAudioItem.prototype.waitForCompletion = function() {\n        if (!this.waitPromise) {\n            this.waitPromise = this.wait();\n        }\n        return this.waitPromise;\n    };\n    return RTInputAudioItem;\n}();\n/* TODO: Move to PAL so we use Buffer.from in Node */ function decodeBase64(base64) {\n    var binaryString = atob(base64);\n    var length = binaryString.length;\n    var uint8Array = new Uint8Array(length);\n    for(var i = 0; i < length; i++){\n        uint8Array[i] = binaryString.charCodeAt(i);\n    }\n    return uint8Array;\n}\nvar RTAudioContent = /** @class */ function() {\n    function RTAudioContent(message, queue) {\n        var _this = this;\n        this.queue = queue;\n        this.type = \"audio\";\n        this.itemId = message.item_id;\n        this.contentIndex = message.content_index;\n        if (message.part.type !== \"audio\") {\n            throw new Error(\"Unexpected part type\");\n        }\n        this.part = message.part;\n        this.contentQueue = new SharedEndQueue(function() {\n            return _this.receiveContent();\n        }, function(m) {\n            return m !== null && m.type === \"error\";\n        }, function(m) {\n            return m !== null && m.type === \"response.content_part.done\";\n        });\n    }\n    RTAudioContent.create = function(message, queue) {\n        return new RTAudioContent(message, queue);\n    };\n    Object.defineProperty(RTAudioContent.prototype, \"transcript\", {\n        get: function() {\n            return this.part.transcript;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTAudioContent.prototype.receiveContent = function() {\n        var _this = this;\n        function isValidMessage(m) {\n            return [\n                \"response.audio.delta\",\n                \"response.audio.done\",\n                \"response.audio_transcript.delta\",\n                \"response.audio_transcript.done\",\n                \"response.content_part.done\"\n            ].includes(m.type);\n        }\n        return this.queue.receive(function(m) {\n            return isValidMessage(m) && m.item_id === _this.itemId && m.content_index === _this.contentIndex;\n        });\n    };\n    RTAudioContent.prototype.audioChunks = function() {\n        return __asyncGenerator(this, arguments, function audioChunks_1() {\n            var message, buffer;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.contentQueue.receive(function(m) {\n                                return m !== null && [\n                                    \"response.audio.delta\",\n                                    \"response.audio.done\"\n                                ].includes(m.type);\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"audio\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.audio.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        buffer = decodeBase64(message.delta);\n                        return [\n                            4 /*yield*/ ,\n                            __await(buffer)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.audio.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTAudioContent.prototype.transcriptChunks = function() {\n        return __asyncGenerator(this, arguments, function transcriptChunks_1() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.contentQueue.receive(function(m) {\n                                return m !== null && [\n                                    \"response.audio_transcript.delta\",\n                                    \"response.audio_transcript.done\"\n                                ].includes(m.type);\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"audio\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.audio_transcript.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.audio_transcript.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTAudioContent;\n}();\nvar RTTextContent = /** @class */ function() {\n    function RTTextContent(message, queue) {\n        this.queue = queue;\n        this.type = \"text\";\n        this.itemId = message.item_id;\n        this.contentIndex = message.content_index;\n        if (message.part.type !== \"text\") {\n            throw new Error(\"Unexpected part type\");\n        }\n        this.part = message.part;\n    }\n    RTTextContent.create = function(message, queue) {\n        return new RTTextContent(message, queue);\n    };\n    Object.defineProperty(RTTextContent.prototype, \"text\", {\n        get: function() {\n            return this.part.text;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTTextContent.prototype.textChunks = function() {\n        return __asyncGenerator(this, arguments, function textChunks_1() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return (m.type === \"response.content_part.done\" || m.type === \"response.text.delta\" || m.type === \"response.text.done\") && m.item_id === _this.itemId && m.content_index === _this.contentIndex;\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.content_part.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.part.type !== \"text\") {\n                            throw new Error(\"Unexpected part type\");\n                        }\n                        this.part = message.part;\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.text.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.text.done\") {\n                            // We are skipping this as it's information is already provided by 'response.content_part.done'\n                            // and that is a better signal to end the iteration\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        }\n                        _a.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTTextContent;\n}();\nvar RTMessageItem = /** @class */ function() {\n    function RTMessageItem(responseId, item, previousItemId, queue) {\n        this.responseId = responseId;\n        this.item = item;\n        this.previousItemId = previousItemId;\n        this.queue = queue;\n        this.type = \"message\";\n    }\n    RTMessageItem.create = function(responseId, item, previousItemId, queue) {\n        return new RTMessageItem(responseId, item, previousItemId, queue);\n    };\n    Object.defineProperty(RTMessageItem.prototype, \"id\", {\n        get: function() {\n            return this.item.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTMessageItem.prototype, \"role\", {\n        get: function() {\n            return this.item.role;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTMessageItem.prototype, \"status\", {\n        get: function() {\n            return this.item.status;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTMessageItem.prototype[Symbol.asyncIterator] = function() {\n        return __asyncGenerator(this, arguments, function _a() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return m.type === \"response.content_part.added\" && m.item_id === _this.id || m.type === \"response.output_item.done\" && m.item.id === _this.id;\n                            }))\n                        ];\n                    case 1:\n                        message = _b.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            14\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.output_item.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.item.type === \"message\") {\n                            this.item = message.item;\n                        } else {\n                            throw new Error(\"Unexpected item type\");\n                        }\n                        return [\n                            3 /*break*/ ,\n                            14\n                        ];\n                    case 4:\n                        if (!(message.type === \"response.content_part.added\")) return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                        if (!(message.part.type === \"audio\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTAudioContent.create(message, this.queue))\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _b.sent()\n                        ];\n                    case 6:\n                        _b.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 7:\n                        if (!(message.part.type === \"text\")) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTTextContent.create(message, this.queue))\n                        ];\n                    case 8:\n                        return [\n                            4 /*yield*/ ,\n                            _b.sent()\n                        ];\n                    case 9:\n                        _b.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        throw new Error(\"Unexpected part type: \".concat(message.part.type));\n                    case 11:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 12:\n                        throw new Error(\"Unexpected message type: \".concat(message.type));\n                    case 13:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 14:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTMessageItem;\n}();\nvar RTFunctionCallItem = /** @class */ function() {\n    function RTFunctionCallItem(responseId, item, previousItemId, queue) {\n        this.responseId = responseId;\n        this.item = item;\n        this.previousItemId = previousItemId;\n        this.queue = queue;\n        this.type = \"function_call\";\n        this.awaited = false;\n        this.iterated = false;\n    }\n    RTFunctionCallItem.create = function(responseId, item, previousItemId, queue) {\n        return new RTFunctionCallItem(responseId, item, previousItemId, queue);\n    };\n    Object.defineProperty(RTFunctionCallItem.prototype, \"id\", {\n        get: function() {\n            return this.item.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"functionName\", {\n        get: function() {\n            return this.item.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"callId\", {\n        get: function() {\n            return this.item.call_id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTFunctionCallItem.prototype, \"arguments\", {\n        get: function() {\n            return this.item.arguments;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTFunctionCallItem.prototype.inner = function() {\n        return __asyncGenerator(this, arguments, function inner_1() {\n            var message;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.queue.receive(function(m) {\n                                return (m.type == \"response.function_call_arguments.delta\" || m.type == \"response.function_call_arguments.done\") && m.item_id === _this.id || m.type === \"response.output_item.done\" && m.item.id === _this.id;\n                            }))\n                        ];\n                    case 1:\n                        message = _a.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 2:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        throw new RTError(message.error);\n                    case 3:\n                        if (!(message.type === \"response.output_item.done\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        if (message.item.type === \"function_call\") {\n                            this.item = message.item;\n                            return [\n                                3 /*break*/ ,\n                                9\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected item type\");\n                        }\n                    case 4:\n                        if (!(message.type === \"response.function_call_arguments.delta\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(message.delta)\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _a.sent()\n                        ];\n                    case 6:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        if (message.type === \"response.function_call_arguments.done\") {\n                            return [\n                                3 /*break*/ ,\n                                0\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type: \".concat(message.type));\n                        }\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            0\n                        ];\n                    case 9:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTFunctionCallItem.prototype[Symbol.asyncIterator] = function() {\n        return __asyncGenerator(this, arguments, function _a() {\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        if (this.awaited) {\n                            throw new Error(\"Cannot iterate after awaiting.\");\n                        }\n                        this.iterated = true;\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.inner())\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _b.sent()\n                        ];\n                }\n            });\n        });\n    };\n    RTFunctionCallItem.prototype.waitForCompletion = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var _a, _b, _c, e_2_1;\n            var _d, e_2, _e;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        if (this.iterated) {\n                            throw new Error(\"Cannot await after iterating.\");\n                        }\n                        this.awaited = true;\n                        _g.label = 1;\n                    case 1:\n                        _g.trys.push([\n                            1,\n                            6,\n                            7,\n                            12\n                        ]);\n                        _a = true, _b = __asyncValues(this.inner());\n                        _g.label = 2;\n                    case 2:\n                        return [\n                            4 /*yield*/ ,\n                            _b.next()\n                        ];\n                    case 3:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                        _c.value;\n                        _a = false;\n                        _g.label = 4;\n                    case 4:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                    case 5:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 6:\n                        e_2_1 = _g.sent();\n                        e_2 = {\n                            error: e_2_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 7:\n                        _g.trys.push([\n                            7,\n                            ,\n                            10,\n                            11\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            _e.call(_b)\n                        ];\n                    case 8:\n                        _g.sent();\n                        _g.label = 9;\n                    case 9:\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        if (e_2) throw e_2.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 11:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTFunctionCallItem;\n}();\nfunction isMessageItem(item) {\n    return item.type === \"message\";\n}\nfunction isFunctionCallItem(item) {\n    return item.type === \"function_call\";\n}\nvar RTResponse = /** @class */ function() {\n    function RTResponse(response, queue, client) {\n        this.response = response;\n        this.queue = queue;\n        this.client = client;\n        this.type = \"response\";\n        this.done = false;\n    }\n    RTResponse.create = function(response, queue, client) {\n        return new RTResponse(response, queue, client);\n    };\n    Object.defineProperty(RTResponse.prototype, \"id\", {\n        get: function() {\n            return this.response.id;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"status\", {\n        get: function() {\n            return this.response.status;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"statusDetails\", {\n        get: function() {\n            return this.response.status_details;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"output\", {\n        get: function() {\n            return this.response.output;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RTResponse.prototype, \"usage\", {\n        get: function() {\n            return this.response.usage;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTResponse.prototype.cancel = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var _a, _b, _c, e_3_1;\n            var _d, e_3, _e;\n            return __generator(this, function(_g) {\n                switch(_g.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"response.cancel\"\n                            })\n                        ];\n                    case 1:\n                        _g.sent();\n                        _g.label = 2;\n                    case 2:\n                        _g.trys.push([\n                            2,\n                            7,\n                            8,\n                            13\n                        ]);\n                        _a = true, _b = __asyncValues(this);\n                        _g.label = 3;\n                    case 3:\n                        return [\n                            4 /*yield*/ ,\n                            _b.next()\n                        ];\n                    case 4:\n                        if (!(_c = _g.sent(), _d = _c.done, !_d)) return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                        _c.value;\n                        _a = false;\n                        _g.label = 5;\n                    case 5:\n                        _a = true;\n                        return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 7:\n                        e_3_1 = _g.sent();\n                        e_3 = {\n                            error: e_3_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            13\n                        ];\n                    case 8:\n                        _g.trys.push([\n                            8,\n                            ,\n                            11,\n                            12\n                        ]);\n                        if (!(!_a && !_d && (_e = _b.return))) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            _e.call(_b)\n                        ];\n                    case 9:\n                        _g.sent();\n                        _g.label = 10;\n                    case 10:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 11:\n                        if (e_3) throw e_3.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTResponse.prototype[Symbol.asyncIterator] = function() {\n        var _this = this;\n        return {\n            next: function() {\n                return __awaiter(_this, void 0, void 0, function() {\n                    var message, created_message, messageItem, functionCallItem;\n                    var _this = this;\n                    return __generator(this, function(_a) {\n                        switch(_a.label){\n                            case 0:\n                                if (this.done) {\n                                    return [\n                                        2 /*return*/ ,\n                                        {\n                                            value: undefined,\n                                            done: true\n                                        }\n                                    ];\n                                }\n                                return [\n                                    4 /*yield*/ ,\n                                    this.queue.receive(function(m) {\n                                        return m.type === \"response.done\" && m.response.id === _this.id || m.type === \"response.output_item.added\" && m.response_id === _this.id;\n                                    })\n                                ];\n                            case 1:\n                                message = _a.sent();\n                                if (!(message === null)) return [\n                                    3 /*break*/ ,\n                                    2\n                                ];\n                                return [\n                                    2 /*return*/ ,\n                                    {\n                                        value: undefined,\n                                        done: true\n                                    }\n                                ];\n                            case 2:\n                                if (!(message.type === \"error\")) return [\n                                    3 /*break*/ ,\n                                    3\n                                ];\n                                throw new RTError(message.error);\n                            case 3:\n                                if (!(message.type === \"response.done\")) return [\n                                    3 /*break*/ ,\n                                    4\n                                ];\n                                this.done = true;\n                                this.response = message.response;\n                                return [\n                                    2 /*return*/ ,\n                                    {\n                                        value: undefined,\n                                        done: true\n                                    }\n                                ];\n                            case 4:\n                                if (!(message.type === \"response.output_item.added\")) return [\n                                    3 /*break*/ ,\n                                    6\n                                ];\n                                return [\n                                    4 /*yield*/ ,\n                                    this.queue.receive(function(m) {\n                                        return m.type === \"conversation.item.created\" && m.item.id === message.item.id;\n                                    })\n                                ];\n                            case 5:\n                                created_message = _a.sent();\n                                if (created_message === null) {\n                                    return [\n                                        2 /*return*/ ,\n                                        {\n                                            value: undefined,\n                                            done: true\n                                        }\n                                    ];\n                                } else if (created_message.type === \"error\") {\n                                    throw new RTError(created_message.error);\n                                } else if (created_message.type === \"conversation.item.created\") {\n                                    if (created_message.item.type === \"message\") {\n                                        messageItem = RTMessageItem.create(this.id, created_message.item, created_message.previous_item_id, this.queue);\n                                        return [\n                                            2 /*return*/ ,\n                                            {\n                                                value: messageItem,\n                                                done: false\n                                            }\n                                        ];\n                                    } else if (created_message.item.type === \"function_call\") {\n                                        functionCallItem = RTFunctionCallItem.create(this.id, created_message.item, created_message.previous_item_id, this.queue);\n                                        return [\n                                            2 /*return*/ ,\n                                            {\n                                                value: functionCallItem,\n                                                done: false\n                                            }\n                                        ];\n                                    } else {\n                                        throw new Error(\"Unexpected item type (\".concat(created_message.item.type, \".\"));\n                                    }\n                                } else {\n                                    throw new Error(\"Unexpected message type: \".concat(created_message.type));\n                                }\n                            case 6:\n                                throw new Error(\"Unexpected message type: \".concat(message.type));\n                            case 7:\n                                return [\n                                    2 /*return*/ \n                                ];\n                        }\n                    });\n                });\n            }\n        };\n    };\n    return RTResponse;\n}();\nvar RTClient = /** @class */ function() {\n    function RTClient(uriOrCredential, credentialOrOptions, options) {\n        var _this = this;\n        this.iterating = false;\n        this.client = function() {\n            if (isKeyCredential(uriOrCredential)) {\n                return new LowLevelRTClient(uriOrCredential, credentialOrOptions);\n            } else {\n                return new LowLevelRTClient(uriOrCredential, credentialOrOptions, options);\n            }\n        }();\n        this.messagesIterable = this.client.messages()[Symbol.asyncIterator]();\n        this.messageQueue = new MessageQueueWithError(function() {\n            return _this.receiveMessages();\n        }, function(m) {\n            return m.type === \"error\";\n        });\n    }\n    RTClient.prototype.receiveMessages = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var result;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.messagesIterable.next()\n                        ];\n                    case 1:\n                        result = _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            result.done ? null : result.value\n                        ];\n                }\n            });\n        });\n    };\n    Object.defineProperty(RTClient.prototype, \"requestId\", {\n        get: function() {\n            return this.client.requestId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    RTClient.prototype.init = function() {\n        var _this = this;\n        if (this.initPromise !== undefined) {\n            return this.initPromise;\n        }\n        this.initPromise = function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                var message;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (this.session !== undefined) {\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                            return [\n                                4 /*yield*/ ,\n                                this.messageQueue.receive(function(m) {\n                                    return m.type === \"session.created\";\n                                })\n                            ];\n                        case 1:\n                            message = _a.sent();\n                            if (message === null) {\n                                throw new Error(\"Failed to initialize session\");\n                            }\n                            if (message.type === \"error\") {\n                                throw new RTError(message.error);\n                            }\n                            if (message.type !== \"session.created\") {\n                                throw new Error(\"Unexpected message type\");\n                            }\n                            this.session = message.session;\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        }();\n        return this.initPromise;\n    };\n    RTClient.prototype.configure = function(params) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"session.update\",\n                                session: params\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"session.updated\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to update session\");\n                        }\n                        if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        }\n                        if (message.type !== \"session.updated\") {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                        this.session = message.session;\n                        return [\n                            2 /*return*/ ,\n                            this.session\n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.sendAudio = function(audio) {\n        return __awaiter(this, void 0, void 0, function() {\n            var base64;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        base64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(audio), false)));\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.append\",\n                                audio: base64\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.commitAudio = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            var _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.commit\"\n                            })\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.committed\";\n                            })\n                        ];\n                    case 3:\n                        message = _c.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to commit audio\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"input_audio_buffer.committed\") {\n                            return [\n                                2 /*return*/ ,\n                                RTInputAudioItem.create(message.item_id, undefined, ((_a = this.session) === null || _a === void 0 ? void 0 : _a.input_audio_transcription) !== undefined && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.input_audio_transcription) !== null, this.messageQueue)\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.clearAudio = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"input_audio_buffer.clear\"\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.cleared\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to clear audio\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type !== \"input_audio_buffer.cleared\") {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.sendItem = function(item, previousItemId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        item.id = item.id || generateId(\"item\", 32);\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"conversation.item.create\",\n                                previous_item_id: previousItemId,\n                                item: item\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"conversation.item.created\" && m.item.id === item.id;\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to create item\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"conversation.item.created\") {\n                            return [\n                                2 /*return*/ ,\n                                message.item\n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.removeItem = function(itemId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"conversation.item.delete\",\n                                item_id: itemId\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"conversation.item.deleted\" && m.item_id === itemId;\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to delete item\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"conversation.item.deleted\") {\n                            return [\n                                2 /*return*/ \n                            ];\n                        } else {\n                            throw new Error(\"Unexpected message type\");\n                        }\n                }\n            });\n        });\n    };\n    RTClient.prototype.generateResponse = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var message;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.init()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this.client.send({\n                                type: \"response.create\"\n                            })\n                        ];\n                    case 2:\n                        _a.sent();\n                        if (!!this.iterating) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.messageQueue.receive(function(m) {\n                                return m.type === \"response.created\";\n                            })\n                        ];\n                    case 3:\n                        message = _a.sent();\n                        if (message === null) {\n                            throw new Error(\"Failed to create response\");\n                        } else if (message.type === \"error\") {\n                            throw new RTError(message.error);\n                        } else if (message.type === \"response.created\") {\n                            return [\n                                2 /*return*/ ,\n                                RTResponse.create(message.response, this.messageQueue, this.client)\n                            ];\n                        }\n                        throw new Error(\"Unexpected message type\");\n                    case 4:\n                        return [\n                            2 /*return*/ ,\n                            undefined\n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.events = function() {\n        return __asyncGenerator(this, arguments, function events_1() {\n            var message;\n            var _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        _c.trys.push([\n                            0,\n                            ,\n                            13,\n                            14\n                        ]);\n                        this.iterating = true;\n                        _c.label = 1;\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            __await(this.messageQueue.receive(function(m) {\n                                return m.type === \"input_audio_buffer.speech_started\" || m.type === \"response.created\";\n                            }))\n                        ];\n                    case 2:\n                        message = _c.sent();\n                        if (!(message === null)) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 3:\n                        if (!(message.type === \"error\")) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        throw new RTError(message.error);\n                    case 4:\n                        if (!(message.type === \"input_audio_buffer.speech_started\")) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTInputAudioItem.create(message.item_id, message.audio_start_ms, ((_a = this.session) === null || _a === void 0 ? void 0 : _a.input_audio_transcription) !== undefined && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.input_audio_transcription) !== null, this.messageQueue))\n                        ];\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            _c.sent()\n                        ];\n                    case 6:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 7:\n                        if (!(message.type === \"response.created\")) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            __await(RTResponse.create(message.response, this.messageQueue, this.client))\n                        ];\n                    case 8:\n                        return [\n                            4 /*yield*/ ,\n                            _c.sent()\n                        ];\n                    case 9:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        throw new Error(\"Unexpected message type\");\n                    case 11:\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 12:\n                        return [\n                            3 /*break*/ ,\n                            14\n                        ];\n                    case 13:\n                        this.iterating = false;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 14:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    RTClient.prototype.close = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.client.close()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return RTClient;\n}();\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnQtY2xpZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0o7QUFDSTtBQUNGO0FBQ0U7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBRTdCLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFDbEMsSUFBSVUsa0JBQWtCO0FBRXRCOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSw4REFBOEQsR0FFOUQsSUFBSUMsZ0JBQWdCLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztJQUM3QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1FBQUVDLFdBQVcsRUFBRTtJQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1FBQUlELEVBQUVJLFNBQVMsR0FBR0g7SUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU1MsVUFBVVYsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVUsVUFBVSx5QkFBeUJDLE9BQU9YLEtBQUs7SUFDN0RGLGNBQWNDLEdBQUdDO0lBQ2pCLFNBQVNZO1FBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdkO0lBQUc7SUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPYSxNQUFNLENBQUNkLEtBQU1ZLENBQUFBLEdBQUdOLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlNLElBQUc7QUFDdEY7QUFFQSxJQUFJRyxXQUFXO0lBQ1hBLFdBQVdkLE9B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b0JBQ3RHLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUkzQixHQUFHN25CLElBQUk7eUJBQUc7b0JBQ3ZDLEtBQUs7d0JBQ0Q2bkIsR0FBRzduQixJQUFJO3dCQUNQLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFHO29CQUM1QixLQUFLO3dCQUFJLE1BQU0sSUFBSTJDLE1BQU07b0JBQ3pCLEtBQUs7d0JBQUksT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQ2hDLEtBQUs7d0JBQUksT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUc7b0JBQ2pDLEtBQUs7d0JBQ0QsSUFBSSxDQUFDMnJCLFNBQVMsR0FBRzt3QkFDakIsT0FBTzs0QkFBQyxFQUFFLFlBQVk7eUJBQUc7b0JBQzdCLEtBQUs7d0JBQUksT0FBTzs0QkFBQyxFQUFFLFFBQVE7eUJBQUc7Z0JBQ2xDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FELFNBQVM3d0IsU0FBUyxDQUFDa00sS0FBSyxHQUFHO1FBQ3ZCLE9BQU9oTCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVd2tCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdya0IsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3lwQixNQUFNLENBQUM5ZixLQUFLO3lCQUFHO29CQUNqRCxLQUFLO3dCQUNEMGEsR0FBR3BrQixJQUFJO3dCQUNQLE9BQU87NEJBQUMsRUFBRSxRQUFRO3lCQUFHO2dCQUM3QjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9xdUI7QUFDWDtBQUVtRyxDQUNuRyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9ydC1jbGllbnQvZGlzdC9lc20vaW5kZXguanM/M2EyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWlyZSQkMCQyIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgcmVxdWlyZSQkMCBmcm9tICd6bGliJztcbmltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAnYnVmZmVyJztcbmltcG9ydCByZXF1aXJlJCQxIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgcmVxdWlyZSQkMCQzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgcmVxdWlyZSQkMSQxIGZyb20gJ2h0dHBzJztcbmltcG9ydCByZXF1aXJlJCQyIGZyb20gJ2h0dHAnO1xuaW1wb3J0IHJlcXVpcmUkJDMgZnJvbSAnbmV0JztcbmltcG9ydCByZXF1aXJlJCQ0IGZyb20gJ3Rscyc7XG5pbXBvcnQgcmVxdWlyZSQkNyBmcm9tICd1cmwnO1xuXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbnZhciBNZXNzYWdlSXRlbVR5cGUgPSBcIm1lc3NhZ2VcIjtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcclxuICAgIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxudmFyIGlzUmVhbHRpbWVFdmVudCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJ0eXBlXCIgaW4gbWVzc2FnZTtcbn07XG52YXIgaXNTZXJ2ZXJNZXNzYWdlVHlwZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGlzUmVhbHRpbWVFdmVudChtZXNzYWdlKSAmJlxuICAgICAgICBbXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcInNlc3Npb24uY3JlYXRlZFwiLFxuICAgICAgICAgICAgXCJzZXNzaW9uLnVwZGF0ZWRcIixcbiAgICAgICAgICAgIFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZFwiLFxuICAgICAgICAgICAgXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZFwiLFxuICAgICAgICAgICAgXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0YXJ0ZWRcIixcbiAgICAgICAgICAgIFwiaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkXCIsXG4gICAgICAgICAgICBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRcIixcbiAgICAgICAgICAgIFwiY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVkXCIsXG4gICAgICAgICAgICBcImNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRcIixcbiAgICAgICAgICAgIFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRcIixcbiAgICAgICAgICAgIFwiY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5mYWlsZWRcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UuY3JlYXRlZFwiLFxuICAgICAgICAgICAgXCJyZXNwb25zZS5kb25lXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmFkZGVkXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLmNvbnRlbnRfcGFydC5kb25lXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLnRleHQuZGVsdGFcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UudGV4dC5kb25lXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZGVsdGFcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvLmRlbHRhXCIsXG4gICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvLmRvbmVcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGFcIixcbiAgICAgICAgICAgIFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZVwiLFxuICAgICAgICAgICAgXCJyYXRlX2xpbWl0cy51cGRhdGVkXCIsXG4gICAgICAgIF0uaW5jbHVkZXMobWVzc2FnZS50eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBidWZmZXJVdGlsID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGNvbnN0YW50cztcbnZhciBoYXNSZXF1aXJlZENvbnN0YW50cztcblxuZnVuY3Rpb24gcmVxdWlyZUNvbnN0YW50cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENvbnN0YW50cykgcmV0dXJuIGNvbnN0YW50cztcblx0aGFzUmVxdWlyZWRDb25zdGFudHMgPSAxO1xuXG5cdGNvbnN0IEJJTkFSWV9UWVBFUyA9IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXTtcblx0Y29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuXHRpZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcblxuXHRjb25zdGFudHMgPSB7XG5cdCAgQklOQVJZX1RZUEVTLFxuXHQgIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuXHQgIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuXHQgIGhhc0Jsb2IsXG5cdCAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuXHQgIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcblx0ICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuXHQgIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG5cdCAgTk9PUDogKCkgPT4ge31cblx0fTtcblx0cmV0dXJuIGNvbnN0YW50cztcbn1cblxudmFyIGhhc1JlcXVpcmVkQnVmZmVyVXRpbDtcblxuZnVuY3Rpb24gcmVxdWlyZUJ1ZmZlclV0aWwgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRCdWZmZXJVdGlsKSByZXR1cm4gYnVmZmVyVXRpbC5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEJ1ZmZlclV0aWwgPSAxO1xuXG5cdGNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Y29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cblx0LyoqXG5cdCAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG5cdCAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuXHQgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cblx0ICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuXHQgIGxldCBvZmZzZXQgPSAwO1xuXG5cdCAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuXHQgICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG5cdCAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcblx0ICB9XG5cblx0ICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcblx0ICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2Vcblx0ICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG5cdCAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG5cdCAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG5cdCAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuXHQgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcblx0ICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cblx0ICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuXHQgIGxldCBidWY7XG5cblx0ICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcblx0ICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuXHQgICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG5cdCAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiBidWY7XG5cdH1cblxuXHRidWZmZXJVdGlsLmV4cG9ydHMgPSB7XG5cdCAgY29uY2F0LFxuXHQgIG1hc2s6IF9tYXNrLFxuXHQgIHRvQXJyYXlCdWZmZXIsXG5cdCAgdG9CdWZmZXIsXG5cdCAgdW5tYXNrOiBfdW5tYXNrXG5cdH07XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5cdGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcblx0ICB0cnkge1xuXHQgICAgY29uc3QgYnVmZmVyVXRpbCQxID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG5cdCAgICBidWZmZXJVdGlsLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuXHQgICAgICBlbHNlIGJ1ZmZlclV0aWwkMS5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG5cdCAgICB9O1xuXG5cdCAgICBidWZmZXJVdGlsLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFzaykge1xuXHQgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG5cdCAgICAgIGVsc2UgYnVmZmVyVXRpbCQxLnVubWFzayhidWZmZXIsIG1hc2spO1xuXHQgICAgfTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cblx0ICB9XG5cdH1cblx0cmV0dXJuIGJ1ZmZlclV0aWwuZXhwb3J0cztcbn1cblxudmFyIGxpbWl0ZXI7XG52YXIgaGFzUmVxdWlyZWRMaW1pdGVyO1xuXG5mdW5jdGlvbiByZXF1aXJlTGltaXRlciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZExpbWl0ZXIpIHJldHVybiBsaW1pdGVyO1xuXHRoYXNSZXF1aXJlZExpbWl0ZXIgPSAxO1xuXG5cdGNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuXHRjb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XG5cblx0LyoqXG5cdCAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXG5cdCAqL1xuXHRjbGFzcyBMaW1pdGVyIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcblx0ICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG5cdCAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcblx0ICAgICAgdGhpcy5wZW5kaW5nLS07XG5cdCAgICAgIHRoaXNba1J1bl0oKTtcblx0ICAgIH07XG5cdCAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG5cdCAgICB0aGlzLmpvYnMgPSBbXTtcblx0ICAgIHRoaXMucGVuZGluZyA9IDA7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgYWRkKGpvYikge1xuXHQgICAgdGhpcy5qb2JzLnB1c2goam9iKTtcblx0ICAgIHRoaXNba1J1bl0oKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBba1J1bl0oKSB7XG5cdCAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cblx0ICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG5cdCAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuXG5cdCAgICAgIHRoaXMucGVuZGluZysrO1xuXHQgICAgICBqb2IodGhpc1trRG9uZV0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGxpbWl0ZXIgPSBMaW1pdGVyO1xuXHRyZXR1cm4gbGltaXRlcjtcbn1cblxudmFyIHBlcm1lc3NhZ2VEZWZsYXRlO1xudmFyIGhhc1JlcXVpcmVkUGVybWVzc2FnZURlZmxhdGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVQZXJtZXNzYWdlRGVmbGF0ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFBlcm1lc3NhZ2VEZWZsYXRlKSByZXR1cm4gcGVybWVzc2FnZURlZmxhdGU7XG5cdGhhc1JlcXVpcmVkUGVybWVzc2FnZURlZmxhdGUgPSAxO1xuXG5cdGNvbnN0IHpsaWIgPSByZXF1aXJlJCQwO1xuXG5cdGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlQnVmZmVyVXRpbCgpO1xuXHRjb25zdCBMaW1pdGVyID0gcmVxdWlyZUxpbWl0ZXIoKTtcblx0Y29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZUNvbnN0YW50cygpO1xuXG5cdGNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXHRjb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcblx0Y29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcblx0Y29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcblx0Y29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuXHRjb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuXHRjb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cblx0Ly9cblx0Ly8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG5cdC8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcblx0Ly8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG5cdC8vXG5cdC8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuXHQvL1xuXHRsZXQgemxpYkxpbWl0ZXI7XG5cblx0LyoqXG5cdCAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cblx0ICovXG5cdGNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuXHQgICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcblx0ICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG5cdCAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcblx0ICAgKiAgICAgY2FsbHMgdG8gemxpYlxuXHQgICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuXHQgICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcblx0ICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcblx0ICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuXHQgICAqICAgICBkZWZsYXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cblx0ICAgKiAgICAgaW5mbGF0ZVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3Jcblx0ICAgKiAgICAgY2xpZW50IG1vZGVcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG5cdCAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG5cdCAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgIHRoaXMuX3RocmVzaG9sZCA9XG5cdCAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG5cdCAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG5cdCAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblx0ICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG5cdCAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cblx0ICAgIGlmICghemxpYkxpbWl0ZXIpIHtcblx0ICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuXHQgICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG5cdCAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuXHQgICAgICAgICAgOiAxMDtcblx0ICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge1N0cmluZ31cblx0ICAgKi9cblx0ICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG5cdCAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgb2ZmZXIoKSB7XG5cdCAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuXHQgICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcblx0ICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG5cdCAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG5cdCAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuXHQgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcblx0ICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcGFyYW1zO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuXHQgICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cblx0ICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcblx0ICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuXHQgICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG5cdCAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG5cdCAgICpcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgY2xlYW51cCgpIHtcblx0ICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG5cdCAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcblx0ICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG5cdCAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG5cdCAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcblx0ICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cblx0ICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2soXG5cdCAgICAgICAgICBuZXcgRXJyb3IoXG5cdCAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG5cdCAgICAgICAgICApXG5cdCAgICAgICAgKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcblx0ICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuXHQgICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcblx0ICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcblx0ICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcblx0ICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG5cdCAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuXHQgICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG5cdCAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG5cdCAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG5cdCAgICAgICkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICghYWNjZXB0ZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuXHQgICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuXHQgICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuXHQgICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuXHQgICAgfSBlbHNlIGlmIChcblx0ICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuXHQgICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG5cdCAgICApIHtcblx0ICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhY2NlcHRlZDtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2Vcblx0ICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG5cdCAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuXHQgICAgaWYgKFxuXHQgICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuXHQgICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcblx0ICAgICkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKFxuXHQgICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG5cdCAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuXHQgICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuXHQgICAgKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcblx0ICAgICAgKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBhcmFtcztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2Vcblx0ICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG5cdCAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcblx0ICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcblx0ICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuXHQgICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuXHQgICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdCAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuXHQgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFsdWUgPSBudW07XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuXHQgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuXHQgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB2YWx1ZSA9IG51bTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFxuXHQgICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG5cdCAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3Zlcidcblx0ICAgICAgICApIHtcblx0ICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuXHQgICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG5cdCAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcblx0ICAgICAgICBkb25lKCk7XG5cdCAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0ICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG5cdCAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcblx0ICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcblx0ICAgICAgICBkb25lKCk7XG5cdCAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIERlY29tcHJlc3MgZGF0YS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcblx0ICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG5cdCAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcblx0ICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG5cdCAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuXHQgICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuXHQgICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG5cdCAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cblx0ICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG5cdCAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG5cdCAgICAgICAgd2luZG93Qml0c1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcblx0ICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcblx0ICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblx0ICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG5cdCAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cblx0ICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG5cdCAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG5cdCAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcblx0ICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG5cdCAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cdCAgICAgICAgY2FsbGJhY2soZXJyKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG5cdCAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG5cdCAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG5cdCAgICAgICk7XG5cblx0ICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuXHQgICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcblx0ICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuXHQgICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cblx0ICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcblx0ICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENvbXByZXNzIGRhdGEuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcblx0ICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG5cdCAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcblx0ICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG5cdCAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuXHQgICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuXHQgICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG5cdCAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cblx0ICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG5cdCAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG5cdCAgICAgICAgd2luZG93Qml0c1xuXHQgICAgICB9KTtcblxuXHQgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuXHQgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG5cdCAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cblx0ICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG5cdCAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG5cdCAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuXHQgICAgICAgIC8vXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcblx0ICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcblx0ICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cblx0ICAgICAgKTtcblxuXHQgICAgICBpZiAoZmluKSB7XG5cdCAgICAgICAgZGF0YSA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEubGVuZ3RoIC0gNCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvL1xuXHQgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG5cdCAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuXHQgICAgICAvL1xuXHQgICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG5cdCAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG5cdCAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cblx0ICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG5cdCAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG5cdCAgICB9KTtcblx0ICB9XG5cdH1cblxuXHRwZXJtZXNzYWdlRGVmbGF0ZSA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuXHQgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuXHQgIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcblx0ICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG5cdCAgaWYgKFxuXHQgICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuXHQgICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuXHQgICkge1xuXHQgICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcblx0ICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuXHQgIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuXHQgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcblx0ICB0aGlzLnJlc2V0KCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3Jcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuXHQgIC8vXG5cdCAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuXHQgIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG5cdCAgLy9cblx0ICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuXHQgIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuXHQgIHRoaXNba0NhbGxiYWNrXShlcnIpO1xuXHR9XG5cdHJldHVybiBwZXJtZXNzYWdlRGVmbGF0ZTtcbn1cblxudmFyIHZhbGlkYXRpb24gPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRWYWxpZGF0aW9uO1xuXG5mdW5jdGlvbiByZXF1aXJlVmFsaWRhdGlvbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFZhbGlkYXRpb24pIHJldHVybiB2YWxpZGF0aW9uLmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkVmFsaWRhdGlvbiA9IDE7XG5cblx0Y29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUkJDAkMTtcblxuXHRjb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHQvL1xuXHQvLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG5cdC8vXG5cdC8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG5cdC8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcblx0Ly9cblx0Ly8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG5cdC8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuXHQvLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG5cdC8vIC4uLlxuXHQvL1xuXHQvLyBwcmV0dGllci1pZ25vcmVcblx0Y29uc3QgdG9rZW5DaGFycyA9IFtcblx0ICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcblx0ICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG5cdCAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuXHQgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcblx0ICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG5cdCAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuXHQgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG5cdCAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcblx0XTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcblx0ICByZXR1cm4gKFxuXHQgICAgKGNvZGUgPj0gMTAwMCAmJlxuXHQgICAgICBjb2RlIDw9IDEwMTQgJiZcblx0ICAgICAgY29kZSAhPT0gMTAwNCAmJlxuXHQgICAgICBjb2RlICE9PSAxMDA1ICYmXG5cdCAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG5cdCAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcblx0ICApO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG5cdCAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG5cdCAqIE1hcmt1cyBLdWhuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcblx0ICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuXHQgIGxldCBpID0gMDtcblxuXHQgIHdoaWxlIChpIDwgbGVuKSB7XG5cdCAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG5cdCAgICAgIC8vIDB4eHh4eHh4XG5cdCAgICAgIGkrKztcblx0ICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG5cdCAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG5cdCAgICAgIGlmIChcblx0ICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG5cdCAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuXHQgICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuXHQgICAgICApIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpICs9IDI7XG5cdCAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuXHQgICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuXHQgICAgICBpZiAoXG5cdCAgICAgICAgaSArIDIgPj0gbGVuIHx8XG5cdCAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuXHQgICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcblx0ICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG5cdCAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcblx0ICAgICAgKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaSArPSAzO1xuXHQgICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcblx0ICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIGkgKyAzID49IGxlbiB8fFxuXHQgICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcblx0ICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG5cdCAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuXHQgICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3Zlcmxvbmdcblx0ICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuXHQgICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuXHQgICAgICApIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpICs9IDQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgYSBgQmxvYmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGBCbG9iYCwgZWxzZSBgZmFsc2VgXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcblx0ICByZXR1cm4gKFxuXHQgICAgaGFzQmxvYiAmJlxuXHQgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHQgICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcblx0ICAgIHR5cGVvZiB2YWx1ZS5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcblx0ICAgICh2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQmxvYicgfHxcblx0ICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuXHQgICk7XG5cdH1cblxuXHR2YWxpZGF0aW9uLmV4cG9ydHMgPSB7XG5cdCAgaXNCbG9iLFxuXHQgIGlzVmFsaWRTdGF0dXNDb2RlLFxuXHQgIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG5cdCAgdG9rZW5DaGFyc1xuXHR9O1xuXG5cdGlmIChpc1V0ZjgpIHtcblx0ICB2YWxpZGF0aW9uLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG5cdCAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcblx0ICB9O1xuXHR9IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcblx0ICB0cnkge1xuXHQgICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG5cdCAgICB2YWxpZGF0aW9uLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG5cdCAgICAgIHJldHVybiBidWYubGVuZ3RoIDwgMzIgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG5cdCAgICB9O1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuXHQgIH1cblx0fVxuXHRyZXR1cm4gdmFsaWRhdGlvbi5leHBvcnRzO1xufVxuXG52YXIgcmVjZWl2ZXI7XG52YXIgaGFzUmVxdWlyZWRSZWNlaXZlcjtcblxuZnVuY3Rpb24gcmVxdWlyZVJlY2VpdmVyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUmVjZWl2ZXIpIHJldHVybiByZWNlaXZlcjtcblx0aGFzUmVxdWlyZWRSZWNlaXZlciA9IDE7XG5cblx0Y29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSQkMCQyO1xuXG5cdGNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZVBlcm1lc3NhZ2VEZWZsYXRlKCk7XG5cdGNvbnN0IHtcblx0ICBCSU5BUllfVFlQRVMsXG5cdCAgRU1QVFlfQlVGRkVSLFxuXHQgIGtTdGF0dXNDb2RlLFxuXHQgIGtXZWJTb2NrZXRcblx0fSA9IHJlcXVpcmVDb25zdGFudHMoKTtcblx0Y29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZUJ1ZmZlclV0aWwoKTtcblx0Y29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmVWYWxpZGF0aW9uKCk7XG5cblx0Y29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cblx0Y29uc3QgR0VUX0lORk8gPSAwO1xuXHRjb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuXHRjb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuXHRjb25zdCBHRVRfTUFTSyA9IDM7XG5cdGNvbnN0IEdFVF9EQVRBID0gNDtcblx0Y29uc3QgSU5GTEFUSU5HID0gNTtcblx0Y29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG5cdC8qKlxuXHQgKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuXHQgKlxuXHQgKiBAZXh0ZW5kcyBXcml0YWJsZVxuXHQgKi9cblx0Y2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuXHQgICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuXHQgICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG5cdCAgICogICAgIGV4dGVuc2lvbnNcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG5cdCAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Jcblx0ICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcblx0ICAgKi9cblx0ICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0ICAgIHN1cGVyKCk7XG5cblx0ICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxuXHQgICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxuXHQgICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG5cdCAgICAgICAgOiB0cnVlO1xuXHQgICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG5cdCAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuXHQgICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XG5cdCAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcblx0ICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG5cdCAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG5cdCAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcblx0ICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuXHQgICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG5cdCAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG5cdCAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuXHQgICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuXHQgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcblx0ICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuXHQgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cblx0ICAgIHRoaXMuX2Vycm9yZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2Bcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcblx0ICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG5cdCAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblx0ICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG5cdCAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcblx0ICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgY29uc3VtZShuKSB7XG5cdCAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cblx0ICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuXHQgICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuXHQgICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuXHQgICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG5cdCAgICAgICAgYnVmLmJ1ZmZlcixcblx0ICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG5cdCAgICAgICAgYnVmLmxlbmd0aCAtIG5cblx0ICAgICAgKTtcblxuXHQgICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcblx0ICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cblx0ICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuXHQgICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcblx0ICAgICAgICAgIGJ1Zi5idWZmZXIsXG5cdCAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG5cdCAgICAgICAgICBidWYubGVuZ3RoIC0gblxuXHQgICAgICAgICk7XG5cdCAgICAgIH1cblxuXHQgICAgICBuIC09IGJ1Zi5sZW5ndGg7XG5cdCAgICB9IHdoaWxlIChuID4gMCk7XG5cblx0ICAgIHJldHVybiBkc3Q7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgc3RhcnRMb29wKGNiKSB7XG5cdCAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuXHQgICAgZG8ge1xuXHQgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG5cdCAgICAgICAgY2FzZSBHRVRfSU5GTzpcblx0ICAgICAgICAgIHRoaXMuZ2V0SW5mbyhjYik7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcblx0ICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KGNiKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuXHQgICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoY2IpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBHRVRfTUFTSzpcblx0ICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBHRVRfREFUQTpcblx0ICAgICAgICAgIHRoaXMuZ2V0RGF0YShjYik7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIElORkxBVElORzpcblx0ICAgICAgICBjYXNlIERFRkVSX0VWRU5UOlxuXHQgICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuXHQgICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBnZXRJbmZvKGNiKSB7XG5cdCAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcblx0ICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuXHQgICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuXHQgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG5cdCAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcblx0ICAgICAgICB0cnVlLFxuXHQgICAgICAgIDEwMDIsXG5cdCAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG5cdCAgICAgICk7XG5cblx0ICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cblx0ICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG5cdCAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcblx0ICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuXHQgICAgICAgIHRydWUsXG5cdCAgICAgICAgMTAwMixcblx0ICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG5cdCAgICAgICk7XG5cblx0ICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcblx0ICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG5cdCAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuXHQgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuXHQgICAgICBpZiAoY29tcHJlc3NlZCkge1xuXHQgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcblx0ICAgICAgICAgIFJhbmdlRXJyb3IsXG5cdCAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcblx0ICAgICAgICAgIHRydWUsXG5cdCAgICAgICAgICAxMDAyLFxuXHQgICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuXHQgICAgICAgICk7XG5cblx0ICAgICAgICBjYihlcnJvcik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcblx0ICAgICAgICAgIHRydWUsXG5cdCAgICAgICAgICAxMDAyLFxuXHQgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcblx0ICAgICAgICApO1xuXG5cdCAgICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcblx0ICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcblx0ICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG5cdCAgICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG5cdCAgICAgICAgICB0cnVlLFxuXHQgICAgICAgICAgMTAwMixcblx0ICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG5cdCAgICAgICAgKTtcblxuXHQgICAgICAgIGNiKGVycm9yKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG5cdCAgICAgIGlmICghdGhpcy5fZmluKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuXHQgICAgICAgICAgdHJ1ZSxcblx0ICAgICAgICAgIDEwMDIsXG5cdCAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcblx0ICAgICAgICApO1xuXG5cdCAgICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjb21wcmVzc2VkKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuXHQgICAgICAgICAgdHJ1ZSxcblx0ICAgICAgICAgIDEwMDIsXG5cdCAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG5cdCAgICAgICAgKTtcblxuXHQgICAgICAgIGNiKGVycm9yKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoXG5cdCAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcblx0ICAgICAgICAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpXG5cdCAgICAgICkge1xuXHQgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcblx0ICAgICAgICAgIFJhbmdlRXJyb3IsXG5cdCAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcblx0ICAgICAgICAgIHRydWUsXG5cdCAgICAgICAgICAxMDAyLFxuXHQgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG5cdCAgICAgICAgKTtcblxuXHQgICAgICAgIGNiKGVycm9yKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcblx0ICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuXHQgICAgICAgIHRydWUsXG5cdCAgICAgICAgMTAwMixcblx0ICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuXHQgICAgICApO1xuXG5cdCAgICAgIGNiKGVycm9yKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcblx0ICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuXHQgICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG5cdCAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0Jyxcblx0ICAgICAgICAgIHRydWUsXG5cdCAgICAgICAgICAxMDAyLFxuXHQgICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuXHQgICAgICAgICk7XG5cblx0ICAgICAgICBjYihlcnJvcik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuXHQgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG5cdCAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcblx0ICAgICAgICB0cnVlLFxuXHQgICAgICAgIDEwMDIsXG5cdCAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG5cdCAgICAgICk7XG5cblx0ICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuXHQgICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcblx0ICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcblx0ICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuXHQgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG5cdCAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGdldFBheWxvYWRMZW5ndGg2NChjYikge1xuXHQgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG5cdCAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG5cdCAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG5cdCAgICAvL1xuXHQgICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG5cdCAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG5cdCAgICAvL1xuXHQgICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuXHQgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG5cdCAgICAgICAgUmFuZ2VFcnJvcixcblx0ICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcblx0ICAgICAgICBmYWxzZSxcblx0ICAgICAgICAxMDA5LFxuXHQgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcblx0ICAgICAgKTtcblxuXHQgICAgICBjYihlcnJvcik7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG5cdCAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgaGF2ZUxlbmd0aChjYikge1xuXHQgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuXHQgICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcblx0ICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcblx0ICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG5cdCAgICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuXHQgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAxMDA5LFxuXHQgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcblx0ICAgICAgICApO1xuXG5cdCAgICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuXHQgICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGdldE1hc2soKSB7XG5cdCAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcblx0ICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZ2V0RGF0YShjYikge1xuXHQgICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cblx0ICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuXHQgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG5cdCAgICAgIGlmIChcblx0ICAgICAgICB0aGlzLl9tYXNrZWQgJiZcblx0ICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcblx0ICAgICAgKSB7XG5cdCAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG5cdCAgICAgIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG5cdCAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuXHQgICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChkYXRhLmxlbmd0aCkge1xuXHQgICAgICAvL1xuXHQgICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG5cdCAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuXHQgICAgICAvL1xuXHQgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuXHQgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRGVjb21wcmVzc2VzIGRhdGEuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZGVjb21wcmVzcyhkYXRhLCBjYikge1xuXHQgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG5cdCAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG5cdCAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG5cdCAgICAgIGlmIChidWYubGVuZ3RoKSB7XG5cdCAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuXHQgICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuXHQgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG5cdCAgICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgICAxMDA5LFxuXHQgICAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuXHQgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgY2IoZXJyb3IpO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcblx0ICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBHRVRfSU5GTykgdGhpcy5zdGFydExvb3AoY2IpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBkYXRhTWVzc2FnZShjYikge1xuXHQgICAgaWYgKCF0aGlzLl9maW4pIHtcblx0ICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcblx0ICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuXHQgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcblx0ICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuXHQgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG5cdCAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuXHQgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuXHQgICAgICBsZXQgZGF0YTtcblxuXHQgICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG5cdCAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcblx0ICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG5cdCAgICAgICAgZGF0YSA9IG5ldyBCbG9iKGZyYWdtZW50cyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuXHQgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG5cdCAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcblx0ICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG5cdCAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG5cdCAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgRXJyb3IsXG5cdCAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG5cdCAgICAgICAgICB0cnVlLFxuXHQgICAgICAgICAgMTAwNyxcblx0ICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuXHQgICAgICAgICk7XG5cblx0ICAgICAgICBjYihlcnJvcik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcgfHwgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuXHQgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcblx0ICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuXHQgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG5cdCAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuXHQgICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG5cdCAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpIHtcblx0ICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcblx0ICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuXHQgICAgICAgIHRoaXMuZW5kKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG5cdCAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuXHQgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuXHQgICAgICAgICAgICBSYW5nZUVycm9yLFxuXHQgICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcblx0ICAgICAgICAgICAgdHJ1ZSxcblx0ICAgICAgICAgICAgMTAwMixcblx0ICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG5cdCAgICAgICAgICApO1xuXG5cdCAgICAgICAgICBjYihlcnJvcik7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29uc3QgYnVmID0gbmV3IEZhc3RCdWZmZXIoXG5cdCAgICAgICAgICBkYXRhLmJ1ZmZlcixcblx0ICAgICAgICAgIGRhdGEuYnl0ZU9mZnNldCArIDIsXG5cdCAgICAgICAgICBkYXRhLmxlbmd0aCAtIDJcblx0ICAgICAgICApO1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcblx0ICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcblx0ICAgICAgICAgICAgRXJyb3IsXG5cdCAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcblx0ICAgICAgICAgICAgdHJ1ZSxcblx0ICAgICAgICAgICAgMTAwNyxcblx0ICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG5cdCAgICAgICAgICApO1xuXG5cdCAgICAgICAgICBjYihlcnJvcik7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuXHQgICAgICAgIHRoaXMuZW5kKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG5cdCAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuXHQgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcblx0ICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcblx0ICAgICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuXHQgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2Vcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cblx0ICAgKiAgICAgYG1lc3NhZ2VgXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG5cdCAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3Jcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGNyZWF0ZUVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlLCBlcnJvckNvZGUpIHtcblx0ICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG5cdCAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuXHQgICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuXHQgICAgKTtcblxuXHQgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzLmNyZWF0ZUVycm9yKTtcblx0ICAgIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuXHQgICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG5cdCAgICByZXR1cm4gZXJyO1xuXHQgIH1cblx0fVxuXG5cdHJlY2VpdmVyID0gUmVjZWl2ZXI7XG5cdHJldHVybiByZWNlaXZlcjtcbn1cblxucmVxdWlyZVJlY2VpdmVyKCk7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbnZhciBzZW5kZXI7XG52YXIgaGFzUmVxdWlyZWRTZW5kZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTZW5kZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRTZW5kZXIpIHJldHVybiBzZW5kZXI7XG5cdGhhc1JlcXVpcmVkU2VuZGVyID0gMTtcblx0Y29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSQkMTtcblxuXHRjb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmVQZXJtZXNzYWdlRGVmbGF0ZSgpO1xuXHRjb25zdCB7IEVNUFRZX0JVRkZFUiwga1dlYlNvY2tldCwgTk9PUCB9ID0gcmVxdWlyZUNvbnN0YW50cygpO1xuXHRjb25zdCB7IGlzQmxvYiwgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmVWYWxpZGF0aW9uKCk7XG5cdGNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZUJ1ZmZlclV0aWwoKTtcblxuXHRjb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcblx0Y29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcblx0Y29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xuXHRsZXQgcmFuZG9tUG9vbDtcblx0bGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcblxuXHRjb25zdCBERUZBVUxUID0gMDtcblx0Y29uc3QgREVGTEFUSU5HID0gMTtcblx0Y29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XG5cblx0LyoqXG5cdCAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuXHQgKi9cblx0Y2xhc3MgU2VuZGVyIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuXHQgICAqICAgICBrZXlcblx0ICAgKi9cblx0ICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuXHQgICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cblx0ICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcblx0ICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuXHQgICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cblx0ICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXHQgICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuXHQgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG5cdCAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXHQgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuXHQgICAgdGhpcy5vbmVycm9yID0gTk9PUDtcblx0ICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuXHQgICAqICAgICBGSU4gYml0XG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcblx0ICAgKiAgICAgbWFza2luZyBrZXlcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG5cdCAgICogICAgIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcblx0ICAgKiAgICAga2V5XG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG5cdCAgICogICAgIG1vZGlmaWVkXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuXHQgICAqICAgICBSU1YxIGJpdFxuXHQgICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgIGxldCBtYXNrO1xuXHQgICAgbGV0IG1lcmdlID0gZmFsc2U7XG5cdCAgICBsZXQgb2Zmc2V0ID0gMjtcblx0ICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG5cdCAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG5cdCAgICAgIG1hc2sgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcblxuXHQgICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcblx0ICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcblx0ICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXHQgICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAvL1xuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxuXHQgICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuXHQgICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuXHQgICAgICAgIG1hc2tbMV0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuXHQgICAgICAgIG1hc2tbMl0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuXHQgICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XG5cdCAgICAgIG9mZnNldCA9IDY7XG5cdCAgICB9XG5cblx0ICAgIGxldCBkYXRhTGVuZ3RoO1xuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICAoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiZcblx0ICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG5cdCAgICAgICkge1xuXHQgICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG5cdCAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdCAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuXHQgICAgfVxuXG5cdCAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XG5cblx0ICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG5cdCAgICAgIG9mZnNldCArPSA4O1xuXHQgICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuXHQgICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG5cdCAgICAgIG9mZnNldCArPSAyO1xuXHQgICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuXHQgICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcblx0ICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG5cdCAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG5cdCAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG5cdCAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuXHQgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcblx0ICAgICAgdGFyZ2V0WzJdID0gdGFyZ2V0WzNdID0gMDtcblx0ICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG5cdCAgICB0YXJnZXRbMV0gfD0gMHg4MDtcblx0ICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG5cdCAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuXHQgICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcblx0ICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cblx0ICAgIGlmIChza2lwTWFza2luZykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG5cdCAgICBpZiAobWVyZ2UpIHtcblx0ICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcblx0ICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuXHQgICAgfVxuXG5cdCAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG5cdCAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG5cdCAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcblx0ICAgIGxldCBidWY7XG5cblx0ICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG5cdCAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuXHQgICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG5cdCAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcblx0ICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuXHQgICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcblx0ICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cblx0ICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IG9wdGlvbnMgPSB7XG5cdCAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG5cdCAgICAgIGZpbjogdHJ1ZSxcblx0ICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG5cdCAgICAgIG1hc2ssXG5cdCAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG5cdCAgICAgIG9wY29kZTogMHgwOCxcblx0ICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuXHQgICAgICByc3YxOiBmYWxzZVxuXHQgICAgfTtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG5cdCAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuXHQgICAgbGV0IGJ5dGVMZW5ndGg7XG5cdCAgICBsZXQgcmVhZE9ubHk7XG5cblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXHQgICAgICByZWFkT25seSA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcblx0ICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcblx0ICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcblx0ICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHQgICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuXHQgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IG9wdGlvbnMgPSB7XG5cdCAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG5cdCAgICAgIGZpbjogdHJ1ZSxcblx0ICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG5cdCAgICAgIG1hc2ssXG5cdCAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG5cdCAgICAgIG9wY29kZTogMHgwOSxcblx0ICAgICAgcmVhZE9ubHksXG5cdCAgICAgIHJzdjE6IGZhbHNlXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuXHQgICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG5cdCAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0ICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG5cdCAgICBsZXQgYnl0ZUxlbmd0aDtcblx0ICAgIGxldCByZWFkT25seTtcblxuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHQgICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cdCAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG5cdCAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuXHQgICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuXHQgICAgICByZWFkT25seSA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuXHQgICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdCAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG5cdCAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcblx0ICAgIH1cblxuXHQgICAgY29uc3Qgb3B0aW9ucyA9IHtcblx0ICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcblx0ICAgICAgZmluOiB0cnVlLFxuXHQgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcblx0ICAgICAgbWFzayxcblx0ICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcblx0ICAgICAgb3Bjb2RlOiAweDBhLFxuXHQgICAgICByZWFkT25seSxcblx0ICAgICAgcnN2MTogZmFsc2Vcblx0ICAgIH07XG5cblx0ICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcblx0ICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG5cdCAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcblx0ICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG5cdCAgICogICAgIG9yIHRleHRcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cblx0ICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcblx0ICAgKiAgICAgbGFzdCBvbmVcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG5cdCAgICogICAgIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuXHQgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXHQgICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG5cdCAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cblx0ICAgIGxldCBieXRlTGVuZ3RoO1xuXHQgICAgbGV0IHJlYWRPbmx5O1xuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblx0ICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcblx0ICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG5cdCAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG5cdCAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG5cdCAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0ICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcblx0ICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuXHQgICAgICBpZiAoXG5cdCAgICAgICAgcnN2MSAmJlxuXHQgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG5cdCAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuXHQgICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG5cdCAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuXHQgICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3Zlcidcblx0ICAgICAgICBdXG5cdCAgICAgICkge1xuXHQgICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcnN2MSA9IGZhbHNlO1xuXHQgICAgICBvcGNvZGUgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG5cdCAgICBjb25zdCBvcHRzID0ge1xuXHQgICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuXHQgICAgICBmaW46IG9wdGlvbnMuZmluLFxuXHQgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcblx0ICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuXHQgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuXHQgICAgICBvcGNvZGUsXG5cdCAgICAgIHJlYWRPbmx5LFxuXHQgICAgICByc3YxXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuXHQgICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG5cdCAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBibG9iIGFzIGJpbmFyeSBkYXRhLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuXHQgICAqICAgICB0aGUgZGF0YVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG5cdCAgICogICAgIEZJTiBiaXRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuXHQgICAqICAgICBtYXNraW5nIGtleVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcblx0ICAgKiAgICAgYGRhdGFgXG5cdCAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuXHQgICAqICAgICBrZXlcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcblx0ICAgKiAgICAgbW9kaWZpZWRcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG5cdCAgICogICAgIFJTVjEgYml0XG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZ2V0QmxvYkRhdGEoYmxvYiwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG5cdCAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuXHQgICAgdGhpcy5fc3RhdGUgPSBHRVRfQkxPQl9EQVRBO1xuXG5cdCAgICBibG9iXG5cdCAgICAgIC5hcnJheUJ1ZmZlcigpXG5cdCAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuXHQgICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG5cdCAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG5cdCAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXG5cdCAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAvL1xuXHQgICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xuXHQgICAgICAgICAgLy8gdGhhdCBtaWdodCBiZSB0aHJvd24gaW4gdGhlIGNhbGxiYWNrcyBiZWhhdmUgbGlrZSBlcnJvcnMgdGhyb3duXG5cdCAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuXHQgICAgICAgICAgLy9cblx0ICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbENhbGxiYWNrcywgdGhpcywgZXJyLCBjYik7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcblx0ICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG5cdCAgICAgICAgaWYgKCFjb21wcmVzcykge1xuXHQgICAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuXHQgICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG5cdCAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSlcblx0ICAgICAgLmNhdGNoKChlcnIpID0+IHtcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIGBvbkVycm9yYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayBmb3IgdGhlIHNhbWUgcmVhc29uIHRoYXRcblx0ICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG5cdCAgICAgICAgLy9cblx0ICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRXJyb3IsIHRoaXMsIGVyciwgY2IpO1xuXHQgICAgICB9KTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG5cdCAgICogICAgIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG5cdCAgICogICAgIEZJTiBiaXRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuXHQgICAqICAgICBtYXNraW5nIGtleVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcblx0ICAgKiAgICAgYGRhdGFgXG5cdCAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuXHQgICAqICAgICBrZXlcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcblx0ICAgKiAgICAgbW9kaWZpZWRcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG5cdCAgICogICAgIFJTVjEgYml0XG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG5cdCAgICBpZiAoIWNvbXByZXNzKSB7XG5cdCAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuXHQgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcblx0ICAgIHRoaXMuX3N0YXRlID0gREVGTEFUSU5HO1xuXHQgICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcblx0ICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcblx0ICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG5cdCAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG5cdCAgICAgICAgKTtcblxuXHQgICAgICAgIGNhbGxDYWxsYmFja3ModGhpcywgZXJyLCBjYik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcblx0ICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuXHQgICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG5cdCAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZGVxdWV1ZSgpIHtcblx0ICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuXHQgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG5cdCAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGVucXVldWUocGFyYW1zKSB7XG5cdCAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG5cdCAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU2VuZHMgYSBmcmFtZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcblx0ICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuXHQgICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuXHQgICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG5cdCAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG5cdCAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0c2VuZGVyID0gU2VuZGVyO1xuXG5cdC8qKlxuXHQgKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgY2FsbGJhY2tcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKSB7XG5cdCAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VuZGVyLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLl9xdWV1ZVtpXTtcblx0ICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuXHQgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGBTZW5kZXJgIGVycm9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XG5cdCAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xuXHQgIHNlbmRlci5vbmVycm9yKGVycik7XG5cdH1cblx0cmV0dXJuIHNlbmRlcjtcbn1cblxucmVxdWlyZVNlbmRlcigpO1xuXG52YXIgZXZlbnRUYXJnZXQ7XG52YXIgaGFzUmVxdWlyZWRFdmVudFRhcmdldDtcblxuZnVuY3Rpb24gcmVxdWlyZUV2ZW50VGFyZ2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRXZlbnRUYXJnZXQpIHJldHVybiBldmVudFRhcmdldDtcblx0aGFzUmVxdWlyZWRFdmVudFRhcmdldCA9IDE7XG5cblx0Y29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Y29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5cdGNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuXHRjb25zdCBrRXJyb3IgPSBTeW1ib2woJ2tFcnJvcicpO1xuXHRjb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcblx0Y29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuXHRjb25zdCBrVGFyZ2V0ID0gU3ltYm9sKCdrVGFyZ2V0Jyk7XG5cdGNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuXHRjb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG5cdC8qKlxuXHQgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG5cdCAqL1xuXHRjbGFzcyBFdmVudCB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0ICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKHR5cGUpIHtcblx0ICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuXHQgICAgdGhpc1trVHlwZV0gPSB0eXBlO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHsqfVxuXHQgICAqL1xuXHQgIGdldCB0YXJnZXQoKSB7XG5cdCAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7U3RyaW5nfVxuXHQgICAqL1xuXHQgIGdldCB0eXBlKCkge1xuXHQgICAgcmV0dXJuIHRoaXNba1R5cGVdO1xuXHQgIH1cblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0YXJnZXQnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5cdC8qKlxuXHQgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cblx0ICpcblx0ICogQGV4dGVuZHMgRXZlbnRcblx0ICovXG5cdGNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuXHQgICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuXHQgICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuXHQgICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuXHQgICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuXHQgICAgc3VwZXIodHlwZSk7XG5cblx0ICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuXHQgICAgdGhpc1trUmVhc29uXSA9IG9wdGlvbnMucmVhc29uID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMucmVhc29uO1xuXHQgICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgZ2V0IGNvZGUoKSB7XG5cdCAgICByZXR1cm4gdGhpc1trQ29kZV07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge1N0cmluZ31cblx0ICAgKi9cblx0ICBnZXQgcmVhc29uKCkge1xuXHQgICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge0Jvb2xlYW59XG5cdCAgICovXG5cdCAgZ2V0IHdhc0NsZWFuKCkge1xuXHQgICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcblx0ICB9XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3dhc0NsZWFuJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5cdC8qKlxuXHQgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG5cdCAqXG5cdCAqIEBleHRlbmRzIEV2ZW50XG5cdCAqL1xuXHRjbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcblx0ICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuXHQgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2Vcblx0ICAgKi9cblx0ICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcblx0ICAgIHN1cGVyKHR5cGUpO1xuXG5cdCAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcblx0ICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7Kn1cblx0ICAgKi9cblx0ICBnZXQgZXJyb3IoKSB7XG5cdCAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHtTdHJpbmd9XG5cdCAgICovXG5cdCAgZ2V0IG1lc3NhZ2UoKSB7XG5cdCAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG5cdCAgfVxuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cblx0LyoqXG5cdCAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG5cdCAqXG5cdCAqIEBleHRlbmRzIEV2ZW50XG5cdCAqL1xuXHRjbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG5cdCAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcblx0ICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmRhdGE9bnVsbF0gVGhlIG1lc3NhZ2UgY29udGVudFxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuXHQgICAgc3VwZXIodHlwZSk7XG5cblx0ICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHsqfVxuXHQgICAqL1xuXHQgIGdldCBkYXRhKCkge1xuXHQgICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuXHQgIH1cblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuXHQvKipcblx0ICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuXHQgKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBAbWl4aW5cblx0ICovXG5cdGNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuXHQgIC8qKlxuXHQgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcblx0ICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG5cdCAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuXHQgICAqICAgICB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcblx0ICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgICFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXSAmJlxuXHQgICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcblx0ICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXG5cdCAgICAgICkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBsZXQgd3JhcHBlcjtcblxuXHQgICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuXHQgICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG5cdCAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuXHQgICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG5cdCAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuXHQgICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XG5cdCAgICAgICAgICBjb2RlLFxuXHQgICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG5cdCAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG5cdCAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuXHQgICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuXHQgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuXHQgICAgICAgICAgZXJyb3IsXG5cdCAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG5cdCAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG5cdCAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk9wZW4oKSB7XG5cdCAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuXHQgICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcblx0ICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG5cdCAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBoYW5kbGVyO1xuXG5cdCAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG5cdCAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcblx0ICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG5cdCAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRldmVudFRhcmdldCA9IHtcblx0ICBDbG9zZUV2ZW50LFxuXHQgIEVycm9yRXZlbnQsXG5cdCAgRXZlbnQsXG5cdCAgRXZlbnRUYXJnZXQsXG5cdCAgTWVzc2FnZUV2ZW50XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcblx0ICpcblx0ICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNhbGxcblx0ICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gY2FsbExpc3RlbmVyKGxpc3RlbmVyLCB0aGlzQXJnLCBldmVudCkge1xuXHQgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnICYmIGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XG5cdCAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZywgZXZlbnQpO1xuXHQgIH1cblx0fVxuXHRyZXR1cm4gZXZlbnRUYXJnZXQ7XG59XG5cbnZhciBleHRlbnNpb247XG52YXIgaGFzUmVxdWlyZWRFeHRlbnNpb247XG5cbmZ1bmN0aW9uIHJlcXVpcmVFeHRlbnNpb24gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRFeHRlbnNpb24pIHJldHVybiBleHRlbnNpb247XG5cdGhhc1JlcXVpcmVkRXh0ZW5zaW9uID0gMTtcblxuXHRjb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmVWYWxpZGF0aW9uKCk7XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2Zcblx0ICogcGFyYW1ldGVycy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuXHQgKiBAcGFyYW0geyhPYmplY3R8Qm9vbGVhbnxTdHJpbmcpfSBlbGVtIFRoZSBleHRlbnNpb24gcGFyYW1ldGVycyBvciB0aGVcblx0ICogICAgIHBhcmFtZXRlciB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG5cdCAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcblx0ICBlbHNlIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuXHQgIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuXHQgIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG5cdCAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG5cdCAgbGV0IGV4dGVuc2lvbk5hbWU7XG5cdCAgbGV0IHBhcmFtTmFtZTtcblx0ICBsZXQgc3RhcnQgPSAtMTtcblx0ICBsZXQgY29kZSA9IC0xO1xuXHQgIGxldCBlbmQgPSAtMTtcblx0ICBsZXQgaSA9IDA7XG5cblx0ICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcblx0ICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG5cdCAgICAgIH0gZWxzZSBpZiAoXG5cdCAgICAgICAgaSAhPT0gMCAmJlxuXHQgICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuXHQgICAgICApIHtcblx0ICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG5cdCAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcblx0ICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblx0ICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHQgICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG5cdCAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcblx0ICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuXHQgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcblx0ICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcblx0ICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG5cdCAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG5cdCAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG5cdCAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcblx0ICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuXHQgICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcblx0ICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuXHQgICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG5cdCAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy9cblx0ICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcblx0ICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cblx0ICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuXHQgICAgICAvL1xuXHQgICAgICBpZiAoaXNFc2NhcGluZykge1xuXHQgICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuXHQgICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XG5cdCAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuXHQgICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG5cdCAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcblx0ICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcblx0ICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG5cdCAgICAgICAgICBlbmQgPSBpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG5cdCAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG5cdCAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuXHQgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcblx0ICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcblx0ICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblx0ICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcblx0ICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblx0ICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cdCAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuXHQgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcblx0ICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcblx0ICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuXHQgICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzIHx8IGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuXHQgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuXHQgIH1cblxuXHQgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXHQgIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHQgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwgcGFyYW1zKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHB1c2gocGFyYW1zLCB0b2tlbiwgdHJ1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuXHQgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG5cdCAgICB9XG5cdCAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcblx0ICB9XG5cblx0ICByZXR1cm4gb2ZmZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3Rcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcblx0ICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucylcblx0ICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuXHQgICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG5cdCAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcblx0ICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG5cdCAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG5cdCAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl1cblx0ICAgICAgICAgICAgLmNvbmNhdChcblx0ICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuXHQgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHBhcmFtc1trXTtcblx0ICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApKVxuXHQgICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcblx0ICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICApXG5cdCAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuXHQgICAgICAgIH0pXG5cdCAgICAgICAgLmpvaW4oJywgJyk7XG5cdCAgICB9KVxuXHQgICAgLmpvaW4oJywgJyk7XG5cdH1cblxuXHRleHRlbnNpb24gPSB7IGZvcm1hdCwgcGFyc2UgfTtcblx0cmV0dXJuIGV4dGVuc2lvbjtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG52YXIgd2Vic29ja2V0O1xudmFyIGhhc1JlcXVpcmVkV2Vic29ja2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlV2Vic29ja2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2Vic29ja2V0KSByZXR1cm4gd2Vic29ja2V0O1xuXHRoYXNSZXF1aXJlZFdlYnNvY2tldCA9IDE7XG5cblx0Y29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSQkMCQzO1xuXHRjb25zdCBodHRwcyA9IHJlcXVpcmUkJDEkMTtcblx0Y29uc3QgaHR0cCA9IHJlcXVpcmUkJDI7XG5cdGNvbnN0IG5ldCA9IHJlcXVpcmUkJDM7XG5cdGNvbnN0IHRscyA9IHJlcXVpcmUkJDQ7XG5cdGNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUkJDE7XG5cdGNvbnN0IHsgVVJMIH0gPSByZXF1aXJlJCQ3O1xuXG5cdGNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZVBlcm1lc3NhZ2VEZWZsYXRlKCk7XG5cdGNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZVJlY2VpdmVyKCk7XG5cdGNvbnN0IFNlbmRlciA9IHJlcXVpcmVTZW5kZXIoKTtcblx0Y29uc3QgeyBpc0Jsb2IgfSA9IHJlcXVpcmVWYWxpZGF0aW9uKCk7XG5cblx0Y29uc3Qge1xuXHQgIEJJTkFSWV9UWVBFUyxcblx0ICBFTVBUWV9CVUZGRVIsXG5cdCAgR1VJRCxcblx0ICBrRm9yT25FdmVudEF0dHJpYnV0ZSxcblx0ICBrTGlzdGVuZXIsXG5cdCAga1N0YXR1c0NvZGUsXG5cdCAga1dlYlNvY2tldCxcblx0ICBOT09QXG5cdH0gPSByZXF1aXJlQ29uc3RhbnRzKCk7XG5cdGNvbnN0IHtcblx0ICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cblx0fSA9IHJlcXVpcmVFdmVudFRhcmdldCgpO1xuXHRjb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmVFeHRlbnNpb24oKTtcblx0Y29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZUJ1ZmZlclV0aWwoKTtcblxuXHRjb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cdGNvbnN0IGtBYm9ydGVkID0gU3ltYm9sKCdrQWJvcnRlZCcpO1xuXHRjb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcblx0Y29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuXHRjb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuXG5cdC8qKlxuXHQgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG5cdCAqXG5cdCAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuXHQgKi9cblx0Y2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3Rcblx0ICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcblx0ICAgKi9cblx0ICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcblx0ICAgIHN1cGVyKCk7XG5cblx0ICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG5cdCAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuXHQgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuXHQgICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG5cdCAgICB0aGlzLl9lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcblx0ICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcblx0ICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcblx0ICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcblx0ICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG5cdCAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG5cdCAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG5cdCAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuX3JlZGlyZWN0cyA9IDA7XG5cblx0ICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcHJvdG9jb2xzID0gW107XG5cdCAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcblx0ICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG5cdCAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9hdXRvUG9uZyA9IG9wdGlvbnMuYXV0b1Bvbmc7XG5cdCAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuXHQgICAqIGluc3RlYWQgb2YgXCJibG9iXCIuXG5cdCAgICpcblx0ICAgKiBAdHlwZSB7U3RyaW5nfVxuXHQgICAqL1xuXHQgIGdldCBiaW5hcnlUeXBlKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG5cdCAgfVxuXG5cdCAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuXHQgICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuXHQgICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cblx0ICAgIC8vXG5cdCAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG5cdCAgICAvL1xuXHQgICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge051bWJlcn1cblx0ICAgKi9cblx0ICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG5cdCAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7U3RyaW5nfVxuXHQgICAqL1xuXHQgIGdldCBleHRlbnNpb25zKCkge1xuXHQgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICAgKi9cblx0ICBnZXQgaXNQYXVzZWQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHtGdW5jdGlvbn1cblx0ICAgKi9cblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgIGdldCBvbmNsb3NlKCkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgICAqL1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgZ2V0IG9uZXJyb3IoKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAgICovXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBnZXQgb25vcGVuKCkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgICAqL1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgZ2V0IG9ubWVzc2FnZSgpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHtTdHJpbmd9XG5cdCAgICovXG5cdCAgZ2V0IHByb3RvY29sKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgZ2V0IHJlYWR5U3RhdGUoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAdHlwZSB7U3RyaW5nfVxuXHQgICAqL1xuXHQgIGdldCB1cmwoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdXJsO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcblx0ICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXJcblx0ICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcblx0ICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG5cdCAgICogICAgIG1hc2tpbmcga2V5XG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Jcblx0ICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcblx0ICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcblx0ICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuXHQgICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG5cdCAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG5cdCAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcblx0ICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuXHQgICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG5cdCAgICB9KTtcblxuXHQgICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcblxuXHQgICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcblx0ICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcblx0ICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuXHQgICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuXHQgICAgc2VuZGVyW2tXZWJTb2NrZXRdID0gdGhpcztcblx0ICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cblx0ICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG5cdCAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuXHQgICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcblx0ICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuXHQgICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG5cdCAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuXHQgICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xuXG5cdCAgICAvL1xuXHQgICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG5cdCAgICAvL1xuXHQgICAgaWYgKHNvY2tldC5zZXRUaW1lb3V0KSBzb2NrZXQuc2V0VGltZW91dCgwKTtcblx0ICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuXHQgICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cblx0ICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcblx0ICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cdCAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcblx0ICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuXHQgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuXHQgICAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBlbWl0Q2xvc2UoKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuXHQgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcblx0ICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuXHQgICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcblx0ICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cblx0ICAgKlxuXHQgICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcblx0ICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cblx0ICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG5cdCAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcblx0ICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG5cdCAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcblx0ICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG5cdCAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG5cdCAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuXHQgICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5cdCAgICogICAgICAgICAgICAgICstLS0rXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3Npbmdcblx0ICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG5cdCAgICogICAgIGNsb3Npbmdcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgY2xvc2UoY29kZSwgZGF0YSkge1xuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcblx0ICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG5cdCAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG5cdCAgICAgICkge1xuXHQgICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXHQgICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuXHQgICAgICAvL1xuXHQgICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG5cdCAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuXHQgICAgICAvL1xuXHQgICAgICBpZiAoZXJyKSByZXR1cm47XG5cblx0ICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChcblx0ICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcblx0ICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcblx0ICAgICAgKSB7XG5cdCAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQYXVzZSB0aGUgc29ja2V0LlxuXHQgICAqXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIHBhdXNlKCkge1xuXHQgICAgaWYgKFxuXHQgICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG5cdCAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuXHQgICAgKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcblx0ICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNlbmQgYSBwaW5nLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcblx0ICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjYiA9IGRhdGE7XG5cdCAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjYiA9IG1hc2s7XG5cdCAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cblx0ICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG5cdCAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuXHQgICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBTZW5kIGEgcG9uZy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0ICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG5cdCAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY2IgPSBkYXRhO1xuXHQgICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY2IgPSBtYXNrO1xuXHQgICAgICBtYXNrID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG5cdCAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuXHQgICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcblx0ICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUmVzdW1lIHRoZSBzb2NrZXQuXG5cdCAgICpcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgcmVzdW1lKCkge1xuXHQgICAgaWYgKFxuXHQgICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG5cdCAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuXHQgICAgKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdCAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Rcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuXHQgICAqICAgICB0ZXh0XG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG5cdCAgICogICAgIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcblx0ICAgKiAgICAgbGFzdCBvbmVcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcblx0ICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjYiA9IG9wdGlvbnM7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcblx0ICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IG9wdHMgPSB7XG5cdCAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuXHQgICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG5cdCAgICAgIGNvbXByZXNzOiB0cnVlLFxuXHQgICAgICBmaW46IHRydWUsXG5cdCAgICAgIC4uLm9wdGlvbnNcblx0ICAgIH07XG5cblx0ICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuXHQgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG5cdCAgICpcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgdGVybWluYXRlKCkge1xuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuXHQgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcblx0ICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NvY2tldCkge1xuXHQgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cdCAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG5cdCAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuXHQgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxuXHR9KTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcblx0ICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcblx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcblx0fSk7XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG5cdCAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuXHQgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxuXHR9KTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cblx0ICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcblx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcblx0fSk7XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG5cdCAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuXHQgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxuXHR9KTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcblx0ICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcblx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcblx0fSk7XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcblx0ICogQG1lbWJlcm9mIFdlYlNvY2tldFxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcblx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxuXHR9KTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuXHQgKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG5cdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcblx0fSk7XG5cblx0W1xuXHQgICdiaW5hcnlUeXBlJyxcblx0ICAnYnVmZmVyZWRBbW91bnQnLFxuXHQgICdleHRlbnNpb25zJyxcblx0ICAnaXNQYXVzZWQnLFxuXHQgICdwcm90b2NvbCcsXG5cdCAgJ3JlYWR5U3RhdGUnLFxuXHQgICd1cmwnXG5cdF0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0Ly9cblx0Ly8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuXHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuXHQvL1xuXHRbJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG5cdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgZ2V0KCkge1xuXHQgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcblx0ICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfSxcblx0ICAgIHNldChoYW5kbGVyKSB7XG5cdCAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuXHQgICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcblx0ICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuXHQgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG5cdCAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0fSk7XG5cblx0V2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcblx0V2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuXHR3ZWJzb2NrZXQgPSBXZWJTb2NrZXQ7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuXHQgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3Rcblx0ICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIGFueVxuXHQgKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuXHQgKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuXHQgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xuXHQgKiAgICAgY3VzdG9taXplIHRoZSBoZWFkZXJzIG9mIGVhY2ggaHR0cCByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcblx0ICogICAgIHJlZGlyZWN0c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuXHQgKiAgICAgbWFza2luZyBrZXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcblx0ICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG5cdCAqICAgICBzaXplXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcblx0ICogICAgIGFsbG93ZWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG5cdCAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuXHQgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG5cdCAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG5cdCAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG5cdCAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG5cdCAgY29uc3Qgb3B0cyA9IHtcblx0ICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG5cdCAgICBhdXRvUG9uZzogdHJ1ZSxcblx0ICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcblx0ICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuXHQgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcblx0ICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuXHQgICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcblx0ICAgIG1heFJlZGlyZWN0czogMTAsXG5cdCAgICAuLi5vcHRpb25zLFxuXHQgICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxuXHQgICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcblx0ICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG5cdCAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG5cdCAgICBtZXRob2Q6ICdHRVQnLFxuXHQgICAgaG9zdDogdW5kZWZpbmVkLFxuXHQgICAgcGF0aDogdW5kZWZpbmVkLFxuXHQgICAgcG9ydDogdW5kZWZpbmVkXG5cdCAgfTtcblxuXHQgIHdlYnNvY2tldC5fYXV0b1BvbmcgPSBvcHRzLmF1dG9Qb25nO1xuXG5cdCAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG5cdCAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcblx0ICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcblx0ICAgICk7XG5cdCAgfVxuXG5cdCAgbGV0IHBhcnNlZFVybDtcblxuXHQgIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG5cdCAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuXHQgICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzOic7XG5cdCAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG5cdCAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG5cdCAgfVxuXG5cdCAgd2Vic29ja2V0Ll91cmwgPSBwYXJzZWRVcmwuaHJlZjtcblxuXHQgIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG5cdCAgY29uc3QgaXNJcGNVcmwgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG5cdCAgbGV0IGludmFsaWRVcmxNZXNzYWdlO1xuXG5cdCAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuXHQgICAgaW52YWxpZFVybE1lc3NhZ2UgPVxuXHQgICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xuXHQgICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG5cdCAgfSBlbHNlIGlmIChpc0lwY1VybCAmJiAhcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG5cdCAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG5cdCAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuXHQgICAgaW52YWxpZFVybE1lc3NhZ2UgPSAnVGhlIFVSTCBjb250YWlucyBhIGZyYWdtZW50IGlkZW50aWZpZXInO1xuXHQgIH1cblxuXHQgIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuXHQgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcblxuXHQgICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG5cdCAgICAgIHRocm93IGVycjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcblx0ICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHQgIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG5cdCAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG5cdCAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG5cdCAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cblx0ICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG5cdCAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG5cdCAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG5cdCAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuXHQgICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG5cdCAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcblx0ICBvcHRzLmhlYWRlcnMgPSB7XG5cdCAgICAuLi5vcHRzLmhlYWRlcnMsXG5cdCAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG5cdCAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG5cdCAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG5cdCAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuXHQgIH07XG5cdCAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcblx0ICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cblx0ICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuXHQgICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG5cdCAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG5cdCAgICAgIGZhbHNlLFxuXHQgICAgICBvcHRzLm1heFBheWxvYWRcblx0ICAgICk7XG5cdCAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcblx0ICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG5cdCAgICB9KTtcblx0ICB9XG5cdCAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcblx0ICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG5cdCAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcblx0ICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG5cdCAgICAgICkge1xuXHQgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcblx0ICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcblx0ICAgIH1cblxuXHQgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuXHQgIH1cblx0ICBpZiAob3B0cy5vcmlnaW4pIHtcblx0ICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG5cdCAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuXHQgICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuXHQgIH1cblxuXHQgIGlmIChpc0lwY1VybCkge1xuXHQgICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuXHQgICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG5cdCAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcblx0ICB9XG5cblx0ICBsZXQgcmVxO1xuXG5cdCAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG5cdCAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcblx0ICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbElwYyA9IGlzSXBjVXJsO1xuXHQgICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG5cdCAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcblx0ICAgICAgICA/IG9wdHMuc29ja2V0UGF0aFxuXHQgICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cblx0ICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuXHQgICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cdCAgICAgIC8vXG5cdCAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cblx0ICAgICAgaWYgKGhlYWRlcnMpIHtcblx0ICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuXHQgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuXHQgICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcblx0ICAgICAgICA/IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcblx0ICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuXHQgICAgICAgICAgOiBmYWxzZVxuXHQgICAgICAgIDogd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuXHQgICAgICAgICAgPyBmYWxzZVxuXHQgICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cblx0ICAgICAgaWYgKCFpc1NhbWVIb3N0IHx8ICh3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlICYmICFpc1NlY3VyZSkpIHtcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2Vcblx0ICAgICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cblx0ICAgICAgICAvL1xuXHQgICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcblx0ICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcblxuXHQgICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG5cdCAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vXG5cdCAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgbWFrZSB0aGUgZmlyc3QgYEF1dGhvcml6YXRpb25gIGhlYWRlciB3aW4uXG5cdCAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuXHQgICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG5cdCAgICAvL1xuXHQgICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcblx0ICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuXHQgICAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG5cdCAgICB9XG5cblx0ICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuXHQgICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzKSB7XG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuXHQgICAgICAvLyB0cmlnZ2VyZWQgaGVyZSBpZiB0aGUgdXNlciBjYWxscyBgd2Vic29ja2V0LmNsb3NlKClgIG9yXG5cdCAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG5cdCAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3Jcblx0ICAgICAgLy8gYmVmb3JlIGNhbGxpbmcgYHdlYnNvY2tldC5jbG9zZSgpYCBvciBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBhbmQgdGhpc1xuXHQgICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG5cdCAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cdCAgICAgIC8vXG5cdCAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblx0ICB9XG5cblx0ICBpZiAob3B0cy50aW1lb3V0KSB7XG5cdCAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG5cdCAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcblx0ICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxW2tBYm9ydGVkXSkgcmV0dXJuO1xuXG5cdCAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cdCAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG5cdCAgfSk7XG5cblx0ICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuXHQgICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcblx0ICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuXHQgICAgaWYgKFxuXHQgICAgICBsb2NhdGlvbiAmJlxuXHQgICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuXHQgICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuXHQgICAgICBzdGF0dXNDb2RlIDwgNDAwXG5cdCAgICApIHtcblx0ICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuXHQgICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICByZXEuYWJvcnQoKTtcblxuXHQgICAgICBsZXQgYWRkcjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG5cdCAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG5cdCAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZShcblx0ICAgICAgICB3ZWJzb2NrZXQsXG5cdCAgICAgICAgcmVxLFxuXHQgICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcblx0ICAgIHdlYnNvY2tldC5lbWl0KCd1cGdyYWRlJywgcmVzKTtcblxuXHQgICAgLy9cblx0ICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG5cdCAgICAvLyBgJ3VwZ3JhZGUnYCBldmVudC5cblx0ICAgIC8vXG5cdCAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cblx0ICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuXHQgICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cblx0ICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcblx0ICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuXHQgICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuXHQgICAgaWYgKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBkaWdlc3QpIHtcblx0ICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXHQgICAgbGV0IHByb3RFcnJvcjtcblxuXHQgICAgaWYgKHNlcnZlclByb3QgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcblx0ICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcblx0ICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XG5cdCAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHByb3RvY29sU2V0LnNpemUpIHtcblx0ICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcblx0ICAgIH1cblxuXHQgICAgaWYgKHByb3RFcnJvcikge1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cblx0ICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cblx0ICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuXHQgICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuXHQgICAgICAgICAgJ1NlcnZlciBzZW50IGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBidXQgbm8gZXh0ZW5zaW9uICcgK1xuXHQgICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuXHQgICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBsZXQgZXh0ZW5zaW9ucztcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuXHQgICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG5cdCAgICAgIGlmIChcblx0ICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcblx0ICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuXHQgICAgICApIHtcblx0ICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xuXHQgICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuXHQgICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuXHQgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgICAgfVxuXG5cdCAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuXHQgICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRzLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG5cdCAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG5cdCAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcblx0ICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxuXHQgICAgfSk7XG5cdCAgfSk7XG5cblx0ICBpZiAob3B0cy5maW5pc2hSZXF1ZXN0KSB7XG5cdCAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXEuZW5kKCk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuXHQgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXHQgIC8vXG5cdCAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3Jcblx0ICAvLyBjb25zaXN0ZW5jeS5cblx0ICAvL1xuXHQgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcblx0ICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG5cdCAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcblx0ICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG5cdCAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcblx0ICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuXHQgIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuXHQgIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcblx0ICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcblx0ICB9XG5cblx0ICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cblx0ICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcblx0ICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuXHQgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuXHQgIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG5cdCAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcblx0ICAgIHN0cmVhbS5hYm9ydCgpO1xuXG5cdCAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcblx0ICAgICAgLy9cblx0ICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG5cdCAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cblx0ICAgICAgLy9cblx0ICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG5cdCAgICB9XG5cblx0ICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2UsIHdlYnNvY2tldCwgZXJyKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcblx0ICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG5cdCAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcblx0ICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcblx0ICBpZiAoZGF0YSkge1xuXHQgICAgY29uc3QgbGVuZ3RoID0gaXNCbG9iKGRhdGEpID8gZGF0YS5zaXplIDogdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG5cdCAgICAvL1xuXHQgICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuXHQgICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcblx0ICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuXHQgICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cblx0ICAgIC8vXG5cdCAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcblx0ICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG5cdCAgfVxuXG5cdCAgaWYgKGNiKSB7XG5cdCAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG5cdCAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG5cdCAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuXHQgICAgKTtcblx0ICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycik7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3Npbmdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcblx0ICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG5cdCAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuXHQgIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuXHQgIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuXHQgIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0ICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cdCAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuXHQgIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcblx0ICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG5cdCAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuXHQgIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG5cdCAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuXHQgIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cblx0ICAgIC8vXG5cdCAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxuXHQgICAgLy9cblx0ICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cblx0ICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcblx0ICB9XG5cblx0ICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG5cdCAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG5cdCAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG5cdCAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3Rcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG5cdCAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcblx0ICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG5cdCAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XG5cdCAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG5cdCAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSBUaGUgcmVhZGFibGUgc3RyZWFtXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiByZXN1bWUoc3RyZWFtKSB7XG5cdCAgc3RyZWFtLnJlc3VtZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3Jcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHNlbmRlck9uRXJyb3IoZXJyKSB7XG5cdCAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuXHQgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuXHQgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcblx0ICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXHQgICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xuXHQgIH1cblxuXHQgIC8vXG5cdCAgLy8gYHNvY2tldC5lbmQoKWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzb2NrZXQuZGVzdHJveSgpYCB0byBhbGxvdyB0aGUgb3RoZXJcblx0ICAvLyBwZWVyIHRvIGZpbmlzaCBzZW5kaW5nIHF1ZXVlZCBkYXRhLiBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCBhIHRpbWVyIGhlcmVcblx0ICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG5cdCAgLy9cblx0ICB0aGlzLl9zb2NrZXQuZW5kKCk7XG5cblx0ICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG5cdCAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG5cdCAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpIHtcblx0ICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuXHQgICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcblx0ICAgIGNsb3NlVGltZW91dFxuXHQgICk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdjbG9zZSdgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcblx0ICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG5cdCAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcblx0ICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblx0ICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cblx0ICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuXHQgIGxldCBjaHVuaztcblxuXHQgIC8vXG5cdCAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcblx0ICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG5cdCAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG5cdCAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cblx0ICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuXHQgIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuXHQgIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuXHQgIC8vXG5cdCAgaWYgKFxuXHQgICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuXHQgICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG5cdCAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcblx0ICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcblx0ICApIHtcblx0ICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuXHQgIH1cblxuXHQgIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cblx0ICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG5cdCAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cblx0ICBpZiAoXG5cdCAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG5cdCAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuXHQgICkge1xuXHQgICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuXHQgICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcblx0ICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuXHQgICAgdGhpcy5wYXVzZSgpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2VuZCdgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG5cdCAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuXHQgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXHQgIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cdCAgdGhpcy5lbmQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuXHQgIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cblx0ICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXHQgIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cblx0ICBpZiAod2Vic29ja2V0KSB7XG5cdCAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblx0ICAgIHRoaXMuZGVzdHJveSgpO1xuXHQgIH1cblx0fVxuXHRyZXR1cm4gd2Vic29ja2V0O1xufVxuXG52YXIgd2Vic29ja2V0RXhwb3J0cyA9IHJlcXVpcmVXZWJzb2NrZXQoKTtcbnZhciBXUyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh3ZWJzb2NrZXRFeHBvcnRzKTtcblxudmFyIHN1YnByb3RvY29sO1xudmFyIGhhc1JlcXVpcmVkU3VicHJvdG9jb2w7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTdWJwcm90b2NvbCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFN1YnByb3RvY29sKSByZXR1cm4gc3VicHJvdG9jb2w7XG5cdGhhc1JlcXVpcmVkU3VicHJvdG9jb2wgPSAxO1xuXG5cdGNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZVZhbGlkYXRpb24oKTtcblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgaGVhZGVyIGludG8gYSBzZXQgb2Ygc3VicHJvdG9jb2wgbmFtZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcblx0ICogQHJldHVybiB7U2V0fSBUaGUgc3VicHJvdG9jb2wgbmFtZXNcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG5cdCAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXHQgIGxldCBzdGFydCA9IC0xO1xuXHQgIGxldCBlbmQgPSAtMTtcblx0ICBsZXQgaSA9IDA7XG5cblx0ICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuXHQgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuXHQgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG5cdCAgICB9IGVsc2UgaWYgKFxuXHQgICAgICBpICE9PSAwICYmXG5cdCAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuXHQgICAgKSB7XG5cdCAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcblx0ICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcblx0ICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG5cblx0ICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cblx0ICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuXHQgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG5cdCAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG5cdCAgfVxuXG5cdCAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG5cdCAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG5cdCAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuXHQgIH1cblxuXHQgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuXHQgIHJldHVybiBwcm90b2NvbHM7XG5cdH1cblxuXHRzdWJwcm90b2NvbCA9IHsgcGFyc2UgfTtcblx0cmV0dXJuIHN1YnByb3RvY29sO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbnZhciB3ZWJzb2NrZXRTZXJ2ZXI7XG52YXIgaGFzUmVxdWlyZWRXZWJzb2NrZXRTZXJ2ZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVXZWJzb2NrZXRTZXJ2ZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRXZWJzb2NrZXRTZXJ2ZXIpIHJldHVybiB3ZWJzb2NrZXRTZXJ2ZXI7XG5cdGhhc1JlcXVpcmVkV2Vic29ja2V0U2VydmVyID0gMTtcblxuXHRjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlJCQwJDM7XG5cdGNvbnN0IGh0dHAgPSByZXF1aXJlJCQyO1xuXHRjb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUkJDE7XG5cblx0Y29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZUV4dGVuc2lvbigpO1xuXHRjb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmVQZXJtZXNzYWdlRGVmbGF0ZSgpO1xuXHRjb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmVTdWJwcm90b2NvbCgpO1xuXHRjb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlV2Vic29ja2V0KCk7XG5cdGNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZUNvbnN0YW50cygpO1xuXG5cdGNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cblx0Y29uc3QgUlVOTklORyA9IDA7XG5cdGNvbnN0IENMT1NJTkcgPSAxO1xuXHRjb25zdCBDTE9TRUQgPSAyO1xuXG5cdC8qKlxuXHQgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuXHQgKlxuXHQgKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcblx0ICovXG5cdGNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcblx0ICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcblx0ICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG5cdCAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG5cdCAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcblx0ICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuXHQgICAqICAgICB0cmFjayBjbGllbnRzXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXSBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Vcblx0ICAgKiAgICAgc2l6ZVxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcblx0ICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPWZhbHNlXSBFbmFibGUvZGlzYWJsZVxuXHQgICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcblx0ICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG5cdCAgICogQHBhcmFtIHsoaHR0cC5TZXJ2ZXJ8aHR0cHMuU2VydmVyKX0gW29wdGlvbnMuc2VydmVyXSBBIHByZS1jcmVhdGVkIEhUVFAvU1xuXHQgICAqICAgICBzZXJ2ZXIgdG8gdXNlXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG5cdCAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuXHQgICAqICAgICBjbGFzcyB0byB1c2UuIEl0IG11c3QgYmUgdGhlIGBXZWJTb2NrZXRgIGNsYXNzIG9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBpdFxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG5cdCAgICovXG5cdCAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcblx0ICAgIHN1cGVyKCk7XG5cblx0ICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG5cdCAgICAgIGF1dG9Qb25nOiB0cnVlLFxuXHQgICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcblx0ICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcblx0ICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuXHQgICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG5cdCAgICAgIGNsaWVudFRyYWNraW5nOiB0cnVlLFxuXHQgICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG5cdCAgICAgIG5vU2VydmVyOiBmYWxzZSxcblx0ICAgICAgYmFja2xvZzogbnVsbCwgLy8gdXNlIGRlZmF1bHQgKDUxMSBhcyBpbXBsZW1lbnRlZCBpbiBuZXQuanMpXG5cdCAgICAgIHNlcnZlcjogbnVsbCxcblx0ICAgICAgaG9zdDogbnVsbCxcblx0ICAgICAgcGF0aDogbnVsbCxcblx0ICAgICAgcG9ydDogbnVsbCxcblx0ICAgICAgV2ViU29ja2V0LFxuXHQgICAgICAuLi5vcHRpb25zXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoXG5cdCAgICAgIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHx8XG5cdCAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG5cdCAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuXHQgICAgKSB7XG5cdCAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdCAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcblx0ICAgICAgICAgICdtdXN0IGJlIHNwZWNpZmllZCdcblx0ICAgICAgKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuXHQgICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG5cdCAgICAgICAgcmVzLndyaXRlSGVhZCg0MjYsIHtcblx0ICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuXHQgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJlcy5lbmQoYm9keSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLl9zZXJ2ZXIubGlzdGVuKFxuXHQgICAgICAgIG9wdGlvbnMucG9ydCxcblx0ICAgICAgICBvcHRpb25zLmhvc3QsXG5cdCAgICAgICAgb3B0aW9ucy5iYWNrbG9nLFxuXHQgICAgICAgIGNhbGxiYWNrXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VydmVyKSB7XG5cdCAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2VydmVyKSB7XG5cdCAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuXHQgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG5cdCAgICAgICAgbGlzdGVuaW5nOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbGlzdGVuaW5nJyksXG5cdCAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuXHQgICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuXHQgICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcblx0ICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG5cdCAgICAgIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcblx0ICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcblx0ICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuXHQgICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG5cdCAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG5cdCAgICpcblx0ICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0ICBhZGRyZXNzKCkge1xuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcblx0ICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuXHQgICAqIHdoZW4gYWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcblx0ICAgKiBAcHVibGljXG5cdCAgICovXG5cdCAgY2xvc2UoY2IpIHtcblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEKSB7XG5cdCAgICAgIGlmIChjYikge1xuXHQgICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG5cdCAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcnKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG5cdCAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcblx0ICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlciB8fCB0aGlzLm9wdGlvbnMuc2VydmVyKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcblx0ICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcblx0ICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuXHQgICAgICAgIGlmICghdGhpcy5jbGllbnRzLnNpemUpIHtcblx0ICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXI7XG5cblx0ICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG5cdCAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cblx0ICAgICAgLy9cblx0ICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuXHQgICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG5cdCAgICAgIC8vXG5cdCAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG5cdCAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3Rcblx0ICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0ICBzaG91bGRIYW5kbGUocmVxKSB7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcblx0ICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcblx0ICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cblx0ICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3Rcblx0ICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG5cdCAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cblx0ICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuXHQgICAgY29uc3QgdXBncmFkZSA9IHJlcS5oZWFkZXJzLnVwZ3JhZGU7XG5cdCAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuXHQgICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG5cdCAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBIVFRQIG1ldGhvZCc7XG5cdCAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcblx0ICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcblx0ICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCAha2V5UmVnZXgudGVzdChrZXkpKSB7XG5cdCAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG5cdCAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuXHQgICAgICBjb25zdCBtZXNzYWdlID0gJ01pc3Npbmcgb3IgaW52YWxpZCBTZWMtV2ViU29ja2V0LVZlcnNpb24gaGVhZGVyJztcblx0ICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuXHQgICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXHQgICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcblxuXHQgICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG5cdCAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG5cdCAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXHQgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdCAgICBpZiAoXG5cdCAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuXHQgICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcblx0ICAgICkge1xuXHQgICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcblx0ICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG5cdCAgICAgICAgdHJ1ZSxcblx0ICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuXHQgICAgICApO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG5cdCAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuXHQgICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG5cdCAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICBjb25zdCBtZXNzYWdlID1cblx0ICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcblx0ICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vXG5cdCAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuXHQgICAgLy9cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG5cdCAgICAgIGNvbnN0IGluZm8gPSB7XG5cdCAgICAgICAgb3JpZ2luOlxuXHQgICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcblx0ICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG5cdCAgICAgICAgcmVxXG5cdCAgICAgIH07XG5cblx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcblx0ICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcblx0ICAgICAgICAgICAgZXh0ZW5zaW9ucyxcblx0ICAgICAgICAgICAga2V5LFxuXHQgICAgICAgICAgICBwcm90b2NvbHMsXG5cdCAgICAgICAgICAgIHJlcSxcblx0ICAgICAgICAgICAgc29ja2V0LFxuXHQgICAgICAgICAgICBoZWFkLFxuXHQgICAgICAgICAgICBjYlxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcblx0ICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcblx0ICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG5cdCAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcblx0ICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuXHQgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG5cdCAgICAvL1xuXHQgICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG5cdCAgICAvL1xuXHQgICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cblx0ICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcblx0ICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG5cdCAgICAgICk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cblx0ICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuXHQgICAgICAudXBkYXRlKGtleSArIEdVSUQpXG5cdCAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG5cdCAgICBjb25zdCBoZWFkZXJzID0gW1xuXHQgICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuXHQgICAgICAnVXBncmFkZTogd2Vic29ja2V0Jyxcblx0ICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuXHQgICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcblx0ICAgIF07XG5cblx0ICAgIGNvbnN0IHdzID0gbmV3IHRoaXMub3B0aW9ucy5XZWJTb2NrZXQobnVsbCwgdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMpO1xuXG5cdCAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcblx0ICAgICAgLy9cblx0ICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuXHQgICAgICAvL1xuXHQgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcblx0ICAgICAgICA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpXG5cdCAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG5cdCAgICAgIGlmIChwcm90b2NvbCkge1xuXHQgICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcblx0ICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuXHQgICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcblx0ICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcblx0ICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG5cdCAgICAgIH0pO1xuXHQgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcblx0ICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXHQgICAgfVxuXG5cdCAgICAvL1xuXHQgICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG5cdCAgICAvL1xuXHQgICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuXHQgICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cblx0ICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcblx0ICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG5cdCAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuXHQgICAgICBza2lwVVRGOFZhbGlkYXRpb246IHRoaXMub3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cblx0ICAgIH0pO1xuXG5cdCAgICBpZiAodGhpcy5jbGllbnRzKSB7XG5cdCAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuXHQgICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG5cdCAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cblx0ICAgICAgICBpZiAodGhpcy5fc2hvdWxkRW1pdENsb3NlICYmICF0aGlzLmNsaWVudHMuc2l6ZSkge1xuXHQgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGNiKHdzLCByZXEpO1xuXHQgIH1cblx0fVxuXG5cdHdlYnNvY2tldFNlcnZlciA9IFdlYlNvY2tldFNlcnZlcjtcblxuXHQvKipcblx0ICogQWRkIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBgRXZlbnRFbWl0dGVyYCB1c2luZyBhIG1hcCBvZiA8ZXZlbnQsIGxpc3RlbmVyPlxuXHQgKiBwYWlycy5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuXHQgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuXHQgKiAgICAgY2FsbGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcblx0ICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuXHQgICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG5cdCAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG5cdCAgc2VydmVyLl9zdGF0ZSA9IENMT1NFRDtcblx0ICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBwcmVjb25kaXRpb25zIGFyZSBub3QgZnVsZmlsbGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcblx0ICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG5cdCAgLy9cblx0ICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcblx0ICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcblx0ICAvLyBlcnJvci4gSGFuZGxpbmcgdGhpcyBkb2VzIG5vdCBtYWtlIG11Y2ggc2Vuc2UgYXMgdGhlIHdvcnN0IHRoYXQgY2FuIGhhcHBlblxuXHQgIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG5cdCAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cblx0ICAvLyB0dXJuIGNhdXNlcyB0aGUgc29ja2V0IHRvIGJlIGRlc3Ryb3llZC5cblx0ICAvL1xuXHQgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuXHQgIGhlYWRlcnMgPSB7XG5cdCAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuXHQgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuXHQgICAgJ0NvbnRlbnQtTGVuZ3RoJzogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG5cdCAgICAuLi5oZWFkZXJzXG5cdCAgfTtcblxuXHQgIHNvY2tldC5vbmNlKCdmaW5pc2gnLCBzb2NrZXQuZGVzdHJveSk7XG5cblx0ICBzb2NrZXQuZW5kKFxuXHQgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcblx0ICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcblx0ICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG5cdCAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcblx0ICAgICAgJ1xcclxcblxcclxcbicgK1xuXHQgICAgICBtZXNzYWdlXG5cdCAgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuXHQgKiBvbmUgbGlzdGVuZXIgZm9yIGl0LCBvdGhlcndpc2UgY2FsbCBgYWJvcnRIYW5kc2hha2UoKWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcblx0ICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuXHQgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgSFRUUCByZXNwb25zZSBib2R5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3Ioc2VydmVyLCByZXEsIHNvY2tldCwgY29kZSwgbWVzc2FnZSkge1xuXHQgIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG5cdCAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdCAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcik7XG5cblx0ICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSk7XG5cdCAgfVxuXHR9XG5cdHJldHVybiB3ZWJzb2NrZXRTZXJ2ZXI7XG59XG5cbnJlcXVpcmVXZWJzb2NrZXRTZXJ2ZXIoKTtcblxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG52YXIgV2ViU29ja2V0ID0gV1M7XG52YXIgc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoc29ja2V0LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc29ja2V0LnNlbmQobWVzc2FnZSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBnZXRXZWJzb2NrZXQoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNldHRpbmdzLnBvbGljeSAhPSB1bmRlZmluZWQpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2V0dGluZ3MucG9saWN5KHNldHRpbmdzKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBXZWJTb2NrZXQoc2V0dGluZ3MudXJpLCBzZXR0aW5ncy5wcm90b2NvbHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxudmFyIHZhbGlkYXRpb25TdWNjZXNzID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuICh7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxufSk7IH07XG52YXIgdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoe1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yOiBlcnJvcixcbn0pOyB9O1xudmFyIGlzVmFsaWRhdG9yU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5zdWNjZXNzOyB9O1xudmFyIFdlYlNvY2tldENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRDbGllbnQoc2V0dGluZ3MsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbG9zZWRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlY2VpdmVyUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSBoYW5kbGVyLnZhbGlkYXRlO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IGhhbmRsZXIuc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0V2Vic29ja2V0KHNldHRpbmdzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNvY2tldCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb2NrZXQub25tZXNzYWdlID0gX3RoaXMuZ2V0TWVzc2FnZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0Lm9uY2xvc2UgPSBfdGhpcy5nZXRDbG9zZWRIYW5kbGVyKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNvY2tldC5vbmVycm9yID0gX3RoaXMuaGFuZGxlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSk7XG4gICAgfVxuICAgIFdlYlNvY2tldENsaWVudC5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlclF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLnJlY2VpdmVyUXVldWUuc2hpZnQoKSwgMik7IF9hWzBdOyB2YXIgcmVqZWN0ID0gX2FbMV07XG4gICAgICAgICAgICByZWplY3QoZXZlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmdldENsb3NlZEhhbmRsZXIgPSBmdW5jdGlvbiAoY2xvc2VSZXNvbHZlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgX3RoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoX3RoaXMucmVjZWl2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKF90aGlzLnJlY2VpdmVyUXVldWUuc2hpZnQoKSwgMiksIHJlc29sdmUgPSBfYVswXSwgcmVqZWN0ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZVJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFdlYlNvY2tldENsaWVudC5wcm90b3R5cGUuZ2V0TWVzc2FnZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYudmFsaWRhdGUoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRhdG9yU3VjY2VzcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yZWNlaXZlclF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHNlbGYucmVjZWl2ZXJRdWV1ZS5zaGlmdCgpLCAyKSwgcmVzb2x2ZSA9IF9hWzBdOyBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBtZXNzYWdlLCBkb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICBzZWxmLnNvY2tldC5jbG9zZSgxMDAwLCBcIlVuZXhwZWN0ZWQgbWVzc2FnZSByZWNlaXZlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFdlYlNvY2tldENsaWVudC5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3RoaXMuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5tZXNzYWdlUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF90aGlzLm1lc3NhZ2VRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IG1lc3NhZ2UsIGRvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlY2VpdmVyUXVldWUucHVzaChbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jb25uZWN0ZWRQcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlbmRNZXNzYWdlKHRoaXMuc29ja2V0LCBzZXJpYWxpemVkKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNvbm5lY3RlZFByb21pc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2xvc2VkUHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViU29ja2V0Q2xpZW50O1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5mdW5jdGlvbiBpc0tleUNyZWRlbnRpYWwoY3JlZGVudGlhbCkge1xuICAgIHJldHVybiAodHlwZW9mIGNyZWRlbnRpYWwgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgY3JlZGVudGlhbCAhPT0gbnVsbCAmJlxuICAgICAgICBcImtleVwiIGluIGNyZWRlbnRpYWwgJiZcbiAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWwua2V5ID09PSBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGlzVG9rZW5DcmVkZW50aWFsKGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBjcmVkZW50aWFsID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGNyZWRlbnRpYWwgIT09IG51bGwgJiZcbiAgICAgICAgXCJnZXRUb2tlblwiIGluIGNyZWRlbnRpYWwgJiZcbiAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWwuZ2V0VG9rZW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG52YXIgaXNDcmVkZW50aWFsID0gZnVuY3Rpb24gKGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gaXNLZXlDcmVkZW50aWFsKGNyZWRlbnRpYWwpIHx8IGlzVG9rZW5DcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xufTtcblxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG52YXIgaXNSVE9wZW5BSU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBcIm1vZGVsXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5tb2RlbCA9PT0gXCJzdHJpbmdcIik7XG59O1xudmFyIGlzUlRBenVyZU9wZW5BSU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBcImRlcGxveW1lbnRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlcGxveW1lbnQgPT09IFwic3RyaW5nXCIpO1xufTtcblxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgcmV0dXJuIFwibXMtcnRjbGllbnQvMC41LjBcIjtcbn1cbmZ1bmN0aW9uIG9wZW5BSVNldHRpbmdzKGNyZWRlbnRpYWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdXJpID0gbmV3IFVSTChcIndzczovL2FwaS5vcGVuYWkuY29tL3YxL3JlYWx0aW1lXCIpO1xuICAgIHVyaS5zZWFyY2hQYXJhbXMuc2V0KFwibW9kZWxcIiwgb3B0aW9ucy5tb2RlbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJpOiB1cmksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiLmNvbmNhdChjcmVkZW50aWFsLmtleSksXG4gICAgICAgICAgICBcIm9wZW5haS1iZXRhXCI6IFwicmVhbHRpbWU9djFcIixcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBcIm9wZW5haS1ub2RlXCIsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF6dXJlT3BlbkFJU2V0dGluZ3ModXJpLCBjcmVkZW50aWFsLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2E7XG4gICAgdmFyIHJlcXVlc3RJZCA9IChfYSA9IG9wdGlvbnMucmVxdWVzdElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIHZhciBzY29wZXMgPSBbXCJodHRwczovL2NvZ25pdGl2ZXNlcnZpY2VzLmF6dXJlLmNvbS8uZGVmYXVsdFwiXTtcbiAgICB1cmkuc2VhcmNoUGFyYW1zLnNldChcImFwaS12ZXJzaW9uXCIsIFwiMjAyNC0xMC0wMS1wcmV2aWV3XCIpO1xuICAgIHVyaS5zZWFyY2hQYXJhbXMuc2V0KFwiZGVwbG95bWVudFwiLCBvcHRpb25zLmRlcGxveW1lbnQpO1xuICAgIHVyaS5wYXRobmFtZSA9IFwib3BlbmFpL3JlYWx0aW1lXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJpOiB1cmksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBnZXRVc2VyQWdlbnQoKSxcbiAgICAgICAgICAgIFwieC1tcy1jbGllbnQtcmVxdWVzdC1pZFwiOiByZXF1ZXN0SWQsXG4gICAgICAgIH0sXG4gICAgICAgIHBvbGljeTogZnVuY3Rpb24gKHNldHRpbmdzKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzS2V5Q3JlZGVudGlhbChjcmVkZW50aWFsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oZWFkZXJzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHNldHRpbmdzLmhlYWRlcnMpLCB7IFwiYXBpLWtleVwiOiBjcmVkZW50aWFsLmtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIGNyZWRlbnRpYWwuZ2V0VG9rZW4oc2NvcGVzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGVhZGVycyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzZXR0aW5ncy5oZWFkZXJzKSwgeyBBdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodG9rZW4udG9rZW4pLCByZXF1ZXN0SWQ6IHJlcXVlc3RJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgc2V0dGluZ3NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSxcbiAgICB9O1xufVxuXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbnZhciBNZXNzYWdlUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVF1ZXVlKHJlY2VpdmVEZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLnJlY2VpdmVEZWxlZ2F0ZSA9IHJlY2VpdmVEZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLndhaXRpbmdSZWNlaXZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pc1BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb2xsUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucHVzaEJhY2sgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmZpbmRBbmRSZW1vdmUgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnBvbGxSZWNlaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1BvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbFByb21pc2UgPSB0aGlzLmRvUG9sbFJlY2VpdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wb2xsUHJvbWlzZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmRvUG9sbFJlY2VpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCA0LCA1LCA2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1BvbGxpbmcpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZWNlaXZlRGVsZWdhdGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5UmVjZWl2ZXIobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53YWl0aW5nUmVjZWl2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUVycm9yKGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNQb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMud2FpdGluZ1JlY2VpdmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy53YWl0aW5nUmVjZWl2ZXJzLnNoaWZ0KCksIDMpOyBfYVswXTsgdmFyIF9iID0gX19yZWFkKF9hWzFdLCAyKTsgX2JbMF07IHZhciByZWplY3QgPSBfYlsxXTsgX2FbMl07XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLm5vdGlmeUVuZE9mU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy53YWl0aW5nUmVjZWl2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLndhaXRpbmdSZWNlaXZlcnMuc2hpZnQoKSwgMyk7IF9hWzBdOyB2YXIgX2IgPSBfX3JlYWQoX2FbMV0sIDIpLCByZXNvbHZlID0gX2JbMF07IF9iWzFdOyBfYVsyXTtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubm90aWZ5UmVjZWl2ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLndhaXRpbmdSZWNlaXZlcnMuZmluZEluZGV4KGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgcHJlZGljYXRlID0gX2JbMF0sIF9jID0gX19yZWFkKF9iWzFdLCAyKTsgX2NbMF07IF9jWzFdOyBfYlsyXTtcbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hCYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLndhaXRpbmdSZWNlaXZlcnMuc3BsaWNlKGluZGV4LCAxKVswXSwgMyk7IF9hWzBdOyB2YXIgX2IgPSBfX3JlYWQoX2FbMV0sIDIpLCByZXNvbHZlID0gX2JbMF07IF9iWzFdOyBfYVsyXTtcbiAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucXVldWVkTWVzc2FnZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBhYm9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZm91bmRNZXNzYWdlID0gdGhpcy5maW5kQW5kUmVtb3ZlKHByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChmb3VuZE1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm91bmRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nUmVjZWl2ZXJzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCB8fCBuZXcgQWJvcnRDb250cm9sbGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucG9sbFJlY2VpdmUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VRdWV1ZTtcbn0oKSk7XG52YXIgTWVzc2FnZVF1ZXVlV2l0aEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlUXVldWVXaXRoRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVF1ZXVlV2l0aEVycm9yKHJlY2VpdmVEZWxlZ2F0ZSwgZXJyb3JQcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVjZWl2ZURlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvclByZWRpY2F0ZSA9IGVycm9yUHJlZGljYXRlO1xuICAgICAgICBfdGhpcy5lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXNzYWdlUXVldWVXaXRoRXJyb3IucHJvdG90eXBlLm5vdGlmeUVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLndhaXRpbmdSZWNlaXZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMud2FpdGluZ1JlY2VpdmVycy5zaGlmdCgpLCAyKTsgX2FbMF07IHZhciBfYiA9IF9fcmVhZChfYVsxXSwgMiksIHJlc29sdmUgPSBfYlswXTsgX2JbMV07XG4gICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWVXaXRoRXJyb3IucHJvdG90eXBlLm5vdGlmeVJlY2VpdmVyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JQcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBtZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlFcnJvck1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy53YWl0aW5nUmVjZWl2ZXJzLmZpbmRJbmRleChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIHByZWRpY2F0ZSA9IF9iWzBdLCBfYyA9IF9fcmVhZChfYlsxXSwgMik7IF9jWzBdOyBfY1sxXTsgX2JbMl07XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy53YWl0aW5nUmVjZWl2ZXJzLnNwbGljZShpbmRleCwgMSlbMF0sIDMpOyBfYVswXTsgdmFyIF9iID0gX19yZWFkKF9hWzFdLCAyKSwgcmVzb2x2ZSA9IF9iWzBdOyBfYlsxXTsgX2FbMl07XG4gICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWVXaXRoRXJyb3IucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5lcnJvcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLnJlY2VpdmUuY2FsbCh0aGlzLCBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gcHJlZGljYXRlKG1lc3NhZ2UpIHx8IF90aGlzLmVycm9yUHJlZGljYXRlKG1lc3NhZ2UpOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWVzc2FnZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VRdWV1ZVdpdGhFcnJvcjtcbn0oTWVzc2FnZVF1ZXVlKSk7XG52YXIgU2hhcmVkRW5kUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhcmVkRW5kUXVldWUocmVjZWl2ZURlbGVnYXRlLCBlcnJvclByZWRpY2F0ZSwgZW5kUHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZURlbGVnYXRlID0gcmVjZWl2ZURlbGVnYXRlO1xuICAgICAgICB0aGlzLmVycm9yUHJlZGljYXRlID0gZXJyb3JQcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuZW5kUHJlZGljYXRlID0gZW5kUHJlZGljYXRlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMubG9jayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBTaGFyZWRFbmRRdWV1ZS5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlbGVhc2UsIGksIG1lc3NhZ2UsIG1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYWNxdWlyZUxvY2soKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgLCA2LCA3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBtZXNzYWdlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbmRQcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1lc3NhZ2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZWNlaXZlRGVsZWdhdGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JQcmVkaWNhdGUobWVzc2FnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWVzc2FnZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRQcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1lc3NhZ2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNoYXJlZEVuZFF1ZXVlLnByb3RvdHlwZS5hY3F1aXJlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlbGVhc2UsIG5ld0xvY2ssIG9sZExvY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMb2NrID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkTG9jayA9IHRoaXMubG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jayA9IG5ld0xvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvbGRMb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlbGVhc2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTaGFyZWRFbmRRdWV1ZTtcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKGFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgd2luZG93LmNyeXB0byAmJlxuICAgICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGF2YWlsYWJsZS5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVJZChwcmVmaXgsIGxlbmd0aCkge1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFycmF5KSwgZmFsc2UpKSlcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIilcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgXCJcIik7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdChiYXNlNjQpLnNsaWNlKDAsIGxlbmd0aCk7XG59XG5cbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxudmFyIExvd0xldmVsUlRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG93TGV2ZWxSVENsaWVudCh1cmlPckNyZWRlbnRpYWwsIGNyZWRlbnRpYWxPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc0tleUNyZWRlbnRpYWwodXJpT3JDcmVkZW50aWFsKSAmJlxuICAgICAgICAgICAgICAgIGlzUlRPcGVuQUlPcHRpb25zKGNyZWRlbnRpYWxPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5BSVNldHRpbmdzKHVyaU9yQ3JlZGVudGlhbCwgY3JlZGVudGlhbE9yT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NyZWRlbnRpYWwoY3JlZGVudGlhbE9yT3B0aW9ucykgJiZcbiAgICAgICAgICAgICAgICBpc1JUQXp1cmVPcGVuQUlPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF6dXJlT3BlbkFJU2V0dGluZ3ModXJpT3JDcmVkZW50aWFsLCBjcmVkZW50aWFsT3JPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGluaXRpYWxpemUgdGhlIFJlYWx0aW1lIGNsaWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBzZXR0aW5ncy5yZXF1ZXN0SWQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gdGhpcy5nZXRXZWJzb2NrZXQoc2V0dGluZ3MpO1xuICAgIH1cbiAgICBMb3dMZXZlbFJUQ2xpZW50LnByb3RvdHlwZS5nZXRXZWJzb2NrZXQgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB7XG4gICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlIHR5cGVcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcnZlck1lc3NhZ2VUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvblN1Y2Nlc3MoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2UgdHlwZVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBtZXNzYWdlXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0Q2xpZW50KHNldHRpbmdzLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIExvd0xldmVsUlRDbGllbnQucHJvdG90eXBlLm1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIG1lc3NhZ2VzXzEoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgbWVzc2FnZSwgZV8xXzE7XG4gICAgICAgICAgICB2YXIgX2QsIGVfMSwgX2UsIF9mO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2cubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2cudHJ5cy5wdXNoKFswLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0cnVlLCBfYiA9IF9fYXN5bmNWYWx1ZXModGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2IubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9jID0gX2cuc2VudCgpLCBfZCA9IF9jLmRvbmUsICFfZCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2Y7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KG1lc3NhZ2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfZy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISghX2EgJiYgIV9kICYmIChfZSA9IF9iLnJldHVybikpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9lLmNhbGwoX2IpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb3dMZXZlbFJUQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNsaWVudC5zZW5kKG1lc3NhZ2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvd0xldmVsUlRDbGllbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2xpZW50LmNsb3NlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExvd0xldmVsUlRDbGllbnQ7XG59KCkpO1xudmFyIFJURXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJURXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUlRFcnJvcihlcnJvckRldGFpbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3JEZXRhaWxzLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yRGV0YWlscyA9IGVycm9yRGV0YWlscztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSVEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJURXJyb3IucHJvdG90eXBlLCBcImNvZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yRGV0YWlscy5jb2RlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJURXJyb3IucHJvdG90eXBlLCBcInBhcmFtXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckRldGFpbHMucGFyYW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUlRFcnJvci5wcm90b3R5cGUsIFwiZXZlbnRJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JEZXRhaWxzLmV2ZW50X2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJURXJyb3I7XG59KEVycm9yKSk7XG52YXIgUlRJbnB1dEF1ZGlvSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSVElucHV0QXVkaW9JdGVtKGlkLCBhdWRpb1N0YXJ0TWlsbGlzLCBoYXNUcmFuc2NyaXB0aW9uLCBxdWV1ZSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuYXVkaW9TdGFydE1pbGxpcyA9IGF1ZGlvU3RhcnRNaWxsaXM7XG4gICAgICAgIHRoaXMuaGFzVHJhbnNjcmlwdGlvbiA9IGhhc1RyYW5zY3JpcHRpb247XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJpbnB1dF9hdWRpb1wiO1xuICAgICAgICB0aGlzLmF1ZGlvRW5kTWlsbGlzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2FpdFByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICBSVElucHV0QXVkaW9JdGVtLmNyZWF0ZSA9IGZ1bmN0aW9uIChpZCwgYXVkaW9TdGFydE1pbGxpcywgaGFzVHJhbnNjcmlwdGlvbiwgcXVldWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSVElucHV0QXVkaW9JdGVtKGlkLCBhdWRpb1N0YXJ0TWlsbGlzLCBoYXNUcmFuc2NyaXB0aW9uLCBxdWV1ZSk7XG4gICAgfTtcbiAgICBSVElucHV0QXVkaW9JdGVtLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUlkVmFsaWRNZXNzYWdlLCBtZXNzYWdlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZFZhbGlkTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmNvbXBsZXRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5xdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbUlkVmFsaWRNZXNzYWdlKG0pICYmIG0uaXRlbV9pZCA9PSBfdGhpcy5pZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiICYmIG0uaXRlbS5pZCA9PSBfdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VuZE1pbGxpcyA9IG1lc3NhZ2UuYXVkaW9fZW5kX21zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUcmFuc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuaGFzVHJhbnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2NyaXB0aW9uID0gbWVzc2FnZS50cmFuc2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmZhaWxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRJbnB1dEF1ZGlvSXRlbS5wcm90b3R5cGUud2FpdEZvckNvbXBsZXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy53YWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy53YWl0UHJvbWlzZSA9IHRoaXMud2FpdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRQcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFJUSW5wdXRBdWRpb0l0ZW07XG59KCkpO1xuLyogVE9ETzogTW92ZSB0byBQQUwgc28gd2UgdXNlIEJ1ZmZlci5mcm9tIGluIE5vZGUgKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChiYXNlNjQpIHtcbiAgICB2YXIgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIHZhciBsZW5ndGggPSBiaW5hcnlTdHJpbmcubGVuZ3RoO1xuICAgIHZhciB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG52YXIgUlRBdWRpb0NvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUlRBdWRpb0NvbnRlbnQobWVzc2FnZSwgcXVldWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImF1ZGlvXCI7XG4gICAgICAgIHRoaXMuaXRlbUlkID0gbWVzc2FnZS5pdGVtX2lkO1xuICAgICAgICB0aGlzLmNvbnRlbnRJbmRleCA9IG1lc3NhZ2UuY29udGVudF9pbmRleDtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGFydCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydCA9IG1lc3NhZ2UucGFydDtcbiAgICAgICAgdGhpcy5jb250ZW50UXVldWUgPSBuZXcgU2hhcmVkRW5kUXVldWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZUNvbnRlbnQoKTsgfSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09IG51bGwgJiYgbS50eXBlID09PSBcImVycm9yXCI7IH0sIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICE9PSBudWxsICYmIG0udHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiOyB9KTtcbiAgICB9XG4gICAgUlRBdWRpb0NvbnRlbnQuY3JlYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHF1ZXVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUlRBdWRpb0NvbnRlbnQobWVzc2FnZSwgcXVldWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJUQXVkaW9Db250ZW50LnByb3RvdHlwZSwgXCJ0cmFuc2NyaXB0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0LnRyYW5zY3JpcHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSVEF1ZGlvQ29udGVudC5wcm90b3R5cGUucmVjZWl2ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRNZXNzYWdlKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXCJyZXNwb25zZS5hdWRpby5kZWx0YVwiLFxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2UuYXVkaW8uZG9uZVwiLFxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kZWx0YVwiLFxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lXCIsXG4gICAgICAgICAgICAgICAgXCJyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZVwiLFxuICAgICAgICAgICAgXS5pbmNsdWRlcyhtLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkTWVzc2FnZShtKSAmJlxuICAgICAgICAgICAgICAgIG0uaXRlbV9pZCA9PT0gX3RoaXMuaXRlbUlkICYmXG4gICAgICAgICAgICAgICAgbS5jb250ZW50X2luZGV4ID09PSBfdGhpcy5jb250ZW50SW5kZXg7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRBdWRpb0NvbnRlbnQucHJvdG90eXBlLmF1ZGlvQ2h1bmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIGF1ZGlvQ2h1bmtzXzEoKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSwgYnVmZmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh0aGlzLmNvbnRlbnRRdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJyZXNwb25zZS5hdWRpby5kZWx0YVwiLCBcInJlc3BvbnNlLmF1ZGlvLmRvbmVcIl0uaW5jbHVkZXMobS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZSA9PT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmNvbnRlbnRfcGFydC5kb25lXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcnQudHlwZSAhPT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXJ0IHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnQgPSBtZXNzYWdlLnBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmF1ZGlvLmRlbHRhXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGRlY29kZUJhc2U2NChtZXNzYWdlLmRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoYnVmZmVyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuYXVkaW8uZG9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNraXBwaW5nIHRoaXMgYXMgaXQncyBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IHByb3ZpZGVkIGJ5ICdyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhhdCBpcyBhIGJldHRlciBzaWduYWwgdG8gZW5kIHRoZSBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRBdWRpb0NvbnRlbnQucHJvdG90eXBlLnRyYW5zY3JpcHRDaHVua3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gdHJhbnNjcmlwdENodW5rc18xKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHRoaXMuY29udGVudFF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZG9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlID09PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBhcnQgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydCA9IG1lc3NhZ2UucGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kZWx0YVwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KG1lc3NhZ2UuZGVsdGEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBza2lwcGluZyB0aGlzIGFzIGl0J3MgaW5mb3JtYXRpb24gaXMgYWxyZWFkeSBwcm92aWRlZCBieSAncmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoYXQgaXMgYSBiZXR0ZXIgc2lnbmFsIHRvIGVuZCB0aGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSVEF1ZGlvQ29udGVudDtcbn0oKSk7XG52YXIgUlRUZXh0Q29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSVFRleHRDb250ZW50KG1lc3NhZ2UsIHF1ZXVlKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIHRoaXMuaXRlbUlkID0gbWVzc2FnZS5pdGVtX2lkO1xuICAgICAgICB0aGlzLmNvbnRlbnRJbmRleCA9IG1lc3NhZ2UuY29udGVudF9pbmRleDtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXJ0IHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0ID0gbWVzc2FnZS5wYXJ0O1xuICAgIH1cbiAgICBSVFRleHRDb250ZW50LmNyZWF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBxdWV1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJUVGV4dENvbnRlbnQobWVzc2FnZSwgcXVldWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJUVGV4dENvbnRlbnQucHJvdG90eXBlLCBcInRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnQudGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJUVGV4dENvbnRlbnQucHJvdG90eXBlLnRleHRDaHVua3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gdGV4dENodW5rc18xKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh0aGlzLnF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtLnR5cGUgPT09IFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZGVsdGFcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZG9uZVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5pdGVtX2lkID09PSBfdGhpcy5pdGVtSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uY29udGVudF9pbmRleCA9PT0gX3RoaXMuY29udGVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlID09PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGFydCB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0ID0gbWVzc2FnZS5wYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS50ZXh0LmRlbHRhXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQobWVzc2FnZS5kZWx0YSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLnRleHQuZG9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNraXBwaW5nIHRoaXMgYXMgaXQncyBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IHByb3ZpZGVkIGJ5ICdyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhhdCBpcyBhIGJldHRlciBzaWduYWwgdG8gZW5kIHRoZSBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJUVGV4dENvbnRlbnQ7XG59KCkpO1xudmFyIFJUTWVzc2FnZUl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUlRNZXNzYWdlSXRlbShyZXNwb25zZUlkLCBpdGVtLCBwcmV2aW91c0l0ZW1JZCwgcXVldWUpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUlkID0gcmVzcG9uc2VJZDtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0l0ZW1JZCA9IHByZXZpb3VzSXRlbUlkO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMudHlwZSA9IFwibWVzc2FnZVwiO1xuICAgIH1cbiAgICBSVE1lc3NhZ2VJdGVtLmNyZWF0ZSA9IGZ1bmN0aW9uIChyZXNwb25zZUlkLCBpdGVtLCBwcmV2aW91c0l0ZW1JZCwgcXVldWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSVE1lc3NhZ2VJdGVtKHJlc3BvbnNlSWQsIGl0ZW0sIHByZXZpb3VzSXRlbUlkLCBxdWV1ZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUlRNZXNzYWdlSXRlbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW0uaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUlRNZXNzYWdlSXRlbS5wcm90b3R5cGUsIFwicm9sZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5yb2xlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJUTWVzc2FnZUl0ZW0ucHJvdG90eXBlLCBcInN0YXR1c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5zdGF0dXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSVE1lc3NhZ2VJdGVtLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gX2EoKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHRoaXMucXVldWUucmVjZWl2ZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG0udHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWRcIiAmJiBtLml0ZW1faWQgPT09IF90aGlzLmlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG0udHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lXCIgJiYgbS5pdGVtLmlkID09PSBfdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UgPT09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2Uub3V0cHV0X2l0ZW0uZG9uZVwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5pdGVtLnR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtID0gbWVzc2FnZS5pdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBpdGVtIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWRcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucGFydC50eXBlID09PSBcImF1ZGlvXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoUlRBdWRpb0NvbnRlbnQuY3JlYXRlKG1lc3NhZ2UsIHRoaXMucXVldWUpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KFJUVGV4dENvbnRlbnQuY3JlYXRlKG1lc3NhZ2UsIHRoaXMucXVldWUpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBhcnQgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UucGFydC50eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGU6IFwiLmNvbmNhdChtZXNzYWdlLnR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUlRNZXNzYWdlSXRlbTtcbn0oKSk7XG52YXIgUlRGdW5jdGlvbkNhbGxJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJURnVuY3Rpb25DYWxsSXRlbShyZXNwb25zZUlkLCBpdGVtLCBwcmV2aW91c0l0ZW1JZCwgcXVldWUpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUlkID0gcmVzcG9uc2VJZDtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0l0ZW1JZCA9IHByZXZpb3VzSXRlbUlkO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiZnVuY3Rpb25fY2FsbFwiO1xuICAgICAgICB0aGlzLmF3YWl0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGVyYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBSVEZ1bmN0aW9uQ2FsbEl0ZW0uY3JlYXRlID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQsIGl0ZW0sIHByZXZpb3VzSXRlbUlkLCBxdWV1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJURnVuY3Rpb25DYWxsSXRlbShyZXNwb25zZUlkLCBpdGVtLCBwcmV2aW91c0l0ZW1JZCwgcXVldWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJURnVuY3Rpb25DYWxsSXRlbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW0uaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUlRGdW5jdGlvbkNhbGxJdGVtLnByb3RvdHlwZSwgXCJmdW5jdGlvbk5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW0ubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVEZ1bmN0aW9uQ2FsbEl0ZW0ucHJvdG90eXBlLCBcImNhbGxJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5jYWxsX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJURnVuY3Rpb25DYWxsSXRlbS5wcm90b3R5cGUsIFwiYXJndW1lbnRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmFyZ3VtZW50cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJURnVuY3Rpb25DYWxsSXRlbS5wcm90b3R5cGUuaW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gaW5uZXJfMSgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5xdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG0udHlwZSA9PSBcInJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcInJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmVcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaXRlbV9pZCA9PT0gX3RoaXMuaWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobS50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIiAmJiBtLml0ZW0uaWQgPT09IF90aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZSA9PT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaXRlbS50eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbSA9IG1lc3NhZ2UuaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaXRlbSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGFcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChtZXNzYWdlLmRlbHRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UudHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSVEZ1bmN0aW9uQ2FsbEl0ZW0ucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiBfYSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF3YWl0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBhZnRlciBhd2FpdGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5pbm5lcigpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRGdW5jdGlvbkNhbGxJdGVtLnByb3RvdHlwZS53YWl0Rm9yQ29tcGxldGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIGVfMl8xO1xuICAgICAgICAgICAgdmFyIF9kLCBlXzIsIF9lO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2cubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXdhaXQgYWZ0ZXIgaXRlcmF0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLnRyeXMucHVzaChbMSwgNiwgNywgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdHJ1ZSwgX2IgPSBfX2FzeW5jVmFsdWVzKHRoaXMuaW5uZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2IubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2MgPSBfZy5zZW50KCksIF9kID0gX2MuZG9uZSwgIV9kKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy50cnlzLnB1c2goWzcsICwgMTAsIDExXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISghX2EgJiYgIV9kICYmIChfZSA9IF9iLnJldHVybikpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9lLmNhbGwoX2IpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUlRGdW5jdGlvbkNhbGxJdGVtO1xufSgpKTtcbmZ1bmN0aW9uIGlzTWVzc2FnZUl0ZW0oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnR5cGUgPT09IFwibWVzc2FnZVwiO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkNhbGxJdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIjtcbn1cbnZhciBSVFJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJUUmVzcG9uc2UocmVzcG9uc2UsIHF1ZXVlLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSBcInJlc3BvbnNlXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBSVFJlc3BvbnNlLmNyZWF0ZSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcXVldWUsIGNsaWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFJUUmVzcG9uc2UocmVzcG9uc2UsIHF1ZXVlLCBjbGllbnQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJUUmVzcG9uc2UucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVFJlc3BvbnNlLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVFJlc3BvbnNlLnByb3RvdHlwZSwgXCJzdGF0dXNEZXRhaWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXNfZGV0YWlscztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVFJlc3BvbnNlLnByb3RvdHlwZSwgXCJvdXRwdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLm91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVFJlc3BvbnNlLnByb3RvdHlwZSwgXCJ1c2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2UudXNhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSVFJlc3BvbnNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBlXzNfMTtcbiAgICAgICAgICAgIHZhciBfZCwgZV8zLCBfZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2cpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9nLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXNwb25zZS5jYW5jZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRydWUsIF9iID0gX19hc3luY1ZhbHVlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYyA9IF9nLnNlbnQoKSwgX2QgPSBfYy5kb25lLCAhX2QpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzNfMSA9IF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFfYSAmJiAhX2QgJiYgKF9lID0gX2IucmV0dXJuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9lLmNhbGwoX2IpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJUUmVzcG9uc2UucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSwgY3JlYXRlZF9tZXNzYWdlLCBtZXNzYWdlSXRlbSwgZnVuY3Rpb25DYWxsSXRlbTtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5xdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG0udHlwZSA9PT0gXCJyZXNwb25zZS5kb25lXCIgJiYgbS5yZXNwb25zZS5pZCA9PT0gX3RoaXMuaWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG0udHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucmVzcG9uc2VfaWQgPT09IF90aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZSA9PT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGUgPT09IFwicmVzcG9uc2UuZG9uZVwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5xdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS50eXBlID09PSBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaXRlbS5pZCA9PT0gbWVzc2FnZS5pdGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9tZXNzYWdlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVkX21lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlZF9tZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihjcmVhdGVkX21lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjcmVhdGVkX21lc3NhZ2UudHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZWRfbWVzc2FnZS5pdGVtLnR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSXRlbSA9IFJUTWVzc2FnZUl0ZW0uY3JlYXRlKHRoaXMuaWQsIGNyZWF0ZWRfbWVzc2FnZS5pdGVtLCBjcmVhdGVkX21lc3NhZ2UucHJldmlvdXNfaXRlbV9pZCwgdGhpcy5xdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyB2YWx1ZTogbWVzc2FnZUl0ZW0sIGRvbmU6IGZhbHNlIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZWRfbWVzc2FnZS5pdGVtLnR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxJdGVtID0gUlRGdW5jdGlvbkNhbGxJdGVtLmNyZWF0ZSh0aGlzLmlkLCBjcmVhdGVkX21lc3NhZ2UuaXRlbSwgY3JlYXRlZF9tZXNzYWdlLnByZXZpb3VzX2l0ZW1faWQsIHRoaXMucXVldWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IGZ1bmN0aW9uQ2FsbEl0ZW0sIGRvbmU6IGZhbHNlIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBpdGVtIHR5cGUgKFwiLmNvbmNhdChjcmVhdGVkX21lc3NhZ2UuaXRlbS50eXBlLCBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogXCIuY29uY2F0KGNyZWF0ZWRfbWVzc2FnZS50eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UudHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFJUUmVzcG9uc2U7XG59KCkpO1xudmFyIFJUQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJUQ2xpZW50KHVyaU9yQ3JlZGVudGlhbCwgY3JlZGVudGlhbE9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLml0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsaWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNLZXlDcmVkZW50aWFsKHVyaU9yQ3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExvd0xldmVsUlRDbGllbnQodXJpT3JDcmVkZW50aWFsLCBjcmVkZW50aWFsT3JPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTG93TGV2ZWxSVENsaWVudCh1cmlPckNyZWRlbnRpYWwsIGNyZWRlbnRpYWxPck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzSXRlcmFibGUgPSB0aGlzLmNsaWVudC5tZXNzYWdlcygpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IG5ldyBNZXNzYWdlUXVldWVXaXRoRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZU1lc3NhZ2VzKCk7IH0sIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnR5cGUgPT09IFwiZXJyb3JcIjsgfSk7XG4gICAgfVxuICAgIFJUQ2xpZW50LnByb3RvdHlwZS5yZWNlaXZlTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubWVzc2FnZXNJdGVyYWJsZS5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRvbmUgPyBudWxsIDogcmVzdWx0LnZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUlRDbGllbnQucHJvdG90eXBlLCBcInJlcXVlc3RJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3RJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJUQ2xpZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pbml0UHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlID09PSBcInNlc3Npb24uY3JlYXRlZFwiOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIHNlc3Npb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwic2Vzc2lvbi5jcmVhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG1lc3NhZ2Uuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xuICAgIH07XG4gICAgUlRDbGllbnQucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaW5pdCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2Vzc2lvbi51cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlID09PSBcInNlc3Npb24udXBkYXRlZFwiOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgc2Vzc2lvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJzZXNzaW9uLnVwZGF0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWVzc2FnZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbWVzc2FnZS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2Vzc2lvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRDbGllbnQucHJvdG90eXBlLnNlbmRBdWRpbyA9IGZ1bmN0aW9uIChhdWRpbykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZTY0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmluaXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhdWRpbyksIGZhbHNlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmFwcGVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpbzogYmFzZTY0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJUQ2xpZW50LnByb3RvdHlwZS5jb21taXRBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmluaXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2xpZW50LnNlbmQoeyB0eXBlOiBcImlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXRcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZSA9PT0gXCJpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0dGVkXCI7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbW1pdCBhdWRpb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFJUSW5wdXRBdWRpb0l0ZW0uY3JlYXRlKG1lc3NhZ2UuaXRlbV9pZCwgdW5kZWZpbmVkLCAoKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbikgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24pICE9PSBudWxsLCB0aGlzLm1lc3NhZ2VRdWV1ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRDbGllbnQucHJvdG90eXBlLmNsZWFyQXVkaW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmluaXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2xpZW50LnNlbmQoeyB0eXBlOiBcImlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhclwiIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlID09PSBcImlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmVkXCI7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNsZWFyIGF1ZGlvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtZXNzYWdlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUlRDbGllbnQucHJvdG90eXBlLnNlbmRJdGVtID0gZnVuY3Rpb24gKGl0ZW0sIHByZXZpb3VzSXRlbUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmluaXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaWQgPSBpdGVtLmlkIHx8IGdlbmVyYXRlSWQoXCJpdGVtXCIsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2xpZW50LnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19pdGVtX2lkOiBwcmV2aW91c0l0ZW1JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkXCIgJiYgbS5pdGVtLmlkID09PSBpdGVtLmlkOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgaXRlbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJURXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1lc3NhZ2UuaXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSVENsaWVudC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaW5pdCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1faWQ6IGl0ZW1JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubWVzc2FnZVF1ZXVlLnJlY2VpdmUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkXCIgJiYgbS5pdGVtX2lkID09PSBpdGVtSWQ7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBpdGVtXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSVENsaWVudC5wcm90b3R5cGUuZ2VuZXJhdGVSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaW5pdCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuc2VuZCh7IHR5cGU6IFwicmVzcG9uc2UuY3JlYXRlXCIgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISF0aGlzLml0ZXJhdGluZykgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLm1lc3NhZ2VRdWV1ZS5yZWNlaXZlKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnR5cGUgPT09IFwicmVzcG9uc2UuY3JlYXRlZFwiOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSVEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcInJlc3BvbnNlLmNyZWF0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBSVFJlc3BvbnNlLmNyZWF0ZShtZXNzYWdlLnJlc3BvbnNlLCB0aGlzLm1lc3NhZ2VRdWV1ZSwgdGhpcy5jbGllbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWVzc2FnZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJUQ2xpZW50LnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gZXZlbnRzXzEoKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsICwgMTMsIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5tZXNzYWdlUXVldWUucmVjZWl2ZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS50eXBlID09PSBcImlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RhcnRlZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT09IFwicmVzcG9uc2UuY3JlYXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlID09PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJlcnJvclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlRFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50eXBlID09PSBcImlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RhcnRlZFwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KFJUSW5wdXRBdWRpb0l0ZW0uY3JlYXRlKG1lc3NhZ2UuaXRlbV9pZCwgbWVzc2FnZS5hdWRpb19zdGFydF9tcywgKChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24pICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24pICE9PSBudWxsLCB0aGlzLm1lc3NhZ2VRdWV1ZSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZSA9PT0gXCJyZXNwb25zZS5jcmVhdGVkXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KFJUUmVzcG9uc2UuY3JlYXRlKG1lc3NhZ2UucmVzcG9uc2UsIHRoaXMubWVzc2FnZVF1ZXVlLCB0aGlzLmNsaWVudCkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWVzc2FnZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSVENsaWVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQuY2xvc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUlRDbGllbnQ7XG59KCkpO1xuXG5leHBvcnQgeyBMb3dMZXZlbFJUQ2xpZW50LCBNZXNzYWdlSXRlbVR5cGUsIFJUQ2xpZW50LCBSVEVycm9yLCBpc0Z1bmN0aW9uQ2FsbEl0ZW0sIGlzTWVzc2FnZUl0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbInJlcXVpcmUkJDAkMiIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQwJDEiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMCQzIiwicmVxdWlyZSQkMSQxIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwicmVxdWlyZSQkNyIsIk1lc3NhZ2VJdGVtVHlwZSIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwiSXRlcmF0b3IiLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2Iiwib3AiLCJwb3AiLCJwdXNoIiwiX192YWx1ZXMiLCJvIiwibSIsIl9fcmVhZCIsInIiLCJhciIsImVycm9yIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwic2xpY2UiLCJjb25jYXQiLCJfX2F3YWl0IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJxIiwiQXN5bmNJdGVyYXRvciIsImF3YWl0UmV0dXJuIiwiYSIsInJlc3VtZSIsInNldHRsZSIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsImlzUmVhbHRpbWVFdmVudCIsImlzU2VydmVyTWVzc2FnZVR5cGUiLCJpbmNsdWRlcyIsInR5cGUiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiYnVmZmVyVXRpbCIsImV4cG9ydHMiLCJjb25zdGFudHMiLCJoYXNSZXF1aXJlZENvbnN0YW50cyIsInJlcXVpcmVDb25zdGFudHMiLCJCSU5BUllfVFlQRVMiLCJoYXNCbG9iIiwiQmxvYiIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsImhhc1JlcXVpcmVkQnVmZmVyVXRpbCIsInJlcXVpcmVCdWZmZXJVdGlsIiwiRmFzdEJ1ZmZlciIsInNwZWNpZXMiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsImJ1ZiIsInNldCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJfbWFzayIsInNvdXJjZSIsIm1hc2siLCJvdXRwdXQiLCJfdW5tYXNrIiwidG9BcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJ0b0J1ZmZlciIsImRhdGEiLCJyZWFkT25seSIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJ1bm1hc2siLCJwcm9jZXNzIiwiZW52IiwiV1NfTk9fQlVGRkVSX1VUSUwiLCJidWZmZXJVdGlsJDEiLCJyZXF1aXJlIiwibGltaXRlciIsImhhc1JlcXVpcmVkTGltaXRlciIsInJlcXVpcmVMaW1pdGVyIiwia0RvbmUiLCJrUnVuIiwiTGltaXRlciIsImNvbmN1cnJlbmN5IiwicGVuZGluZyIsIkluZmluaXR5Iiwiam9icyIsImFkZCIsImpvYiIsInBlcm1lc3NhZ2VEZWZsYXRlIiwiaGFzUmVxdWlyZWRQZXJtZXNzYWdlRGVmbGF0ZSIsInJlcXVpcmVQZXJtZXNzYWdlRGVmbGF0ZSIsInpsaWIiLCJUUkFJTEVSIiwia1Blck1lc3NhZ2VEZWZsYXRlIiwia1RvdGFsTGVuZ3RoIiwia0NhbGxiYWNrIiwia0J1ZmZlcnMiLCJrRXJyb3IiLCJ6bGliTGltaXRlciIsIlBlck1lc3NhZ2VEZWZsYXRlIiwib3B0aW9ucyIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsIl9tYXhQYXlsb2FkIiwiX29wdGlvbnMiLCJfdGhyZXNob2xkIiwidGhyZXNob2xkIiwidW5kZWZpbmVkIiwiX2lzU2VydmVyIiwiX2RlZmxhdGUiLCJfaW5mbGF0ZSIsInBhcmFtcyIsImNvbmN1cnJlbmN5TGltaXQiLCJleHRlbnNpb25OYW1lIiwib2ZmZXIiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIiwiY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIiLCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzIiwiY2xpZW50TWF4V2luZG93Qml0cyIsImNsaWVudF9tYXhfd2luZG93X2JpdHMiLCJhY2NlcHQiLCJjb25maWd1cmF0aW9ucyIsIm5vcm1hbGl6ZVBhcmFtcyIsImFjY2VwdEFzU2VydmVyIiwiYWNjZXB0QXNDbGllbnQiLCJjbGVhbnVwIiwiY2xvc2UiLCJjYWxsYmFjayIsIm9mZmVycyIsIm9wdHMiLCJhY2NlcHRlZCIsImZpbmQiLCJyZXNwb25zZSIsImZvckVhY2giLCJrZXlzIiwia2V5IiwibnVtIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZGVjb21wcmVzcyIsImZpbiIsIl9kZWNvbXByZXNzIiwiZXJyIiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZXNldCIsImNyZWF0ZURlZmxhdGVSYXciLCJ6bGliRGVmbGF0ZU9wdGlvbnMiLCJkZWZsYXRlT25EYXRhIiwiWl9TWU5DX0ZMVVNIIiwiY2h1bmsiLCJSYW5nZUVycm9yIiwiY29kZSIsInJlbW92ZUxpc3RlbmVyIiwidmFsaWRhdGlvbiIsImhhc1JlcXVpcmVkVmFsaWRhdGlvbiIsInJlcXVpcmVWYWxpZGF0aW9uIiwiaXNVdGY4IiwidG9rZW5DaGFycyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiX2lzVmFsaWRVVEY4IiwibGVuIiwiaXNCbG9iIiwiYXJyYXlCdWZmZXIiLCJzdHJlYW0iLCJ0b1N0cmluZ1RhZyIsImlzVmFsaWRVVEY4IiwiV1NfTk9fVVRGXzhfVkFMSURBVEUiLCJyZWNlaXZlciIsImhhc1JlcXVpcmVkUmVjZWl2ZXIiLCJyZXF1aXJlUmVjZWl2ZXIiLCJXcml0YWJsZSIsIkdFVF9JTkZPIiwiR0VUX1BBWUxPQURfTEVOR1RIXzE2IiwiR0VUX1BBWUxPQURfTEVOR1RIXzY0IiwiR0VUX01BU0siLCJHRVRfREFUQSIsIklORkxBVElORyIsIkRFRkVSX0VWRU5UIiwiUmVjZWl2ZXIiLCJfYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJfc2tpcFVURjhWYWxpZGF0aW9uIiwic2tpcFVURjhWYWxpZGF0aW9uIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfYnVmZmVycyIsIl9jb21wcmVzc2VkIiwiX3BheWxvYWRMZW5ndGgiLCJfZnJhZ21lbnRlZCIsIl9tYXNrZWQiLCJfZmluIiwiX29wY29kZSIsIl90b3RhbFBheWxvYWRMZW5ndGgiLCJfbWVzc2FnZUxlbmd0aCIsIl9mcmFnbWVudHMiLCJfZXJyb3JlZCIsIl9sb29wIiwiX3N0YXRlIiwiX3dyaXRlIiwiZW5jb2RpbmciLCJjYiIsInN0YXJ0TG9vcCIsImNvbnN1bWUiLCJkc3QiLCJVaW50OEFycmF5IiwiZ2V0SW5mbyIsImdldFBheWxvYWRMZW5ndGgxNiIsImdldFBheWxvYWRMZW5ndGg2NCIsImdldE1hc2siLCJnZXREYXRhIiwiY3JlYXRlRXJyb3IiLCJjb21wcmVzc2VkIiwiaGF2ZUxlbmd0aCIsInJlYWRVSW50MTZCRSIsInJlYWRVSW50MzJCRSIsIk1hdGgiLCJwb3ciLCJjb250cm9sTWVzc2FnZSIsImRhdGFNZXNzYWdlIiwicGVyTWVzc2FnZURlZmxhdGUiLCJtZXNzYWdlTGVuZ3RoIiwiZnJhZ21lbnRzIiwiZW1pdCIsInNldEltbWVkaWF0ZSIsImVuZCIsIkVycm9yQ3RvciIsInByZWZpeCIsInN0YXR1c0NvZGUiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInNlbmRlciIsImhhc1JlcXVpcmVkU2VuZGVyIiwicmVxdWlyZVNlbmRlciIsInJhbmRvbUZpbGxTeW5jIiwiYXBwbHlNYXNrIiwia0J5dGVMZW5ndGgiLCJtYXNrQnVmZmVyIiwiUkFORE9NX1BPT0xfU0laRSIsInJhbmRvbVBvb2wiLCJyYW5kb21Qb29sUG9pbnRlciIsIkRFRkFVTFQiLCJERUZMQVRJTkciLCJHRVRfQkxPQl9EQVRBIiwiU2VuZGVyIiwic29ja2V0IiwiZ2VuZXJhdGVNYXNrIiwiX2dlbmVyYXRlTWFzayIsIl9tYXNrQnVmZmVyIiwiX3NvY2tldCIsIl9maXJzdEZyYWdtZW50IiwiX3F1ZXVlIiwib25lcnJvciIsImZyYW1lIiwibWVyZ2UiLCJza2lwTWFza2luZyIsImRhdGFMZW5ndGgiLCJwYXlsb2FkTGVuZ3RoIiwib3Bjb2RlIiwicnN2MSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsImVucXVldWUiLCJkaXNwYXRjaCIsInNlbmRGcmFtZSIsInBpbmciLCJzaXplIiwiZ2V0QmxvYkRhdGEiLCJwb25nIiwic2VuZCIsImJpbmFyeSIsImJsb2IiLCJkZXN0cm95ZWQiLCJuZXh0VGljayIsImNhbGxDYWxsYmFja3MiLCJkZXF1ZXVlIiwiY2F0Y2giLCJvbkVycm9yIiwiUmVmbGVjdCIsImNvcmsiLCJ1bmNvcmsiLCJldmVudFRhcmdldCIsImhhc1JlcXVpcmVkRXZlbnRUYXJnZXQiLCJyZXF1aXJlRXZlbnRUYXJnZXQiLCJrQ29kZSIsImtEYXRhIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50IiwicmVhc29uIiwid2FzQ2xlYW4iLCJFcnJvckV2ZW50IiwiTWVzc2FnZUV2ZW50IiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwid3JhcHBlciIsIm9uTWVzc2FnZSIsImlzQmluYXJ5IiwiZXZlbnQiLCJ0b1N0cmluZyIsImNhbGxMaXN0ZW5lciIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25PcGVuIiwib25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVFdmVudCIsImV4dGVuc2lvbiIsImhhc1JlcXVpcmVkRXh0ZW5zaW9uIiwicmVxdWlyZUV4dGVuc2lvbiIsImRlc3QiLCJlbGVtIiwicGFyc2UiLCJoZWFkZXIiLCJtdXN0VW5lc2NhcGUiLCJpc0VzY2FwaW5nIiwiaW5RdW90ZXMiLCJwYXJhbU5hbWUiLCJzdGFydCIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInJlcGxhY2UiLCJ0b2tlbiIsImZvcm1hdCIsIm1hcCIsImlzQXJyYXkiLCJrIiwidmFsdWVzIiwiam9pbiIsIndlYnNvY2tldCIsImhhc1JlcXVpcmVkV2Vic29ja2V0IiwicmVxdWlyZVdlYnNvY2tldCIsIkV2ZW50RW1pdHRlciIsImh0dHBzIiwiaHR0cCIsIm5ldCIsInRscyIsInJhbmRvbUJ5dGVzIiwiY3JlYXRlSGFzaCIsIlVSTCIsImNsb3NlVGltZW91dCIsImtBYm9ydGVkIiwicHJvdG9jb2xWZXJzaW9ucyIsInJlYWR5U3RhdGVzIiwic3VicHJvdG9jb2xSZWdleCIsIldlYlNvY2tldCIsImFkZHJlc3MiLCJwcm90b2NvbHMiLCJfY2xvc2VDb2RlIiwiX2Nsb3NlTWVzc2FnZSIsIl9jbG9zZVRpbWVyIiwiX2Vycm9yRW1pdHRlZCIsIl9wYXVzZWQiLCJfcHJvdG9jb2wiLCJfcmVhZHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJfcmVjZWl2ZXIiLCJfc2VuZGVyIiwiX2J1ZmZlcmVkQW1vdW50IiwiX3JlZGlyZWN0cyIsImluaXRBc0NsaWVudCIsIl9hdXRvUG9uZyIsImF1dG9Qb25nIiwiYnVmZmVyZWRBbW91bnQiLCJfd3JpdGFibGVTdGF0ZSIsImlzUGF1c2VkIiwib25jbG9zZSIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsInByb3RvY29sIiwicmVhZHlTdGF0ZSIsInVybCIsIl91cmwiLCJzZXRTb2NrZXQiLCJoZWFkIiwicmVjZWl2ZXJPbkNvbmNsdWRlIiwicmVjZWl2ZXJPbkRyYWluIiwicmVjZWl2ZXJPbkVycm9yIiwicmVjZWl2ZXJPbk1lc3NhZ2UiLCJyZWNlaXZlck9uUGluZyIsInJlY2VpdmVyT25Qb25nIiwic2VuZGVyT25FcnJvciIsInNldFRpbWVvdXQiLCJzZXROb0RlbGF5IiwidW5zaGlmdCIsInNvY2tldE9uQ2xvc2UiLCJzb2NrZXRPbkRhdGEiLCJzb2NrZXRPbkVuZCIsInNvY2tldE9uRXJyb3IiLCJPUEVOIiwiZW1pdENsb3NlIiwiQ0xPU0VEIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwibXNnIiwiYWJvcnRIYW5kc2hha2UiLCJfcmVxIiwiQ0xPU0lORyIsImVycm9yRW1pdHRlZCIsInNldENsb3NlVGltZXIiLCJwYXVzZSIsInNlbmRBZnRlckNsb3NlIiwibmVlZERyYWluIiwidGVybWluYXRlIiwiZGVzdHJveSIsImluZGV4T2YiLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsInByb3RvY29sVmVyc2lvbiIsImZvbGxvd1JlZGlyZWN0cyIsIm1heFJlZGlyZWN0cyIsInNvY2tldFBhdGgiLCJob3N0bmFtZSIsInRpbWVvdXQiLCJob3N0IiwicGF0aCIsInBvcnQiLCJwYXJzZWRVcmwiLCJocmVmIiwiaXNTZWN1cmUiLCJpc0lwY1VybCIsImludmFsaWRVcmxNZXNzYWdlIiwicGF0aG5hbWUiLCJoYXNoIiwiZW1pdEVycm9yQW5kQ2xvc2UiLCJkZWZhdWx0UG9ydCIsInJlcXVlc3QiLCJwcm90b2NvbFNldCIsIlNldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ0bHNDb25uZWN0IiwibmV0Q29ubmVjdCIsInN0YXJ0c1dpdGgiLCJoZWFkZXJzIiwiQ29ubmVjdGlvbiIsIlVwZ3JhZGUiLCJzZWFyY2giLCJoYW5kc2hha2VUaW1lb3V0IiwidGVzdCIsImhhcyIsIm9yaWdpbiIsIk9yaWdpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwicGFydHMiLCJzcGxpdCIsInJlcSIsIl9vcmlnaW5hbElwYyIsIl9vcmlnaW5hbFNlY3VyZSIsIl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGgiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJsaXN0ZW5lckNvdW50IiwiaXNTYW1lSG9zdCIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJyZXMiLCJsb2NhdGlvbiIsImFib3J0IiwiYWRkciIsInVwZ3JhZGUiLCJkaWdlc3QiLCJ1cGRhdGUiLCJzZXJ2ZXJQcm90IiwicHJvdEVycm9yIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsImV4dGVuc2lvbk5hbWVzIiwiZmluaXNoUmVxdWVzdCIsImNvbm5lY3QiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsInNldEhlYWRlciIsImJpbmQiLCJyZWNlaXZlck9uRmluaXNoIiwicmVhZCIsImNsZWFyVGltZW91dCIsImZpbmlzaGVkIiwid2Vic29ja2V0RXhwb3J0cyIsIldTIiwic3VicHJvdG9jb2wiLCJoYXNSZXF1aXJlZFN1YnByb3RvY29sIiwicmVxdWlyZVN1YnByb3RvY29sIiwid2Vic29ja2V0U2VydmVyIiwiaGFzUmVxdWlyZWRXZWJzb2NrZXRTZXJ2ZXIiLCJyZXF1aXJlV2Vic29ja2V0U2VydmVyIiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiV2ViU29ja2V0U2VydmVyIiwiaGFuZGxlUHJvdG9jb2xzIiwiY2xpZW50VHJhY2tpbmciLCJ2ZXJpZnlDbGllbnQiLCJub1NlcnZlciIsImJhY2tsb2ciLCJzZXJ2ZXIiLCJfc2VydmVyIiwiY3JlYXRlU2VydmVyIiwiU1RBVFVTX0NPREVTIiwid3JpdGVIZWFkIiwibGlzdGVuIiwiZW1pdENvbm5lY3Rpb24iLCJfcmVtb3ZlTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXJzIiwibGlzdGVuaW5nIiwiaGFuZGxlVXBncmFkZSIsImNsaWVudHMiLCJfc2hvdWxkRW1pdENsb3NlIiwic2hvdWxkSGFuZGxlIiwiaW5kZXgiLCJ2ZXJzaW9uIiwiYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yIiwic2VjV2ViU29ja2V0UHJvdG9jb2wiLCJpbmZvIiwic2VjdXJlIiwiYXV0aG9yaXplZCIsImVuY3J5cHRlZCIsInZlcmlmaWVkIiwiY29tcGxldGVVcGdyYWRlIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsIndzIiwiZGVsZXRlIiwicmVtb3ZlTGlzdGVuZXJzIiwiaCIsInNlbmRNZXNzYWdlIiwiZ2V0V2Vic29ja2V0Iiwic2V0dGluZ3MiLCJfYSIsInBvbGljeSIsInVyaSIsInZhbGlkYXRpb25TdWNjZXNzIiwic3VjY2VzcyIsInZhbGlkYXRpb25FcnJvciIsImlzVmFsaWRhdG9yU3VjY2VzcyIsIldlYlNvY2tldENsaWVudCIsIl90aGlzIiwiY2xvc2VkUHJvbWlzZSIsIm1lc3NhZ2VRdWV1ZSIsInJlY2VpdmVyUXVldWUiLCJ2YWxpZGF0ZSIsInNlcmlhbGl6ZSIsImNvbm5lY3RlZFByb21pc2UiLCJfYiIsImdldE1lc3NhZ2VIYW5kbGVyIiwiZ2V0Q2xvc2VkSGFuZGxlciIsImhhbmRsZUVycm9yIiwiY2xvc2VSZXNvbHZlIiwic2VsZiIsInNlcmlhbGl6ZWQiLCJpc0tleUNyZWRlbnRpYWwiLCJjcmVkZW50aWFsIiwiaXNUb2tlbkNyZWRlbnRpYWwiLCJnZXRUb2tlbiIsImlzQ3JlZGVudGlhbCIsImlzUlRPcGVuQUlPcHRpb25zIiwibW9kZWwiLCJpc1JUQXp1cmVPcGVuQUlPcHRpb25zIiwiZGVwbG95bWVudCIsImdldFVzZXJBZ2VudCIsIm9wZW5BSVNldHRpbmdzIiwic2VhcmNoUGFyYW1zIiwiQXV0aG9yaXphdGlvbiIsImF6dXJlT3BlbkFJU2V0dGluZ3MiLCJyZXF1ZXN0SWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwic2NvcGVzIiwiTWVzc2FnZVF1ZXVlIiwicmVjZWl2ZURlbGVnYXRlIiwibWVzc2FnZXMiLCJ3YWl0aW5nUmVjZWl2ZXJzIiwiaXNQb2xsaW5nIiwicG9sbFByb21pc2UiLCJwdXNoQmFjayIsImZpbmRBbmRSZW1vdmUiLCJwcmVkaWNhdGUiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwb2xsUmVjZWl2ZSIsImRvUG9sbFJlY2VpdmUiLCJlcnJvcl8xIiwibm90aWZ5RW5kT2ZTdHJlYW0iLCJub3RpZnlSZWNlaXZlciIsIm5vdGlmeUVycm9yIiwiX2MiLCJxdWV1ZWRNZXNzYWdlQ291bnQiLCJyZWNlaXZlIiwiZm91bmRNZXNzYWdlIiwiQWJvcnRDb250cm9sbGVyIiwiTWVzc2FnZVF1ZXVlV2l0aEVycm9yIiwiX3N1cGVyIiwiZXJyb3JQcmVkaWNhdGUiLCJub3RpZnlFcnJvck1lc3NhZ2UiLCJTaGFyZWRFbmRRdWV1ZSIsImVuZFByZWRpY2F0ZSIsInF1ZXVlIiwibG9jayIsInJlbGVhc2UiLCJhY3F1aXJlTG9jayIsIm5ld0xvY2siLCJvbGRMb2NrIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYXJyYXkiLCJ3aW5kb3ciLCJnZW5lcmF0ZUlkIiwiYmFzZTY0IiwiYnRvYSIsImZyb21DaGFyQ29kZSIsIkxvd0xldmVsUlRDbGllbnQiLCJ1cmlPckNyZWRlbnRpYWwiLCJjcmVkZW50aWFsT3JPcHRpb25zIiwiY2xpZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2VzXzEiLCJlXzFfMSIsIl9kIiwiZV8xIiwiX2UiLCJfZiIsIl9nIiwicmV0dXJuIiwiUlRFcnJvciIsImVycm9yRGV0YWlscyIsImNvbmZpZ3VyYWJsZSIsInBhcmFtIiwiZXZlbnRfaWQiLCJSVElucHV0QXVkaW9JdGVtIiwiaWQiLCJhdWRpb1N0YXJ0TWlsbGlzIiwiaGFzVHJhbnNjcmlwdGlvbiIsImF1ZGlvRW5kTWlsbGlzIiwidHJhbnNjcmlwdGlvbiIsIndhaXRQcm9taXNlIiwid2FpdCIsIml0ZW1JZFZhbGlkTWVzc2FnZSIsIml0ZW1faWQiLCJpdGVtIiwiYXVkaW9fZW5kX21zIiwidHJhbnNjcmlwdCIsIndhaXRGb3JDb21wbGV0aW9uIiwiZGVjb2RlQmFzZTY0IiwiYmluYXJ5U3RyaW5nIiwiYXRvYiIsInVpbnQ4QXJyYXkiLCJSVEF1ZGlvQ29udGVudCIsIml0ZW1JZCIsImNvbnRlbnRJbmRleCIsImNvbnRlbnRfaW5kZXgiLCJwYXJ0IiwiY29udGVudFF1ZXVlIiwicmVjZWl2ZUNvbnRlbnQiLCJpc1ZhbGlkTWVzc2FnZSIsImF1ZGlvQ2h1bmtzIiwiYXVkaW9DaHVua3NfMSIsImRlbHRhIiwidHJhbnNjcmlwdENodW5rcyIsInRyYW5zY3JpcHRDaHVua3NfMSIsIlJUVGV4dENvbnRlbnQiLCJ0ZXh0IiwidGV4dENodW5rcyIsInRleHRDaHVua3NfMSIsIlJUTWVzc2FnZUl0ZW0iLCJyZXNwb25zZUlkIiwicHJldmlvdXNJdGVtSWQiLCJyb2xlIiwic3RhdHVzIiwiUlRGdW5jdGlvbkNhbGxJdGVtIiwiYXdhaXRlZCIsIml0ZXJhdGVkIiwiY2FsbF9pZCIsImlubmVyIiwiaW5uZXJfMSIsImVfMl8xIiwiZV8yIiwiaXNNZXNzYWdlSXRlbSIsImlzRnVuY3Rpb25DYWxsSXRlbSIsIlJUUmVzcG9uc2UiLCJzdGF0dXNfZGV0YWlscyIsInVzYWdlIiwiY2FuY2VsIiwiZV8zXzEiLCJlXzMiLCJjcmVhdGVkX21lc3NhZ2UiLCJtZXNzYWdlSXRlbSIsImZ1bmN0aW9uQ2FsbEl0ZW0iLCJyZXNwb25zZV9pZCIsInByZXZpb3VzX2l0ZW1faWQiLCJSVENsaWVudCIsIml0ZXJhdGluZyIsIm1lc3NhZ2VzSXRlcmFibGUiLCJyZWNlaXZlTWVzc2FnZXMiLCJpbml0IiwiaW5pdFByb21pc2UiLCJzZXNzaW9uIiwiY29uZmlndXJlIiwic2VuZEF1ZGlvIiwiYXVkaW8iLCJjb21taXRBdWRpbyIsImlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24iLCJjbGVhckF1ZGlvIiwic2VuZEl0ZW0iLCJyZW1vdmVJdGVtIiwiZ2VuZXJhdGVSZXNwb25zZSIsImV2ZW50cyIsImV2ZW50c18xIiwiYXVkaW9fc3RhcnRfbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rt-client/dist/esm/index.js\n");

/***/ })

};
;
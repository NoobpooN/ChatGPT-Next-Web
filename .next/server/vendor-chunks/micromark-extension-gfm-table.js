"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-table";
exports.ids = ["vendor-chunks/micromark-extension-gfm-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableHtml: () => (/* binding */ gfmTableHtml)\n/* harmony export */ });\n/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('./syntax.js').Align} Align\n */ const alignment = {\n    none: \"\",\n    left: ' align=\"left\"',\n    right: ' align=\"right\"',\n    center: ' align=\"center\"'\n};\n/** @type {HtmlExtension} */ const gfmTableHtml = {\n    enter: {\n        table (token) {\n            /** @type {Array<Align>} */ // @ts-expect-error Custom.\n            const tableAlign = token._align;\n            this.lineEndingIfNeeded();\n            this.tag(\"<table>\");\n            this.setData(\"tableAlign\", tableAlign);\n        },\n        tableBody () {\n            // Clear slurping line ending from the delimiter row.\n            this.setData(\"slurpOneLineEnding\");\n            this.tag(\"<tbody>\");\n        },\n        tableData () {\n            const tableAlign = /** @type {Array<Align>} */ this.getData(\"tableAlign\");\n            const tableColumn = /** @type {number} */ this.getData(\"tableColumn\");\n            const align = alignment[tableAlign[tableColumn]];\n            if (align === undefined) {\n                // Capture results to ignore them.\n                this.buffer();\n            } else {\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + align + \">\");\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"<thead>\");\n        },\n        tableHeader () {\n            const tableAlign = /** @type {Array<Align>} */ this.getData(\"tableAlign\");\n            const tableColumn = /** @type {number} */ this.getData(\"tableColumn\");\n            const align = alignment[tableAlign[tableColumn]];\n            this.lineEndingIfNeeded();\n            this.tag(\"<th\" + align + \">\");\n        },\n        tableRow () {\n            this.setData(\"tableColumn\", 0);\n            this.lineEndingIfNeeded();\n            this.tag(\"<tr>\");\n        }\n    },\n    exit: {\n        // Overwrite the default code text data handler to unescape escaped pipes when\n        // they are in tables.\n        codeTextData (token) {\n            let value = this.sliceSerialize(token);\n            if (this.getData(\"tableAlign\")) {\n                value = value.replace(/\\\\([\\\\|])/g, replace);\n            }\n            this.raw(this.encode(value));\n        },\n        table () {\n            this.setData(\"tableAlign\");\n            // If there was no table body, make sure the slurping from the delimiter row\n            // is cleared.\n            this.setData(\"slurpAllLineEndings\");\n            this.lineEndingIfNeeded();\n            this.tag(\"</table>\");\n        },\n        tableBody () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</tbody>\");\n        },\n        tableData () {\n            const tableAlign = /** @type {Array<Align>} */ this.getData(\"tableAlign\");\n            const tableColumn = /** @type {number} */ this.getData(\"tableColumn\");\n            if (tableColumn in tableAlign) {\n                this.tag(\"</td>\");\n                this.setData(\"tableColumn\", tableColumn + 1);\n            } else {\n                // Stop capturing.\n                this.resume();\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</thead>\");\n            this.setData(\"slurpOneLineEnding\", true);\n        // Slurp the line ending from the delimiter row.\n        },\n        tableHeader () {\n            const tableColumn = /** @type {number} */ this.getData(\"tableColumn\");\n            this.tag(\"</th>\");\n            this.setData(\"tableColumn\", tableColumn + 1);\n        },\n        tableRow () {\n            const tableAlign = /** @type {Array<Align>} */ this.getData(\"tableAlign\");\n            let tableColumn = /** @type {number} */ this.getData(\"tableColumn\");\n            while(tableColumn < tableAlign.length){\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + alignment[tableAlign[tableColumn]] + \"></td>\");\n                tableColumn++;\n            }\n            this.setData(\"tableColumn\", tableColumn);\n            this.lineEndingIfNeeded();\n            this.tag(\"</tr>\");\n        }\n    }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */ function replace($0, $1) {\n    // Pipes work, backslashes don’t (but can’t escape pipes).\n    return $1 === \"|\" ? $1 : $0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9odG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FFRCxNQUFNQSxZQUFZO0lBQ2hCQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0FBQ1Y7QUFFQSwwQkFBMEIsR0FDbkIsTUFBTUMsZUFBZTtJQUMxQkMsT0FBTztRQUNMQyxPQUFNQyxLQUFLO1lBQ1QseUJBQXlCLEdBQ3pCLDJCQUEyQjtZQUMzQixNQUFNQyxhQUFhRCxNQUFNRSxNQUFNO1lBQy9CLElBQUksQ0FBQ0Msa0JBQWtCO1lBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1lBQ1QsSUFBSSxDQUFDQyxPQUFPLENBQUMsY0FBY0o7UUFDN0I7UUFDQUs7WUFDRSxxREFBcUQ7WUFDckQsSUFBSSxDQUFDRCxPQUFPLENBQUM7WUFDYixJQUFJLENBQUNELEdBQUcsQ0FBQztRQUNYO1FBQ0FHO1lBQ0UsTUFBTU4sYUFBYSx5QkFBeUIsR0FDMUMsSUFBSSxDQUFDTyxPQUFPLENBQUM7WUFFZixNQUFNQyxjQUFjLG1CQUFtQixHQUFJLElBQUksQ0FBQ0QsT0FBTyxDQUFDO1lBQ3hELE1BQU1FLFFBQVFsQixTQUFTLENBQUNTLFVBQVUsQ0FBQ1EsWUFBWSxDQUFDO1lBRWhELElBQUlDLFVBQVVDLFdBQVc7Z0JBQ3ZCLGtDQUFrQztnQkFDbEMsSUFBSSxDQUFDQyxNQUFNO1lBQ2IsT0FBTztnQkFDTCxJQUFJLENBQUNULGtCQUFrQjtnQkFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUU0sUUFBUTtZQUMzQjtRQUNGO1FBQ0FHO1lBQ0UsSUFBSSxDQUFDVixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7UUFDWDtRQUNBVTtZQUNFLE1BQU1iLGFBQWEseUJBQXlCLEdBQzFDLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBRWYsTUFBTUMsY0FBYyxtQkFBbUIsR0FBSSxJQUFJLENBQUNELE9BQU8sQ0FBQztZQUN4RCxNQUFNRSxRQUFRbEIsU0FBUyxDQUFDUyxVQUFVLENBQUNRLFlBQVksQ0FBQztZQUVoRCxJQUFJLENBQUNOLGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQyxRQUFRTSxRQUFRO1FBQzNCO1FBQ0FLO1lBQ0UsSUFBSSxDQUFDVixPQUFPLENBQUMsZUFBZTtZQUM1QixJQUFJLENBQUNGLGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztRQUNYO0lBQ0Y7SUFDQVksTUFBTTtRQUNKLDhFQUE4RTtRQUM5RSxzQkFBc0I7UUFDdEJDLGNBQWFqQixLQUFLO1lBQ2hCLElBQUlrQixRQUFRLElBQUksQ0FBQ0MsY0FBYyxDQUFDbkI7WUFFaEMsSUFBSSxJQUFJLENBQUNRLE9BQU8sQ0FBQyxlQUFlO2dCQUM5QlUsUUFBUUEsTUFBTUUsT0FBTyxDQUFDLGNBQWNBO1lBQ3RDO1lBRUEsSUFBSSxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNKO1FBQ3ZCO1FBQ0FuQjtZQUNFLElBQUksQ0FBQ00sT0FBTyxDQUFDO1lBQ2IsNEVBQTRFO1lBQzVFLGNBQWM7WUFDZCxJQUFJLENBQUNBLE9BQU8sQ0FBQztZQUNiLElBQUksQ0FBQ0Ysa0JBQWtCO1lBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1FBQ1g7UUFDQUU7WUFDRSxJQUFJLENBQUNILGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztRQUNYO1FBQ0FHO1lBQ0UsTUFBTU4sYUFBYSx5QkFBeUIsR0FDMUMsSUFBSSxDQUFDTyxPQUFPLENBQUM7WUFFZixNQUFNQyxjQUFjLG1CQUFtQixHQUFJLElBQUksQ0FBQ0QsT0FBTyxDQUFDO1lBRXhELElBQUlDLGVBQWVSLFlBQVk7Z0JBQzdCLElBQUksQ0FBQ0csR0FBRyxDQUFDO2dCQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVJLGNBQWM7WUFDNUMsT0FBTztnQkFDTCxrQkFBa0I7Z0JBQ2xCLElBQUksQ0FBQ2MsTUFBTTtZQUNiO1FBQ0Y7UUFDQVY7WUFDRSxJQUFJLENBQUNWLGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDLHNCQUFzQjtRQUNuQyxnREFBZ0Q7UUFDbEQ7UUFDQVM7WUFDRSxNQUFNTCxjQUFjLG1CQUFtQixHQUFJLElBQUksQ0FBQ0QsT0FBTyxDQUFDO1lBQ3hELElBQUksQ0FBQ0osR0FBRyxDQUFDO1lBQ1QsSUFBSSxDQUFDQyxPQUFPLENBQUMsZUFBZUksY0FBYztRQUM1QztRQUNBTTtZQUNFLE1BQU1kLGFBQWEseUJBQXlCLEdBQzFDLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBRWYsSUFBSUMsY0FBYyxtQkFBbUIsR0FBSSxJQUFJLENBQUNELE9BQU8sQ0FBQztZQUV0RCxNQUFPQyxjQUFjUixXQUFXdUIsTUFBTSxDQUFFO2dCQUN0QyxJQUFJLENBQUNyQixrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDLFFBQVFaLFNBQVMsQ0FBQ1MsVUFBVSxDQUFDUSxZQUFZLENBQUMsR0FBRztnQkFDdERBO1lBQ0Y7WUFFQSxJQUFJLENBQUNKLE9BQU8sQ0FBQyxlQUFlSTtZQUM1QixJQUFJLENBQUNOLGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztRQUNYO0lBQ0Y7QUFDRixFQUFDO0FBRUQ7Ozs7Q0FJQyxHQUNELFNBQVNnQixRQUFRSyxFQUFFLEVBQUVDLEVBQUU7SUFDckIsMERBQTBEO0lBQzFELE9BQU9BLE9BQU8sTUFBTUEsS0FBS0Q7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2h0bWwuanM/ZWE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSHRtbEV4dGVuc2lvbn0gSHRtbEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9zeW50YXguanMnKS5BbGlnbn0gQWxpZ25cbiAqL1xuXG5jb25zdCBhbGlnbm1lbnQgPSB7XG4gIG5vbmU6ICcnLFxuICBsZWZ0OiAnIGFsaWduPVwibGVmdFwiJyxcbiAgcmlnaHQ6ICcgYWxpZ249XCJyaWdodFwiJyxcbiAgY2VudGVyOiAnIGFsaWduPVwiY2VudGVyXCInXG59XG5cbi8qKiBAdHlwZSB7SHRtbEV4dGVuc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBnZm1UYWJsZUh0bWwgPSB7XG4gIGVudGVyOiB7XG4gICAgdGFibGUodG9rZW4pIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QWxpZ24+fSAqL1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDdXN0b20uXG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdG9rZW4uX2FsaWduXG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPHRhYmxlPicpXG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQWxpZ24nLCB0YWJsZUFsaWduKVxuICAgIH0sXG4gICAgdGFibGVCb2R5KCkge1xuICAgICAgLy8gQ2xlYXIgc2x1cnBpbmcgbGluZSBlbmRpbmcgZnJvbSB0aGUgZGVsaW1pdGVyIHJvdy5cbiAgICAgIHRoaXMuc2V0RGF0YSgnc2x1cnBPbmVMaW5lRW5kaW5nJylcbiAgICAgIHRoaXMudGFnKCc8dGJvZHk+JylcbiAgICB9LFxuICAgIHRhYmxlRGF0YSgpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi8gKFxuICAgICAgICB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgKVxuICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKSlcbiAgICAgIGNvbnN0IGFsaWduID0gYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXVxuXG4gICAgICBpZiAoYWxpZ24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDYXB0dXJlIHJlc3VsdHMgdG8gaWdub3JlIHRoZW0uXG4gICAgICAgIHRoaXMuYnVmZmVyKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgdGhpcy50YWcoJzx0ZCcgKyBhbGlnbiArICc+JylcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlSGVhZCgpIHtcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8dGhlYWQ+JylcbiAgICB9LFxuICAgIHRhYmxlSGVhZGVyKCkge1xuICAgICAgY29uc3QgdGFibGVBbGlnbiA9IC8qKiBAdHlwZSB7QXJyYXk8QWxpZ24+fSAqLyAoXG4gICAgICAgIHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICApXG4gICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpKVxuICAgICAgY29uc3QgYWxpZ24gPSBhbGlnbm1lbnRbdGFibGVBbGlnblt0YWJsZUNvbHVtbl1dXG5cbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8dGgnICsgYWxpZ24gKyAnPicpXG4gICAgfSxcbiAgICB0YWJsZVJvdygpIHtcbiAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCAwKVxuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzx0cj4nKVxuICAgIH1cbiAgfSxcbiAgZXhpdDoge1xuICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBjb2RlIHRleHQgZGF0YSBoYW5kbGVyIHRvIHVuZXNjYXBlIGVzY2FwZWQgcGlwZXMgd2hlblxuICAgIC8vIHRoZXkgYXJlIGluIHRhYmxlcy5cbiAgICBjb2RlVGV4dERhdGEodG9rZW4pIHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG5cbiAgICAgIGlmICh0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwoW1xcXFx8XSkvZywgcmVwbGFjZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXcodGhpcy5lbmNvZGUodmFsdWUpKVxuICAgIH0sXG4gICAgdGFibGUoKSB7XG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIHRhYmxlIGJvZHksIG1ha2Ugc3VyZSB0aGUgc2x1cnBpbmcgZnJvbSB0aGUgZGVsaW1pdGVyIHJvd1xuICAgICAgLy8gaXMgY2xlYXJlZC5cbiAgICAgIHRoaXMuc2V0RGF0YSgnc2x1cnBBbGxMaW5lRW5kaW5ncycpXG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90YWJsZT4nKVxuICAgIH0sXG4gICAgdGFibGVCb2R5KCkge1xuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzwvdGJvZHk+JylcbiAgICB9LFxuICAgIHRhYmxlRGF0YSgpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi8gKFxuICAgICAgICB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgKVxuICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKSlcblxuICAgICAgaWYgKHRhYmxlQ29sdW1uIGluIHRhYmxlQWxpZ24pIHtcbiAgICAgICAgdGhpcy50YWcoJzwvdGQ+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0b3AgY2FwdHVyaW5nLlxuICAgICAgICB0aGlzLnJlc3VtZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUhlYWQoKSB7XG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90aGVhZD4nKVxuICAgICAgdGhpcy5zZXREYXRhKCdzbHVycE9uZUxpbmVFbmRpbmcnLCB0cnVlKVxuICAgICAgLy8gU2x1cnAgdGhlIGxpbmUgZW5kaW5nIGZyb20gdGhlIGRlbGltaXRlciByb3cuXG4gICAgfSxcbiAgICB0YWJsZUhlYWRlcigpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldERhdGEoJ3RhYmxlQ29sdW1uJykpXG4gICAgICB0aGlzLnRhZygnPC90aD4nKVxuICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICB9LFxuICAgIHRhYmxlUm93KCkge1xuICAgICAgY29uc3QgdGFibGVBbGlnbiA9IC8qKiBAdHlwZSB7QXJyYXk8QWxpZ24+fSAqLyAoXG4gICAgICAgIHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICApXG4gICAgICBsZXQgdGFibGVDb2x1bW4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKSlcblxuICAgICAgd2hpbGUgKHRhYmxlQ29sdW1uIDwgdGFibGVBbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPHRkJyArIGFsaWdubWVudFt0YWJsZUFsaWduW3RhYmxlQ29sdW1uXV0gKyAnPjwvdGQ+JylcbiAgICAgICAgdGFibGVDb2x1bW4rK1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQ29sdW1uJywgdGFibGVDb2x1bW4pXG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90cj4nKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogQHBhcmFtIHtzdHJpbmd9ICQxXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlKCQwLCAkMSkge1xuICAvLyBQaXBlcyB3b3JrLCBiYWNrc2xhc2hlcyBkb27igJl0IChidXQgY2Fu4oCZdCBlc2NhcGUgcGlwZXMpLlxuICByZXR1cm4gJDEgPT09ICd8JyA/ICQxIDogJDBcbn1cbiJdLCJuYW1lcyI6WyJhbGlnbm1lbnQiLCJub25lIiwibGVmdCIsInJpZ2h0IiwiY2VudGVyIiwiZ2ZtVGFibGVIdG1sIiwiZW50ZXIiLCJ0YWJsZSIsInRva2VuIiwidGFibGVBbGlnbiIsIl9hbGlnbiIsImxpbmVFbmRpbmdJZk5lZWRlZCIsInRhZyIsInNldERhdGEiLCJ0YWJsZUJvZHkiLCJ0YWJsZURhdGEiLCJnZXREYXRhIiwidGFibGVDb2x1bW4iLCJhbGlnbiIsInVuZGVmaW5lZCIsImJ1ZmZlciIsInRhYmxlSGVhZCIsInRhYmxlSGVhZGVyIiwidGFibGVSb3ciLCJleGl0IiwiY29kZVRleHREYXRhIiwidmFsdWUiLCJzbGljZVNlcmlhbGl6ZSIsInJlcGxhY2UiLCJyYXciLCJlbmNvZGUiLCJyZXN1bWUiLCJsZW5ndGgiLCIkMCIsIiQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTable: () => (/* binding */ gfmTable)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(ssr)/./node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(ssr)/./node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(ssr)/./node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(ssr)/./node_modules/micromark-util-symbol/types.js\");\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */ /**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */ \n\n\n\n\n\n/** @type {Extension} */ const gfmTable = {\n    flow: {\n        null: {\n            tokenize: tokenizeTable,\n            resolve: resolveTable\n        }\n    }\n};\nconst nextPrefixedOrBlank = {\n    tokenize: tokenizeNextPrefixedOrBlank,\n    partial: true\n};\n/** @type {Resolver} */ function resolveTable(events, context) {\n    let index = -1;\n    /** @type {boolean|undefined} */ let inHead;\n    /** @type {boolean|undefined} */ let inDelimiterRow;\n    /** @type {boolean|undefined} */ let inRow;\n    /** @type {number|undefined} */ let contentStart;\n    /** @type {number|undefined} */ let contentEnd;\n    /** @type {number|undefined} */ let cellStart;\n    /** @type {boolean|undefined} */ let seenCellInRow;\n    while(++index < events.length){\n        const token = events[index][1];\n        if (inRow) {\n            if (token.type === \"temporaryTableCellContent\") {\n                contentStart = contentStart || index;\n                contentEnd = index;\n            }\n            if (// Combine separate content parts into one.\n            (token.type === \"tableCellDivider\" || token.type === \"tableRow\") && contentEnd) {\n                (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(contentStart, \"expected `contentStart` to be defined if `contentEnd` is\");\n                const content = {\n                    type: \"tableContent\",\n                    start: events[contentStart][1].start,\n                    end: events[contentEnd][1].end\n                };\n                /** @type {Token} */ const text = {\n                    type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.chunkText,\n                    start: content.start,\n                    end: content.end,\n                    // @ts-expect-error It’s fine.\n                    contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.contentTypeText\n                };\n                (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(contentStart, \"expected `contentStart` to be defined if `contentEnd` is\");\n                events.splice(contentStart, contentEnd - contentStart + 1, [\n                    \"enter\",\n                    content,\n                    context\n                ], [\n                    \"enter\",\n                    text,\n                    context\n                ], [\n                    \"exit\",\n                    text,\n                    context\n                ], [\n                    \"exit\",\n                    content,\n                    context\n                ]);\n                index -= contentEnd - contentStart - 3;\n                contentStart = undefined;\n                contentEnd = undefined;\n            }\n        }\n        if (events[index][0] === \"exit\" && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === \"tableCellDivider\" || token.type === \"tableRow\" && (cellStart + 3 < index || events[cellStart][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace))) {\n            const cell = {\n                type: inDelimiterRow ? \"tableDelimiter\" : inHead ? \"tableHeader\" : \"tableData\",\n                start: events[cellStart][1].start,\n                end: events[index][1].end\n            };\n            events.splice(index + (token.type === \"tableCellDivider\" ? 1 : 0), 0, [\n                \"exit\",\n                cell,\n                context\n            ]);\n            events.splice(cellStart, 0, [\n                \"enter\",\n                cell,\n                context\n            ]);\n            index += 2;\n            cellStart = index + 1;\n            seenCellInRow = true;\n        }\n        if (token.type === \"tableRow\") {\n            inRow = events[index][0] === \"enter\";\n            if (inRow) {\n                cellStart = index + 1;\n                seenCellInRow = false;\n            }\n        }\n        if (token.type === \"tableDelimiterRow\") {\n            inDelimiterRow = events[index][0] === \"enter\";\n            if (inDelimiterRow) {\n                cellStart = index + 1;\n                seenCellInRow = false;\n            }\n        }\n        if (token.type === \"tableHead\") {\n            inHead = events[index][0] === \"enter\";\n        }\n    }\n    return events;\n}\n/** @type {Tokenizer} */ function tokenizeTable(effects, ok, nok) {\n    const self = this;\n    /** @type {Array<Align>} */ const align = [];\n    let tableHeaderCount = 0;\n    /** @type {boolean|undefined} */ let seenDelimiter;\n    /** @type {boolean|undefined} */ let hasDash;\n    return start;\n    /** @type {State} */ function start(code) {\n        // @ts-expect-error Custom.\n        effects.enter(\"table\")._align = align;\n        effects.enter(\"tableHead\");\n        effects.enter(\"tableRow\");\n        // If we start with a pipe, we open a cell marker.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            return cellDividerHead(code);\n        }\n        tableHeaderCount++;\n        effects.enter(\"temporaryTableCellContent\");\n        // Can’t be space or eols at the start of a construct, so we’re in a cell.\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(!(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code), \"expected non-space\");\n        return inCellContentHead(code);\n    }\n    /** @type {State} */ function cellDividerHead(code) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar, \"expected `|`\");\n        effects.enter(\"tableCellDivider\");\n        effects.consume(code);\n        effects.exit(\"tableCellDivider\");\n        seenDelimiter = true;\n        return cellBreakHead;\n    }\n    /** @type {State} */ function cellBreakHead(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n            return atRowEndHead(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n            effects.consume(code);\n            return inWhitespaceHead;\n        }\n        if (seenDelimiter) {\n            seenDelimiter = undefined;\n            tableHeaderCount++;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            return cellDividerHead(code);\n        }\n        // Anything else is cell content.\n        effects.enter(\"temporaryTableCellContent\");\n        return inCellContentHead(code);\n    }\n    /** @type {State} */ function inWhitespaceHead(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.consume(code);\n            return inWhitespaceHead;\n        }\n        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n        return cellBreakHead(code);\n    }\n    /** @type {State} */ function inCellContentHead(code) {\n        // EOF, whitespace, pipe\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(\"temporaryTableCellContent\");\n            return cellBreakHead(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.backslash ? inCellContentEscapeHead : inCellContentHead;\n    }\n    /** @type {State} */ function inCellContentEscapeHead(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            effects.consume(code);\n            return inCellContentHead;\n        }\n        // Anything else.\n        return inCellContentHead(code);\n    }\n    /** @type {State} */ function atRowEndHead(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {\n            return nok(code);\n        }\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code), \"expected eol\");\n        effects.exit(\"tableRow\");\n        effects.exit(\"tableHead\");\n        const originalInterrupt = self.interrupt;\n        self.interrupt = true;\n        return effects.attempt({\n            tokenize: tokenizeRowEnd,\n            partial: true\n        }, function(code) {\n            self.interrupt = originalInterrupt;\n            effects.enter(\"tableDelimiterRow\");\n            return atDelimiterRowBreak(code);\n        }, function(code) {\n            self.interrupt = originalInterrupt;\n            return nok(code);\n        })(code);\n    }\n    /** @type {State} */ function atDelimiterRowBreak(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n            return rowEndDelimiter(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n            effects.consume(code);\n            return inWhitespaceDelimiter;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.dash) {\n            effects.enter(\"tableDelimiterFiller\");\n            effects.consume(code);\n            hasDash = true;\n            align.push(\"none\");\n            return inFillerDelimiter;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.colon) {\n            effects.enter(\"tableDelimiterAlignment\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterAlignment\");\n            align.push(\"left\");\n            return afterLeftAlignment;\n        }\n        // If we start with a pipe, we open a cell marker.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return atDelimiterRowBreak;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function inWhitespaceDelimiter(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.consume(code);\n            return inWhitespaceDelimiter;\n        }\n        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n        return atDelimiterRowBreak(code);\n    }\n    /** @type {State} */ function inFillerDelimiter(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.dash) {\n            effects.consume(code);\n            return inFillerDelimiter;\n        }\n        effects.exit(\"tableDelimiterFiller\");\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.colon) {\n            effects.enter(\"tableDelimiterAlignment\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterAlignment\");\n            align[align.length - 1] = align[align.length - 1] === \"left\" ? \"center\" : \"right\";\n            return afterRightAlignment;\n        }\n        return atDelimiterRowBreak(code);\n    }\n    /** @type {State} */ function afterLeftAlignment(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.dash) {\n            effects.enter(\"tableDelimiterFiller\");\n            effects.consume(code);\n            hasDash = true;\n            return inFillerDelimiter;\n        }\n        // Anything else is not ok.\n        return nok(code);\n    }\n    /** @type {State} */ function afterRightAlignment(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n            return rowEndDelimiter(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n            effects.consume(code);\n            return inWhitespaceDelimiter;\n        }\n        // `|`\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return atDelimiterRowBreak;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function rowEndDelimiter(code) {\n        effects.exit(\"tableDelimiterRow\");\n        // Exit if there was no dash at all, or if the header cell count is not the\n        // delimiter cell count.\n        if (!hasDash || tableHeaderCount !== align.length) {\n            return nok(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {\n            return tableClose(code);\n        }\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code), \"expected eol\");\n        return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n            tokenize: tokenizeRowEnd,\n            partial: true\n        }, (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__.factorySpace)(effects, bodyStart, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix, micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.tabSize), tableClose))(code);\n    }\n    /** @type {State} */ function tableClose(code) {\n        effects.exit(\"table\");\n        return ok(code);\n    }\n    /** @type {State} */ function bodyStart(code) {\n        effects.enter(\"tableBody\");\n        return rowStartBody(code);\n    }\n    /** @type {State} */ function rowStartBody(code) {\n        effects.enter(\"tableRow\");\n        // If we start with a pipe, we open a cell marker.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            return cellDividerBody(code);\n        }\n        effects.enter(\"temporaryTableCellContent\");\n        // Can’t be space or eols at the start of a construct, so we’re in a cell.\n        return inCellContentBody(code);\n    }\n    /** @type {State} */ function cellDividerBody(code) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar, \"expected `|`\");\n        effects.enter(\"tableCellDivider\");\n        effects.consume(code);\n        effects.exit(\"tableCellDivider\");\n        return cellBreakBody;\n    }\n    /** @type {State} */ function cellBreakBody(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n            return atRowEndBody(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n            effects.consume(code);\n            return inWhitespaceBody;\n        }\n        // `|`\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            return cellDividerBody(code);\n        }\n        // Anything else is cell content.\n        effects.enter(\"temporaryTableCellContent\");\n        return inCellContentBody(code);\n    }\n    /** @type {State} */ function inWhitespaceBody(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownSpace)(code)) {\n            effects.consume(code);\n            return inWhitespaceBody;\n        }\n        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace);\n        return cellBreakBody(code);\n    }\n    /** @type {State} */ function inCellContentBody(code) {\n        // EOF, whitespace, pipe\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(\"temporaryTableCellContent\");\n            return cellBreakBody(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.backslash ? inCellContentEscapeBody : inCellContentBody;\n    }\n    /** @type {State} */ function inCellContentEscapeBody(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.verticalBar) {\n            effects.consume(code);\n            return inCellContentBody;\n        }\n        // Anything else.\n        return inCellContentBody(code);\n    }\n    /** @type {State} */ function atRowEndBody(code) {\n        effects.exit(\"tableRow\");\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {\n            return tableBodyClose(code);\n        }\n        return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n            tokenize: tokenizeRowEnd,\n            partial: true\n        }, (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__.factorySpace)(effects, rowStartBody, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix, micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.tabSize), tableBodyClose))(code);\n    }\n    /** @type {State} */ function tableBodyClose(code) {\n        effects.exit(\"tableBody\");\n        return tableClose(code);\n    }\n    /** @type {Tokenizer} */ function tokenizeRowEnd(effects, ok, nok) {\n        return start;\n        /** @type {State} */ function start(code) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code), \"expected eol\");\n            effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n            effects.consume(code);\n            effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__.factorySpace)(effects, prefixed, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix);\n        }\n        /** @type {State} */ function prefixed(code) {\n            // Blank or interrupting line.\n            if (self.parser.lazy[self.now().line] || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n                return nok(code);\n            }\n            const tail = self.events[self.events.length - 1];\n            // Indented code can interrupt delimiter and body rows.\n            if (!self.parser.constructs.disable.null.includes(\"codeIndented\") && tail && tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.tabSize) {\n                return nok(code);\n            }\n            self._gfmTableDynamicInterruptHack = true;\n            return effects.check(self.parser.constructs.flow, function(code) {\n                self._gfmTableDynamicInterruptHack = false;\n                return nok(code);\n            }, function(code) {\n                self._gfmTableDynamicInterruptHack = false;\n                return ok(code);\n            })(code);\n        }\n    }\n}\n/** @type {Tokenizer} */ function tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n    let size = 0;\n    return start;\n    /** @type {State} */ function start(code) {\n        // This is a check, so we don’t care about tokens, but we open a bogus one\n        // so we’re valid.\n        effects.enter(\"check\");\n        // EOL.\n        effects.consume(code);\n        return whitespace;\n    }\n    /** @type {State} */ function whitespace(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.virtualSpace || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.space) {\n            effects.consume(code);\n            size++;\n            return size === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.tabSize ? ok : whitespace;\n        }\n        // EOF or whitespace\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)) {\n            return ok(code);\n        }\n        // Anything else.\n        return nok(code);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUVEOztDQUVDLEdBRXNDO0FBQ2E7QUFLbkI7QUFDbUI7QUFDUTtBQUNSO0FBRXBELHNCQUFzQixHQUNmLE1BQU1TLFdBQVc7SUFDdEJDLE1BQU07UUFBQ0MsTUFBTTtZQUFDQyxVQUFVQztZQUFlQyxTQUFTQztRQUFZO0lBQUM7QUFDL0QsRUFBQztBQUVELE1BQU1DLHNCQUFzQjtJQUMxQkosVUFBVUs7SUFDVkMsU0FBUztBQUNYO0FBRUEscUJBQXFCLEdBQ3JCLFNBQVNILGFBQWFJLE1BQU0sRUFBRUMsT0FBTztJQUNuQyxJQUFJQyxRQUFRLENBQUM7SUFDYiw4QkFBOEIsR0FDOUIsSUFBSUM7SUFDSiw4QkFBOEIsR0FDOUIsSUFBSUM7SUFDSiw4QkFBOEIsR0FDOUIsSUFBSUM7SUFDSiw2QkFBNkIsR0FDN0IsSUFBSUM7SUFDSiw2QkFBNkIsR0FDN0IsSUFBSUM7SUFDSiw2QkFBNkIsR0FDN0IsSUFBSUM7SUFDSiw4QkFBOEIsR0FDOUIsSUFBSUM7SUFFSixNQUFPLEVBQUVQLFFBQVFGLE9BQU9VLE1BQU0sQ0FBRTtRQUM5QixNQUFNQyxRQUFRWCxNQUFNLENBQUNFLE1BQU0sQ0FBQyxFQUFFO1FBRTlCLElBQUlHLE9BQU87WUFDVCxJQUFJTSxNQUFNQyxJQUFJLEtBQUssNkJBQTZCO2dCQUM5Q04sZUFBZUEsZ0JBQWdCSjtnQkFDL0JLLGFBQWFMO1lBQ2Y7WUFFQSxJQUVFLDJDQUQyQztZQUMxQ1MsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLHNCQUFzQkQsTUFBTUMsSUFBSSxLQUFLLFVBQVMsS0FDOURMLFlBQ0E7Z0JBQ0F6Qiw4Q0FBTUEsQ0FDSndCLGNBQ0E7Z0JBRUYsTUFBTU8sVUFBVTtvQkFDZEQsTUFBTTtvQkFDTkUsT0FBT2QsTUFBTSxDQUFDTSxhQUFhLENBQUMsRUFBRSxDQUFDUSxLQUFLO29CQUNwQ0MsS0FBS2YsTUFBTSxDQUFDTyxXQUFXLENBQUMsRUFBRSxDQUFDUSxHQUFHO2dCQUNoQztnQkFDQSxrQkFBa0IsR0FDbEIsTUFBTUMsT0FBTztvQkFDWEosTUFBTXZCLGlFQUFLQSxDQUFDNEIsU0FBUztvQkFDckJILE9BQU9ELFFBQVFDLEtBQUs7b0JBQ3BCQyxLQUFLRixRQUFRRSxHQUFHO29CQUNoQiw4QkFBOEI7b0JBQzlCRyxhQUFhOUIseUVBQVNBLENBQUMrQixlQUFlO2dCQUN4QztnQkFFQXJDLDhDQUFNQSxDQUNKd0IsY0FDQTtnQkFHRk4sT0FBT29CLE1BQU0sQ0FDWGQsY0FDQUMsYUFBYUQsZUFBZSxHQUM1QjtvQkFBQztvQkFBU087b0JBQVNaO2lCQUFRLEVBQzNCO29CQUFDO29CQUFTZTtvQkFBTWY7aUJBQVEsRUFDeEI7b0JBQUM7b0JBQVFlO29CQUFNZjtpQkFBUSxFQUN2QjtvQkFBQztvQkFBUVk7b0JBQVNaO2lCQUFRO2dCQUc1QkMsU0FBU0ssYUFBYUQsZUFBZTtnQkFDckNBLGVBQWVlO2dCQUNmZCxhQUFhYztZQUNmO1FBQ0Y7UUFFQSxJQUNFckIsTUFBTSxDQUFDRSxNQUFNLENBQUMsRUFBRSxLQUFLLFVBQ3JCTSxjQUFjYSxhQUNkYixZQUFhQyxDQUFBQSxnQkFBZ0IsSUFBSSxLQUFLUCxTQUNyQ1MsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLHNCQUNiRCxNQUFNQyxJQUFJLEtBQUssY0FDYkosQ0FBQUEsWUFBWSxJQUFJTixTQUNmRixNQUFNLENBQUNRLFVBQVUsQ0FBQyxFQUFFLENBQUNJLElBQUksS0FBS3ZCLGlFQUFLQSxDQUFDaUMsVUFBVSxDQUFDLEdBQ3JEO1lBQ0EsTUFBTUMsT0FBTztnQkFDWFgsTUFBTVIsaUJBQ0YsbUJBQ0FELFNBQ0EsZ0JBQ0E7Z0JBQ0pXLE9BQU9kLE1BQU0sQ0FBQ1EsVUFBVSxDQUFDLEVBQUUsQ0FBQ00sS0FBSztnQkFDakNDLEtBQUtmLE1BQU0sQ0FBQ0UsTUFBTSxDQUFDLEVBQUUsQ0FBQ2EsR0FBRztZQUMzQjtZQUNBZixPQUFPb0IsTUFBTSxDQUFDbEIsUUFBU1MsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLHFCQUFxQixJQUFJLElBQUksR0FBRztnQkFDcEU7Z0JBQ0FXO2dCQUNBdEI7YUFDRDtZQUNERCxPQUFPb0IsTUFBTSxDQUFDWixXQUFXLEdBQUc7Z0JBQUM7Z0JBQVNlO2dCQUFNdEI7YUFBUTtZQUNwREMsU0FBUztZQUNUTSxZQUFZTixRQUFRO1lBQ3BCTyxnQkFBZ0I7UUFDbEI7UUFFQSxJQUFJRSxNQUFNQyxJQUFJLEtBQUssWUFBWTtZQUM3QlAsUUFBUUwsTUFBTSxDQUFDRSxNQUFNLENBQUMsRUFBRSxLQUFLO1lBRTdCLElBQUlHLE9BQU87Z0JBQ1RHLFlBQVlOLFFBQVE7Z0JBQ3BCTyxnQkFBZ0I7WUFDbEI7UUFDRjtRQUVBLElBQUlFLE1BQU1DLElBQUksS0FBSyxxQkFBcUI7WUFDdENSLGlCQUFpQkosTUFBTSxDQUFDRSxNQUFNLENBQUMsRUFBRSxLQUFLO1lBRXRDLElBQUlFLGdCQUFnQjtnQkFDbEJJLFlBQVlOLFFBQVE7Z0JBQ3BCTyxnQkFBZ0I7WUFDbEI7UUFDRjtRQUVBLElBQUlFLE1BQU1DLElBQUksS0FBSyxhQUFhO1lBQzlCVCxTQUFTSCxNQUFNLENBQUNFLE1BQU0sQ0FBQyxFQUFFLEtBQUs7UUFDaEM7SUFDRjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQSxzQkFBc0IsR0FDdEIsU0FBU04sY0FBYzhCLE9BQU8sRUFBRTNDLEVBQUUsRUFBRTRDLEdBQUc7SUFDckMsTUFBTUMsT0FBTyxJQUFJO0lBQ2pCLHlCQUF5QixHQUN6QixNQUFNQyxRQUFRLEVBQUU7SUFDaEIsSUFBSUMsbUJBQW1CO0lBQ3ZCLDhCQUE4QixHQUM5QixJQUFJQztJQUNKLDhCQUE4QixHQUM5QixJQUFJQztJQUVKLE9BQU9oQjtJQUVQLGtCQUFrQixHQUNsQixTQUFTQSxNQUFNaUIsSUFBSTtRQUNqQiwyQkFBMkI7UUFDM0JQLFFBQVFRLEtBQUssQ0FBQyxTQUFTQyxNQUFNLEdBQUdOO1FBQ2hDSCxRQUFRUSxLQUFLLENBQUM7UUFDZFIsUUFBUVEsS0FBSyxDQUFDO1FBRWQsa0RBQWtEO1FBQ2xELElBQUlELFNBQVM1QyxpRUFBS0EsQ0FBQytDLFdBQVcsRUFBRTtZQUM5QixPQUFPQyxnQkFBZ0JKO1FBQ3pCO1FBRUFIO1FBQ0FKLFFBQVFRLEtBQUssQ0FBQztRQUNkLDBFQUEwRTtRQUMxRWxELDhDQUFNQSxDQUFDLENBQUNHLG1GQUF5QkEsQ0FBQzhDLE9BQU87UUFDekMsT0FBT0ssa0JBQWtCTDtJQUMzQjtJQUVBLGtCQUFrQixHQUNsQixTQUFTSSxnQkFBZ0JKLElBQUk7UUFDM0JqRCw4Q0FBTUEsQ0FBQ2lELFNBQVM1QyxpRUFBS0EsQ0FBQytDLFdBQVcsRUFBRTtRQUNuQ1YsUUFBUVEsS0FBSyxDQUFDO1FBQ2RSLFFBQVFhLE9BQU8sQ0FBQ047UUFDaEJQLFFBQVFjLElBQUksQ0FBQztRQUNiVCxnQkFBZ0I7UUFDaEIsT0FBT1U7SUFDVDtJQUVBLGtCQUFrQixHQUNsQixTQUFTQSxjQUFjUixJQUFJO1FBQ3pCLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ3FELEdBQUcsSUFBSXhELDRFQUFrQkEsQ0FBQytDLE9BQU87WUFDbEQsT0FBT1UsYUFBYVY7UUFDdEI7UUFFQSxJQUFJN0MsdUVBQWFBLENBQUM2QyxPQUFPO1lBQ3ZCUCxRQUFRUSxLQUFLLENBQUMzQyxpRUFBS0EsQ0FBQ2lDLFVBQVU7WUFDOUJFLFFBQVFhLE9BQU8sQ0FBQ047WUFDaEIsT0FBT1c7UUFDVDtRQUVBLElBQUliLGVBQWU7WUFDakJBLGdCQUFnQlI7WUFDaEJPO1FBQ0Y7UUFFQSxJQUFJRyxTQUFTNUMsaUVBQUtBLENBQUMrQyxXQUFXLEVBQUU7WUFDOUIsT0FBT0MsZ0JBQWdCSjtRQUN6QjtRQUVBLGlDQUFpQztRQUNqQ1AsUUFBUVEsS0FBSyxDQUFDO1FBQ2QsT0FBT0ksa0JBQWtCTDtJQUMzQjtJQUVBLGtCQUFrQixHQUNsQixTQUFTVyxpQkFBaUJYLElBQUk7UUFDNUIsSUFBSTdDLHVFQUFhQSxDQUFDNkMsT0FBTztZQUN2QlAsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQixPQUFPVztRQUNUO1FBRUFsQixRQUFRYyxJQUFJLENBQUNqRCxpRUFBS0EsQ0FBQ2lDLFVBQVU7UUFDN0IsT0FBT2lCLGNBQWNSO0lBQ3ZCO0lBRUEsa0JBQWtCLEdBQ2xCLFNBQVNLLGtCQUFrQkwsSUFBSTtRQUM3Qix3QkFBd0I7UUFDeEIsSUFDRUEsU0FBUzVDLGlFQUFLQSxDQUFDcUQsR0FBRyxJQUNsQlQsU0FBUzVDLGlFQUFLQSxDQUFDK0MsV0FBVyxJQUMxQmpELG1GQUF5QkEsQ0FBQzhDLE9BQzFCO1lBQ0FQLFFBQVFjLElBQUksQ0FBQztZQUNiLE9BQU9DLGNBQWNSO1FBQ3ZCO1FBRUFQLFFBQVFhLE9BQU8sQ0FBQ047UUFDaEIsT0FBT0EsU0FBUzVDLGlFQUFLQSxDQUFDd0QsU0FBUyxHQUMzQkMsMEJBQ0FSO0lBQ047SUFFQSxrQkFBa0IsR0FDbEIsU0FBU1Esd0JBQXdCYixJQUFJO1FBQ25DLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ3dELFNBQVMsSUFBSVosU0FBUzVDLGlFQUFLQSxDQUFDK0MsV0FBVyxFQUFFO1lBQzFEVixRQUFRYSxPQUFPLENBQUNOO1lBQ2hCLE9BQU9LO1FBQ1Q7UUFFQSxpQkFBaUI7UUFDakIsT0FBT0Esa0JBQWtCTDtJQUMzQjtJQUVBLGtCQUFrQixHQUNsQixTQUFTVSxhQUFhVixJQUFJO1FBQ3hCLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ3FELEdBQUcsRUFBRTtZQUN0QixPQUFPZixJQUFJTTtRQUNiO1FBRUFqRCw4Q0FBTUEsQ0FBQ0UsNEVBQWtCQSxDQUFDK0MsT0FBTztRQUNqQ1AsUUFBUWMsSUFBSSxDQUFDO1FBQ2JkLFFBQVFjLElBQUksQ0FBQztRQUNiLE1BQU1PLG9CQUFvQm5CLEtBQUtvQixTQUFTO1FBQ3hDcEIsS0FBS29CLFNBQVMsR0FBRztRQUNqQixPQUFPdEIsUUFBUXVCLE9BQU8sQ0FDcEI7WUFBQ3RELFVBQVV1RDtZQUFnQmpELFNBQVM7UUFBSSxHQUN4QyxTQUFVZ0MsSUFBSTtZQUNaTCxLQUFLb0IsU0FBUyxHQUFHRDtZQUNqQnJCLFFBQVFRLEtBQUssQ0FBQztZQUNkLE9BQU9pQixvQkFBb0JsQjtRQUM3QixHQUNBLFNBQVVBLElBQUk7WUFDWkwsS0FBS29CLFNBQVMsR0FBR0Q7WUFDakIsT0FBT3BCLElBQUlNO1FBQ2IsR0FDQUE7SUFDSjtJQUVBLGtCQUFrQixHQUNsQixTQUFTa0Isb0JBQW9CbEIsSUFBSTtRQUMvQixJQUFJQSxTQUFTNUMsaUVBQUtBLENBQUNxRCxHQUFHLElBQUl4RCw0RUFBa0JBLENBQUMrQyxPQUFPO1lBQ2xELE9BQU9tQixnQkFBZ0JuQjtRQUN6QjtRQUVBLElBQUk3Qyx1RUFBYUEsQ0FBQzZDLE9BQU87WUFDdkJQLFFBQVFRLEtBQUssQ0FBQzNDLGlFQUFLQSxDQUFDaUMsVUFBVTtZQUM5QkUsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQixPQUFPb0I7UUFDVDtRQUVBLElBQUlwQixTQUFTNUMsaUVBQUtBLENBQUNpRSxJQUFJLEVBQUU7WUFDdkI1QixRQUFRUSxLQUFLLENBQUM7WUFDZFIsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQkQsVUFBVTtZQUNWSCxNQUFNMEIsSUFBSSxDQUFDO1lBQ1gsT0FBT0M7UUFDVDtRQUVBLElBQUl2QixTQUFTNUMsaUVBQUtBLENBQUNvRSxLQUFLLEVBQUU7WUFDeEIvQixRQUFRUSxLQUFLLENBQUM7WUFDZFIsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQlAsUUFBUWMsSUFBSSxDQUFDO1lBQ2JYLE1BQU0wQixJQUFJLENBQUM7WUFDWCxPQUFPRztRQUNUO1FBRUEsa0RBQWtEO1FBQ2xELElBQUl6QixTQUFTNUMsaUVBQUtBLENBQUMrQyxXQUFXLEVBQUU7WUFDOUJWLFFBQVFRLEtBQUssQ0FBQztZQUNkUixRQUFRYSxPQUFPLENBQUNOO1lBQ2hCUCxRQUFRYyxJQUFJLENBQUM7WUFDYixPQUFPVztRQUNUO1FBRUEsT0FBT3hCLElBQUlNO0lBQ2I7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU29CLHNCQUFzQnBCLElBQUk7UUFDakMsSUFBSTdDLHVFQUFhQSxDQUFDNkMsT0FBTztZQUN2QlAsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQixPQUFPb0I7UUFDVDtRQUVBM0IsUUFBUWMsSUFBSSxDQUFDakQsaUVBQUtBLENBQUNpQyxVQUFVO1FBQzdCLE9BQU8yQixvQkFBb0JsQjtJQUM3QjtJQUVBLGtCQUFrQixHQUNsQixTQUFTdUIsa0JBQWtCdkIsSUFBSTtRQUM3QixJQUFJQSxTQUFTNUMsaUVBQUtBLENBQUNpRSxJQUFJLEVBQUU7WUFDdkI1QixRQUFRYSxPQUFPLENBQUNOO1lBQ2hCLE9BQU91QjtRQUNUO1FBRUE5QixRQUFRYyxJQUFJLENBQUM7UUFFYixJQUFJUCxTQUFTNUMsaUVBQUtBLENBQUNvRSxLQUFLLEVBQUU7WUFDeEIvQixRQUFRUSxLQUFLLENBQUM7WUFDZFIsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQlAsUUFBUWMsSUFBSSxDQUFDO1lBRWJYLEtBQUssQ0FBQ0EsTUFBTWpCLE1BQU0sR0FBRyxFQUFFLEdBQ3JCaUIsS0FBSyxDQUFDQSxNQUFNakIsTUFBTSxHQUFHLEVBQUUsS0FBSyxTQUFTLFdBQVc7WUFFbEQsT0FBTytDO1FBQ1Q7UUFFQSxPQUFPUixvQkFBb0JsQjtJQUM3QjtJQUVBLGtCQUFrQixHQUNsQixTQUFTeUIsbUJBQW1CekIsSUFBSTtRQUM5QixJQUFJQSxTQUFTNUMsaUVBQUtBLENBQUNpRSxJQUFJLEVBQUU7WUFDdkI1QixRQUFRUSxLQUFLLENBQUM7WUFDZFIsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQkQsVUFBVTtZQUNWLE9BQU93QjtRQUNUO1FBRUEsMkJBQTJCO1FBQzNCLE9BQU83QixJQUFJTTtJQUNiO0lBRUEsa0JBQWtCLEdBQ2xCLFNBQVMwQixvQkFBb0IxQixJQUFJO1FBQy9CLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ3FELEdBQUcsSUFBSXhELDRFQUFrQkEsQ0FBQytDLE9BQU87WUFDbEQsT0FBT21CLGdCQUFnQm5CO1FBQ3pCO1FBRUEsSUFBSTdDLHVFQUFhQSxDQUFDNkMsT0FBTztZQUN2QlAsUUFBUVEsS0FBSyxDQUFDM0MsaUVBQUtBLENBQUNpQyxVQUFVO1lBQzlCRSxRQUFRYSxPQUFPLENBQUNOO1lBQ2hCLE9BQU9vQjtRQUNUO1FBRUEsTUFBTTtRQUNOLElBQUlwQixTQUFTNUMsaUVBQUtBLENBQUMrQyxXQUFXLEVBQUU7WUFDOUJWLFFBQVFRLEtBQUssQ0FBQztZQUNkUixRQUFRYSxPQUFPLENBQUNOO1lBQ2hCUCxRQUFRYyxJQUFJLENBQUM7WUFDYixPQUFPVztRQUNUO1FBRUEsT0FBT3hCLElBQUlNO0lBQ2I7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU21CLGdCQUFnQm5CLElBQUk7UUFDM0JQLFFBQVFjLElBQUksQ0FBQztRQUViLDJFQUEyRTtRQUMzRSx3QkFBd0I7UUFDeEIsSUFBSSxDQUFDUixXQUFXRixxQkFBcUJELE1BQU1qQixNQUFNLEVBQUU7WUFDakQsT0FBT2UsSUFBSU07UUFDYjtRQUVBLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ3FELEdBQUcsRUFBRTtZQUN0QixPQUFPa0IsV0FBVzNCO1FBQ3BCO1FBRUFqRCw4Q0FBTUEsQ0FBQ0UsNEVBQWtCQSxDQUFDK0MsT0FBTztRQUNqQyxPQUFPUCxRQUFRbUMsS0FBSyxDQUNsQjlELHFCQUNBNkQsWUFDQWxDLFFBQVF1QixPQUFPLENBQ2I7WUFBQ3RELFVBQVV1RDtZQUFnQmpELFNBQVM7UUFBSSxHQUN4Q2hCLHFFQUFZQSxDQUFDeUMsU0FBU29DLFdBQVd2RSxpRUFBS0EsQ0FBQ3dFLFVBQVUsRUFBRXpFLHlFQUFTQSxDQUFDMEUsT0FBTyxHQUNwRUosYUFFRjNCO0lBQ0o7SUFFQSxrQkFBa0IsR0FDbEIsU0FBUzJCLFdBQVczQixJQUFJO1FBQ3RCUCxRQUFRYyxJQUFJLENBQUM7UUFDYixPQUFPekQsR0FBR2tEO0lBQ1o7SUFFQSxrQkFBa0IsR0FDbEIsU0FBUzZCLFVBQVU3QixJQUFJO1FBQ3JCUCxRQUFRUSxLQUFLLENBQUM7UUFDZCxPQUFPK0IsYUFBYWhDO0lBQ3RCO0lBRUEsa0JBQWtCLEdBQ2xCLFNBQVNnQyxhQUFhaEMsSUFBSTtRQUN4QlAsUUFBUVEsS0FBSyxDQUFDO1FBRWQsa0RBQWtEO1FBQ2xELElBQUlELFNBQVM1QyxpRUFBS0EsQ0FBQytDLFdBQVcsRUFBRTtZQUM5QixPQUFPOEIsZ0JBQWdCakM7UUFDekI7UUFFQVAsUUFBUVEsS0FBSyxDQUFDO1FBQ2QsMEVBQTBFO1FBQzFFLE9BQU9pQyxrQkFBa0JsQztJQUMzQjtJQUVBLGtCQUFrQixHQUNsQixTQUFTaUMsZ0JBQWdCakMsSUFBSTtRQUMzQmpELDhDQUFNQSxDQUFDaUQsU0FBUzVDLGlFQUFLQSxDQUFDK0MsV0FBVyxFQUFFO1FBQ25DVixRQUFRUSxLQUFLLENBQUM7UUFDZFIsUUFBUWEsT0FBTyxDQUFDTjtRQUNoQlAsUUFBUWMsSUFBSSxDQUFDO1FBQ2IsT0FBTzRCO0lBQ1Q7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU0EsY0FBY25DLElBQUk7UUFDekIsSUFBSUEsU0FBUzVDLGlFQUFLQSxDQUFDcUQsR0FBRyxJQUFJeEQsNEVBQWtCQSxDQUFDK0MsT0FBTztZQUNsRCxPQUFPb0MsYUFBYXBDO1FBQ3RCO1FBRUEsSUFBSTdDLHVFQUFhQSxDQUFDNkMsT0FBTztZQUN2QlAsUUFBUVEsS0FBSyxDQUFDM0MsaUVBQUtBLENBQUNpQyxVQUFVO1lBQzlCRSxRQUFRYSxPQUFPLENBQUNOO1lBQ2hCLE9BQU9xQztRQUNUO1FBRUEsTUFBTTtRQUNOLElBQUlyQyxTQUFTNUMsaUVBQUtBLENBQUMrQyxXQUFXLEVBQUU7WUFDOUIsT0FBTzhCLGdCQUFnQmpDO1FBQ3pCO1FBRUEsaUNBQWlDO1FBQ2pDUCxRQUFRUSxLQUFLLENBQUM7UUFDZCxPQUFPaUMsa0JBQWtCbEM7SUFDM0I7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU3FDLGlCQUFpQnJDLElBQUk7UUFDNUIsSUFBSTdDLHVFQUFhQSxDQUFDNkMsT0FBTztZQUN2QlAsUUFBUWEsT0FBTyxDQUFDTjtZQUNoQixPQUFPcUM7UUFDVDtRQUVBNUMsUUFBUWMsSUFBSSxDQUFDakQsaUVBQUtBLENBQUNpQyxVQUFVO1FBQzdCLE9BQU80QyxjQUFjbkM7SUFDdkI7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU2tDLGtCQUFrQmxDLElBQUk7UUFDN0Isd0JBQXdCO1FBQ3hCLElBQ0VBLFNBQVM1QyxpRUFBS0EsQ0FBQ3FELEdBQUcsSUFDbEJULFNBQVM1QyxpRUFBS0EsQ0FBQytDLFdBQVcsSUFDMUJqRCxtRkFBeUJBLENBQUM4QyxPQUMxQjtZQUNBUCxRQUFRYyxJQUFJLENBQUM7WUFDYixPQUFPNEIsY0FBY25DO1FBQ3ZCO1FBRUFQLFFBQVFhLE9BQU8sQ0FBQ047UUFDaEIsT0FBT0EsU0FBUzVDLGlFQUFLQSxDQUFDd0QsU0FBUyxHQUMzQjBCLDBCQUNBSjtJQUNOO0lBRUEsa0JBQWtCLEdBQ2xCLFNBQVNJLHdCQUF3QnRDLElBQUk7UUFDbkMsSUFBSUEsU0FBUzVDLGlFQUFLQSxDQUFDd0QsU0FBUyxJQUFJWixTQUFTNUMsaUVBQUtBLENBQUMrQyxXQUFXLEVBQUU7WUFDMURWLFFBQVFhLE9BQU8sQ0FBQ047WUFDaEIsT0FBT2tDO1FBQ1Q7UUFFQSxpQkFBaUI7UUFDakIsT0FBT0Esa0JBQWtCbEM7SUFDM0I7SUFFQSxrQkFBa0IsR0FDbEIsU0FBU29DLGFBQWFwQyxJQUFJO1FBQ3hCUCxRQUFRYyxJQUFJLENBQUM7UUFFYixJQUFJUCxTQUFTNUMsaUVBQUtBLENBQUNxRCxHQUFHLEVBQUU7WUFDdEIsT0FBTzhCLGVBQWV2QztRQUN4QjtRQUVBLE9BQU9QLFFBQVFtQyxLQUFLLENBQ2xCOUQscUJBQ0F5RSxnQkFDQTlDLFFBQVF1QixPQUFPLENBQ2I7WUFBQ3RELFVBQVV1RDtZQUFnQmpELFNBQVM7UUFBSSxHQUN4Q2hCLHFFQUFZQSxDQUNWeUMsU0FDQXVDLGNBQ0ExRSxpRUFBS0EsQ0FBQ3dFLFVBQVUsRUFDaEJ6RSx5RUFBU0EsQ0FBQzBFLE9BQU8sR0FFbkJRLGlCQUVGdkM7SUFDSjtJQUVBLGtCQUFrQixHQUNsQixTQUFTdUMsZUFBZXZDLElBQUk7UUFDMUJQLFFBQVFjLElBQUksQ0FBQztRQUNiLE9BQU9vQixXQUFXM0I7SUFDcEI7SUFFQSxzQkFBc0IsR0FDdEIsU0FBU2lCLGVBQWV4QixPQUFPLEVBQUUzQyxFQUFFLEVBQUU0QyxHQUFHO1FBQ3RDLE9BQU9YO1FBRVAsa0JBQWtCLEdBQ2xCLFNBQVNBLE1BQU1pQixJQUFJO1lBQ2pCakQsOENBQU1BLENBQUNFLDRFQUFrQkEsQ0FBQytDLE9BQU87WUFDakNQLFFBQVFRLEtBQUssQ0FBQzNDLGlFQUFLQSxDQUFDa0YsVUFBVTtZQUM5Qi9DLFFBQVFhLE9BQU8sQ0FBQ047WUFDaEJQLFFBQVFjLElBQUksQ0FBQ2pELGlFQUFLQSxDQUFDa0YsVUFBVTtZQUM3QixPQUFPeEYscUVBQVlBLENBQUN5QyxTQUFTZ0QsVUFBVW5GLGlFQUFLQSxDQUFDd0UsVUFBVTtRQUN6RDtRQUVBLGtCQUFrQixHQUNsQixTQUFTVyxTQUFTekMsSUFBSTtZQUNwQiw4QkFBOEI7WUFDOUIsSUFDRUwsS0FBSytDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEQsS0FBS2lELEdBQUcsR0FBR0MsSUFBSSxDQUFDLElBQ2pDN0MsU0FBUzVDLGlFQUFLQSxDQUFDcUQsR0FBRyxJQUNsQnhELDRFQUFrQkEsQ0FBQytDLE9BQ25CO2dCQUNBLE9BQU9OLElBQUlNO1lBQ2I7WUFFQSxNQUFNOEMsT0FBT25ELEtBQUsxQixNQUFNLENBQUMwQixLQUFLMUIsTUFBTSxDQUFDVSxNQUFNLEdBQUcsRUFBRTtZQUVoRCx1REFBdUQ7WUFDdkQsSUFDRSxDQUFDZ0IsS0FBSytDLE1BQU0sQ0FBQ0ssVUFBVSxDQUFDQyxPQUFPLENBQUN2RixJQUFJLENBQUN3RixRQUFRLENBQUMsbUJBQzlDSCxRQUNBQSxJQUFJLENBQUMsRUFBRSxDQUFDakUsSUFBSSxLQUFLdkIsaUVBQUtBLENBQUN3RSxVQUFVLElBQ2pDZ0IsSUFBSSxDQUFDLEVBQUUsQ0FBQ0ksY0FBYyxDQUFDSixJQUFJLENBQUMsRUFBRSxFQUFFLE1BQU1uRSxNQUFNLElBQUl0Qix5RUFBU0EsQ0FBQzBFLE9BQU8sRUFDakU7Z0JBQ0EsT0FBT3JDLElBQUlNO1lBQ2I7WUFFQUwsS0FBS3dELDZCQUE2QixHQUFHO1lBRXJDLE9BQU8xRCxRQUFRbUMsS0FBSyxDQUNsQmpDLEtBQUsrQyxNQUFNLENBQUNLLFVBQVUsQ0FBQ3ZGLElBQUksRUFDM0IsU0FBVXdDLElBQUk7Z0JBQ1pMLEtBQUt3RCw2QkFBNkIsR0FBRztnQkFDckMsT0FBT3pELElBQUlNO1lBQ2IsR0FDQSxTQUFVQSxJQUFJO2dCQUNaTCxLQUFLd0QsNkJBQTZCLEdBQUc7Z0JBQ3JDLE9BQU9yRyxHQUFHa0Q7WUFDWixHQUNBQTtRQUNKO0lBQ0Y7QUFDRjtBQUVBLHNCQUFzQixHQUN0QixTQUFTakMsNEJBQTRCMEIsT0FBTyxFQUFFM0MsRUFBRSxFQUFFNEMsR0FBRztJQUNuRCxJQUFJMEQsT0FBTztJQUVYLE9BQU9yRTtJQUVQLGtCQUFrQixHQUNsQixTQUFTQSxNQUFNaUIsSUFBSTtRQUNqQiwwRUFBMEU7UUFDMUUsa0JBQWtCO1FBQ2xCUCxRQUFRUSxLQUFLLENBQUM7UUFDZCxPQUFPO1FBQ1BSLFFBQVFhLE9BQU8sQ0FBQ047UUFDaEIsT0FBT1Q7SUFDVDtJQUVBLGtCQUFrQixHQUNsQixTQUFTQSxXQUFXUyxJQUFJO1FBQ3RCLElBQUlBLFNBQVM1QyxpRUFBS0EsQ0FBQ2lHLFlBQVksSUFBSXJELFNBQVM1QyxpRUFBS0EsQ0FBQ2tHLEtBQUssRUFBRTtZQUN2RDdELFFBQVFhLE9BQU8sQ0FBQ047WUFDaEJvRDtZQUNBLE9BQU9BLFNBQVMvRix5RUFBU0EsQ0FBQzBFLE9BQU8sR0FBR2pGLEtBQUt5QztRQUMzQztRQUVBLG9CQUFvQjtRQUNwQixJQUFJUyxTQUFTNUMsaUVBQUtBLENBQUNxRCxHQUFHLElBQUl2RCxtRkFBeUJBLENBQUM4QyxPQUFPO1lBQ3pELE9BQU9sRCxHQUFHa0Q7UUFDWjtRQUVBLGlCQUFpQjtRQUNqQixPQUFPTixJQUFJTTtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL3N5bnRheC5qcz9mNDEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdub25lJ30gQWxpZ25cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAndXZ1L2Fzc2VydCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25TcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvY29kZXMuanMnXG5pbXBvcnQge2NvbnN0YW50c30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL2NvbnN0YW50cy5qcydcbmltcG9ydCB7dHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC90eXBlcy5qcydcblxuLyoqIEB0eXBlIHtFeHRlbnNpb259ICovXG5leHBvcnQgY29uc3QgZ2ZtVGFibGUgPSB7XG4gIGZsb3c6IHtudWxsOiB7dG9rZW5pemU6IHRva2VuaXplVGFibGUsIHJlc29sdmU6IHJlc29sdmVUYWJsZX19XG59XG5cbmNvbnN0IG5leHRQcmVmaXhlZE9yQmxhbmsgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZU5leHRQcmVmaXhlZE9yQmxhbmssXG4gIHBhcnRpYWw6IHRydWVcbn1cblxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cbmZ1bmN0aW9uIHJlc29sdmVUYWJsZShldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGluSGVhZFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICBsZXQgaW5EZWxpbWl0ZXJSb3dcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGluUm93XG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGNvbnRlbnRTdGFydFxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gIGxldCBjb250ZW50RW5kXG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGNlbGxTdGFydFxuICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICBsZXQgc2VlbkNlbGxJblJvd1xuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gZXZlbnRzW2luZGV4XVsxXVxuXG4gICAgaWYgKGluUm93KSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKSB7XG4gICAgICAgIGNvbnRlbnRTdGFydCA9IGNvbnRlbnRTdGFydCB8fCBpbmRleFxuICAgICAgICBjb250ZW50RW5kID0gaW5kZXhcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAvLyBDb21iaW5lIHNlcGFyYXRlIGNvbnRlbnQgcGFydHMgaW50byBvbmUuXG4gICAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVDZWxsRGl2aWRlcicgfHwgdG9rZW4udHlwZSA9PT0gJ3RhYmxlUm93JykgJiZcbiAgICAgICAgY29udGVudEVuZFxuICAgICAgKSB7XG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICBjb250ZW50U3RhcnQsXG4gICAgICAgICAgJ2V4cGVjdGVkIGBjb250ZW50U3RhcnRgIHRvIGJlIGRlZmluZWQgaWYgYGNvbnRlbnRFbmRgIGlzJ1xuICAgICAgICApXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlQ29udGVudCcsXG4gICAgICAgICAgc3RhcnQ6IGV2ZW50c1tjb250ZW50U3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgICAgIGVuZDogZXZlbnRzW2NvbnRlbnRFbmRdWzFdLmVuZFxuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZXMuY2h1bmtUZXh0LFxuICAgICAgICAgIHN0YXJ0OiBjb250ZW50LnN0YXJ0LFxuICAgICAgICAgIGVuZDogY29udGVudC5lbmQsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdOKAmXMgZmluZS5cbiAgICAgICAgICBjb250ZW50VHlwZTogY29uc3RhbnRzLmNvbnRlbnRUeXBlVGV4dFxuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgICAgICAnZXhwZWN0ZWQgYGNvbnRlbnRTdGFydGAgdG8gYmUgZGVmaW5lZCBpZiBgY29udGVudEVuZGAgaXMnXG4gICAgICAgIClcblxuICAgICAgICBldmVudHMuc3BsaWNlKFxuICAgICAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgICAgICBjb250ZW50RW5kIC0gY29udGVudFN0YXJ0ICsgMSxcbiAgICAgICAgICBbJ2VudGVyJywgY29udGVudCwgY29udGV4dF0sXG4gICAgICAgICAgWydlbnRlcicsIHRleHQsIGNvbnRleHRdLFxuICAgICAgICAgIFsnZXhpdCcsIHRleHQsIGNvbnRleHRdLFxuICAgICAgICAgIFsnZXhpdCcsIGNvbnRlbnQsIGNvbnRleHRdXG4gICAgICAgIClcblxuICAgICAgICBpbmRleCAtPSBjb250ZW50RW5kIC0gY29udGVudFN0YXJ0IC0gM1xuICAgICAgICBjb250ZW50U3RhcnQgPSB1bmRlZmluZWRcbiAgICAgICAgY29udGVudEVuZCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgY2VsbFN0YXJ0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNlbGxTdGFydCArIChzZWVuQ2VsbEluUm93ID8gMCA6IDEpIDwgaW5kZXggJiZcbiAgICAgICh0b2tlbi50eXBlID09PSAndGFibGVDZWxsRGl2aWRlcicgfHxcbiAgICAgICAgKHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgJiZcbiAgICAgICAgICAoY2VsbFN0YXJ0ICsgMyA8IGluZGV4IHx8XG4gICAgICAgICAgICBldmVudHNbY2VsbFN0YXJ0XVsxXS50eXBlICE9PSB0eXBlcy53aGl0ZXNwYWNlKSkpXG4gICAgKSB7XG4gICAgICBjb25zdCBjZWxsID0ge1xuICAgICAgICB0eXBlOiBpbkRlbGltaXRlclJvd1xuICAgICAgICAgID8gJ3RhYmxlRGVsaW1pdGVyJ1xuICAgICAgICAgIDogaW5IZWFkXG4gICAgICAgICAgPyAndGFibGVIZWFkZXInXG4gICAgICAgICAgOiAndGFibGVEYXRhJyxcbiAgICAgICAgc3RhcnQ6IGV2ZW50c1tjZWxsU3RhcnRdWzFdLnN0YXJ0LFxuICAgICAgICBlbmQ6IGV2ZW50c1tpbmRleF1bMV0uZW5kXG4gICAgICB9XG4gICAgICBldmVudHMuc3BsaWNlKGluZGV4ICsgKHRva2VuLnR5cGUgPT09ICd0YWJsZUNlbGxEaXZpZGVyJyA/IDEgOiAwKSwgMCwgW1xuICAgICAgICAnZXhpdCcsXG4gICAgICAgIGNlbGwsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIF0pXG4gICAgICBldmVudHMuc3BsaWNlKGNlbGxTdGFydCwgMCwgWydlbnRlcicsIGNlbGwsIGNvbnRleHRdKVxuICAgICAgaW5kZXggKz0gMlxuICAgICAgY2VsbFN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBzZWVuQ2VsbEluUm93ID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGFibGVSb3cnKSB7XG4gICAgICBpblJvdyA9IGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcidcblxuICAgICAgaWYgKGluUm93KSB7XG4gICAgICAgIGNlbGxTdGFydCA9IGluZGV4ICsgMVxuICAgICAgICBzZWVuQ2VsbEluUm93ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgaW5EZWxpbWl0ZXJSb3cgPSBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInXG5cbiAgICAgIGlmIChpbkRlbGltaXRlclJvdykge1xuICAgICAgICBjZWxsU3RhcnQgPSBpbmRleCArIDFcbiAgICAgICAgc2VlbkNlbGxJblJvdyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICBpbkhlYWQgPSBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuXG4vKiogQHR5cGUge1Rva2VuaXplcn0gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGFibGUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi9cbiAgY29uc3QgYWxpZ24gPSBbXVxuICBsZXQgdGFibGVIZWFkZXJDb3VudCA9IDBcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IHNlZW5EZWxpbWl0ZXJcbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGhhc0Rhc2hcblxuICByZXR1cm4gc3RhcnRcblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDdXN0b20uXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGUnKS5fYWxpZ24gPSBhbGlnblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuXG4gICAgLy8gSWYgd2Ugc3RhcnQgd2l0aCBhIHBpcGUsIHdlIG9wZW4gYSBjZWxsIG1hcmtlci5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckhlYWQoY29kZSlcbiAgICB9XG5cbiAgICB0YWJsZUhlYWRlckNvdW50KytcbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAvLyBDYW7igJl0IGJlIHNwYWNlIG9yIGVvbHMgYXQgdGhlIHN0YXJ0IG9mIGEgY29uc3RydWN0LCBzbyB3ZeKAmXJlIGluIGEgY2VsbC5cbiAgICBhc3NlcnQoIW1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSksICdleHBlY3RlZCBub24tc3BhY2UnKVxuICAgIHJldHVybiBpbkNlbGxDb250ZW50SGVhZChjb2RlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gY2VsbERpdmlkZXJIZWFkKGNvZGUpIHtcbiAgICBhc3NlcnQoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIsICdleHBlY3RlZCBgfGAnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgc2VlbkRlbGltaXRlciA9IHRydWVcbiAgICByZXR1cm4gY2VsbEJyZWFrSGVhZFxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gY2VsbEJyZWFrSGVhZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBhdFJvd0VuZEhlYWQoY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5lbnRlcih0eXBlcy53aGl0ZXNwYWNlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlSGVhZFxuICAgIH1cblxuICAgIGlmIChzZWVuRGVsaW1pdGVyKSB7XG4gICAgICBzZWVuRGVsaW1pdGVyID0gdW5kZWZpbmVkXG4gICAgICB0YWJsZUhlYWRlckNvdW50KytcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckhlYWQoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGNlbGwgY29udGVudC5cbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWQoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZUhlYWQoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VIZWFkXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KHR5cGVzLndoaXRlc3BhY2UpXG4gICAgcmV0dXJuIGNlbGxCcmVha0hlYWQoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGluQ2VsbENvbnRlbnRIZWFkKGNvZGUpIHtcbiAgICAvLyBFT0YsIHdoaXRlc3BhY2UsIHBpcGVcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ3RlbXBvcmFyeVRhYmxlQ2VsbENvbnRlbnQnKVxuICAgICAgcmV0dXJuIGNlbGxCcmVha0hlYWQoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gY29kZXMuYmFja3NsYXNoXG4gICAgICA/IGluQ2VsbENvbnRlbnRFc2NhcGVIZWFkXG4gICAgICA6IGluQ2VsbENvbnRlbnRIZWFkXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBpbkNlbGxDb250ZW50RXNjYXBlSGVhZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5DZWxsQ29udGVudEhlYWRcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlLlxuICAgIHJldHVybiBpbkNlbGxDb250ZW50SGVhZChjb2RlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gYXRSb3dFbmRIZWFkKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgYXNzZXJ0KG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSwgJ2V4cGVjdGVkIGVvbCcpXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZUhlYWQnKVxuICAgIGNvbnN0IG9yaWdpbmFsSW50ZXJydXB0ID0gc2VsZi5pbnRlcnJ1cHRcbiAgICBzZWxmLmludGVycnVwdCA9IHRydWVcbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAge3Rva2VuaXplOiB0b2tlbml6ZVJvd0VuZCwgcGFydGlhbDogdHJ1ZX0sXG4gICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBzZWxmLmludGVycnVwdCA9IG9yaWdpbmFsSW50ZXJydXB0XG4gICAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyUm93JylcbiAgICAgICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWsoY29kZSlcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBzZWxmLmludGVycnVwdCA9IG9yaWdpbmFsSW50ZXJydXB0XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cbiAgICApKGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIHJvd0VuZERlbGltaXRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKHR5cGVzLndoaXRlc3BhY2UpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZGFzaCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBoYXNEYXNoID0gdHJ1ZVxuICAgICAgYWxpZ24ucHVzaCgnbm9uZScpXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG4gICAgICBhbGlnbi5wdXNoKCdsZWZ0JylcbiAgICAgIHJldHVybiBhZnRlckxlZnRBbGlnbm1lbnRcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYXREZWxpbWl0ZXJSb3dCcmVha1xuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGluV2hpdGVzcGFjZURlbGltaXRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluV2hpdGVzcGFjZURlbGltaXRlclxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCh0eXBlcy53aGl0ZXNwYWNlKVxuICAgIHJldHVybiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBpbkZpbGxlckRlbGltaXRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluRmlsbGVyRGVsaW1pdGVyXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckZpbGxlcicpXG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyQWxpZ25tZW50JylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlckFsaWdubWVudCcpXG5cbiAgICAgIGFsaWduW2FsaWduLmxlbmd0aCAtIDFdID1cbiAgICAgICAgYWxpZ25bYWxpZ24ubGVuZ3RoIC0gMV0gPT09ICdsZWZ0JyA/ICdjZW50ZXInIDogJ3JpZ2h0J1xuXG4gICAgICByZXR1cm4gYWZ0ZXJSaWdodEFsaWdubWVudFxuICAgIH1cblxuICAgIHJldHVybiBhdERlbGltaXRlclJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBhZnRlckxlZnRBbGlnbm1lbnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5kYXNoKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGhhc0Rhc2ggPSB0cnVlXG4gICAgICByZXR1cm4gaW5GaWxsZXJEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGlzIG5vdCBvay5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBhZnRlclJpZ2h0QWxpZ25tZW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIHJvd0VuZERlbGltaXRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKHR5cGVzLndoaXRlc3BhY2UpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VEZWxpbWl0ZXJcbiAgICB9XG5cbiAgICAvLyBgfGBcbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgcmV0dXJuIGF0RGVsaW1pdGVyUm93QnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiByb3dFbmREZWxpbWl0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKVxuXG4gICAgLy8gRXhpdCBpZiB0aGVyZSB3YXMgbm8gZGFzaCBhdCBhbGwsIG9yIGlmIHRoZSBoZWFkZXIgY2VsbCBjb3VudCBpcyBub3QgdGhlXG4gICAgLy8gZGVsaW1pdGVyIGNlbGwgY291bnQuXG4gICAgaWYgKCFoYXNEYXNoIHx8IHRhYmxlSGVhZGVyQ291bnQgIT09IGFsaWduLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YpIHtcbiAgICAgIHJldHVybiB0YWJsZUNsb3NlKGNvZGUpXG4gICAgfVxuXG4gICAgYXNzZXJ0KG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSwgJ2V4cGVjdGVkIGVvbCcpXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICBuZXh0UHJlZml4ZWRPckJsYW5rLFxuICAgICAgdGFibGVDbG9zZSxcbiAgICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAge3Rva2VuaXplOiB0b2tlbml6ZVJvd0VuZCwgcGFydGlhbDogdHJ1ZX0sXG4gICAgICAgIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBib2R5U3RhcnQsIHR5cGVzLmxpbmVQcmVmaXgsIGNvbnN0YW50cy50YWJTaXplKSxcbiAgICAgICAgdGFibGVDbG9zZVxuICAgICAgKVxuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIHRhYmxlQ2xvc2UoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGUnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gYm9keVN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUJvZHknKVxuICAgIHJldHVybiByb3dTdGFydEJvZHkoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIHJvd1N0YXJ0Qm9keShjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuXG4gICAgLy8gSWYgd2Ugc3RhcnQgd2l0aCBhIHBpcGUsIHdlIG9wZW4gYSBjZWxsIG1hcmtlci5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHJldHVybiBjZWxsRGl2aWRlckJvZHkoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmVudGVyKCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAvLyBDYW7igJl0IGJlIHNwYWNlIG9yIGVvbHMgYXQgdGhlIHN0YXJ0IG9mIGEgY29uc3RydWN0LCBzbyB3ZeKAmXJlIGluIGEgY2VsbC5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGNlbGxEaXZpZGVyQm9keShjb2RlKSB7XG4gICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyLCAnZXhwZWN0ZWQgYHxgJylcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgIHJldHVybiBjZWxsQnJlYWtCb2R5XG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBjZWxsQnJlYWtCb2R5KGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGF0Um93RW5kQm9keShjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKHR5cGVzLndoaXRlc3BhY2UpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBpbldoaXRlc3BhY2VCb2R5XG4gICAgfVxuXG4gICAgLy8gYHxgXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICByZXR1cm4gY2VsbERpdmlkZXJCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBjZWxsIGNvbnRlbnQuXG4gICAgZWZmZWN0cy5lbnRlcigndGVtcG9yYXJ5VGFibGVDZWxsQ29udGVudCcpXG4gICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5KGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBpbldoaXRlc3BhY2VCb2R5KGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaW5XaGl0ZXNwYWNlQm9keVxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCh0eXBlcy53aGl0ZXNwYWNlKVxuICAgIHJldHVybiBjZWxsQnJlYWtCb2R5KGNvZGUpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBpbkNlbGxDb250ZW50Qm9keShjb2RlKSB7XG4gICAgLy8gRU9GLCB3aGl0ZXNwYWNlLCBwaXBlXG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KCd0ZW1wb3JhcnlUYWJsZUNlbGxDb250ZW50JylcbiAgICAgIHJldHVybiBjZWxsQnJlYWtCb2R5KGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaFxuICAgICAgPyBpbkNlbGxDb250ZW50RXNjYXBlQm9keVxuICAgICAgOiBpbkNlbGxDb250ZW50Qm9keVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gaW5DZWxsQ29udGVudEVzY2FwZUJvZHkoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5iYWNrc2xhc2ggfHwgY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluQ2VsbENvbnRlbnRCb2R5XG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZS5cbiAgICByZXR1cm4gaW5DZWxsQ29udGVudEJvZHkoY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGF0Um93RW5kQm9keShjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mKSB7XG4gICAgICByZXR1cm4gdGFibGVCb2R5Q2xvc2UoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgIG5leHRQcmVmaXhlZE9yQmxhbmssXG4gICAgICB0YWJsZUJvZHlDbG9zZSxcbiAgICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgICAge3Rva2VuaXplOiB0b2tlbml6ZVJvd0VuZCwgcGFydGlhbDogdHJ1ZX0sXG4gICAgICAgIGZhY3RvcnlTcGFjZShcbiAgICAgICAgICBlZmZlY3RzLFxuICAgICAgICAgIHJvd1N0YXJ0Qm9keSxcbiAgICAgICAgICB0eXBlcy5saW5lUHJlZml4LFxuICAgICAgICAgIGNvbnN0YW50cy50YWJTaXplXG4gICAgICAgICksXG4gICAgICAgIHRhYmxlQm9keUNsb3NlXG4gICAgICApXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gdGFibGVCb2R5Q2xvc2UoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgndGFibGVCb2R5JylcbiAgICByZXR1cm4gdGFibGVDbG9zZShjb2RlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG4gIGZ1bmN0aW9uIHRva2VuaXplUm93RW5kKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgYXNzZXJ0KG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSwgJ2V4cGVjdGVkIGVvbCcpXG4gICAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5saW5lRW5kaW5nKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBwcmVmaXhlZCwgdHlwZXMubGluZVByZWZpeClcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICAgIGZ1bmN0aW9uIHByZWZpeGVkKGNvZGUpIHtcbiAgICAgIC8vIEJsYW5rIG9yIGludGVycnVwdGluZyBsaW5lLlxuICAgICAgaWYgKFxuICAgICAgICBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gfHxcbiAgICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG5cbiAgICAgIC8vIEluZGVudGVkIGNvZGUgY2FuIGludGVycnVwdCBkZWxpbWl0ZXIgYW5kIGJvZHkgcm93cy5cbiAgICAgIGlmIChcbiAgICAgICAgIXNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKSAmJlxuICAgICAgICB0YWlsICYmXG4gICAgICAgIHRhaWxbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeCAmJlxuICAgICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA+PSBjb25zdGFudHMudGFiU2l6ZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5fZ2ZtVGFibGVEeW5hbWljSW50ZXJydXB0SGFjayA9IHRydWVcblxuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZmxvdyxcbiAgICAgICAgZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBzZWxmLl9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgc2VsZi5fZ2ZtVGFibGVEeW5hbWljSW50ZXJydXB0SGFjayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgICAgIH1cbiAgICAgICkoY29kZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtUb2tlbml6ZXJ9ICovXG5mdW5jdGlvbiB0b2tlbml6ZU5leHRQcmVmaXhlZE9yQmxhbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBsZXQgc2l6ZSA9IDBcblxuICByZXR1cm4gc3RhcnRcblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gVGhpcyBpcyBhIGNoZWNrLCBzbyB3ZSBkb27igJl0IGNhcmUgYWJvdXQgdG9rZW5zLCBidXQgd2Ugb3BlbiBhIGJvZ3VzIG9uZVxuICAgIC8vIHNvIHdl4oCZcmUgdmFsaWQuXG4gICAgZWZmZWN0cy5lbnRlcignY2hlY2snKVxuICAgIC8vIEVPTC5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gd2hpdGVzcGFjZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gd2hpdGVzcGFjZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZpcnR1YWxTcGFjZSB8fCBjb2RlID09PSBjb2Rlcy5zcGFjZSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBzaXplID09PSBjb25zdGFudHMudGFiU2l6ZSA/IG9rIDogd2hpdGVzcGFjZVxuICAgIH1cblxuICAgIC8vIEVPRiBvciB3aGl0ZXNwYWNlXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlLlxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiZmFjdG9yeVNwYWNlIiwibWFya2Rvd25MaW5lRW5kaW5nIiwibWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSIsIm1hcmtkb3duU3BhY2UiLCJjb2RlcyIsImNvbnN0YW50cyIsInR5cGVzIiwiZ2ZtVGFibGUiLCJmbG93IiwibnVsbCIsInRva2VuaXplIiwidG9rZW5pemVUYWJsZSIsInJlc29sdmUiLCJyZXNvbHZlVGFibGUiLCJuZXh0UHJlZml4ZWRPckJsYW5rIiwidG9rZW5pemVOZXh0UHJlZml4ZWRPckJsYW5rIiwicGFydGlhbCIsImV2ZW50cyIsImNvbnRleHQiLCJpbmRleCIsImluSGVhZCIsImluRGVsaW1pdGVyUm93IiwiaW5Sb3ciLCJjb250ZW50U3RhcnQiLCJjb250ZW50RW5kIiwiY2VsbFN0YXJ0Iiwic2VlbkNlbGxJblJvdyIsImxlbmd0aCIsInRva2VuIiwidHlwZSIsImNvbnRlbnQiLCJzdGFydCIsImVuZCIsInRleHQiLCJjaHVua1RleHQiLCJjb250ZW50VHlwZSIsImNvbnRlbnRUeXBlVGV4dCIsInNwbGljZSIsInVuZGVmaW5lZCIsIndoaXRlc3BhY2UiLCJjZWxsIiwiZWZmZWN0cyIsIm5vayIsInNlbGYiLCJhbGlnbiIsInRhYmxlSGVhZGVyQ291bnQiLCJzZWVuRGVsaW1pdGVyIiwiaGFzRGFzaCIsImNvZGUiLCJlbnRlciIsIl9hbGlnbiIsInZlcnRpY2FsQmFyIiwiY2VsbERpdmlkZXJIZWFkIiwiaW5DZWxsQ29udGVudEhlYWQiLCJjb25zdW1lIiwiZXhpdCIsImNlbGxCcmVha0hlYWQiLCJlb2YiLCJhdFJvd0VuZEhlYWQiLCJpbldoaXRlc3BhY2VIZWFkIiwiYmFja3NsYXNoIiwiaW5DZWxsQ29udGVudEVzY2FwZUhlYWQiLCJvcmlnaW5hbEludGVycnVwdCIsImludGVycnVwdCIsImF0dGVtcHQiLCJ0b2tlbml6ZVJvd0VuZCIsImF0RGVsaW1pdGVyUm93QnJlYWsiLCJyb3dFbmREZWxpbWl0ZXIiLCJpbldoaXRlc3BhY2VEZWxpbWl0ZXIiLCJkYXNoIiwicHVzaCIsImluRmlsbGVyRGVsaW1pdGVyIiwiY29sb24iLCJhZnRlckxlZnRBbGlnbm1lbnQiLCJhZnRlclJpZ2h0QWxpZ25tZW50IiwidGFibGVDbG9zZSIsImNoZWNrIiwiYm9keVN0YXJ0IiwibGluZVByZWZpeCIsInRhYlNpemUiLCJyb3dTdGFydEJvZHkiLCJjZWxsRGl2aWRlckJvZHkiLCJpbkNlbGxDb250ZW50Qm9keSIsImNlbGxCcmVha0JvZHkiLCJhdFJvd0VuZEJvZHkiLCJpbldoaXRlc3BhY2VCb2R5IiwiaW5DZWxsQ29udGVudEVzY2FwZUJvZHkiLCJ0YWJsZUJvZHlDbG9zZSIsImxpbmVFbmRpbmciLCJwcmVmaXhlZCIsInBhcnNlciIsImxhenkiLCJub3ciLCJsaW5lIiwidGFpbCIsImNvbnN0cnVjdHMiLCJkaXNhYmxlIiwiaW5jbHVkZXMiLCJzbGljZVNlcmlhbGl6ZSIsIl9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrIiwic2l6ZSIsInZpcnR1YWxTcGFjZSIsInNwYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable$1),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/es/index.js\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %cðŸ‘·â€ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(...args){\n        super(...args);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nvar preset$1 = preset;\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = (line, value, otherValue = 0)=>{\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(target);\n};\nvar getSubject = ({ page, withPlaceholder, axis, frame })=>{\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nconst toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>Object.values(droppables));\nconst toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = ({ isMovingForward, draggable, destination, insideDestination, previousImpact })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar noImpact$1 = noImpact;\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({ target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn })=>{\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({ afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last }) {\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({ insideDestination, inHomeList, displacedBy, destination }) {\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact({ draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate }) {\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = ({ isMovingForward, destination, draggables, combine, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = ({ isMovingForward, isInHomeList, insideDestination, location })=>{\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = ({ isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical })=>{\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = ({ displaced, afterCritical, combineWith, displacedBy })=>{\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = ({ afterCritical, impact, draggables })=>{\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant(false) : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({ axis, moveInto, isMoving })=>patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\nvar whenReordering = ({ impact, draggable, draggables, droppable, afterCritical })=>{\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = ({ impact, draggable, droppable, draggables, afterCritical })=>{\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = ({ impact, viewport, destination, draggables, maxScrollChange })=>{\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = ({ pageBorderBoxCenter, draggable, viewport })=>{\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = ({ draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false })=>{\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = ({ isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical })=>{\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = ({ isMovingForward, pageBorderBoxCenter, source, droppables, viewport })=>{\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = ({ pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical })=>{\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = ({ previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical })=>{\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = ({ isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical })=>{\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = ({ state, type })=>{\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({ pageBorderBox, draggable, candidates }) {\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({ pageBorderBox, draggable, droppables }) {\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced({ displaced, id }) {\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex({ draggable, closest, inHomeList }) {\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = ({ pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical })=>{\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({ draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = ({ pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical })=>{\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact$1;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = ({ previousImpact, impact, droppables })=>{\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({ draggable, draggables, droppables, previousImpact, impact })=>{\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = ({ state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest })=>{\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = ({ impact, viewport, draggables, destination, forceShouldAnimate })=>{\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = ({ impact, draggable, droppable, draggables, viewport, afterCritical })=>{\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = ({ state, dimensions: forcedDimensions, viewport: forcedViewport })=>{\n    !(state.movementMode === \"SNAP\") ?  true ? invariant(false) : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = ({ draggable, home, draggables, viewport })=>{\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = ({ draggable, offset: offset$1, initialWindowScroll })=>{\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = ({ additions, updatedDroppables, viewport })=>{\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nconst timingsKey = \"Processing dynamic changes\";\nvar publishWhileDraggingInVirtual = ({ state, published })=>{\n    start(timingsKey);\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish(timingsKey);\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = (state = idle$2, action)=>{\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop$1 = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[ðŸ”¥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>({ getState, dispatch })=>(next)=>(action)=>{\n                if (action.type !== \"LIFT\") {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    marshal.dragging();\n                }\n                if (action.type === \"DROP_ANIMATE\") {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\") {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({ current, destination, reason })=>{\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = ({ impact, draggable, dimensions, viewport, afterCritical })=>{\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = ({ draggables, reason, lastImpact, home, viewport, onLiftImpact })=>{\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = ({ getState, dispatch })=>(next)=>(action)=>{\n            if (action.type !== \"DROP\") {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\nvar drop = dropMiddleware;\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener({ onWindowScroll }) {\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldEnd = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && action.type === \"INITIAL_PUBLISH\") {\n                listener.start();\n            }\n            if (listener.isActive() && shouldEnd(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar scrollListener$1 = scrollListener;\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset$1.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (action.type === \"BEFORE_INITIAL_CAPTURE\") {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (action.type === \"FLUSH\") {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (action.type !== \"DROP_ANIMATION_FINISHED\") {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nvar dropAnimationFinish = dropAnimationFinishMiddleware;\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATION_FINISHED\") {\n                clear();\n            }\n            next(action);\n            if (action.type !== \"DROP_ANIMATE\") {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"DROP_COMPLETE\" || action.type === \"FLUSH\" || action.type === \"DROP_ANIMATE\") {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (action.type === \"FLUSH\") {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (action.type !== \"PUBLISH_WHILE_DRAGGING\") {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop$1({\n                reason: postActionState.reason\n            }));\n        };\nvar pendingDrop$1 = pendingDrop;\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_7__.compose;\nvar createStore = ({ dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller })=>(0,redux__WEBPACK_IMPORTED_MODULE_7__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_7__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), drop, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal), responders(getResponders, announce))));\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher({ registry, callbacks }) {\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = ({ scrollHeight, scrollWidth, height, width })=>{\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = ({ critical, scrollOptions, registry })=>{\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = ({ center, destination, droppables })=>{\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = ({ startOfRange, endOfRange, current })=>{\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = ({ distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = ({ container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = ({ container, subject, proposedScroll })=>{\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = ({ dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return ({ current, max, change })=>{\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = ({ max: rawMax, current, change })=>{\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = ({ viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = ({ droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = ({ state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions })=>{\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = ({ scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions })=>{\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = ({ move, scrollDroppable, scrollWindow })=>{\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = ({ scrollDroppable, scrollWindow, move, getAutoScrollerOptions })=>{\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useLayoutEffect = useIsomorphicLayoutEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>{\n    if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n        return el.ownerDocument.defaultView;\n    }\n    return window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                requestAnimationFrame(registry.clean);\n            } else {\n                registry.clean();\n            }\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nvar visuallyHidden$1 = visuallyHidden;\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(el.style, visuallyHidden$1);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nlet count$1 = 0;\nconst defaults = {\n    separator: \"::\"\n};\nfunction resetDeprecatedUniqueId() {\n    count$1 = 0;\n}\nfunction useDeprecatedUniqueId(prefix, options = defaults) {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${count$1++}`, [\n        options.separator,\n        prefix\n    ]);\n}\nfunction useUniqueId(prefix, options = defaults) {\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nvar useUniqueId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueId : useDeprecatedUniqueId;\nfunction getElementId({ contextId, uniqueId }) {\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({ contextId, text }) {\n    const uniqueId = useUniqueId$1(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^16.8.5 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.5 || ^17.0.0 || ^18.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nvar supportedPageVisibilityEventName = supportedEventName;\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings({ cancel, completed, getPhase, setPhase }) {\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({ cancel, getPhase }) {\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings({ cancel, completed, getPhase }) {\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false) : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive({ expected, phase, isLockActive, shouldWarn }) {\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart({ lockAPI, store, registry, draggableId }) {\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart({ lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent }) {\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options = {\n            shouldBlockNextClick: false\n        }) {\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop$1({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal({ contextId, store, registry, customSensors, enableDefaultSensors }) {\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                onBeforeCapureCallback();\n            } else {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n            }\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nlet count = 0;\nfunction resetDeprecatedUniqueContextId() {\n    count = 0;\n}\nfunction useDeprecatedUniqueContextId() {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${count++}`, []);\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nvar useUniqueContextId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueContextId : useDeprecatedUniqueContextId;\nfunction resetServerContext() {\n    if (\"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default())) {\n         true ? warning(`It is not necessary to call resetServerContext when using React 18+`) : 0;\n        return;\n    }\n    resetDeprecatedUniqueContextId();\n    resetDeprecatedUniqueId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId$1();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId$1(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((el = null)=>{\n        ref.current = el;\n    }, []);\n    const getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n            dropAnimationFinishedAction();\n        } else {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n        }\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar Draggable$1 = Draggable;\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((mode, isClone, draggingOver = null, combineWith = null, dropping = null)=>({\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        }));\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null)=>({\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        }));\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(getSecondarySnapshot);\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((offset, combineTargetFor = null, shouldAnimateDisplacement)=>({\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        }));\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable$1);\nvar ConnectedDraggable$1 = ConnectedDraggable;\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable$1, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant(false) : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar getClosestScrollable$1 = getClosestScrollable;\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable$1(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable$1(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = ({ descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest })=>{\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = ({ ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject })=>{\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId$1(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required({ props }) {\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean({ props }) {\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref({ getDroppableRef }) {\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder({ props, getPlaceholderRef }) {\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone({ props }) {\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder({ getPlaceholderRef }) {\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>droppableRef.current, []);\n    const setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((value = null)=>{\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>placeholderRef.current, []);\n    const setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((value = null)=>{\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, ({ onClose, data, animate })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            })), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nvar Droppable$1 = Droppable;\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable$1);\nvar ConnectedDroppable$1 = ConnectedDroppable;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUM3RDtBQUNtRDtBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDMkI7QUFFMUQsTUFBTTRCLGlCQUFpQkMsa0JBQXlCO0FBQ2hELE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsVUFBVUMsQ0FBQUEsUUFBU0EsTUFBTUMsT0FBTyxDQUFDSixlQUFlLEtBQUtJLE9BQU8sQ0FBQ0gscUJBQXFCLElBQUlJLElBQUk7QUFDaEcsTUFBTUMsZ0JBQWdCQyxDQUFBQSxVQUFXTCxRQUFRLENBQUM7OztJQUd0QyxFQUFFQSxRQUFRSyxTQUFTOzs7QUFHdkIsQ0FBQztBQUNELE1BQU1DLHNCQUFzQkQsQ0FBQUEsVUFBVztRQUFDRCxjQUFjQztRQUFVO1FBQXdEO1FBQW9CO0tBQWtCO0FBQzlKLE1BQU1FLGlCQUFpQjtBQUN2QixTQUFTQyxJQUFJQyxJQUFJLEVBQUVKLE9BQU87SUFDeEIsSUFBSVQsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJLEtBQXVELEVBQUUsRUFFNUQ7SUFDRGUsT0FBTyxDQUFDRixLQUFLLElBQUlILG9CQUFvQkQ7QUFDdkM7QUFDQSxNQUFNTyxVQUFVSixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUMvQixNQUFNQyxRQUFRTixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUU3QixTQUFTRSxVQUFVO0FBRW5CLFNBQVNDLFdBQVdDLE1BQU0sRUFBRUMsV0FBVztJQUNyQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNULEdBQUdDLFdBQVc7SUFDaEI7QUFDRjtBQUNBLFNBQVNDLFdBQVdDLEVBQUUsRUFBRUMsUUFBUSxFQUFFQyxhQUFhO0lBQzdDLE1BQU1DLGFBQWFGLFNBQVNHLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDOUIsTUFBTUMsVUFBVVYsV0FB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QUFrQnFHLFVBQVVyVCxNQUFNLE1BQU03RjtZQUN4RCxNQUFNc3JDLGVBQWU3L0IsUUFBUXlOLFVBQVVyVCxNQUFNLENBQUNDLEVBQUUsSUFBSW9ULFVBQVVyVCxNQUFNLENBQUNDLEVBQUUsQ0FBQ2hLLElBQUksS0FBSztZQUNqRixNQUFNc3ZDLFNBQVNseUIsVUFBVTdGLFFBQVEsQ0FBQ2pQLFNBQVMsQ0FBQ3BFLEVBQUUsS0FBS0E7WUFDbkQsSUFBSXdZLFNBQVM7Z0JBQ1gsT0FBTzh5QixlQUFlWixvQkFBb0JLO1lBQzVDO1lBQ0EsSUFBSUssUUFBUTtnQkFDVixPQUFPVjtZQUNUO1lBQ0EsT0FBT0s7UUFDVDtRQUNBLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPaGU7QUFDVDtBQUNBLE1BQU13ZSxxQkFBcUI7SUFDekIvd0IseUJBQXlCQTtBQUMzQjtBQUNBLE1BQU1neEIscUJBQXFCcHhDLG9EQUFPQSxDQUFDcXdDLHFCQUFxQmMsb0JBQW9CLENBQUNFLFlBQVlDLGVBQWVoSjtJQUN0RyxPQUFPO1FBQ0wsR0FBRzBILDZCQUE2QjFILFNBQVM7UUFDekMsR0FBRytJLFVBQVU7UUFDYixHQUFHQyxhQUFhO0lBQ2xCO0FBQ0YsR0FBRztJQUNEbGYsU0FBU2lGO0lBQ1RpUyxvQkFBb0IzQjtBQUN0QixHQUFHa0k7QUFDSCxJQUFJMEIsdUJBQXVCSDtBQUV3SSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRjaGF0Ly4vbm9kZV9tb2R1bGVzL0BoZWxsby1wYW5nZWEvZG5kL2Rpc3QvZG5kLmVzbS5qcz9jOTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0JDEsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmUkMSwgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAndXNlLW1lbW8tb25lJztcbmltcG9ydCB7IGdldFJlY3QsIGV4cGFuZCwgb2Zmc2V0LCB3aXRoU2Nyb2xsLCBjYWxjdWxhdGVCb3gsIGdldEJveCwgY3JlYXRlQm94IH0gZnJvbSAnY3NzLWJveC1tb2RlbCc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgcmFmU2NoZCBmcm9tICdyYWYtc2NoZCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiQxID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmNvbnN0IHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuY29uc3QgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbmNvbnN0IGNsZWFuJDIgPSB2YWx1ZSA9PiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xuY29uc3QgZ2V0RGV2TWVzc2FnZSA9IG1lc3NhZ2UgPT4gY2xlYW4kMihgXG4gICVjQGhlbGxvLXBhbmdlYS9kbmRcblxuICAlYyR7Y2xlYW4kMihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50IG9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuYCk7XG5jb25zdCBnZXRGb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZSA9PiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuMmVtOyBmb250LXdlaWdodDogYm9sZDsnLCAnbGluZS1oZWlnaHQ6IDEuNScsICdjb2xvcjogIzcyMzg3NDsnXTtcbmNvbnN0IGlzRGlzYWJsZWRGbGFnID0gJ19fQGhlbGxvLXBhbmdlYS9kbmQtZGlzYWJsZS1kZXYtd2FybmluZ3MnO1xuZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzUHJvZHVjdGlvbiQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbaXNEaXNhYmxlZEZsYWddKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGVbdHlwZV0oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG59XG5jb25zdCB3YXJuaW5nID0gbG9nLmJpbmQobnVsbCwgJ3dhcm4nKTtcbmNvbnN0IGVycm9yID0gbG9nLmJpbmQobnVsbCwgJ2Vycm9yJyk7XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoc2hhcmVkLCBmcm9tQmluZGluZykge1xuICByZXR1cm4ge1xuICAgIC4uLnNoYXJlZCxcbiAgICAuLi5mcm9tQmluZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhlbCwgYmluZGluZ3MsIHNoYXJlZE9wdGlvbnMpIHtcbiAgY29uc3QgdW5iaW5kaW5ncyA9IGJpbmRpbmdzLm1hcChiaW5kaW5nID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhzaGFyZWRPcHRpb25zLCBiaW5kaW5nLm9wdGlvbnMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICB1bmJpbmRpbmdzLmZvckVhY2godW5iaW5kID0+IHtcbiAgICAgIHVuYmluZCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3QgcHJlZml4JDEgPSAnSW52YXJpYW50IGZhaWxlZCc7XG5jbGFzcyBSYmRJbnZhcmlhbnQgZXh0ZW5kcyBFcnJvciB7fVxuUmJkSW52YXJpYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnVuYmluZCA9IG5vb3AkMjtcbiAgICB0aGlzLm9uV2luZG93RXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmdldENhbGxiYWNrcygpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2FsbGJhY2tzID0gY2FsbGJhY2tzID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH1cbn1cblxuY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gYFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcbmA7XG5jb25zdCBwb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICsgMTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gc3RhcnQgPT4gYFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiAke3Bvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgd2l0aExvY2F0aW9uID0gKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIGNvbnN0IGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgICAgdG8gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICB0byBsaXN0ICR7ZGVzdGluYXRpb24uZHJvcHBhYmxlSWR9XG4gICAgaW4gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgYDtcbn07XG5jb25zdCB3aXRoQ29tYmluZSA9IChpZCwgc291cmNlLCBjb21iaW5lKSA9PiB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1gO1xuICB9XG4gIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfVxuICAgICAgaW4gbGlzdCAke2NvbWJpbmUuZHJvcHBhYmxlSWR9XG4gICAgYDtcbn07XG5jb25zdCBvbkRyYWdVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cbiAgY29uc3QgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuY29uc3QgcmV0dXJuZWRUb1N0YXJ0ID0gc291cmNlID0+IGBcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxuICBvZiAke3Bvc2l0aW9uKHNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgb25EcmFnRW5kID0gcmVzdWx0ID0+IHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cbiAgICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIGNvbnN0IGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbil9XG4gICAgYDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxuICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICBgO1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmRcbn07XG52YXIgcHJlc2V0JDEgPSBwcmVzZXQ7XG5cbmNvbnN0IG9yaWdpbiA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbmNvbnN0IGFkZCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggKyBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgKyBwb2ludDIueVxufSk7XG5jb25zdCBzdWJ0cmFjdCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxufSk7XG5jb25zdCBpc0VxdWFsJDEgPSAocG9pbnQxLCBwb2ludDIpID0+IHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG5jb25zdCBuZWdhdGUgPSBwb2ludCA9PiAoe1xuICB4OiBwb2ludC54ICE9PSAwID8gLXBvaW50LnggOiAwLFxuICB5OiBwb2ludC55ICE9PSAwID8gLXBvaW50LnkgOiAwXG59KTtcbmNvbnN0IHBhdGNoID0gKGxpbmUsIHZhbHVlLCBvdGhlclZhbHVlID0gMCkgPT4ge1xuICBpZiAobGluZSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZhbHVlLFxuICAgICAgeTogb3RoZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBvdGhlclZhbHVlLFxuICAgIHk6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAocG9pbnQxLCBwb2ludDIpID0+IE1hdGguc3FydCgocG9pbnQyLnggLSBwb2ludDEueCkgKiogMiArIChwb2ludDIueSAtIHBvaW50MS55KSAqKiAyKTtcbmNvbnN0IGNsb3Nlc3QkMSA9ICh0YXJnZXQsIHBvaW50cykgPT4gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBkaXN0YW5jZSh0YXJnZXQsIHBvaW50KSkpO1xuY29uc3QgYXBwbHkgPSBmbiA9PiBwb2ludCA9PiAoe1xuICB4OiBmbihwb2ludC54KSxcbiAgeTogZm4ocG9pbnQueSlcbn0pO1xuXG52YXIgZXhlY3V0ZUNsaXAgPSAoKGZyYW1lLCBzdWJqZWN0KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldFJlY3Qoe1xuICAgIHRvcDogTWF0aC5tYXgoc3ViamVjdC50b3AsIGZyYW1lLnRvcCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHN1YmplY3QucmlnaHQsIGZyYW1lLnJpZ2h0KSxcbiAgICBib3R0b206IE1hdGgubWluKHN1YmplY3QuYm90dG9tLCBmcmFtZS5ib3R0b20pLFxuICAgIGxlZnQ6IE1hdGgubWF4KHN1YmplY3QubGVmdCwgZnJhbWUubGVmdClcbiAgfSk7XG4gIGlmIChyZXN1bHQud2lkdGggPD0gMCB8fCByZXN1bHQuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmNvbnN0IG9mZnNldEJ5UG9zaXRpb24gPSAoc3BhY2luZywgcG9pbnQpID0+ICh7XG4gIHRvcDogc3BhY2luZy50b3AgKyBwb2ludC55LFxuICBsZWZ0OiBzcGFjaW5nLmxlZnQgKyBwb2ludC54LFxuICBib3R0b206IHNwYWNpbmcuYm90dG9tICsgcG9pbnQueSxcbiAgcmlnaHQ6IHNwYWNpbmcucmlnaHQgKyBwb2ludC54XG59KTtcbmNvbnN0IGdldENvcm5lcnMgPSBzcGFjaW5nID0+IFt7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5sZWZ0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufSwge1xuICB4OiBzcGFjaW5nLnJpZ2h0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufV07XG5jb25zdCBub1NwYWNpbmcgPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcblxuY29uc3Qgc2Nyb2xsJDEgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaW5jcmVhc2UgPSAodGFyZ2V0LCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpID0+IHtcbiAgaWYgKHdpdGhQbGFjZWhvbGRlciAmJiB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgW2F4aXMuZW5kXTogdGFyZ2V0W2F4aXMuZW5kXSArIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeVtheGlzLmxpbmVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGNsaXAgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoZnJhbWUgJiYgZnJhbWUuc2hvdWxkQ2xpcFN1YmplY3QpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUNsaXAoZnJhbWUucGFnZU1hcmdpbkJveCwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZ2V0UmVjdCh0YXJnZXQpO1xufTtcbnZhciBnZXRTdWJqZWN0ID0gKCh7XG4gIHBhZ2UsXG4gIHdpdGhQbGFjZWhvbGRlcixcbiAgYXhpcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGwkMShwYWdlLm1hcmdpbkJveCwgZnJhbWUpO1xuICBjb25zdCBpbmNyZWFzZWQgPSBpbmNyZWFzZShzY3JvbGxlZCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKTtcbiAgY29uc3QgY2xpcHBlZCA9IGNsaXAoaW5jcmVhc2VkLCBmcmFtZSk7XG4gIHJldHVybiB7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXIsXG4gICAgYWN0aXZlOiBjbGlwcGVkXG4gIH07XG59KTtcblxudmFyIHNjcm9sbERyb3BwYWJsZSA9ICgoZHJvcHBhYmxlLCBuZXdTY3JvbGwpID0+IHtcbiAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBzY3JvbGxhYmxlID0gZHJvcHBhYmxlLmZyYW1lO1xuICBjb25zdCBzY3JvbGxEaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsKTtcbiAgY29uc3Qgc2Nyb2xsRGlzcGxhY2VtZW50ID0gbmVnYXRlKHNjcm9sbERpZmYpO1xuICBjb25zdCBmcmFtZSA9IHtcbiAgICAuLi5zY3JvbGxhYmxlLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IHNjcm9sbERpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogc2Nyb2xsRGlzcGxhY2VtZW50XG4gICAgICB9LFxuICAgICAgbWF4OiBzY3JvbGxhYmxlLnNjcm9sbC5tYXhcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5jb25zdCB0b0Ryb3BwYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBkcm9wcGFibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0RyYWdnYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBkcmFnZ2FibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0Ryb3BwYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcm9wcGFibGVzKSk7XG5jb25zdCB0b0RyYWdnYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyYWdnYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcmFnZ2FibGVzKSk7XG5cbnZhciBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlID0gbWVtb2l6ZU9uZSgoZHJvcHBhYmxlSWQsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gdG9EcmFnZ2FibGVMaXN0KGRyYWdnYWJsZXMpLmZpbHRlcihkcmFnZ2FibGUgPT4gZHJvcHBhYmxlSWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKS5zb3J0KChhLCBiKSA9PiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXgpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmRlc3RpbmF0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q29tYmluZShpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5jb21iaW5lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QgPSBtZW1vaXplT25lKChyZW1vdmUsIGxpc3QpID0+IGxpc3QuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmlkICE9PSByZW1vdmUuZGVzY3JpcHRvci5pZCkpO1xuXG52YXIgbW92ZVRvTmV4dENvbWJpbmUgPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgcHJldmlvdXNJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihwcmV2aW91c0ltcGFjdCk7XG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbXBhY3QodGFyZ2V0KSB7XG4gICAgY29uc3QgYXQgPSB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiB0YXJnZXQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJldmlvdXNJbXBhY3QsXG4gICAgICBhdFxuICAgIH07XG4gIH1cbiAgY29uc3QgYWxsID0gcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLmFsbDtcbiAgY29uc3QgY2xvc2VzdElkID0gYWxsLmxlbmd0aCA/IGFsbFswXSA6IG51bGw7XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY2xvc2VzdElkID8gZ2V0SW1wYWN0KGNsb3Nlc3RJZCkgOiBudWxsO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2FibGUgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgaWYgKCFjbG9zZXN0SWQpIHtcbiAgICBpZiAoIXdpdGhvdXREcmFnZ2FibGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHdpdGhvdXREcmFnZ2FibGVbd2l0aG91dERyYWdnYWJsZS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZ2V0SW1wYWN0KGxhc3QuZGVzY3JpcHRvci5pZCk7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dhYmxlLmZpbmRJbmRleChkID0+IGQuZGVzY3JpcHRvci5pZCA9PT0gY2xvc2VzdElkKTtcbiAgIShpbmRleE9mQ2xvc2VzdCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgZGlzcGxhY2VkIGl0ZW0gaW4gc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaW5kZXhPZkNsb3Nlc3QgLSAxO1xuICBpZiAocHJvcG9zZWRJbmRleCA8IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBiZWZvcmUgPSB3aXRob3V0RHJhZ2dhYmxlW3Byb3Bvc2VkSW5kZXhdO1xuICByZXR1cm4gZ2V0SW1wYWN0KGJlZm9yZS5kZXNjcmlwdG9yLmlkKTtcbn0pO1xuXG52YXIgaXNIb21lT2YgPSAoKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID0+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkKTtcblxuY29uc3Qgbm9EaXNwbGFjZWRCeSA9IHtcbiAgcG9pbnQ6IG9yaWdpbixcbiAgdmFsdWU6IDBcbn07XG5jb25zdCBlbXB0eUdyb3VwcyA9IHtcbiAgaW52aXNpYmxlOiB7fSxcbiAgdmlzaWJsZToge30sXG4gIGFsbDogW11cbn07XG5jb25zdCBub0ltcGFjdCA9IHtcbiAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gIGF0OiBudWxsXG59O1xudmFyIG5vSW1wYWN0JDEgPSBub0ltcGFjdDtcblxudmFyIGlzV2l0aGluID0gKChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA9PiB2YWx1ZSA9PiBsb3dlckJvdW5kIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVwcGVyQm91bmQpO1xuXG52YXIgaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApIHx8IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSA9IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpIHx8IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBjb25zdCBpc1BhcnRpYWxseUNvbnRhaW5lZCA9IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1BhcnRpYWxseUNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzQmlnZ2VyVmVydGljYWxseSA9IHN1YmplY3QudG9wIDwgZnJhbWUudG9wICYmIHN1YmplY3QuYm90dG9tID4gZnJhbWUuYm90dG9tO1xuICAgIGNvbnN0IGlzQmlnZ2VySG9yaXpvbnRhbGx5ID0gc3ViamVjdC5sZWZ0IDwgZnJhbWUubGVmdCAmJiBzdWJqZWN0LnJpZ2h0ID4gZnJhbWUucmlnaHQ7XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNCaWdnZXJIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IHx8IGlzQmlnZ2VySG9yaXpvbnRhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHk7XG4gICAgcmV0dXJuIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzO1xuICB9O1xufSk7XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgcmV0dXJuIGlzQ29udGFpbmVkO1xuICB9O1xufSk7XG5cbmNvbnN0IHZlcnRpY2FsID0ge1xuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGxpbmU6ICd5JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3gnLFxuICBzdGFydDogJ3RvcCcsXG4gIGVuZDogJ2JvdHRvbScsXG4gIHNpemU6ICdoZWlnaHQnLFxuICBjcm9zc0F4aXNTdGFydDogJ2xlZnQnLFxuICBjcm9zc0F4aXNFbmQ6ICdyaWdodCcsXG4gIGNyb3NzQXhpc1NpemU6ICd3aWR0aCdcbn07XG5jb25zdCBob3Jpem9udGFsID0ge1xuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgbGluZTogJ3gnLFxuICBjcm9zc0F4aXNMaW5lOiAneScsXG4gIHN0YXJ0OiAnbGVmdCcsXG4gIGVuZDogJ3JpZ2h0JyxcbiAgc2l6ZTogJ3dpZHRoJyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICd0b3AnLFxuICBjcm9zc0F4aXNFbmQ6ICdib3R0b20nLFxuICBjcm9zc0F4aXNTaXplOiAnaGVpZ2h0J1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMgPSAoYXhpcyA9PiBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGlmIChheGlzID09PSB2ZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICB9O1xufSk7XG5cbmNvbnN0IGdldERyb3BwYWJsZURpc3BsYWNlZCA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRlc3RpbmF0aW9uLmZyYW1lID8gZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50IDogb3JpZ2luO1xuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5Ecm9wcGFibGUgPSAodGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4oZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpKHRhcmdldCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5WaWV3cG9ydCA9ICh0YXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4odmlld3BvcnQpKHRhcmdldCk7XG5jb25zdCBpc1Zpc2libGUkMSA9ICh7XG4gIHRhcmdldDogdG9CZURpc3BsYWNlZCxcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGblxufSkgPT4ge1xuICBjb25zdCBkaXNwbGFjZWRUYXJnZXQgPSB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID8gZ2V0RHJvcHBhYmxlRGlzcGxhY2VkKHRvQmVEaXNwbGFjZWQsIGRlc3RpbmF0aW9uKSA6IHRvQmVEaXNwbGFjZWQ7XG4gIHJldHVybiBpc1Zpc2libGVJbkRyb3BwYWJsZShkaXNwbGFjZWRUYXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgJiYgaXNWaXNpYmxlSW5WaWV3cG9ydChkaXNwbGFjZWRUYXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbik7XG59O1xuY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWVcbn0pO1xuY29uc3QgaXNUb3RhbGx5VmlzaWJsZSA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlT25BeGlzID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzKGFyZ3MuZGVzdGluYXRpb24uYXhpcylcbn0pO1xuXG5jb25zdCBnZXRTaG91bGRBbmltYXRlID0gKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpID0+IHtcbiAgaWYgKHR5cGVvZiBmb3JjZVNob3VsZEFuaW1hdGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBmb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge1xuICAgIGludmlzaWJsZSxcbiAgICB2aXNpYmxlXG4gIH0gPSBsYXN0O1xuICBpZiAoaW52aXNpYmxlW2lkXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcmV2aW91cyA9IHZpc2libGVbaWRdO1xuICByZXR1cm4gcHJldmlvdXMgPyBwcmV2aW91cy5zaG91bGRBbmltYXRlIDogdHJ1ZTtcbn07XG5mdW5jdGlvbiBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSkge1xuICBjb25zdCBtYXJnaW5Cb3ggPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGNvbnN0IGV4cGFuZEJ5ID0ge1xuICAgIHRvcDogZGlzcGxhY2VkQnkucG9pbnQueSxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogZGlzcGxhY2VkQnkucG9pbnQueFxuICB9O1xuICByZXR1cm4gZ2V0UmVjdChleHBhbmQobWFyZ2luQm94LCBleHBhbmRCeSkpO1xufVxuZnVuY3Rpb24gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgYWZ0ZXJEcmFnZ2luZyxcbiAgZGVzdGluYXRpb24sXG4gIGRpc3BsYWNlZEJ5LFxuICB2aWV3cG9ydCxcbiAgZm9yY2VTaG91bGRBbmltYXRlLFxuICBsYXN0XG59KSB7XG4gIHJldHVybiBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiBwcm9jZXNzKGdyb3VwcywgZHJhZ2dhYmxlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpO1xuICAgIGNvbnN0IGlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQ7XG4gICAgZ3JvdXBzLmFsbC5wdXNoKGlkKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBpc1BhcnRpYWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgZ3JvdXBzLmludmlzaWJsZVtkcmFnZ2FibGUuZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2hvdWxkQW5pbWF0ZVxuICAgIH07XG4gICAgZ3JvdXBzLnZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgIHJldHVybiBncm91cHM7XG4gIH0sIHtcbiAgICBhbGw6IFtdLFxuICAgIHZpc2libGU6IHt9LFxuICAgIGludmlzaWJsZToge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4T2ZMYXN0SXRlbShkcmFnZ2FibGVzLCBvcHRpb25zKSB7XG4gIGlmICghZHJhZ2dhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpbmRleE9mTGFzdEl0ZW0gPSBkcmFnZ2FibGVzW2RyYWdnYWJsZXMubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgcmV0dXJuIG9wdGlvbnMuaW5Ib21lTGlzdCA/IGluZGV4T2ZMYXN0SXRlbSA6IGluZGV4T2ZMYXN0SXRlbSArIDE7XG59XG5mdW5jdGlvbiBnb0F0RW5kKHtcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGluSG9tZUxpc3QsXG4gIGRpc3BsYWNlZEJ5LFxuICBkZXN0aW5hdGlvblxufSkge1xuICBjb25zdCBuZXdJbmRleCA9IGdldEluZGV4T2ZMYXN0SXRlbShpbnNpZGVEZXN0aW5hdGlvbiwge1xuICAgIGluSG9tZUxpc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICBkcmFnZ2FibGUsXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGRpc3BsYWNlZEJ5LFxuICBsYXN0LFxuICBpbmRleCxcbiAgZm9yY2VTaG91bGRBbmltYXRlXG59KSB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBpbnNpZGVEZXN0aW5hdGlvbi5maW5kKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmluZGV4ID09PSBpbmRleCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IHNsaWNlRnJvbSA9IGluc2lkZURlc3RpbmF0aW9uLmluZGV4T2YobWF0Y2gpO1xuICBjb25zdCBpbXBhY3RlZCA9IHdpdGhvdXREcmFnZ2luZy5zbGljZShzbGljZUZyb20pO1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGltcGFjdGVkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZUlkLCBhZnRlckNyaXRpY2FsKSB7XG4gIHJldHVybiBCb29sZWFuKGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbZHJhZ2dhYmxlSWRdKTtcbn1cblxudmFyIGZyb21Db21iaW5lID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIGNvbWJpbmUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29tYmluZUlkID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBkcmFnZ2FibGVzW2NvbWJpbmVJZF07XG4gIGNvbnN0IGNvbWJpbmVXaXRoSW5kZXggPSBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lSWQsIGFmdGVyQ3JpdGljYWwpO1xuICBpZiAoZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwpIHtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggLSAxO1xuICB9XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG59KTtcblxudmFyIGZyb21SZW9yZGVyID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgaXNJbkhvbWVMaXN0LFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbG9jYXRpb25cbn0pID0+IHtcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5kZXggPSBsb2NhdGlvbi5pbmRleDtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9IGlzTW92aW5nRm9yd2FyZCA/IGN1cnJlbnRJbmRleCArIDEgOiBjdXJyZW50SW5kZXggLSAxO1xuICBjb25zdCBmaXJzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25bMF0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgbGFzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IGlzSW5Ib21lTGlzdCA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCArIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgZmlyc3RJbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcm9wb3NlZEluZGV4ID4gdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwcm9wb3NlZEluZGV4O1xufSk7XG5cbnZhciBtb3ZlVG9OZXh0SW5kZXggPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgd2FzQXQgPSBwcmV2aW91c0ltcGFjdC5hdDtcbiAgIXdhc0F0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IG1vdmUgaW4gZGlyZWN0aW9uIHdpdGhvdXQgcHJldmlvdXMgaW1wYWN0IGxvY2F0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAod2FzQXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgY29uc3QgbmV3SW5kZXggPSBmcm9tUmVvcmRlcih7XG4gICAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QsXG4gICAgICBsb2NhdGlvbjogd2FzQXQuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvblxuICAgIH0pO1xuICAgIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbmV3SW5kZXggPSBmcm9tQ29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgY29tYmluZTogd2FzQXQuY29tYmluZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxudmFyIGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCA9ICgoe1xuICBkaXNwbGFjZWQsXG4gIGFmdGVyQ3JpdGljYWwsXG4gIGNvbWJpbmVXaXRoLFxuICBkaXNwbGFjZWRCeVxufSkgPT4ge1xuICBjb25zdCBpc0Rpc3BsYWNlZCA9IEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbY29tYmluZVdpdGhdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbY29tYmluZVdpdGhdKTtcbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lV2l0aCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICByZXR1cm4gaXNEaXNwbGFjZWQgPyBvcmlnaW4gOiBuZWdhdGUoZGlzcGxhY2VkQnkucG9pbnQpO1xuICB9XG4gIHJldHVybiBpc0Rpc3BsYWNlZCA/IGRpc3BsYWNlZEJ5LnBvaW50IDogb3JpZ2luO1xufSk7XG5cbnZhciB3aGVuQ29tYmluaW5nID0gKCh7XG4gIGFmdGVyQ3JpdGljYWwsXG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlc1xufSkgPT4ge1xuICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAhY29tYmluZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNlbnRlciA9IGRyYWdnYWJsZXNbY29tYmluZVdpdGhdLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCh7XG4gICAgZGlzcGxhY2VkOiBpbXBhY3QuZGlzcGxhY2VkLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeVxuICB9KTtcbiAgcmV0dXJuIGFkZChjZW50ZXIsIGRpc3BsYWNlQnkpO1xufSk7XG5cbmNvbnN0IGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgYm94KSA9PiBib3gubWFyZ2luW2F4aXMuc3RhcnRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLmVuZF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xuY29uc3QgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIHRhcmdldCwgaXNNb3ZpbmcpID0+IHRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLm1hcmdpbltheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLmJvcmRlckJveFtheGlzLmNyb3NzQXhpc1NpemVdIC8gMjtcbmNvbnN0IGdvQWZ0ZXIgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29CZWZvcmUgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuc3RhcnRdIC0gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29JbnRvU3RhcnQgPSAoe1xuICBheGlzLFxuICBtb3ZlSW50byxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZUludG8uY29udGVudEJveFtheGlzLnN0YXJ0XSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZUludG8uY29udGVudEJveCwgaXNNb3ZpbmcpKTtcblxudmFyIHdoZW5SZW9yZGVyaW5nID0gKCh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZHJhZ2dhYmxlUGFnZSA9IGRyYWdnYWJsZS5wYWdlO1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdvSW50b1N0YXJ0KHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlSW50bzogZHJvcHBhYmxlLnBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnlcbiAgfSA9IGltcGFjdDtcbiAgY29uc3QgY2xvc2VzdEFmdGVyID0gZGlzcGxhY2VkLmFsbFswXTtcbiAgaWYgKGNsb3Nlc3RBZnRlcikge1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBkcmFnZ2FibGVzW2Nsb3Nlc3RBZnRlcl07XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjbG9zZXN0QWZ0ZXIsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgICBheGlzLFxuICAgICAgICBtb3ZlUmVsYXRpdmVUbzogY2xvc2VzdC5wYWdlLFxuICAgICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBvZmZzZXQoY2xvc2VzdC5wYWdlLCBkaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogd2l0aERpc3BsYWNlbWVudCxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdC5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVQYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIH1cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChsYXN0LmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgY29uc3QgcGFnZSA9IG9mZnNldChsYXN0LnBhZ2UsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSk7XG4gICAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiBwYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZ29BZnRlcih7XG4gICAgYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbGFzdC5wYWdlLFxuICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gIH0pO1xufSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKChkcm9wcGFibGUsIHBvaW50KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIHJldHVybiBhZGQocG9pbnQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59KTtcblxuY29uc3QgZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHdoZW5SZW9yZGVyaW5nKHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHdoZW5Db21iaW5pbmcoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xudmFyIGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0ID0gKGFyZ3MgPT4ge1xuICBjb25zdCB3aXRob3V0RGlzcGxhY2VtZW50ID0gZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudChhcmdzKTtcbiAgY29uc3QgZHJvcHBhYmxlID0gYXJncy5kcm9wcGFibGU7XG4gIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBkcm9wcGFibGUgPyB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRyb3BwYWJsZSwgd2l0aG91dERpc3BsYWNlbWVudCkgOiB3aXRob3V0RGlzcGxhY2VtZW50O1xuICByZXR1cm4gd2l0aERpc3BsYWNlbWVudDtcbn0pO1xuXG52YXIgc2Nyb2xsVmlld3BvcnQgPSAoKHZpZXdwb3J0LCBuZXdTY3JvbGwpID0+IHtcbiAgY29uc3QgZGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBuZWdhdGUoZGlmZik7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBuZXdTY3JvbGwueSxcbiAgICBib3R0b206IG5ld1Njcm9sbC55ICsgdmlld3BvcnQuZnJhbWUuaGVpZ2h0LFxuICAgIGxlZnQ6IG5ld1Njcm9sbC54LFxuICAgIHJpZ2h0OiBuZXdTY3JvbGwueCArIHZpZXdwb3J0LmZyYW1lLndpZHRoXG4gIH0pO1xuICBjb25zdCB1cGRhdGVkID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBkaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVkO1xufSk7XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMkMShpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gZHJhZ2dhYmxlc1tpZF0pO1xufVxuZnVuY3Rpb24gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gZ3JvdXBzW2ldLnZpc2libGVbaWRdO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIHNwZWN1bGF0aXZlbHlJbmNyZWFzZSA9ICgoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgbWF4U2Nyb2xsQ2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbGVkVmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydCh2aWV3cG9ydCwgYWRkKHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKTtcbiAgY29uc3Qgc2Nyb2xsZWREcm9wcGFibGUgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IHNjcm9sbERyb3BwYWJsZShkZXN0aW5hdGlvbiwgYWRkKGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKSA6IGRlc3RpbmF0aW9uO1xuICBjb25zdCBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgY29uc3Qgd2l0aFZpZXdwb3J0U2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHNjcm9sbGVkVmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBzY3JvbGxlZERyb3BwYWJsZSxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGludmlzaWJsZSA9IHt9O1xuICBjb25zdCB2aXNpYmxlID0ge307XG4gIGNvbnN0IGdyb3VwcyA9IFtsYXN0LCB3aXRoVmlld3BvcnRTY3JvbGwsIHdpdGhEcm9wcGFibGVTY3JvbGxdO1xuICBsYXN0LmFsbC5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZpc2libGVbaWRdID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IG5ld0ltcGFjdCA9IHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkOiB7XG4gICAgICBhbGw6IGxhc3QuYWxsLFxuICAgICAgaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0ltcGFjdDtcbn0pO1xuXG52YXIgd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50ID0gKCh2aWV3cG9ydCwgcG9pbnQpID0+IGFkZCh2aWV3cG9ydC5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQsIHBvaW50KSk7XG5cbnZhciBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciA9ICgoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlID0gd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50KHZpZXdwb3J0LCBwYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3Qod2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gYWRkKGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlciwgb2Zmc2V0KTtcbn0pO1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24gPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgbmV3UGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIG9ubHlPbk1haW5BeGlzID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBpc0luSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV4dENvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3RcbiAgfSkgfHwgbW92ZVRvTmV4dEluZGV4KHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICB9KTtcbiAgaWYgKGlzVmlzaWJsZUluTmV3TG9jYXRpb24pIHtcbiAgICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc3RhbmNlID0gc3VidHJhY3QocGFnZUJvcmRlckJveENlbnRlciwgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3QgY2F1dGlvdXMgPSBzcGVjdWxhdGl2ZWx5SW5jcmVhc2Uoe1xuICAgIGltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1heFNjcm9sbENoYW5nZTogZGlzdGFuY2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uOiBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3Q6IGNhdXRpb3VzLFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBkaXN0YW5jZVxuICB9O1xufSk7XG5cbmNvbnN0IGdldEtub3duQWN0aXZlID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZTtcbiAgIXJlY3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGNsaXBwZWQgYXJlYSBmcm9tIGRyb3BwYWJsZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlY3Q7XG59O1xudmFyIGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUgPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBzb3VyY2UsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGFjdGl2ZSA9IHNvdXJjZS5zdWJqZWN0LmFjdGl2ZTtcbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gc291cmNlLmF4aXM7XG4gIGNvbnN0IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5zdGFydF0sIGFjdGl2ZVtheGlzLmVuZF0pO1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlICE9PSBzb3VyY2UpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlLmlzRW5hYmxlZCkuZmlsdGVyKGRyb3BwYWJsZSA9PiBCb29sZWFuKGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZSkpLmZpbHRlcihkcm9wcGFibGUgPT4gaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lKHZpZXdwb3J0LmZyYW1lKShnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdIDwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gPCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBjb25zdCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5lbmRdKTtcbiAgfSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3Qgc2Vjb25kID0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gc2Vjb25kIC0gZmlyc3Q7XG4gIH0pLmZpbHRlcigoZHJvcHBhYmxlLCBpbmRleCwgYXJyYXkpID0+IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5jcm9zc0F4aXNTdGFydF0gPT09IGdldEtub3duQWN0aXZlKGFycmF5WzBdKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXTtcbiAgfVxuICBjb25zdCBjb250YWlucyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgaXNXaXRoaW5Ecm9wcGFibGUgPSBpc1dpdGhpbihnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuc3RhcnRdLCBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzV2l0aGluRHJvcHBhYmxlKHBhZ2VCb3JkZXJCb3hDZW50ZXJbYXhpcy5saW5lXSk7XG4gIH0pO1xuICBpZiAoY29udGFpbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWzBdO1xuICB9XG4gIGlmIChjb250YWlucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zLnNvcnQoKGEsIGIpID0+IGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF0pWzBdO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGEpKSk7XG4gICAgY29uc3Qgc2Vjb25kID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYikpKTtcbiAgICBpZiAoZmlyc3QgIT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgfSlbMF07XG59KTtcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBzdWJ0cmFjdChvcmlnaW5hbCwgYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkgOiBvcmlnaW5hbDtcbn07XG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveCA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3g7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gb2Zmc2V0QnlQb3NpdGlvbihvcmlnaW5hbCwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKSA6IG9yaWdpbmFsO1xufTtcblxudmFyIGdldENsb3Nlc3REcmFnZ2FibGUgPSAoKHtcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBzb3J0ZWQgPSBpbnNpZGVEZXN0aW5hdGlvbi5maWx0ZXIoZHJhZ2dhYmxlID0+IGlzVG90YWxseVZpc2libGUoe1xuICAgIHRhcmdldDogZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3goZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICB9KSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlVG9BID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYSwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvQiA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGIsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgaWYgKGRpc3RhbmNlVG9BIDwgZGlzdGFuY2VUb0IpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlVG9CIDwgZGlzdGFuY2VUb0EpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZFswXSB8fCBudWxsO1xufSk7XG5cbnZhciBnZXREaXNwbGFjZWRCeSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gZ2V0RGlzcGxhY2VkQnkoYXhpcywgZGlzcGxhY2VCeSkge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZUJ5W2F4aXMubGluZV07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGRpc3BsYWNlbWVudCxcbiAgICBwb2ludDogcGF0Y2goYXhpcy5saW5lLCBkaXNwbGFjZW1lbnQpXG4gIH07XG59KTtcblxuY29uc3QgZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmIChkcm9wcGFibGUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXSk7XG4gIH1cbiAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBkcm9wcGFibGUuc3ViamVjdC5wYWdlLmNvbnRlbnRCb3hbYXhpcy5zaXplXTtcbiAgY29uc3QgaW5zaWRlRHJvcHBhYmxlID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHNwYWNlVXNlZCA9IGluc2lkZURyb3BwYWJsZS5yZWR1Y2UoKHN1bSwgZGltZW5zaW9uKSA9PiBzdW0gKyBkaW1lbnNpb24uY2xpZW50Lm1hcmdpbkJveFtheGlzLnNpemVdLCAwKTtcbiAgY29uc3QgcmVxdWlyZWRTcGFjZSA9IHNwYWNlVXNlZCArIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdO1xuICBjb25zdCBuZWVkc1RvR3Jvd0J5ID0gcmVxdWlyZWRTcGFjZSAtIGF2YWlsYWJsZVNwYWNlO1xuICBpZiAobmVlZHNUb0dyb3dCeSA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbmVlZHNUb0dyb3dCeSk7XG59O1xuY29uc3Qgd2l0aE1heFNjcm9sbCA9IChmcmFtZSwgbWF4KSA9PiAoe1xuICAuLi5mcmFtZSxcbiAgc2Nyb2xsOiB7XG4gICAgLi4uZnJhbWUuc2Nyb2xsLFxuICAgIG1heFxuICB9XG59KTtcbmNvbnN0IGFkZFBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhIWlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBub3QgYWRkIHBsYWNlaG9sZGVyIHNwYWNlIHRvIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISFkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYWRkIHBsYWNlaG9sZGVyIHNpemUgdG8gYSBzdWJqZWN0IHdoZW4gaXQgYWxyZWFkeSBoYXMgb25lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBwbGFjZWhvbGRlclNpemUgPSBnZXREaXNwbGFjZWRCeShkcm9wcGFibGUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpLnBvaW50O1xuICBjb25zdCByZXF1aXJlZEdyb3d0aCA9IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBhZGRlZCA9IHtcbiAgICBwbGFjZWhvbGRlclNpemUsXG4gICAgaW5jcmVhc2VkQnk6IHJlcXVpcmVkR3Jvd3RoLFxuICAgIG9sZEZyYW1lTWF4U2Nyb2xsOiBkcm9wcGFibGUuZnJhbWUgPyBkcm9wcGFibGUuZnJhbWUuc2Nyb2xsLm1heCA6IG51bGxcbiAgfTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogZHJvcHBhYmxlLmZyYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1heFNjcm9sbCA9IHJlcXVpcmVkR3Jvd3RoID8gYWRkKGZyYW1lLnNjcm9sbC5tYXgsIHJlcXVpcmVkR3Jvd3RoKSA6IGZyYW1lLnNjcm9sbC5tYXg7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuY29uc3QgcmVtb3ZlUGxhY2Vob2xkZXIgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBhZGRlZCA9IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcjtcbiAgIWFkZGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbW92ZSBwbGFjZWhvbGRlciBmb3JtIHN1YmplY3Qgd2hlbiB0aGVyZSB3YXMgbm9uZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcm9wcGFibGUsXG4gICAgICBzdWJqZWN0XG4gICAgfTtcbiAgfVxuICBjb25zdCBvbGRNYXhTY3JvbGwgPSBhZGRlZC5vbGRGcmFtZU1heFNjcm9sbDtcbiAgIW9sZE1heFNjcm9sbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyb3BwYWJsZSB3aXRoIGZyYW1lIHRvIGhhdmUgb2xkIG1heCBmcmFtZSBzY3JvbGwgd2hlbiByZW1vdmluZyBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBvbGRNYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWUsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9O1xufTtcblxudmFyIG1vdmVUb05ld0Ryb3BwYWJsZSA9ICgoe1xuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFtb3ZlUmVsYXRpdmVUbykge1xuICAgIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9wb3NlZCA9IHtcbiAgICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgICAgIGF0OiB7XG4gICAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgICBpbXBhY3Q6IHByb3Bvc2VkLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgY29uc3Qgd2l0aFBsYWNlaG9sZGVyID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPyBkZXN0aW5hdGlvbiA6IGFkZFBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICAgIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbjogd2l0aFBsYWNlaG9sZGVyLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID8gcHJvcG9zZWQgOiBudWxsO1xuICB9XG4gIGNvbnN0IGlzR29pbmdCZWZvcmVUYXJnZXQgPSBCb29sZWFuKHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdIDw9IG1vdmVSZWxhdGl2ZVRvLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdKTtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9ICgoKSA9PiB7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaW5kZXg7XG4gICAgaWYgKG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgaWYgKGlzR29pbmdCZWZvcmVUYXJnZXQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVUbyArIDE7XG4gIH0pKCk7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGVtcHR5R3JvdXBzLFxuICAgIGluZGV4OiBwcm9wb3NlZEluZGV4XG4gIH0pO1xufSk7XG5cbnZhciBtb3ZlQ3Jvc3NBeGlzID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIGlzT3ZlcixcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHNvdXJjZTogaXNPdmVyLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGlmICghZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IG1vdmVSZWxhdGl2ZVRvID0gZ2V0Q2xvc2VzdERyYWdnYWJsZSh7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGltcGFjdCA9IG1vdmVUb05ld0Ryb3BwYWJsZSh7XG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1vdmVSZWxhdGl2ZVRvLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICB9O1xufSk7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlciA9IChpbXBhY3QgPT4ge1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gYXQuZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIGF0LmNvbWJpbmUuZHJvcHBhYmxlSWQ7XG59KTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlciQxID0gKGltcGFjdCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBpZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIHJldHVybiBpZCA/IGRyb3BwYWJsZXNbaWRdIDogbnVsbDtcbn07XG52YXIgbW92ZUluRGlyZWN0aW9uID0gKCh7XG4gIHN0YXRlLFxuICB0eXBlXG59KSA9PiB7XG4gIGNvbnN0IGlzQWN0dWFsbHlPdmVyID0gZ2V0RHJvcHBhYmxlT3ZlciQxKHN0YXRlLmltcGFjdCwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzKTtcbiAgY29uc3QgaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCA9IEJvb2xlYW4oaXNBY3R1YWxseU92ZXIpO1xuICBjb25zdCBob21lID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IGlzQWN0dWFsbHlPdmVyIHx8IGhvbWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGlzT3Zlci5heGlzLmRpcmVjdGlvbjtcbiAgY29uc3QgaXNNb3ZpbmdPbk1haW5BeGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmICh0eXBlID09PSAnTU9WRV9VUCcgfHwgdHlwZSA9PT0gJ01PVkVfRE9XTicpIHx8IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmICh0eXBlID09PSAnTU9WRV9MRUZUJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCcpO1xuICBpZiAoaXNNb3ZpbmdPbk1haW5BeGlzICYmICFpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaXNNb3ZpbmdGb3J3YXJkID0gdHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnO1xuICBjb25zdCBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gc3RhdGUuZGltZW5zaW9ucztcbiAgcmV0dXJuIGlzTW92aW5nT25NYWluQXhpcyA/IG1vdmVUb05leHRQbGFjZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbjogc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KSA6IG1vdmVDcm9zc0F4aXMoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORyc7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJ1bihwb2ludCkge1xuICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHBvaW50LnkpICYmIGlzV2l0aGluSG9yaXpvbnRhbChwb2ludC54KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzT3ZlcmxhcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBmaXJzdC5sZWZ0IDwgc2Vjb25kLnJpZ2h0ICYmIGZpcnN0LnJpZ2h0ID4gc2Vjb25kLmxlZnQgJiYgZmlyc3QudG9wIDwgc2Vjb25kLmJvdHRvbSAmJiBmaXJzdC5ib3R0b20gPiBzZWNvbmQudG9wO1xufVxuZnVuY3Rpb24gZ2V0RnVydGhlc3RBd2F5KHtcbiAgcGFnZUJvcmRlckJveCxcbiAgZHJhZ2dhYmxlLFxuICBjYW5kaWRhdGVzXG59KSB7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IHtcbiAgICBjb25zdCBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZXNcbn0pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgY29uc3QgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICBjb25zdCBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIGNvbnN0IGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG5jb25zdCBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IChyZWN0LCBwb2ludCkgPT4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKChkcm9wcGFibGUsIGFyZWEpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oYXJlYSwgZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWUpO1xufSk7XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKHtcbiAgZGlzcGxhY2VkLFxuICBpZFxufSkge1xuICByZXR1cm4gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtpZF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtpZF0pO1xufVxuXG5mdW5jdGlvbiBhdEluZGV4KHtcbiAgZHJhZ2dhYmxlLFxuICBjbG9zZXN0LFxuICBpbkhvbWVMaXN0XG59KSB7XG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKCh7XG4gIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbGFzdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pIHx8IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxuY29uc3QgY29tYmluZVRocmVzaG9sZERpdmlzb3IgPSA0O1xudmFyIGdldENvbWJpbmVJbXBhY3QgPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY29tYmluZVdpdGggPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkUmVjdCA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94O1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGNoaWxkUmVjdFtheGlzLnNpemVdO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNoaWxkU2l6ZSAvIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yO1xuICAgIGNvbnN0IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICBjb25zdCBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gLSBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSArIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgfSk7XG4gIGlmICghY29tYmluZVdpdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkQnksXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaW1wYWN0O1xufSk7XG5cbnZhciBnZXREcmFnSW1wYWN0ID0gKCh7XG4gIHBhZ2VPZmZzZXQsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3ggPSBvZmZzZXRSZWN0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIHBhZ2VPZmZzZXQpO1xuICBjb25zdCBkZXN0aW5hdGlvbklkID0gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gICAgcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbklkKSB7XG4gICAgcmV0dXJuIG5vSW1wYWN0JDE7XG4gIH1cbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxudmFyIHBhdGNoRHJvcHBhYmxlTWFwID0gKChkcm9wcGFibGVzLCB1cGRhdGVkKSA9PiAoe1xuICAuLi5kcm9wcGFibGVzLFxuICBbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXTogdXBkYXRlZFxufSkpO1xuXG5jb25zdCBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gKHtcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdCxcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBjb25zdCBsYXN0ID0gd2hhdElzRHJhZ2dlZE92ZXIocHJldmlvdXNJbXBhY3QpO1xuICBjb25zdCBub3cgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBpZiAobGFzdCA9PT0gbm93KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgbGFzdERyb3BwYWJsZSA9IGRyb3BwYWJsZXNbbGFzdF07XG4gIGlmICghbGFzdERyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWQgPSByZW1vdmVQbGFjZWhvbGRlcihsYXN0RHJvcHBhYmxlKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMsIHVwZGF0ZWQpO1xufTtcbnZhciByZWNvbXB1dGVQbGFjZWhvbGRlcnMgPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgaW1wYWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsZWFuZWQgPSBjbGVhclVudXNlZFBsYWNlaG9sZGVyKHtcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBpbXBhY3QsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgaWYgKCFpc092ZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBjb25zdCBkcm9wcGFibGUgPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGlmIChpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBpZiAoZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgcGF0Y2hlZCA9IGFkZFBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGNsZWFuZWQsIHBhdGNoZWQpO1xufSk7XG5cbnZhciB1cGRhdGUgPSAoKHtcbiAgc3RhdGUsXG4gIGNsaWVudFNlbGVjdGlvbjogZm9yY2VkQ2xpZW50U2VsZWN0aW9uLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnQsXG4gIGltcGFjdDogZm9yY2VkSW1wYWN0LFxuICBzY3JvbGxKdW1wUmVxdWVzdFxufSkgPT4ge1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG52YXIgcmVjb21wdXRlID0gKCh7XG4gIGltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWRcbiAgfTtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKCh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xufSk7XG5cbnZhciByZWZyZXNoU25hcCA9ICgoe1xuICBzdGF0ZSxcbiAgZGltZW5zaW9uczogZm9yY2VkRGltZW5zaW9ucyxcbiAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0XG59KSA9PiB7XG4gICEoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IG5lZWRzVmlzaWJpbGl0eUNoZWNrID0gc3RhdGUuaW1wYWN0O1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKG5lZWRzVmlzaWJpbGl0eUNoZWNrKTtcbiAgIWlzT3ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgb3ZlciBhIGRlc3RpbmF0aW9uIGluIFNOQVAgbW92ZW1lbnQgbW9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGNvbnN0IGltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgaW1wYWN0OiBuZWVkc1Zpc2liaWxpdHlDaGVjayxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiB1cGRhdGUoe1xuICAgIGltcGFjdCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn0pO1xuXG52YXIgZ2V0SG9tZUxvY2F0aW9uID0gKGRlc2NyaXB0b3IgPT4gKHtcbiAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG59KSk7XG5cbnZhciBnZXRMaWZ0RWZmZWN0ID0gKCh7XG4gIGRyYWdnYWJsZSxcbiAgaG9tZSxcbiAgZHJhZ2dhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShob21lLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgaW5zaWRlSG9tZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoaG9tZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgcmF3SW5kZXggPSBpbnNpZGVIb21lLmluZGV4T2YoZHJhZ2dhYmxlKTtcbiAgIShyYXdJbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJhZ2dhYmxlIHRvIGJlIGluc2lkZSBob21lIGxpc3QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBpbnNpZGVIb21lLnNsaWNlKHJhd0luZGV4ICsgMSk7XG4gIGNvbnN0IGVmZmVjdGVkID0gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoKHByZXZpb3VzLCBpdGVtKSA9PiB7XG4gICAgcHJldmlvdXNbaXRlbS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG4gIGNvbnN0IGFmdGVyQ3JpdGljYWwgPSB7XG4gICAgaW5WaXJ0dWFsTGlzdDogaG9tZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBlZmZlY3RlZFxuICB9O1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbnVsbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IGdldEhvbWVMb2NhdGlvbihkcmFnZ2FibGUuZGVzY3JpcHRvcilcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfTtcbn0pO1xuXG52YXIgcGF0Y2hEaW1lbnNpb25NYXAgPSAoKGRpbWVuc2lvbnMsIHVwZGF0ZWQpID0+ICh7XG4gIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlczogcGF0Y2hEcm9wcGFibGVNYXAoZGltZW5zaW9ucy5kcm9wcGFibGVzLCB1cGRhdGVkKVxufSkpO1xuXG5jb25zdCBzdGFydCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmlzaCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG9mZnNldERyYWdnYWJsZSA9ICgoe1xuICBkcmFnZ2FibGUsXG4gIG9mZnNldDogb2Zmc2V0JDEsXG4gIGluaXRpYWxXaW5kb3dTY3JvbGxcbn0pID0+IHtcbiAgY29uc3QgY2xpZW50ID0gb2Zmc2V0KGRyYWdnYWJsZS5jbGllbnQsIG9mZnNldCQxKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCBpbml0aWFsV2luZG93U2Nyb2xsKTtcbiAgY29uc3QgbW92ZWQgPSB7XG4gICAgLi4uZHJhZ2dhYmxlLFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAuLi5kcmFnZ2FibGUucGxhY2Vob2xkZXIsXG4gICAgICBjbGllbnRcbiAgICB9LFxuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIHJldHVybiBtb3ZlZDtcbn0pO1xuXG52YXIgZ2V0RnJhbWUgPSAoZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICFmcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIERyb3BwYWJsZSB0byBoYXZlIGEgZnJhbWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmcmFtZTtcbn0pO1xuXG52YXIgYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyA9ICgoe1xuICBhZGRpdGlvbnMsXG4gIHVwZGF0ZWREcm9wcGFibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCB3aW5kb3dTY3JvbGxDaGFuZ2UgPSB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgcmV0dXJuIGFkZGl0aW9ucy5tYXAoZHJhZ2dhYmxlID0+IHtcbiAgICBjb25zdCBkcm9wcGFibGVJZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICAgIGNvbnN0IG1vZGlmaWVkID0gdXBkYXRlZERyb3BwYWJsZXNbZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IGZyYW1lID0gZ2V0RnJhbWUobW9kaWZpZWQpO1xuICAgIGNvbnN0IGRyb3BwYWJsZVNjcm9sbENoYW5nZSA9IGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlO1xuICAgIGNvbnN0IHRvdGFsQ2hhbmdlID0gYWRkKHdpbmRvd1Njcm9sbENoYW5nZSwgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKTtcbiAgICBjb25zdCBtb3ZlZCA9IG9mZnNldERyYWdnYWJsZSh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBvZmZzZXQ6IHRvdGFsQ2hhbmdlLFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbW92ZWQ7XG4gIH0pO1xufSk7XG5cbmNvbnN0IHRpbWluZ3NLZXkgPSAnUHJvY2Vzc2luZyBkeW5hbWljIGNoYW5nZXMnO1xudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsID0gKCh7XG4gIHN0YXRlLFxuICBwdWJsaXNoZWRcbn0pID0+IHtcbiAgc3RhcnQodGltaW5nc0tleSk7XG4gIGNvbnN0IHdpdGhTY3JvbGxDaGFuZ2UgPSBwdWJsaXNoZWQubW9kaWZpZWQubWFwKHVwZGF0ZSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbdXBkYXRlLmRyb3BwYWJsZUlkXTtcbiAgICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZShleGlzdGluZywgdXBkYXRlLnNjcm9sbCk7XG4gICAgcmV0dXJuIHNjcm9sbGVkO1xuICB9KTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHtcbiAgICAuLi5zdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgLi4udG9Ecm9wcGFibGVNYXAod2l0aFNjcm9sbENoYW5nZSlcbiAgfTtcbiAgY29uc3QgdXBkYXRlZEFkZGl0aW9ucyA9IHRvRHJhZ2dhYmxlTWFwKGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMoe1xuICAgIGFkZGl0aW9uczogcHVibGlzaGVkLmFkZGl0aW9ucyxcbiAgICB1cGRhdGVkRHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSkpO1xuICBjb25zdCBkcmFnZ2FibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAuLi51cGRhdGVkQWRkaXRpb25zXG4gIH07XG4gIHB1Ymxpc2hlZC5yZW1vdmFscy5mb3JFYWNoKGlkID0+IHtcbiAgICBkZWxldGUgZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb25zID0ge1xuICAgIGRyb3BwYWJsZXMsXG4gICAgZHJhZ2dhYmxlc1xuICB9O1xuICBjb25zdCB3YXNPdmVySWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICBjb25zdCB3YXNPdmVyID0gd2FzT3ZlcklkID8gZGltZW5zaW9ucy5kcm9wcGFibGVzW3dhc092ZXJJZF0gOiBudWxsO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGhvbWUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IHByZXZpb3VzSW1wYWN0ID0gd2FzT3ZlciAmJiB3YXNPdmVyLmlzQ29tYmluZUVuYWJsZWQgPyBzdGF0ZS5pbXBhY3QgOiBvbkxpZnRJbXBhY3Q7XG4gIGNvbnN0IGltcGFjdCA9IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHN0YXRlLmN1cnJlbnQucGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlOiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBmaW5pc2godGltaW5nc0tleSk7XG4gIGNvbnN0IGRyYWdnaW5nU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgaW1wYWN0LFxuICAgIG9uTGlmdEltcGFjdCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiBkcmFnZ2luZ1N0YXRlO1xuICB9XG4gIGNvbnN0IGRyb3BQZW5kaW5nID0ge1xuICAgIC4uLmRyYWdnaW5nU3RhdGUsXG4gICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgIHJlYXNvbjogc3RhdGUucmVhc29uLFxuICAgIGlzV2FpdGluZzogZmFsc2VcbiAgfTtcbiAgcmV0dXJuIGRyb3BQZW5kaW5nO1xufSk7XG5cbmNvbnN0IGlzU25hcHBpbmcgPSBzdGF0ZSA9PiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJztcbmNvbnN0IHBvc3REcm9wcGFibGVDaGFuZ2UgPSAoc3RhdGUsIHVwZGF0ZWQsIGlzRW5hYmxlZENoYW5naW5nKSA9PiB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBwYXRjaERpbWVuc2lvbk1hcChzdGF0ZS5kaW1lbnNpb25zLCB1cGRhdGVkKTtcbiAgaWYgKCFpc1NuYXBwaW5nKHN0YXRlKSB8fCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBkaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5pc0RyYWdnaW5nICYmIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IGlkbGUkMiA9IHtcbiAgcGhhc2U6ICdJRExFJyxcbiAgY29tcGxldGVkOiBudWxsLFxuICBzaG91bGRGbHVzaDogZmFsc2Vcbn07XG52YXIgcmVkdWNlciA9ICgoc3RhdGUgPSBpZGxlJDIsIGFjdGlvbikgPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaWRsZSQyLFxuICAgICAgc2hvdWxkRmx1c2g6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSU5JVElBTF9QVUJMSVNIIG11c3QgY29tZSBhZnRlciBhIElETEUgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgY3JpdGljYWwsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBtb3ZlbWVudE1vZGVcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW2NyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gICAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tjcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICAgIGNvbnN0IGNsaWVudCA9IHtcbiAgICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgYm9yZGVyQm94Q2VudGVyOiBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsXG4gICAgICBvZmZzZXQ6IG9yaWdpblxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgIGNsaWVudCxcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIG9mZnNldDogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNXaW5kb3dTY3JvbGxBbGxvd2VkID0gdG9Ecm9wcGFibGVMaXN0KGRpbWVuc2lvbnMuZHJvcHBhYmxlcykuZXZlcnkoaXRlbSA9PiAhaXRlbS5pc0ZpeGVkT25QYWdlKTtcbiAgICBjb25zdCB7XG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSA9IGdldExpZnRFZmZlY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaG9tZSxcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgY3JpdGljYWwsXG4gICAgICBtb3ZlbWVudE1vZGUsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWwsXG4gICAgICBpc1dpbmRvd1Njcm9sbEFsbG93ZWQsXG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsLFxuICAgICAgb25MaWZ0SW1wYWN0OiBpbXBhY3QsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0NPTExFQ1RJT05fU1RBUlRJTkcnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBoYXNlOiAnQ09MTEVDVElORydcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuZXhwZWN0ZWQgJHthY3Rpb24udHlwZX0gcmVjZWl2ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcHVibGlzaGVkOiBhY3Rpb24ucGF5bG9hZFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkUnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjbGllbnQ6IGNsaWVudFNlbGVjdGlvblxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBpZiAoaXNFcXVhbCQxKGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0OiBpc1NuYXBwaW5nKHN0YXRlKSA/IHN0YXRlLmltcGFjdCA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBuZXdTY3JvbGxcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZSh0YXJnZXQsIG5ld1Njcm9sbCk7XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHNjcm9sbGVkLCBmYWxzZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNFbmFibGVkICE9PSBpc0VuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNFbmFibGVkIHRvICR7U3RyaW5nKGlzRW5hYmxlZCl9XG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSAke1N0cmluZyh0YXJnZXQuaXNFbmFibGVkKX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICAhdGFyZ2V0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiAke2lkfV0gdG8gdG9nZ2xlIGl0cyBpc0NvbWJpbmVFbmFibGVkIHN0YXRlYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQgIT09IGlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNDb21iaW5lRW5hYmxlZCB0byAke1N0cmluZyhpc0NvbWJpbmVFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0NvbWJpbmVFbmFibGVkKX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9O1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCB0cnVlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IG1vdmUgYnkgd2luZG93IGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdXaW5kb3cgc2Nyb2xsaW5nIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciBmaXhlZCBsaXN0cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5uZXdTY3JvbGw7XG4gICAgaWYgKGlzRXF1YWwkMShzdGF0ZS52aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbmV3U2Nyb2xsKSkge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydChzdGF0ZS52aWV3cG9ydCwgbmV3U2Nyb2xsKTtcbiAgICBpZiAoaXNTbmFwcGluZyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJykge1xuICAgIGlmICghaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm1heFNjcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKG1heFNjcm9sbCwgc3RhdGUudmlld3BvcnQuc2Nyb2xsLm1heCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aE1heFNjcm9sbCA9IHtcbiAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpZXdwb3J0OiB3aXRoTWF4U2Nyb2xsXG4gICAgfTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1VQJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9SSUdIVCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSByZWNlaXZlZCB3aGlsZSBub3QgaW4gRFJBR0dJTkcgcGhhc2VgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0gbW92ZUluRGlyZWN0aW9uKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICB9KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgaW1wYWN0OiByZXN1bHQuaW1wYWN0LFxuICAgICAgY2xpZW50U2VsZWN0aW9uOiByZXN1bHQuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IHJlc3VsdC5zY3JvbGxKdW1wUmVxdWVzdFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICBjb25zdCByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IG1vdmUgaW50byB0aGUgRFJPUF9QRU5ESU5HIHBoYXNlIGZyb20gdGhlIENPTExFQ1RJTkcgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICAgIGlzV2FpdGluZzogdHJ1ZSxcbiAgICAgIHJlYXNvblxuICAgIH07XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0XG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBhbmltYXRlIGRyb3AgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RST1BfQU5JTUFUSU5HJyxcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiBzdGF0ZS5kaW1lbnNpb25zXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcGxldGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ0lETEUnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgc2hvdWxkRmx1c2g6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59KTtcblxuY29uc3QgYmVmb3JlSW5pdGlhbENhcHR1cmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBsaWZ0JDEgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdMSUZUJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBpbml0aWFsUHVibGlzaCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0lOSVRJQUxfUFVCTElTSCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgcHVibGlzaFdoaWxlRHJhZ2dpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBjb2xsZWN0aW9uU3RhcnRpbmcgPSAoKSA9PiAoe1xuICB0eXBlOiAnQ09MTEVDVElPTl9TVEFSVElORycsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTU9WRScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZUJ5V2luZG93U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlVXAgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9VUCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZURvd24gPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9ET1dOJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlUmlnaHQgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9SSUdIVCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZUxlZnQgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9MRUZUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBmbHVzaCA9ICgpID0+ICh7XG4gIHR5cGU6ICdGTFVTSCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgYW5pbWF0ZURyb3AgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVEUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbXBsZXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQ09NUExFVEUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3AkMSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1AnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BQZW5kaW5nID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9QRU5ESU5HJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wQW5pbWF0aW9uRmluaXNoZWQgPSAoKSA9PiAoe1xuICB0eXBlOiAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcblxuZnVuY3Rpb24gY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKSB7XG4gIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbmRleGVzID0gaW5zaWRlRGVzdGluYXRpb24ubWFwKGQgPT4gZC5kZXNjcmlwdG9yLmluZGV4KTtcbiAgY29uc3QgZXJyb3JzID0ge307XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBpbmRleGVzW2ldO1xuICAgIGNvbnN0IHByZXZpb3VzID0gaW5kZXhlc1tpIC0gMV07XG4gICAgaWYgKGN1cnJlbnQgIT09IHByZXZpb3VzICsgMSkge1xuICAgICAgZXJyb3JzW2N1cnJlbnRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZWQgPSBpbmRleGVzLm1hcChpbmRleCA9PiB7XG4gICAgY29uc3QgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yc1tpbmRleF0pO1xuICAgIHJldHVybiBoYXNFcnJvciA/IGBb8J+UpSR7aW5kZXh9XWAgOiBgJHtpbmRleH1gO1xuICB9KS5qb2luKCcsICcpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEZXRlY3RlZCBub24tY29uc2VjdXRpdmUgPERyYWdnYWJsZSAvPiBpbmRleGVzLlxuXG4gICAgKFRoaXMgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYnVncylcblxuICAgICR7Zm9ybWF0dGVkfVxuICBgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShjcml0aWNhbC5kcm9wcGFibGUuaWQsIGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyk7XG4gICAgY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG52YXIgbGlmdCA9IChtYXJzaGFsID0+ICh7XG4gIGdldFN0YXRlLFxuICBkaXNwYXRjaFxufSkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgIT09ICdMSUZUJykge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBtb3ZlbWVudE1vZGVcbiAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCBpbml0aWFsID0gZ2V0U3RhdGUoKTtcbiAgaWYgKGluaXRpYWwucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgY29tcGxldGVkOiBpbml0aWFsLmNvbXBsZXRlZFxuICAgIH0pKTtcbiAgfVxuICAhKGdldFN0YXRlKCkucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlIHRvIHN0YXJ0IGEgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZGlzcGF0Y2goZmx1c2goKSk7XG4gIGRpc3BhdGNoKGJlZm9yZUluaXRpYWxDYXB0dXJlKHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgbW92ZW1lbnRNb2RlXG4gIH0pKTtcbiAgY29uc3Qgc2Nyb2xsT3B0aW9ucyA9IHtcbiAgICBzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHk6IG1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnXG4gIH07XG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgIHNjcm9sbE9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGNyaXRpY2FsLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnRcbiAgfSA9IG1hcnNoYWwuc3RhcnRQdWJsaXNoaW5nKHJlcXVlc3QpO1xuICB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpO1xuICBkaXNwYXRjaChpbml0aWFsUHVibGlzaCh7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgbW92ZW1lbnRNb2RlLFxuICAgIHZpZXdwb3J0XG4gIH0pKTtcbn0pO1xuXG52YXIgc3R5bGUgPSAobWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICBtYXJzaGFsLmRyYWdnaW5nKCk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIG1hcnNoYWwuZHJvcHBpbmcoYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdC5yZWFzb24pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgbWFyc2hhbC5yZXN0aW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufSk7XG5cbmNvbnN0IGN1cnZlcyA9IHtcbiAgb3V0T2ZUaGVXYXk6ICdjdWJpYy1iZXppZXIoMC4yLCAwLCAwLCAxKScsXG4gIGRyb3A6ICdjdWJpYy1iZXppZXIoLjIsMSwuMSwxKSdcbn07XG5jb25zdCBjb21iaW5lID0ge1xuICBvcGFjaXR5OiB7XG4gICAgZHJvcDogMCxcbiAgICBjb21iaW5pbmc6IDAuN1xuICB9LFxuICBzY2FsZToge1xuICAgIGRyb3A6IDAuNzVcbiAgfVxufTtcbmNvbnN0IHRpbWluZ3MgPSB7XG4gIG91dE9mVGhlV2F5OiAwLjIsXG4gIG1pbkRyb3BUaW1lOiAwLjMzLFxuICBtYXhEcm9wVGltZTogMC41NVxufTtcbmNvbnN0IG91dE9mVGhlV2F5VGltaW5nID0gYCR7dGltaW5ncy5vdXRPZlRoZVdheX1zICR7Y3VydmVzLm91dE9mVGhlV2F5fWA7XG5jb25zdCB0cmFuc2l0aW9ucyA9IHtcbiAgZmx1aWQ6IGBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgc25hcDogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfSwgb3BhY2l0eSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIGRyb3A6IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0aW1pbmcgPSBgJHtkdXJhdGlvbn1zICR7Y3VydmVzLmRyb3B9YDtcbiAgICByZXR1cm4gYHRyYW5zZm9ybSAke3RpbWluZ30sIG9wYWNpdHkgJHt0aW1pbmd9YDtcbiAgfSxcbiAgb3V0T2ZUaGVXYXk6IGB0cmFuc2Zvcm0gJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBwbGFjZWhvbGRlcjogYGhlaWdodCAke291dE9mVGhlV2F5VGltaW5nfSwgd2lkdGggJHtvdXRPZlRoZVdheVRpbWluZ30sIG1hcmdpbiAke291dE9mVGhlV2F5VGltaW5nfWBcbn07XG5jb25zdCBtb3ZlVG8gPSBvZmZzZXQgPT4gaXNFcXVhbCQxKG9mZnNldCwgb3JpZ2luKSA/IHVuZGVmaW5lZCA6IGB0cmFuc2xhdGUoJHtvZmZzZXQueH1weCwgJHtvZmZzZXQueX1weClgO1xuY29uc3QgdHJhbnNmb3JtcyA9IHtcbiAgbW92ZVRvLFxuICBkcm9wOiAob2Zmc2V0LCBpc0NvbWJpbmluZykgPT4ge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1vdmVUbyhvZmZzZXQpO1xuICAgIGlmICghdHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dHJhbnNsYXRlfSBzY2FsZSgke2NvbWJpbmUuc2NhbGUuZHJvcH0pYDtcbiAgfVxufTtcblxuY29uc3Qge1xuICBtaW5Ecm9wVGltZSxcbiAgbWF4RHJvcFRpbWVcbn0gPSB0aW1pbmdzO1xuY29uc3QgZHJvcFRpbWVSYW5nZSA9IG1heERyb3BUaW1lIC0gbWluRHJvcFRpbWU7XG5jb25zdCBtYXhEcm9wVGltZUF0RGlzdGFuY2UgPSAxNTAwO1xuY29uc3QgY2FuY2VsRHJvcE1vZGlmaWVyID0gMC42O1xudmFyIGdldERyb3BEdXJhdGlvbiA9ICgoe1xuICBjdXJyZW50LFxuICBkZXN0aW5hdGlvbixcbiAgcmVhc29uXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlJDEgPSBkaXN0YW5jZShjdXJyZW50LCBkZXN0aW5hdGlvbik7XG4gIGlmIChkaXN0YW5jZSQxIDw9IDApIHtcbiAgICByZXR1cm4gbWluRHJvcFRpbWU7XG4gIH1cbiAgaWYgKGRpc3RhbmNlJDEgPj0gbWF4RHJvcFRpbWVBdERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIG1heERyb3BUaW1lO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBkaXN0YW5jZSQxIC8gbWF4RHJvcFRpbWVBdERpc3RhbmNlO1xuICBjb25zdCBkdXJhdGlvbiA9IG1pbkRyb3BUaW1lICsgZHJvcFRpbWVSYW5nZSAqIHBlcmNlbnRhZ2U7XG4gIGNvbnN0IHdpdGhEdXJhdGlvbiA9IHJlYXNvbiA9PT0gJ0NBTkNFTCcgPyBkdXJhdGlvbiAqIGNhbmNlbERyb3BNb2RpZmllciA6IGR1cmF0aW9uO1xuICByZXR1cm4gTnVtYmVyKHdpdGhEdXJhdGlvbi50b0ZpeGVkKDIpKTtcbn0pO1xuXG52YXIgZ2V0TmV3SG9tZUNsaWVudE9mZnNldCA9ICgoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZGltZW5zaW9ucyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHJvcHBhYmxlSWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZUlkID8gZHJvcHBhYmxlc1tkcm9wcGFibGVJZF0gOiBudWxsO1xuICBjb25zdCBob21lID0gZHJvcHBhYmxlc1tkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZF07XG4gIGNvbnN0IG5ld0NsaWVudENlbnRlciA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbiB8fCBob21lLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChuZXdDbGllbnRDZW50ZXIsIGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBvZmZzZXQ7XG59KTtcblxudmFyIGdldERyb3BJbXBhY3QgPSAoKHtcbiAgZHJhZ2dhYmxlcyxcbiAgcmVhc29uLFxuICBsYXN0SW1wYWN0LFxuICBob21lLFxuICB2aWV3cG9ydCxcbiAgb25MaWZ0SW1wYWN0XG59KSA9PiB7XG4gIGlmICghbGFzdEltcGFjdC5hdCB8fCByZWFzb24gIT09ICdEUk9QJykge1xuICAgIGNvbnN0IHJlY29tcHV0ZWRIb21lSW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiByZWNvbXB1dGVkSG9tZUltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBpZiAobGFzdEltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiBsYXN0SW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgd2l0aG91dE1vdmVtZW50ID0ge1xuICAgIC4uLmxhc3RJbXBhY3QsXG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3Vwc1xuICB9O1xuICByZXR1cm4ge1xuICAgIGltcGFjdDogd2l0aG91dE1vdmVtZW50LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgfTtcbn0pO1xuXG5jb25zdCBkcm9wTWlkZGxld2FyZSA9ICh7XG4gIGdldFN0YXRlLFxuICBkaXNwYXRjaFxufSkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QJykge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgZGlzcGF0Y2goZHJvcFBlbmRpbmcoe1xuICAgICAgcmVhc29uXG4gICAgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpc1dhaXRpbmdGb3JEcm9wID0gc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnICYmIHN0YXRlLmlzV2FpdGluZztcbiAgISFpc1dhaXRpbmdGb3JEcm9wID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQSBEUk9QIGFjdGlvbiBvY2N1cnJlZCB3aGlsZSBEUk9QX1BFTkRJTkcgYW5kIHN0aWxsIHdhaXRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBkcm9wIGluIHBoYXNlOiAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGVcbiAgfSA9IGdldERyb3BJbXBhY3Qoe1xuICAgIHJlYXNvbixcbiAgICBsYXN0SW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICBvbkxpZnRJbXBhY3Q6IHN0YXRlLm9uTGlmdEltcGFjdCxcbiAgICBob21lOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXSxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgZHJhZ2dhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIDogbnVsbDtcbiAgY29uc3QgY29tYmluZSA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXRDb21iaW5lKGltcGFjdCkgOiBudWxsO1xuICBjb25zdCBzb3VyY2UgPSB7XG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleCxcbiAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZHJhZ2dhYmxlLmRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2UsXG4gICAgcmVhc29uLFxuICAgIG1vZGU6IHN0YXRlLm1vdmVtZW50TW9kZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBjb21iaW5lXG4gIH07XG4gIGNvbnN0IG5ld0hvbWVDbGllbnRPZmZzZXQgPSBnZXROZXdIb21lQ2xpZW50T2Zmc2V0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHtcbiAgICBjcml0aWNhbDogc3RhdGUuY3JpdGljYWwsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICByZXN1bHQsXG4gICAgaW1wYWN0XG4gIH07XG4gIGNvbnN0IGlzQW5pbWF0aW9uUmVxdWlyZWQgPSAhaXNFcXVhbCQxKHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCwgbmV3SG9tZUNsaWVudE9mZnNldCkgfHwgQm9vbGVhbihyZXN1bHQuY29tYmluZSk7XG4gIGlmICghaXNBbmltYXRpb25SZXF1aXJlZCkge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRyb3BEdXJhdGlvbiA9IGdldERyb3BEdXJhdGlvbih7XG4gICAgY3VycmVudDogc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LFxuICAgIGRlc3RpbmF0aW9uOiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIHJlYXNvblxuICB9KTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIGRyb3BEdXJhdGlvbixcbiAgICBjb21wbGV0ZWRcbiAgfTtcbiAgZGlzcGF0Y2goYW5pbWF0ZURyb3AoYXJncykpO1xufTtcbnZhciBkcm9wID0gZHJvcE1pZGRsZXdhcmU7XG5cbnZhciBnZXRXaW5kb3dTY3JvbGwgPSAoKCkgPT4gKHtcbiAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbn0pKTtcblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmluZGluZyh1cGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHdpbmRvdyAmJiBldmVudC50YXJnZXQgIT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxMaXN0ZW5lcih7XG4gIG9uV2luZG93U2Nyb2xsXG59KSB7XG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBvbldpbmRvd1Njcm9sbChnZXRXaW5kb3dTY3JvbGwoKSk7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVkID0gcmFmU2NoZCh1cGRhdGVTY3JvbGwpO1xuICBjb25zdCBiaW5kaW5nID0gZ2V0V2luZG93U2Nyb2xsQmluZGluZyhzY2hlZHVsZWQpO1xuICBsZXQgdW5iaW5kID0gbm9vcCQyO1xuICBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdW5iaW5kICE9PSBub29wJDI7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgISFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IHNjcm9sbCBsaXN0ZW5lciB3aGVuIGFscmVhZHkgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBub3QgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHNjaGVkdWxlZC5jYW5jZWwoKTtcbiAgICB1bmJpbmQoKTtcbiAgICB1bmJpbmQgPSBub29wJDI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGlzQWN0aXZlXG4gIH07XG59XG5cbmNvbnN0IHNob3VsZEVuZCA9IGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbmNvbnN0IHNjcm9sbExpc3RlbmVyID0gc3RvcmUgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IGdldFNjcm9sbExpc3RlbmVyKHtcbiAgICBvbldpbmRvd1Njcm9sbDogbmV3U2Nyb2xsID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKG1vdmVCeVdpbmRvd1Njcm9sbCh7XG4gICAgICAgIG5ld1Njcm9sbFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKCFsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgbGlzdGVuZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgc2hvdWxkRW5kKGFjdGlvbikpIHtcbiAgICAgIGxpc3RlbmVyLnN0b3AoKTtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICB9O1xufTtcbnZhciBzY3JvbGxMaXN0ZW5lciQxID0gc2Nyb2xsTGlzdGVuZXI7XG5cbnZhciBnZXRFeHBpcmluZ0Fubm91bmNlID0gKGFubm91bmNlID0+IHtcbiAgbGV0IHdhc0NhbGxlZCA9IGZhbHNlO1xuICBsZXQgaXNFeHBpcmVkID0gZmFsc2U7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlzRXhwaXJlZCA9IHRydWU7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdBbm5vdW5jZW1lbnQgYWxyZWFkeSBtYWRlLiBOb3QgbWFraW5nIGEgc2Vjb25kIGFubm91bmNlbWVudCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW5ub3VuY2VtZW50cyBjYW5ub3QgYmUgbWFkZSBhc3luY2hyb25vdXNseS5cbiAgICAgICAgRGVmYXVsdCBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gYW5ub3VuY2VkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhc0NhbGxlZCA9IHRydWU7XG4gICAgYW5ub3VuY2UobWVzc2FnZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG4gIHJlc3VsdC53YXNDYWxsZWQgPSAoKSA9PiB3YXNDYWxsZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIGdldEFzeW5jTWFyc2hhbCA9ICgoKSA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgZXhlY3V0ZSA9IHRpbWVySWQgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLnRpbWVySWQgPT09IHRpbWVySWQpO1xuICAgICEoaW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHRpbWVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IFtlbnRyeV0gPSBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgZW50cnkuY2FsbGJhY2soKTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZm4gPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IGV4ZWN1dGUodGltZXJJZCkpO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgdGltZXJJZCxcbiAgICAgIGNhbGxiYWNrOiBmblxuICAgIH07XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFsbG93ID0gWy4uLmVudHJpZXNdO1xuICAgIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgICBzaGFsbG93LmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGVudHJ5LnRpbWVySWQpO1xuICAgICAgZW50cnkuY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgZmx1c2hcbiAgfTtcbn0pO1xuXG5jb25zdCBhcmVMb2NhdGlvbnNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQgJiYgZmlyc3QuaW5kZXggPT09IHNlY29uZC5pbmRleDtcbn07XG5jb25zdCBpc0NvbWJpbmVFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyYWdnYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlSWQgJiYgZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZDtcbn07XG5jb25zdCBpc0NyaXRpY2FsRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzRHJhZ2dhYmxlRXF1YWwgPSBmaXJzdC5kcmFnZ2FibGUuaWQgPT09IHNlY29uZC5kcmFnZ2FibGUuaWQgJiYgZmlyc3QuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkICYmIGZpcnN0LmRyYWdnYWJsZS50eXBlID09PSBzZWNvbmQuZHJhZ2dhYmxlLnR5cGUgJiYgZmlyc3QuZHJhZ2dhYmxlLmluZGV4ID09PSBzZWNvbmQuZHJhZ2dhYmxlLmluZGV4O1xuICBjb25zdCBpc0Ryb3BwYWJsZUVxdWFsID0gZmlyc3QuZHJvcHBhYmxlLmlkID09PSBzZWNvbmQuZHJvcHBhYmxlLmlkICYmIGZpcnN0LmRyb3BwYWJsZS50eXBlID09PSBzZWNvbmQuZHJvcHBhYmxlLnR5cGU7XG4gIHJldHVybiBpc0RyYWdnYWJsZUVxdWFsICYmIGlzRHJvcHBhYmxlRXF1YWw7XG59O1xuXG5jb25zdCB3aXRoVGltaW5ncyA9IChrZXksIGZuKSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGZuKCk7XG4gIGZpbmlzaCgpO1xufTtcbmNvbnN0IGdldERyYWdTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4gKHtcbiAgZHJhZ2dhYmxlSWQ6IGNyaXRpY2FsLmRyYWdnYWJsZS5pZCxcbiAgdHlwZTogY3JpdGljYWwuZHJvcHBhYmxlLnR5cGUsXG4gIHNvdXJjZToge1xuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWQsXG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleFxuICB9LFxuICBtb2RlXG59KTtcbmZ1bmN0aW9uIGV4ZWN1dGUocmVzcG9uZGVyLCBkYXRhLCBhbm5vdW5jZSwgZ2V0RGVmYXVsdE1lc3NhZ2UpIHtcbiAgaWYgKCFyZXNwb25kZXIpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpbGxFeHBpcmUgPSBnZXRFeHBpcmluZ0Fubm91bmNlKGFubm91bmNlKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgYW5ub3VuY2U6IHdpbGxFeHBpcmVcbiAgfTtcbiAgcmVzcG9uZGVyKGRhdGEsIHByb3ZpZGVkKTtcbiAgaWYgKCF3aWxsRXhwaXJlLndhc0NhbGxlZCgpKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICB9XG59XG52YXIgZ2V0UHVibGlzaGVyID0gKChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBhc3luY01hcnNoYWwgPSBnZXRBc3luY01hcnNoYWwoKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgYmVmb3JlQ2FwdHVyZSA9IChkcmFnZ2FibGVJZCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZUNhcHR1cmUgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZUNhcHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZUNhcHR1cmU7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkLFxuICAgICAgICAgIG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgZm4oYmVmb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZURyYWdTdGFydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlRHJhZ1N0YXJ0O1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgZGF0YSA9IGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFzdENyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIGxhc3RMb2NhdGlvbjogZGF0YS5zb3VyY2UsXG4gICAgICBsYXN0Q29tYmluZTogbnVsbFxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnU3RhcnQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdTdGFydCwgZGF0YSwgYW5ub3VuY2UsIHByZXNldCQxLm9uRHJhZ1N0YXJ0KSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZSA9IChjcml0aWNhbCwgaW1wYWN0KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnTW92ZSB3aGVuIG9uRHJhZ1N0YXJ0IGhhcyBub3QgYmVlbiBjYWxsZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgaGFzQ3JpdGljYWxDaGFuZ2VkID0gIWlzQ3JpdGljYWxFcXVhbChjcml0aWNhbCwgZHJhZ2dpbmcubGFzdENyaXRpY2FsKTtcbiAgICBpZiAoaGFzQ3JpdGljYWxDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q3JpdGljYWwgPSBjcml0aWNhbDtcbiAgICB9XG4gICAgY29uc3QgaGFzTG9jYXRpb25DaGFuZ2VkID0gIWFyZUxvY2F0aW9uc0VxdWFsKGRyYWdnaW5nLmxhc3RMb2NhdGlvbiwgbG9jYXRpb24pO1xuICAgIGlmIChoYXNMb2NhdGlvbkNoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCBoYXNHcm91cGluZ0NoYW5nZWQgPSAhaXNDb21iaW5lRXF1YWwoZHJhZ2dpbmcubGFzdENvbWJpbmUsIGNvbWJpbmUpO1xuICAgIGlmIChoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDb21iaW5lID0gY29tYmluZTtcbiAgICB9XG4gICAgaWYgKCFoYXNDcml0aWNhbENoYW5nZWQgJiYgIWhhc0xvY2F0aW9uQ2hhbmdlZCAmJiAhaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoY3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZSxcbiAgICAgIGRlc3RpbmF0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnVXBkYXRlJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnVXBkYXRlLCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0JDEub25EcmFnVXBkYXRlKSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IGZsdXNoIHJlc3BvbmRlcnMgd2hpbGUgZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgYXN5bmNNYXJzaGFsLmZsdXNoKCk7XG4gIH07XG4gIGNvbnN0IGRyb3AgPSByZXN1bHQgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ0VuZCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9uRHJhZ1N0YXJ0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgICB3aXRoVGltaW5ncygnb25EcmFnRW5kJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnRW5kLCByZXN1bHQsIGFubm91bmNlLCBwcmVzZXQkMS5vbkRyYWdFbmQpKTtcbiAgfTtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoZHJhZ2dpbmcubGFzdENyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmU6IG51bGwsXG4gICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgIHJlYXNvbjogJ0NBTkNFTCdcbiAgICB9O1xuICAgIGRyb3AocmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVDYXB0dXJlLFxuICAgIGJlZm9yZVN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIHVwZGF0ZSxcbiAgICBmbHVzaCxcbiAgICBkcm9wLFxuICAgIGFib3J0XG4gIH07XG59KTtcblxudmFyIHJlc3BvbmRlcnMgPSAoKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGdldFB1Ymxpc2hlcihnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSk7XG4gIHJldHVybiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScpIHtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVDYXB0dXJlKGFjdGlvbi5wYXlsb2FkLmRyYWdnYWJsZUlkLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsO1xuICAgICAgcHVibGlzaGVyLmJlZm9yZVN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLnN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIHB1Ymxpc2hlci5mbHVzaCgpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLmRyb3AocmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgICAgcHVibGlzaGVyLmFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHB1Ymxpc2hlci51cGRhdGUoc3RhdGUuY3JpdGljYWwsIHN0YXRlLmltcGFjdCk7XG4gICAgfVxuICB9O1xufSk7XG5cbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluaXNoIGEgZHJvcCBhbmltYXRpbmcgd2hlbiBubyBkcm9wIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgc3RvcmUuZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICBjb21wbGV0ZWQ6IHN0YXRlLmNvbXBsZXRlZFxuICB9KSk7XG59O1xudmFyIGRyb3BBbmltYXRpb25GaW5pc2ggPSBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlID0gc3RvcmUgPT4ge1xuICBsZXQgdW5iaW5kID0gbnVsbDtcbiAgbGV0IGZyYW1lSWQgPSBudWxsO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHVuYmluZCkge1xuICAgICAgdW5iaW5kKCk7XG4gICAgICB1bmJpbmQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSB7XG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKGFjdGlvbi50eXBlICE9PSAnRFJPUF9BTklNQVRFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0sXG4gICAgICBmbjogZnVuY3Rpb24gZmx1c2hEcm9wQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3BBbmltYXRpb25GaW5pc2hlZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICAgIH0pO1xuICB9O1xufTtcbnZhciBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCA9IGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZTtcblxudmFyIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyID0gKG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICBtYXJzaGFsLnN0b3BQdWJsaXNoaW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufSk7XG5cbnZhciBmb2N1cyA9IChtYXJzaGFsID0+IHtcbiAgbGV0IGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgcmV0dXJuICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICBpc1dhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVjb3JkRm9jdXMoYWN0aW9uLnBheWxvYWQuY3JpdGljYWwuZHJhZ2dhYmxlLmlkKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghaXNXYXRjaGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBpZiAocmVzdWx0LmNvbWJpbmUpIHtcbiAgICAgICAgbWFyc2hhbC50cnlTaGlmdFJlY29yZChyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkKTtcbiAgICAgIH1cbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICB9XG4gIH07XG59KTtcblxuY29uc3Qgc2hvdWxkU3RvcCA9IGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbnZhciBhdXRvU2Nyb2xsID0gKGF1dG9TY3JvbGxlciA9PiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChzaG91bGRTdG9wKGFjdGlvbikpIHtcbiAgICBhdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwaGFzZSB0byBiZSBEUkFHR0lORyBhZnRlciBJTklUSUFMX1BVQkxJU0gnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgYXV0b1Njcm9sbGVyLnN0YXJ0KHN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xuICBhdXRvU2Nyb2xsZXIuc2Nyb2xsKHN0b3JlLmdldFN0YXRlKCkpO1xufSk7XG5cbmNvbnN0IHBlbmRpbmdEcm9wID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBuZXh0KGFjdGlvbik7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBvc3RBY3Rpb25TdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUucGhhc2UgIT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUuaXNXYWl0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3JlLmRpc3BhdGNoKGRyb3AkMSh7XG4gICAgcmVhc29uOiBwb3N0QWN0aW9uU3RhdGUucmVhc29uXG4gIH0pKTtcbn07XG52YXIgcGVuZGluZ0Ryb3AkMSA9IHBlbmRpbmdEcm9wO1xuXG5jb25zdCBjb21wb3NlRW5oYW5jZXJzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyh7XG4gIG5hbWU6ICdAaGVsbG8tcGFuZ2VhL2RuZCdcbn0pIDogY29tcG9zZTtcbnZhciBjcmVhdGVTdG9yZSA9ICgoe1xuICBkaW1lbnNpb25NYXJzaGFsLFxuICBmb2N1c01hcnNoYWwsXG4gIHN0eWxlTWFyc2hhbCxcbiAgZ2V0UmVzcG9uZGVycyxcbiAgYW5ub3VuY2UsXG4gIGF1dG9TY3JvbGxlclxufSkgPT4gY3JlYXRlU3RvcmUkMShyZWR1Y2VyLCBjb21wb3NlRW5oYW5jZXJzKGFwcGx5TWlkZGxld2FyZShzdHlsZShzdHlsZU1hcnNoYWwpLCBkaW1lbnNpb25NYXJzaGFsU3RvcHBlcihkaW1lbnNpb25NYXJzaGFsKSwgbGlmdChkaW1lbnNpb25NYXJzaGFsKSwgZHJvcCwgZHJvcEFuaW1hdGlvbkZpbmlzaCwgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGwsIHBlbmRpbmdEcm9wJDEsIGF1dG9TY3JvbGwoYXV0b1Njcm9sbGVyKSwgc2Nyb2xsTGlzdGVuZXIkMSwgZm9jdXMoZm9jdXNNYXJzaGFsKSwgcmVzcG9uZGVycyhnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkpKSkpO1xuXG5jb25zdCBjbGVhbiQxID0gKCkgPT4gKHtcbiAgYWRkaXRpb25zOiB7fSxcbiAgcmVtb3ZhbHM6IHt9LFxuICBtb2RpZmllZDoge31cbn0pO1xuZnVuY3Rpb24gY3JlYXRlUHVibGlzaGVyKHtcbiAgcmVnaXN0cnksXG4gIGNhbGxiYWNrc1xufSkge1xuICBsZXQgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgbGV0IGZyYW1lSWQgPSBudWxsO1xuICBjb25zdCBjb2xsZWN0ID0gKCkgPT4ge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmcoKTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgc3RhcnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWRkaXRpb25zLFxuICAgICAgICByZW1vdmFscyxcbiAgICAgICAgbW9kaWZpZWRcbiAgICAgIH0gPSBzdGFnaW5nO1xuICAgICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhhZGRpdGlvbnMpLm1hcChpZCA9PiByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChpZCkuZ2V0RGltZW5zaW9uKG9yaWdpbikpLnNvcnQoKGEsIGIpID0+IGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleCk7XG4gICAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMobW9kaWZpZWQpLm1hcChpZCA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoaWQpO1xuICAgICAgICBjb25zdCBzY3JvbGwgPSBlbnRyeS5jYWxsYmFja3MuZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRyb3BwYWJsZUlkOiBpZCxcbiAgICAgICAgICBzY3JvbGxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRpdGlvbnM6IGFkZGVkLFxuICAgICAgICByZW1vdmFsczogT2JqZWN0LmtleXMocmVtb3ZhbHMpLFxuICAgICAgICBtb2RpZmllZDogdXBkYXRlZFxuICAgICAgfTtcbiAgICAgIHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gICAgICBmaW5pc2goKTtcbiAgICAgIGNhbGxiYWNrcy5wdWJsaXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGFkZCA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBpZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgc3RhZ2luZy5hZGRpdGlvbnNbaWRdID0gZW50cnk7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcucmVtb3ZhbHNbaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5yZW1vdmFsc1tpZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHN0YWdpbmcucmVtb3ZhbHNbZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuICAgIGlmIChzdGFnaW5nLmFkZGl0aW9uc1tkZXNjcmlwdG9yLmlkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdO1xuICAgIH1cbiAgICBjb2xsZWN0KCk7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKCFmcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkLFxuICAgIHJlbW92ZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbnZhciBnZXRNYXhTY3JvbGwgPSAoKHtcbiAgc2Nyb2xsSGVpZ2h0LFxuICBzY3JvbGxXaWR0aCxcbiAgaGVpZ2h0LFxuICB3aWR0aFxufSkgPT4ge1xuICBjb25zdCBtYXhTY3JvbGwgPSBzdWJ0cmFjdCh7XG4gICAgeDogc2Nyb2xsV2lkdGgsXG4gICAgeTogc2Nyb2xsSGVpZ2h0XG4gIH0sIHtcbiAgICB4OiB3aWR0aCxcbiAgICB5OiBoZWlnaHRcbiAgfSk7XG4gIGNvbnN0IGFkanVzdGVkTWF4U2Nyb2xsID0ge1xuICAgIHg6IE1hdGgubWF4KDAsIG1heFNjcm9sbC54KSxcbiAgICB5OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueSlcbiAgfTtcbiAgcmV0dXJuIGFkanVzdGVkTWF4U2Nyb2xsO1xufSk7XG5cbnZhciBnZXREb2N1bWVudEVsZW1lbnQgPSAoKCkgPT4ge1xuICBjb25zdCBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFkb2MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59KTtcblxudmFyIGdldE1heFdpbmRvd1Njcm9sbCA9ICgoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgIHNjcm9sbEhlaWdodDogZG9jLnNjcm9sbEhlaWdodCxcbiAgICBzY3JvbGxXaWR0aDogZG9jLnNjcm9sbFdpZHRoLFxuICAgIHdpZHRoOiBkb2MuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBkb2MuY2xpZW50SGVpZ2h0XG4gIH0pO1xuICByZXR1cm4gbWF4U2Nyb2xsO1xufSk7XG5cbnZhciBnZXRWaWV3cG9ydCA9ICgoKSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhXaW5kb3dTY3JvbGwoKTtcbiAgY29uc3QgdG9wID0gc2Nyb2xsLnk7XG4gIGNvbnN0IGxlZnQgPSBzY3JvbGwueDtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIGNvbnN0IHdpZHRoID0gZG9jLmNsaWVudFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBkb2MuY2xpZW50SGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBjb25zdCBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9KTtcbiAgY29uc3Qgdmlld3BvcnQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGwsXG4gICAgICBjdXJyZW50OiBzY3JvbGwsXG4gICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB2aWV3cG9ydDtcbn0pO1xuXG52YXIgZ2V0SW5pdGlhbFB1Ymxpc2ggPSAoKHtcbiAgY3JpdGljYWwsXG4gIHNjcm9sbE9wdGlvbnMsXG4gIHJlZ2lzdHJ5XG59KSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQoKTtcbiAgY29uc3Qgd2luZG93U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIGNvbnN0IGhvbWUgPSBjcml0aWNhbC5kcm9wcGFibGU7XG4gIGNvbnN0IGRyb3BwYWJsZXMgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmNhbGxiYWNrcy5nZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCh3aW5kb3dTY3JvbGwsIHNjcm9sbE9wdGlvbnMpKTtcbiAgY29uc3QgZHJhZ2dhYmxlcyA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRBbGxCeVR5cGUoY3JpdGljYWwuZHJhZ2dhYmxlLnR5cGUpLm1hcChlbnRyeSA9PiBlbnRyeS5nZXREaW1lbnNpb24od2luZG93U2Nyb2xsKSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJhZ2dhYmxlczogdG9EcmFnZ2FibGVNYXAoZHJhZ2dhYmxlcyksXG4gICAgZHJvcHBhYmxlczogdG9Ecm9wcGFibGVNYXAoZHJvcHBhYmxlcylcbiAgfTtcbiAgZmluaXNoKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkaW1lbnNpb25zLFxuICAgIGNyaXRpY2FsLFxuICAgIHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGVudHJ5KSB7XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2luZy5pZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZW50cnkuZGVzY3JpcHRvci50eXBlICE9PSBkcmFnZ2luZy50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgaWYgKGhvbWUuZGVzY3JpcHRvci5tb2RlICE9PSAndmlydHVhbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFlvdSBhcmUgYXR0ZW1wdGluZyB0byBhZGQgb3IgcmVtb3ZlIGEgRHJhZ2dhYmxlIFtpZDogJHtlbnRyeS5kZXNjcmlwdG9yLmlkfV1cbiAgICAgIHdoaWxlIGEgZHJhZyBpcyBvY2N1cnJpbmcuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHZpcnR1YWwgbGlzdHMuXG5cbiAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9wYXR0ZXJucy92aXJ0dWFsLWxpc3RzLm1kXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIGNyZWF0ZURpbWVuc2lvbk1hcnNoYWwgPSAoKHJlZ2lzdHJ5LCBjYWxsYmFja3MpID0+IHtcbiAgbGV0IGNvbGxlY3Rpb24gPSBudWxsO1xuICBjb25zdCBwdWJsaXNoZXIgPSBjcmVhdGVQdWJsaXNoZXIoe1xuICAgIGNhbGxiYWNrczoge1xuICAgICAgcHVibGlzaDogY2FsbGJhY2tzLnB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgICAgY29sbGVjdGlvblN0YXJ0aW5nOiBjYWxsYmFja3MuY29sbGVjdGlvblN0YXJ0aW5nXG4gICAgfSxcbiAgICByZWdpc3RyeVxuICB9KTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gKGlkLCBpc0VuYWJsZWQpID0+IHtcbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIGlzIGVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQoe1xuICAgICAgaWQsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IChpZCwgaXNDb21iaW5lRW5hYmxlZCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIGlzQ29tYmluZUVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoe1xuICAgICAgaWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IChpZCwgbmV3U2Nyb2xsKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgdGhlIHNjcm9sbCBvbiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZVNjcm9sbCh7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzY3JvbGxEcm9wcGFibGUgPSAoaWQsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCkuY2FsbGJhY2tzLnNjcm9sbChjaGFuZ2UpO1xuICB9O1xuICBjb25zdCBzdG9wUHVibGlzaGluZyA9ICgpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHVibGlzaGVyLnN0b3AoKTtcbiAgICBjb25zdCBob21lID0gY29sbGVjdGlvbi5jcml0aWNhbC5kcm9wcGFibGU7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLmdldEFsbEJ5VHlwZShob21lLnR5cGUpLmZvckVhY2goZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmRyYWdTdG9wcGVkKCkpO1xuICAgIGNvbGxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICBjb2xsZWN0aW9uID0gbnVsbDtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlciA9IGV2ZW50ID0+IHtcbiAgICAhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBvbmx5IGJlIHN1YnNjcmliZWQgd2hlbiBhIGNvbGxlY3Rpb24gaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyYWdnaW5nID0gY29sbGVjdGlvbi5jcml0aWNhbC5kcmFnZ2FibGU7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdBRERJVElPTicpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5hZGQoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ1JFTU9WQUwnKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIucmVtb3ZlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0UHVibGlzaGluZyA9IHJlcXVlc3QgPT4ge1xuICAgICEhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBjYXB0dXJpbmcgY3JpdGljYWwgZGltZW5zaW9ucyBhcyB0aGVyZSBpcyBhbHJlYWR5IGEgY29sbGVjdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKHJlcXVlc3QuZHJhZ2dhYmxlSWQpO1xuICAgIGNvbnN0IGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgICBjb25zdCBjcml0aWNhbCA9IHtcbiAgICAgIGRyYWdnYWJsZTogZW50cnkuZGVzY3JpcHRvcixcbiAgICAgIGRyb3BwYWJsZTogaG9tZS5kZXNjcmlwdG9yXG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJlZ2lzdHJ5LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgY3JpdGljYWwsXG4gICAgICB1bnN1YnNjcmliZVxuICAgIH07XG4gICAgcmV0dXJuIGdldEluaXRpYWxQdWJsaXNoKHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBzY3JvbGxPcHRpb25zOiByZXF1ZXN0LnNjcm9sbE9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgbWFyc2hhbCA9IHtcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHN0YXJ0UHVibGlzaGluZyxcbiAgICBzdG9wUHVibGlzaGluZ1xuICB9O1xuICByZXR1cm4gbWFyc2hhbDtcbn0pO1xuXG52YXIgY2FuU3RhcnREcmFnID0gKChzdGF0ZSwgaWQpID0+IHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbiA9PT0gJ0RST1AnO1xufSk7XG5cbnZhciBzY3JvbGxXaW5kb3cgPSAoY2hhbmdlID0+IHtcbiAgd2luZG93LnNjcm9sbEJ5KGNoYW5nZS54LCBjaGFuZ2UueSk7XG59KTtcblxuY29uc3QgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICBpZiAoIWRyb3BwYWJsZS5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFkcm9wcGFibGUuZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSk7XG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciA9ICh0YXJnZXQsIGRyb3BwYWJsZXMpID0+IHtcbiAgY29uc3QgbWF5YmUgPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyhkcm9wcGFibGVzKS5maW5kKGRyb3BwYWJsZSA9PiB7XG4gICAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgcmVzdWx0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBpc1Bvc2l0aW9uSW5GcmFtZShkcm9wcGFibGUuZnJhbWUucGFnZU1hcmdpbkJveCkodGFyZ2V0KTtcbiAgfSkgfHwgbnVsbDtcbiAgcmV0dXJuIG1heWJlO1xufTtcbnZhciBnZXRCZXN0U2Nyb2xsYWJsZURyb3BwYWJsZSA9ICgoe1xuICBjZW50ZXIsXG4gIGRlc3RpbmF0aW9uLFxuICBkcm9wcGFibGVzXG59KSA9PiB7XG4gIGlmIChkZXN0aW5hdGlvbikge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25dO1xuICAgIGlmICghZGltZW5zaW9uLmZyYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfVxuICBjb25zdCBkaW1lbnNpb24gPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlcihjZW50ZXIsIGRyb3BwYWJsZXMpO1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbmNvbnN0IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zID0ge1xuICBzdGFydEZyb21QZXJjZW50YWdlOiAwLjI1LFxuICBtYXhTY3JvbGxBdFBlcmNlbnRhZ2U6IDAuMDUsXG4gIG1heFBpeGVsU2Nyb2xsOiAyOCxcbiAgZWFzZTogcGVyY2VudGFnZSA9PiBwZXJjZW50YWdlICoqIDIsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgc3RvcERhbXBlbmluZ0F0OiAxMjAwLFxuICAgIGFjY2VsZXJhdGVBdDogMzYwXG4gIH0sXG4gIGRpc2FibGVkOiBmYWxzZVxufTtcblxudmFyIGdldERpc3RhbmNlVGhyZXNob2xkcyA9ICgoY29udGFpbmVyLCBheGlzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3Qgc3RhcnRTY3JvbGxpbmdGcm9tID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBhdXRvU2Nyb2xsZXJPcHRpb25zLnN0YXJ0RnJvbVBlcmNlbnRhZ2U7XG4gIGNvbnN0IG1heFNjcm9sbFZhbHVlQXQgPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGF1dG9TY3JvbGxlck9wdGlvbnMubWF4U2Nyb2xsQXRQZXJjZW50YWdlO1xuICBjb25zdCB0aHJlc2hvbGRzID0ge1xuICAgIHN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBtYXhTY3JvbGxWYWx1ZUF0XG4gIH07XG4gIHJldHVybiB0aHJlc2hvbGRzO1xufSk7XG5cbnZhciBnZXRQZXJjZW50YWdlID0gKCh7XG4gIHN0YXJ0T2ZSYW5nZSxcbiAgZW5kT2ZSYW5nZSxcbiAgY3VycmVudFxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IGVuZE9mUmFuZ2UgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRGV0ZWN0ZWQgZGlzdGFuY2UgcmFuZ2Ugb2YgMCBpbiB0aGUgZmx1aWQgYXV0byBzY3JvbGxlclxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxuICAgICAgTm90IGFsbG93aW5nIGFuIGF1dG8gc2Nyb2xsXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICBjb25zdCBwZXJjZW50YWdlID0gY3VycmVudEluUmFuZ2UgLyByYW5nZTtcbiAgcmV0dXJuIHBlcmNlbnRhZ2U7XG59KTtcblxudmFyIG1pblNjcm9sbCA9IDE7XG5cbnZhciBnZXRWYWx1ZUZyb21EaXN0YW5jZSA9ICgoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA8PSB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQpIHtcbiAgICByZXR1cm4gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPT09IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCxcbiAgICBlbmRPZlJhbmdlOiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBjdXJyZW50OiBkaXN0YW5jZVRvRWRnZVxuICB9KTtcbiAgY29uc3QgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICBjb25zdCBzY3JvbGwgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufSk7XG5cbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9ICgocHJvcG9zZWRTY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3QgYWNjZWxlcmF0ZUF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5hY2NlbGVyYXRlQXQ7XG4gIGNvbnN0IHN0b3BBdCA9IGF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcuc3RvcERhbXBlbmluZ0F0O1xuICBjb25zdCBzdGFydE9mUmFuZ2UgPSBkcmFnU3RhcnRUaW1lO1xuICBjb25zdCBlbmRPZlJhbmdlID0gc3RvcEF0O1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCBydW5UaW1lID0gbm93IC0gc3RhcnRPZlJhbmdlO1xuICBpZiAocnVuVGltZSA+PSBzdG9wQXQpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKHJ1blRpbWUgPCBhY2NlbGVyYXRlQXQpIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG4gIGNvbnN0IGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiBhY2NlbGVyYXRlQXQsXG4gICAgZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50OiBydW5UaW1lXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBwcm9wb3NlZFNjcm9sbCAqIGF1dG9TY3JvbGxlck9wdGlvbnMuZWFzZShiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0VmFsdWUgPSAoKHtcbiAgZGlzdGFuY2VUb0VkZ2UsXG4gIHRocmVzaG9sZHMsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0VmFsdWVGcm9tRGlzdGFuY2UoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFzaG91bGRVc2VUaW1lRGFtcGVuaW5nKSB7XG4gICAgcmV0dXJuIHNjcm9sbDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoZGFtcGVuVmFsdWVCeVRpbWUoc2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSwgbWluU2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsT25BeGlzID0gKCh7XG4gIGNvbnRhaW5lcixcbiAgZGlzdGFuY2VUb0VkZ2VzLFxuICBkcmFnU3RhcnRUaW1lLFxuICBheGlzLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSBnZXREaXN0YW5jZVRocmVzaG9sZHMoY29udGFpbmVyLCBheGlzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKTtcbiAgY29uc3QgaXNDbG9zZXJUb0VuZCA9IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0gPCBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF07XG4gIGlmIChpc0Nsb3NlclRvRW5kKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKHtcbiAgICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdLFxuICAgICAgdGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAtMSAqIGdldFZhbHVlKHtcbiAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdLFxuICAgIHRocmVzaG9sZHMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG59KTtcblxudmFyIGFkanVzdEZvclNpemVMaW1pdHMgPSAoKHtcbiAgY29udGFpbmVyLFxuICBzdWJqZWN0LFxuICBwcm9wb3NlZFNjcm9sbFxufSkgPT4ge1xuICBjb25zdCBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPSBzdWJqZWN0LmhlaWdodCA+IGNvbnRhaW5lci5oZWlnaHQ7XG4gIGNvbnN0IGlzVG9vQmlnSG9yaXpvbnRhbGx5ID0gc3ViamVjdC53aWR0aCA+IGNvbnRhaW5lci53aWR0aDtcbiAgaWYgKCFpc1Rvb0JpZ0hvcml6b250YWxseSAmJiAhaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG4gIGlmIChpc1Rvb0JpZ0hvcml6b250YWxseSAmJiBpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGlzVG9vQmlnSG9yaXpvbnRhbGx5ID8gMCA6IHByb3Bvc2VkU2Nyb2xsLngsXG4gICAgeTogaXNUb29CaWdWZXJ0aWNhbGx5ID8gMCA6IHByb3Bvc2VkU2Nyb2xsLnlcbiAgfTtcbn0pO1xuXG5jb25zdCBjbGVhbiA9IGFwcGx5KHZhbHVlID0+IHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcbnZhciBnZXRTY3JvbGwkMSA9ICgoe1xuICBkcmFnU3RhcnRUaW1lLFxuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBkaXN0YW5jZVRvRWRnZXMgPSB7XG4gICAgdG9wOiBjZW50ZXIueSAtIGNvbnRhaW5lci50b3AsXG4gICAgcmlnaHQ6IGNvbnRhaW5lci5yaWdodCAtIGNlbnRlci54LFxuICAgIGJvdHRvbTogY29udGFpbmVyLmJvdHRvbSAtIGNlbnRlci55LFxuICAgIGxlZnQ6IGNlbnRlci54IC0gY29udGFpbmVyLmxlZnRcbiAgfTtcbiAgY29uc3QgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IHZlcnRpY2FsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IGhvcml6b250YWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCByZXF1aXJlZCA9IGNsZWFuKHtcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIGlmIChpc0VxdWFsJDEocmVxdWlyZWQsIG9yaWdpbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaW1pdGVkID0gYWRqdXN0Rm9yU2l6ZUxpbWl0cyh7XG4gICAgY29udGFpbmVyLFxuICAgIHN1YmplY3QsXG4gICAgcHJvcG9zZWRTY3JvbGw6IHJlcXVpcmVkXG4gIH0pO1xuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaXNFcXVhbCQxKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn0pO1xuXG5jb25zdCBzbWFsbGVzdFNpZ25lZCA9IGFwcGx5KHZhbHVlID0+IHtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID4gMCA/IDEgOiAtMTtcbn0pO1xuY29uc3QgZ2V0T3ZlcmxhcCA9ICgoKSA9PiB7XG4gIGNvbnN0IGdldFJlbWFpbmRlciA9ICh0YXJnZXQsIG1heCkgPT4ge1xuICAgIGlmICh0YXJnZXQgPCAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID4gbWF4KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IC0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgcmV0dXJuICh7XG4gICAgY3VycmVudCxcbiAgICBtYXgsXG4gICAgY2hhbmdlXG4gIH0pID0+IHtcbiAgICBjb25zdCB0YXJnZXRTY3JvbGwgPSBhZGQoY3VycmVudCwgY2hhbmdlKTtcbiAgICBjb25zdCBvdmVybGFwID0ge1xuICAgICAgeDogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC54LCBtYXgueCksXG4gICAgICB5OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLnksIG1heC55KVxuICAgIH07XG4gICAgaWYgKGlzRXF1YWwkMShvdmVybGFwLCBvcmlnaW4pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJsYXA7XG4gIH07XG59KSgpO1xuY29uc3QgY2FuUGFydGlhbGx5U2Nyb2xsID0gKHtcbiAgbWF4OiByYXdNYXgsXG4gIGN1cnJlbnQsXG4gIGNoYW5nZVxufSkgPT4ge1xuICBjb25zdCBtYXggPSB7XG4gICAgeDogTWF0aC5tYXgoY3VycmVudC54LCByYXdNYXgueCksXG4gICAgeTogTWF0aC5tYXgoY3VycmVudC55LCByYXdNYXgueSlcbiAgfTtcbiAgY29uc3Qgc21hbGxlc3RDaGFuZ2UgPSBzbWFsbGVzdFNpZ25lZChjaGFuZ2UpO1xuICBjb25zdCBvdmVybGFwID0gZ2V0T3ZlcmxhcCh7XG4gICAgbWF4LFxuICAgIGN1cnJlbnQsXG4gICAgY2hhbmdlOiBzbWFsbGVzdENoYW5nZVxuICB9KTtcbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNtYWxsZXN0Q2hhbmdlLnggIT09IDAgJiYgb3ZlcmxhcC54ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNtYWxsZXN0Q2hhbmdlLnkgIT09IDAgJiYgb3ZlcmxhcC55ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGNhblNjcm9sbFdpbmRvdyA9ICh2aWV3cG9ydCwgY2hhbmdlKSA9PiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICBjdXJyZW50OiB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCxcbiAgbWF4OiB2aWV3cG9ydC5zY3JvbGwubWF4LFxuICBjaGFuZ2Vcbn0pO1xuY29uc3QgZ2V0V2luZG93T3ZlcmxhcCA9ICh2aWV3cG9ydCwgY2hhbmdlKSA9PiB7XG4gIGlmICghY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWF4ID0gdmlld3BvcnQuc2Nyb2xsLm1heDtcbiAgY29uc3QgY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50O1xuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudCxcbiAgICBtYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcbmNvbnN0IGNhblNjcm9sbERyb3BwYWJsZSA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcbmNvbnN0IGdldERyb3BwYWJsZU92ZXJsYXAgPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5cbnZhciBnZXRXaW5kb3dTY3JvbGxDaGFuZ2UgPSAoKHtcbiAgdmlld3BvcnQsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSAoKHtcbiAgZHJvcHBhYmxlLFxuICBzdWJqZWN0LFxuICBjZW50ZXIsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IGZyYW1lLnBhZ2VNYXJnaW5Cb3gsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBzY3JvbGwgPSAoKHtcbiAgc3RhdGUsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBzdWJqZWN0ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICBpZiAoc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCBjaGFuZ2UgPSBnZXRXaW5kb3dTY3JvbGxDaGFuZ2Uoe1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc3ViamVjdCxcbiAgICAgIGNlbnRlcixcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlKHtcbiAgICBjZW50ZXIsXG4gICAgZGVzdGluYXRpb246IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCksXG4gICAgZHJvcHBhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGFuZ2UgPSBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2Uoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgaWYgKGNoYW5nZSkge1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgfVxufSk7XG5cbnZhciBjcmVhdGVGbHVpZFNjcm9sbGVyID0gKCh7XG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2NoZWR1bGVXaW5kb3dTY3JvbGwgPSByYWZTY2hkKHNjcm9sbFdpbmRvdyk7XG4gIGNvbnN0IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsID0gcmFmU2NoZChzY3JvbGxEcm9wcGFibGUpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCB0cnlTY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZsdWlkIHNjcm9sbCBpZiBub3QgZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGRyYWdTdGFydFRpbWVcbiAgICB9ID0gZHJhZ2dpbmc7XG4gICAgc2Nyb2xsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2Nyb2xsV2luZG93OiBzY2hlZHVsZVdpbmRvd1Njcm9sbCxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQkMSA9IHN0YXRlID0+IHtcbiAgICBzdGFydCgpO1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgYXV0byBzY3JvbGxpbmcgd2hlbiBhbHJlYWR5IHN0YXJ0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHdhc1Njcm9sbE5lZWRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGZha2VTY3JvbGxDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdhc1Njcm9sbE5lZWRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBkcmFnU3RhcnRUaW1lOiAwLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogZmFsc2UsXG4gICAgICBzY3JvbGxXaW5kb3c6IGZha2VTY3JvbGxDYWxsYmFjayxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHdhc1Njcm9sbE5lZWRlZFxuICAgIH07XG4gICAgZmluaXNoKCk7XG4gICAgaWYgKHdhc1Njcm9sbE5lZWRlZCkge1xuICAgICAgdHJ5U2Nyb2xsKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVdpbmRvd1Njcm9sbC5jYW5jZWwoKTtcbiAgICBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbC5jYW5jZWwoKTtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0JDEsXG4gICAgc3RvcCxcbiAgICBzY3JvbGw6IHRyeVNjcm9sbFxuICB9O1xufSk7XG5cbnZhciBjcmVhdGVKdW1wU2Nyb2xsZXIgPSAoKHtcbiAgbW92ZSxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3dcbn0pID0+IHtcbiAgY29uc3QgbW92ZUJ5T2Zmc2V0ID0gKHN0YXRlLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSBhZGQoc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLCBvZmZzZXQpO1xuICAgIG1vdmUoe1xuICAgICAgY2xpZW50XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4gPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXREcm9wcGFibGVPdmVybGFwKGRyb3BwYWJsZSwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiA9IChpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsV2luZG93KHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3QganVtcFNjcm9sbGVyID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdDtcbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICFkZXN0aW5hdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwZXJmb3JtIGEganVtcCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcm9wcGFibGVSZW1haW5kZXIgPSBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuKHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tkZXN0aW5hdGlvbl0sIHJlcXVlc3QpO1xuICAgIGlmICghZHJvcHBhYmxlUmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG4gICAgY29uc3Qgd2luZG93UmVtYWluZGVyID0gc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbihzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBkcm9wcGFibGVSZW1haW5kZXIpO1xuICAgIGlmICghd2luZG93UmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vdmVCeU9mZnNldChzdGF0ZSwgd2luZG93UmVtYWluZGVyKTtcbiAgfTtcbiAgcmV0dXJuIGp1bXBTY3JvbGxlcjtcbn0pO1xuXG52YXIgY3JlYXRlQXV0b1Njcm9sbGVyID0gKCh7XG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgc2Nyb2xsV2luZG93LFxuICBtb3ZlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGZsdWlkU2Nyb2xsZXIgPSBjcmVhdGVGbHVpZFNjcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGp1bXBTY3JvbGwgPSBjcmVhdGVKdW1wU2Nyb2xsZXIoe1xuICAgIG1vdmUsXG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZVxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gICAgaWYgKGF1dG9TY3JvbGxlck9wdGlvbnMuZGlzYWJsZWQgfHwgc3RhdGUucGhhc2UgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ0ZMVUlEJykge1xuICAgICAgZmx1aWRTY3JvbGxlci5zY3JvbGwoc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGp1bXBTY3JvbGwoc3RhdGUpO1xuICB9O1xuICBjb25zdCBzY3JvbGxlciA9IHtcbiAgICBzY3JvbGwsXG4gICAgc3RhcnQ6IGZsdWlkU2Nyb2xsZXIuc3RhcnQsXG4gICAgc3RvcDogZmx1aWRTY3JvbGxlci5zdG9wXG4gIH07XG4gIHJldHVybiBzY3JvbGxlcjtcbn0pO1xuXG5jb25zdCBwcmVmaXggPSAnZGF0YS1yZmQnO1xuY29uc3QgZHJhZ0hhbmRsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyYWctaGFuZGxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGRyYWdnYWJsZUlkOiBgJHtiYXNlfS1kcmFnZ2FibGUtaWRgLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBkcmFnZ2FibGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcmFnZ2FibGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYCxcbiAgICBpZDogYCR7YmFzZX0taWRgXG4gIH07XG59KSgpO1xuY29uc3QgZHJvcHBhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJvcHBhYmxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGAsXG4gICAgaWQ6IGAke2Jhc2V9LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHtcbiAgY29udGV4dElkOiBgJHtwcmVmaXh9LXNjcm9sbC1jb250YWluZXItY29udGV4dC1pZGBcbn07XG5cbmNvbnN0IG1ha2VHZXRTZWxlY3RvciA9IGNvbnRleHQgPT4gYXR0cmlidXRlID0+IGBbJHthdHRyaWJ1dGV9PVwiJHtjb250ZXh0fVwiXWA7XG5jb25zdCBnZXRTdHlsZXMgPSAocnVsZXMsIHByb3BlcnR5KSA9PiBydWxlcy5tYXAocnVsZSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gcnVsZS5zdHlsZXNbcHJvcGVydHldO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBgJHtydWxlLnNlbGVjdG9yfSB7ICR7dmFsdWV9IH1gO1xufSkuam9pbignICcpO1xuY29uc3Qgbm9Qb2ludGVyRXZlbnRzID0gJ3BvaW50ZXItZXZlbnRzOiBub25lOyc7XG52YXIgZ2V0U3R5bGVzJDEgPSAoY29udGV4dElkID0+IHtcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBtYWtlR2V0U2VsZWN0b3IoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCBncmFiQ3Vyc29yID0gYFxuICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XG4gICAgICBjdXJzb3I6IGdyYWI7XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdIYW5kbGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBhbHdheXM6IGBcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApO1xuICAgICAgICAgIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAgICAgICBgLFxuICAgICAgICByZXN0aW5nOiBncmFiQ3Vyc29yLFxuICAgICAgICBkcmFnZ2luZzogbm9Qb2ludGVyRXZlbnRzLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiBncmFiQ3Vyc29yXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJhZ2dhYmxlJDEgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBgXG4gICAgICB0cmFuc2l0aW9uOiAke3RyYW5zaXRpb25zLm91dE9mVGhlV2F5fTtcbiAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJhZ2dhYmxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgZHJhZ2dpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIGRyb3BBbmltYXRpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIHVzZXJDYW5jZWw6IHRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkcm9wcGFibGUkMSA9IHtcbiAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJvcHBhYmxlLmNvbnRleHRJZCksXG4gICAgc3R5bGVzOiB7XG4gICAgICBhbHdheXM6IGBvdmVyZmxvdy1hbmNob3I6IG5vbmU7YFxuICAgIH1cbiAgfTtcbiAgY29uc3QgYm9keSA9IHtcbiAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgIHN0eWxlczoge1xuICAgICAgZHJhZ2dpbmc6IGBcbiAgICAgICAgY3Vyc29yOiBncmFiYmluZztcbiAgICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBvdmVyZmxvdy1hbmNob3I6IG5vbmU7XG4gICAgICBgXG4gICAgfVxuICB9O1xuICBjb25zdCBydWxlcyA9IFtkcmFnZ2FibGUkMSwgZHJhZ0hhbmRsZSQxLCBkcm9wcGFibGUkMSwgYm9keV07XG4gIHJldHVybiB7XG4gICAgYWx3YXlzOiBnZXRTdHlsZXMocnVsZXMsICdhbHdheXMnKSxcbiAgICByZXN0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdyZXN0aW5nJyksXG4gICAgZHJhZ2dpbmc6IGdldFN0eWxlcyhydWxlcywgJ2RyYWdnaW5nJyksXG4gICAgZHJvcEFuaW1hdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJvcEFuaW1hdGluZycpLFxuICAgIHVzZXJDYW5jZWw6IGdldFN0eWxlcyhydWxlcywgJ3VzZXJDYW5jZWwnKVxuICB9O1xufSk7XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0JDEgOiB1c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDtcblxuY29uc3QgZ2V0SGVhZCA9ICgpID0+IHtcbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgIWhlYWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCB0aGUgaGVhZCB0byBhcHBlbmQgYSBzdHlsZSB0bycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGhlYWQ7XG59O1xuY29uc3QgY3JlYXRlU3R5bGVFbCA9IG5vbmNlID0+IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBpZiAobm9uY2UpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICByZXR1cm4gZWw7XG59O1xuZnVuY3Rpb24gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlTWVtbygoKSA9PiBnZXRTdHlsZXMkMShjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IGFsd2F5c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZHluYW1pY1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0RHluYW1pY1N0eWxlID0gdXNlQ2FsbGJhY2sobWVtb2l6ZU9uZShwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBkeW5hbWljUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9KSwgW10pO1xuICBjb25zdCBzZXRBbHdheXNTdHlsZSA9IHVzZUNhbGxiYWNrKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGFsd2F5c1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSwgW10pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICEoIWFsd2F5c1JlZi5jdXJyZW50ICYmICFkeW5hbWljUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnc3R5bGUgZWxlbWVudHMgYWxyZWFkeSBtb3VudGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFsd2F5cyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBhbHdheXNSZWYuY3VycmVudCA9IGFsd2F5cztcbiAgICBkeW5hbWljUmVmLmN1cnJlbnQgPSBkeW5hbWljO1xuICAgIGFsd2F5cy5zZXRBdHRyaWJ1dGUoYCR7cHJlZml4fS1hbHdheXNgLCBjb250ZXh0SWQpO1xuICAgIGR5bmFtaWMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tZHluYW1pY2AsIGNvbnRleHRJZCk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGFsd2F5cyk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGR5bmFtaWMpO1xuICAgIHNldEFsd2F5c1N0eWxlKHN0eWxlcy5hbHdheXMpO1xuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IHJlZiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgIWN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgdW5tb3VudCByZWYgYXMgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgZ2V0SGVhZCgpLnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgcmVtb3ZlKGFsd2F5c1JlZik7XG4gICAgICByZW1vdmUoZHluYW1pY1JlZik7XG4gICAgfTtcbiAgfSwgW25vbmNlLCBzZXRBbHdheXNTdHlsZSwgc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuYWx3YXlzLCBzdHlsZXMucmVzdGluZywgY29udGV4dElkXSk7XG4gIGNvbnN0IGRyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcmFnZ2luZyksIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcmFnZ2luZ10pO1xuICBjb25zdCBkcm9wcGluZyA9IHVzZUNhbGxiYWNrKHJlYXNvbiA9PiB7XG4gICAgaWYgKHJlYXNvbiA9PT0gJ0RST1AnKSB7XG4gICAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyb3BBbmltYXRpbmcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnVzZXJDYW5jZWwpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJvcEFuaW1hdGluZywgc3R5bGVzLnVzZXJDYW5jZWxdKTtcbiAgY29uc3QgcmVzdGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWR5bmFtaWNSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMucmVzdGluZ10pO1xuICBjb25zdCBtYXJzaGFsID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnaW5nLFxuICAgIGRyb3BwaW5nLFxuICAgIHJlc3RpbmdcbiAgfSksIFtkcmFnZ2luZywgZHJvcHBpbmcsIHJlc3RpbmddKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwocGFyZW50Tm9kZSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbnZhciBnZXRXaW5kb3dGcm9tRWwgPSAoZWwgPT4ge1xuICBpZiAoZWwgJiYgZWwub3duZXJEb2N1bWVudCAmJiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdztcbn0pO1xuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGlmICghcG9zc2libGUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgYW55IGRyYWcgaGFuZGxlcyBpbiB0aGUgY29udGV4dCBcIiR7Y29udGV4dElkfVwiYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlIHdpdGggaWQgXCIke2RyYWdnYWJsZUlkfVwiIGFzIG5vIGhhbmRsZSB3aXRoIGEgbWF0Y2hpbmcgaWQgd2FzIGZvdW5kYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBuZWVkcyB0byBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICBjb25zdCBlbnRyaWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcmVjb3JkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9jdXMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGlkLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIGVudHJpZXNSZWYuY3VycmVudFtpZF0gPSBlbnRyeTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllc1tpZF07XG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgdHJ5R2l2ZUZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5R2l2ZUZvY3VzKHRyeUdpdmVGb2N1c1RvKSB7XG4gICAgY29uc3QgaGFuZGxlID0gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCB0cnlHaXZlRm9jdXNUbyk7XG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGhhbmRsZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCB0cnlTaGlmdFJlY29yZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVNoaWZ0UmVjb3JkKHByZXZpb3VzLCByZWRpcmVjdFRvKSB7XG4gICAgaWYgKHJlY29yZFJlZi5jdXJyZW50ID09PSBwcmV2aW91cykge1xuICAgICAgcmVjb3JkUmVmLmN1cnJlbnQgPSByZWRpcmVjdFRvO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZFJlZi5jdXJyZW50O1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICB0cnlHaXZlRm9jdXMocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3RyeUdpdmVGb2N1c10pO1xuICBjb25zdCB0cnlSZWNvcmRGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlY29yZEZvY3VzKGlkKSB7XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9jdXNlZC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgIT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyRnJhbWVPblVubW91bnQoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgZnJhbWVJZCA9IHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmVnaXN0ZXIsXG4gICAgdHJ5UmVjb3JkRm9jdXMsXG4gICAgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgdHJ5U2hpZnRSZWNvcmRcbiAgfSksIFtyZWdpc3RlciwgdHJ5UmVjb3JkRm9jdXMsIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLCB0cnlTaGlmdFJlY29yZF0pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7XG4gICAgZHJhZ2dhYmxlczoge30sXG4gICAgZHJvcHBhYmxlczoge31cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNiKSB7XG4gICAgc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcmFnZ2FibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcmFnZ2FibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcmFnZ2FibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgICAgbm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ0FERElUSU9OJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogKGVudHJ5LCBsYXN0KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQudW5pcXVlSWQgIT09IGVudHJ5LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcmFnZ2FibGVCeUlkKGRyYWdnYWJsZUlkKTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkudW5pcXVlSWQgIT09IGN1cnJlbnQudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tkcmFnZ2FibGVJZF07XG4gICAgICBpZiAoZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdKSB7XG4gICAgICAgIG5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ1JFTU9WQUwnLFxuICAgICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyYWdnYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcmFnZ2FibGVCeUlkLFxuICAgIGV4aXN0czogaWQgPT4gQm9vbGVhbihmaW5kRHJhZ2dhYmxlQnlJZChpZCkpLFxuICAgIGdldEFsbEJ5VHlwZTogdHlwZSA9PiBPYmplY3QudmFsdWVzKGVudHJpZXMuZHJhZ2dhYmxlcykuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZSlcbiAgfTtcbiAgZnVuY3Rpb24gZmluZERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcm9wcGFibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcm9wcGFibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcm9wcGFibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcm9wcGFibGVCeUlkKGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdO1xuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJvcHBhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyb3BwYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcm9wcGFibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBlbnRyaWVzLmRyYWdnYWJsZXMgPSB7fTtcbiAgICBlbnRyaWVzLmRyb3BwYWJsZXMgPSB7fTtcbiAgICBzdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlLFxuICAgIGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICBjb25zdCByZWdpc3RyeSA9IHVzZU1lbW8oY3JlYXRlUmVnaXN0cnksIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIGlmIChSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE2JykgfHwgUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKCcxNycpKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZWdpc3RyeS5jbGVhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpc3RyeS5jbGVhbigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtyZWdpc3RyeV0pO1xuICByZXR1cm4gcmVnaXN0cnk7XG59XG5cbnZhciBTdG9yZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgZ2V0Qm9keUVsZW1lbnQgPSAoKCkgPT4ge1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5ib2R5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gYm9keTtcbn0pO1xuXG5jb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAnMXB4JyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIGJvcmRlcjogJzAnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAnY2xpcC1wYXRoJzogJ2luc2V0KDEwMCUpJ1xufTtcbnZhciB2aXN1YWxseUhpZGRlbiQxID0gdmlzdWFsbHlIaWRkZW47XG5cbmNvbnN0IGdldElkID0gY29udGV4dElkID0+IGByZmQtYW5ub3VuY2VtZW50LSR7Y29udGV4dElkfWA7XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRJZChjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIF9leHRlbmRzKGVsLnN0eWxlLCB2aXN1YWxseUhpZGRlbiQxKTtcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQ2FsbGJhY2sobWVzc2FnZSA9PiB7XG4gICAgY29uc3QgZWwgPSByZWYuY3VycmVudDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBBIHNjcmVlbiByZWFkZXIgbWVzc2FnZSB3YXMgdHJ5aW5nIHRvIGJlIGFubm91bmNlZCBidXQgaXQgd2FzIHVuYWJsZSB0byBkbyBzby5cbiAgICAgIFRoaXMgY2FuIG9jY3VyIGlmIHlvdSB1bm1vdW50IHlvdXIgPERyYWdEcm9wQ29udGV4dCAvPiBpbiB5b3VyIG9uRHJhZ0VuZC5cbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxuICAgICAgbm90IGJlIGxvc3QgZm9yIHVzZXJzIHJlbHlpbmcgb24gYSBzY3JlZW4gcmVhZGVyLlxuXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcblxuICAgICAgXCIke21lc3NhZ2V9XCJcbiAgICBgKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbmxldCBjb3VudCQxID0gMDtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICBzZXBhcmF0b3I6ICc6Oidcbn07XG5mdW5jdGlvbiByZXNldERlcHJlY2F0ZWRVbmlxdWVJZCgpIHtcbiAgY291bnQkMSA9IDA7XG59XG5mdW5jdGlvbiB1c2VEZXByZWNhdGVkVW5pcXVlSWQocHJlZml4LCBvcHRpb25zID0gZGVmYXVsdHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7cHJlZml4fSR7b3B0aW9ucy5zZXBhcmF0b3J9JHtjb3VudCQxKyt9YCwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXhdKTtcbn1cbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKHByZWZpeCwgb3B0aW9ucyA9IGRlZmF1bHRzKSB7XG4gIGNvbnN0IGlkID0gUmVhY3QudXNlSWQoKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7cHJlZml4fSR7b3B0aW9ucy5zZXBhcmF0b3J9JHtpZH1gLCBbb3B0aW9ucy5zZXBhcmF0b3IsIHByZWZpeCwgaWRdKTtcbn1cbnZhciB1c2VVbmlxdWVJZCQxID0gJ3VzZUlkJyBpbiBSZWFjdCA/IHVzZVVuaXF1ZUlkIDogdXNlRGVwcmVjYXRlZFVuaXF1ZUlkO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50SWQoe1xuICBjb250ZXh0SWQsXG4gIHVuaXF1ZUlkXG59KSB7XG4gIHJldHVybiBgcmZkLWhpZGRlbi10ZXh0LSR7Y29udGV4dElkfS0ke3VuaXF1ZUlkfWA7XG59XG5mdW5jdGlvbiB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gIGNvbnRleHRJZCxcbiAgdGV4dFxufSkge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkJDEoJ2hpZGRlbi10ZXh0Jywge1xuICAgIHNlcGFyYXRvcjogJy0nXG4gIH0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8oKCkgPT4gZ2V0RWxlbWVudElkKHtcbiAgICBjb250ZXh0SWQsXG4gICAgdW5pcXVlSWRcbiAgfSksIFt1bmlxdWVJZCwgY29udGV4dElkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTYuOC41IHx8IF4xNy4wLjAgfHwgXjE4LjAuMFwiLFxuXHRcInJlYWN0LWRvbVwiOiBcIl4xNi44LjUgfHwgXjE3LjAuMCB8fCBeMTguMC4wXCJcbn07XG5cbmNvbnN0IHNlbXZlciA9IC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvO1xuY29uc3QgZ2V0VmVyc2lvbiA9IHZhbHVlID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmV4ZWModmFsdWUpO1xuICAhKHJlc3VsdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBSZWFjdCB2ZXJzaW9uICR7dmFsdWV9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBtYWpvciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICBjb25zdCBtaW5vciA9IE51bWJlcihyZXN1bHRbMl0pO1xuICBjb25zdCBwYXRjaCA9IE51bWJlcihyZXN1bHRbM10pO1xuICByZXR1cm4ge1xuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHBhdGNoLFxuICAgIHJhdzogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBpc1NhdGlzZmllZCA9IChleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gIGlmIChhY3R1YWwubWFqb3IgPiBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWFqb3IgPCBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yID4gZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yIDwgZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFjdHVhbC5wYXRjaCA+PSBleHBlY3RlZC5wYXRjaDtcbn07XG52YXIgY2hlY2tSZWFjdFZlcnNpb24gPSAoKHBlZXJEZXBWYWx1ZSwgYWN0dWFsVmFsdWUpID0+IHtcbiAgY29uc3QgcGVlckRlcCA9IGdldFZlcnNpb24ocGVlckRlcFZhbHVlKTtcbiAgY29uc3QgYWN0dWFsID0gZ2V0VmVyc2lvbihhY3R1YWxWYWx1ZSk7XG4gIGlmIChpc1NhdGlzZmllZChwZWVyRGVwLCBhY3R1YWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFJlYWN0IHZlcnNpb246IFske2FjdHVhbC5yYXd9XVxuICAgIGRvZXMgbm90IHNhdGlzZnkgZXhwZWN0ZWQgcGVlciBkZXBlbmRlbmN5IHZlcnNpb246IFske3BlZXJEZXAucmF3fV1cblxuICAgIFRoaXMgY2FuIHJlc3VsdCBpbiBydW4gdGltZSBidWdzLCBhbmQgZXZlbiBmYXRhbCBjcmFzaGVzXG4gIGApIDogdm9pZCAwO1xufSk7XG5cbmNvbnN0IHN1ZmZpeCA9IGBcbiAgV2UgZXhwZWN0IGEgaHRtbDUgZG9jdHlwZTogPCFkb2N0eXBlIGh0bWw+XG4gIFRoaXMgaXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYnJvd3NlciBsYXlvdXQgYW5kIG1lYXN1cmVtZW50XG5cbiAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2RvY3R5cGUubWRcbmA7XG52YXIgY2hlY2tEb2N0eXBlID0gKGRvYyA9PiB7XG4gIGNvbnN0IGRvY3R5cGUgPSBkb2MuZG9jdHlwZTtcbiAgaWYgKCFkb2N0eXBlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBObyA8IWRvY3R5cGUgaHRtbD4gZm91bmQuXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZG9jdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IGZvdW5kOiAoJHtkb2N0eXBlLm5hbWV9KVxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZG9jdHlwZS5wdWJsaWNJZCAhPT0gJycpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBwdWJsaWNJZCBmb3VuZDogKCR7ZG9jdHlwZS5wdWJsaWNJZH0pXG4gICAgICBBIGh0bWw1IGRvY3R5cGUgZG9lcyBub3QgaGF2ZSBhIHB1YmxpY0lkXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdXNlRGV2KHVzZUhvb2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1c2VIb29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRGV2U2V0dXBXYXJuaW5nKGZuLCBpbnB1dHMpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFxuICAgICAgICAgIEEgc2V0dXAgcHJvYmxlbSB3YXMgZW5jb3VudGVyZWQuXG5cbiAgICAgICAgICA+ICR7ZS5tZXNzYWdlfVxuICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9LCBpbnB1dHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhcnR1cFZhbGlkYXRpb24oKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgY2hlY2tSZWFjdFZlcnNpb24ocGVlckRlcGVuZGVuY2llcy5yZWFjdCwgUmVhY3QudmVyc2lvbik7XG4gICAgY2hlY2tEb2N0eXBlKGRvY3VtZW50KTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyhjdXJyZW50KSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihjdXJyZW50KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgZnVuY3Rpb24gaXNDbGFpbWVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsb2NrO1xuICB9XG4gIGZ1bmN0aW9uIGNsYWltKGFiYW5kb24pIHtcbiAgICAhIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2xhaW0gbG9jayBhcyBpdCBpcyBhbHJlYWR5IGNsYWltZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3TG9jayA9IHtcbiAgICAgIGFiYW5kb25cbiAgICB9O1xuICAgIGxvY2sgPSBuZXdMb2NrO1xuICAgIHJldHVybiBuZXdMb2NrO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVsZWFzZSBsb2NrIHdoZW4gdGhlcmUgaXMgbm8gbG9jaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NrID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0cnlBYmFuZG9uKCkge1xuICAgIGlmIChsb2NrKSB7XG4gICAgICBsb2NrLmFiYW5kb24oKTtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0NsYWltZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgY2xhaW0sXG4gICAgcmVsZWFzZSxcbiAgICB0cnlBYmFuZG9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ2dpbmcoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmlzRHJhZ2dpbmc7XG59XG5cbmNvbnN0IHRhYiA9IDk7XG5jb25zdCBlbnRlciA9IDEzO1xuY29uc3QgZXNjYXBlID0gMjc7XG5jb25zdCBzcGFjZSA9IDMyO1xuY29uc3QgcGFnZVVwID0gMzM7XG5jb25zdCBwYWdlRG93biA9IDM0O1xuY29uc3QgZW5kID0gMzU7XG5jb25zdCBob21lID0gMzY7XG5jb25zdCBhcnJvd0xlZnQgPSAzNztcbmNvbnN0IGFycm93VXAgPSAzODtcbmNvbnN0IGFycm93UmlnaHQgPSAzOTtcbmNvbnN0IGFycm93RG93biA9IDQwO1xuXG5jb25zdCBwcmV2ZW50ZWRLZXlzID0ge1xuICBbZW50ZXJdOiB0cnVlLFxuICBbdGFiXTogdHJ1ZVxufTtcbnZhciBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMgPSAoZXZlbnQgPT4ge1xuICBpZiAocHJldmVudGVkS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn0pO1xuXG5jb25zdCBzdXBwb3J0ZWRFdmVudE5hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgYG1zJHtiYXNlfWAsIGB3ZWJraXQke2Jhc2V9YCwgYG1veiR7YmFzZX1gLCBgbyR7YmFzZX1gXTtcbiAgY29uc3Qgc3VwcG9ydGVkID0gY2FuZGlkYXRlcy5maW5kKGV2ZW50TmFtZSA9PiBgb24ke2V2ZW50TmFtZX1gIGluIGRvY3VtZW50KTtcbiAgcmV0dXJuIHN1cHBvcnRlZCB8fCBiYXNlO1xufSkoKTtcbnZhciBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSA9IHN1cHBvcnRlZEV2ZW50TmFtZTtcblxuY29uc3QgcHJpbWFyeUJ1dHRvbiA9IDA7XG5jb25zdCBzbG9wcHlDbGlja1RocmVzaG9sZCA9IDU7XG5mdW5jdGlvbiBpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQob3JpZ2luYWwsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGN1cnJlbnQueCAtIG9yaWdpbmFsLngpID49IHNsb3BweUNsaWNrVGhyZXNob2xkIHx8IE1hdGguYWJzKGN1cnJlbnQueSAtIG9yaWdpbmFsLnkpID49IHNsb3BweUNsaWNrVGhyZXNob2xkO1xufVxuY29uc3QgaWRsZSQxID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5mdW5jdGlvbiBnZXRDYXB0dXJlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2UsXG4gIHNldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlbW92ZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBpZiAoYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGJlIElETEUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBwZW5kaW5nID0gcGhhc2UucG9pbnQ7XG4gICAgICBpZiAoIWlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChwZW5kaW5nLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwb2ludCk7XG4gICAgICBzZXRQaGFzZSh7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGFjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiAoKSA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgaWYgKHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSkge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQxKTtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMik7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IHByZXZlbnRGb3JjZVByZXNzQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcGkuZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUoaWQpO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYXBpLmNhbkdldExvY2soaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IGlkbGUkMTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IGdldENhcHR1cmVCaW5kaW5ncyh7XG4gICAgICBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZTogKCkgPT4gcGhhc2VSZWYuY3VycmVudCxcbiAgICAgIHNldFBoYXNlOiBwaGFzZSA9PiB7XG4gICAgICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBiaW5kaW5ncywgb3B0aW9ucyk7XG4gIH0sIFtjYW5jZWwsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKHBoYXNlUmVmLmN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0ge1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zXG4gICAgfTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5jb25zdCBzY3JvbGxKdW1wS2V5cyA9IHtcbiAgW3BhZ2VEb3duXTogdHJ1ZSxcbiAgW3BhZ2VVcF06IHRydWUsXG4gIFtob21lXTogdHJ1ZSxcbiAgW2VuZF06IHRydWVcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApIHtcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmNhbmNlbCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuZHJvcCgpO1xuICB9XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gc3BhY2UpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZHJvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dEb3duKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZURvd24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93VXApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlVXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93UmlnaHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlUmlnaHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93TGVmdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVMZWZ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxKdW1wS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoc3RhcnQnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2hlZWwnLFxuICAgIGZuOiBjYW5jZWwsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkUGFnZVZpc2liaWxpdHlFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkU2Vuc29yKGFwaSkge1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQxKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZURyYWcgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcmVEcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgaXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHByZURyYWcuc25hcExpZnQoKTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAhaXNDYXB0dXJpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBjYXB0dXJpbmcgYSBrZXlib2FyZCBkcmFnIHdoZW4gbm90IGNhcHR1cmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgaXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgICAgfVxuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U3RhcnRDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmNvbnN0IGlkbGUgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmNvbnN0IHRpbWVGb3JMb25nUHJlc3MgPSAxMjA7XG5jb25zdCBmb3JjZVByZXNzVGhyZXNob2xkID0gMC4xNTtcbmZ1bmN0aW9uIGdldFdpbmRvd0JpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBnZXRQaGFzZVxufSkge1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdvcmllbnRhdGlvbmNoYW5nZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjb250ZXh0bWVudScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkUGFnZVZpc2liaWxpdHlFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZUJpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBjb21wbGV0ZWQsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgb3B0aW9uczoge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGhhc2UuaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hlbmQnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoY2FuY2VsJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZm9yY2VjaGFuZ2UnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNGb3JjZVByZXNzID0gdG91Y2guZm9yY2UgPj0gZm9yY2VQcmVzc1RocmVzaG9sZDtcbiAgICAgIGlmICghaXNGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZFJlc3BlY3QgPSBwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgaWYgKHBoYXNlLmhhc01vdmVkKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlVG91Y2hTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKGlkbGUpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3QgZ2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBnZXRQaGFzZSgpIHtcbiAgICByZXR1cm4gcGhhc2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHNldFBoYXNlKHBoYXNlKSB7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IHRvdWNoO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50LmxvbmdQcmVzc1RpbWVySWQpO1xuICAgIH1cbiAgICBzZXRQaGFzZShpZGxlKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIGNvbnN0IGNhbmNlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmNhbmNlbCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgY29uc3QgYmluZENhcHR1cmluZ0V2ZW50cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGJpbmRDYXB0dXJpbmdFdmVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlXG4gICAgfTtcbiAgICBjb25zdCB1bmJpbmRUYXJnZXQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0SGFuZGxlQmluZGluZ3MoYXJncyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuYmluZFdpbmRvdyA9IGJpbmRFdmVudHMod2luZG93LCBnZXRXaW5kb3dCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB1bmJpbmRUYXJnZXQoKTtcbiAgICAgIHVuYmluZFdpbmRvdygpO1xuICAgIH07XG4gIH0sIFtjYW5jZWwsIGdldFBoYXNlLCBzdG9wXSk7XG4gIGNvbnN0IHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydERyYWdnaW5nKCkge1xuICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3Qgc3RhcnQgZHJhZ2dpbmcgZnJvbSBwaGFzZSAke3BoYXNlLnR5cGV9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwaGFzZS5wb2ludCk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBoYXNNb3ZlZDogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2dldFBoYXNlLCBzZXRQaGFzZV0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEoZ2V0UGhhc2UoKS50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGxvbmdQcmVzc1RpbWVySWQgPSBzZXRUaW1lb3V0KHN0YXJ0RHJhZ2dpbmcsIHRpbWVGb3JMb25nUHJlc3MpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50LFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGxvbmdQcmVzc1RpbWVySWRcbiAgICB9KTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzLCBnZXRQaGFzZSwgc2V0UGhhc2UsIHN0YXJ0RHJhZ2dpbmddKTtcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChwaGFzZS5sb25nUHJlc3NUaW1lcklkKTtcbiAgICAgICAgc2V0UGhhc2UoaWRsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2dldFBoYXNlLCBsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gd2Via2l0SGFjaygpIHtcbiAgICBjb25zdCB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgICBmbjogKCkgPT4ge30sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gdW5iaW5kO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRlU2Vuc29ySG9va3Moc2Vuc29ySG9va3MpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKHNlbnNvckhvb2tzKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShwcmV2aW91c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gc2Vuc29ySG9va3MubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjaGFuZ2UgdGhlIGFtb3VudCBvZiBzZW5zb3IgaG9va3MgYWZ0ZXIgbW91bnRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBpbnRlcmFjdGl2ZVRhZ05hbWVzID0gWydpbnB1dCcsICdidXR0b24nLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ29wdGlvbicsICdvcHRncm91cCcsICd2aWRlbycsICdhdWRpbyddO1xuZnVuY3Rpb24gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQpIHtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNBbkludGVyYWN0aXZlVGFnID0gaW50ZXJhY3RpdmVUYWdOYW1lcy5pbmNsdWRlcyhjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGlmIChoYXNBbkludGVyYWN0aXZlVGFnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICBpZiAoYXR0cmlidXRlID09PSAndHJ1ZScgfHwgYXR0cmlidXRlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50ID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xufVxuZnVuY3Rpb24gaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChkcmFnZ2FibGUsIHRhcmdldCk7XG59XG5cbnZhciBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiA9IChlbCA9PiBnZXRSZWN0KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5jZW50ZXIpO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5FbGVtZW50O1xufVxuXG5jb25zdCBzdXBwb3J0ZWRNYXRjaGVzTmFtZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSAnbWF0Y2hlcyc7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtiYXNlLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJ107XG4gIGNvbnN0IHZhbHVlID0gY2FuZGlkYXRlcy5maW5kKG5hbWUgPT4gbmFtZSBpbiBFbGVtZW50LnByb3RvdHlwZSk7XG4gIHJldHVybiB2YWx1ZSB8fCBiYXNlO1xufSkoKTtcbmZ1bmN0aW9uIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZWxbc3VwcG9ydGVkTWF0Y2hlc05hbWVdKHNlbGVjdG9yKSkge1xuICAgIHJldHVybiBlbDtcbiAgfVxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLnBhcmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwsIHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoY29udGV4dElkKSB7XG4gIHJldHVybiBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2V2ZW50LnRhcmdldCBtdXN0IGJlIGEgRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29udGV4dElkKTtcbiAgY29uc3QgaGFuZGxlID0gY2xvc2VzdCh0YXJnZXQsIHNlbGVjdG9yKTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG11c3QgYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICBjb25zdCBoYW5kbGUgPSBmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCk7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZS5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtkcmFnZ2FibGUuY29udGV4dElkfT1cIiR7Y29udGV4dElkfVwiXWA7XG4gIGNvbnN0IHBvc3NpYmxlID0gcXVlcnlTZWxlY3RvckFsbChkb2N1bWVudCwgc2VsZWN0b3IpO1xuICBjb25zdCBkcmFnZ2FibGUkMSA9IHBvc3NpYmxlLmZpbmQoZWwgPT4ge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLmlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWRyYWdnYWJsZSQxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGRyYWdnYWJsZSQxKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0RyYWdnYWJsZSBlbGVtZW50IGlzIG5vdCBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGRyYWdnYWJsZSQxO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gaXNBY3RpdmUoe1xuICBleHBlY3RlZCxcbiAgcGhhc2UsXG4gIGlzTG9ja0FjdGl2ZSxcbiAgc2hvdWxkV2FyblxufSkge1xuICBpZiAoIWlzTG9ja0FjdGl2ZSgpKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBzZW5zb3Igbm8gbG9uZ2VyIGhhcyBhbiBhY3Rpb24gbG9jay5cblxuICAgICAgICBUaXBzOlxuXG4gICAgICAgIC0gVGhyb3cgYXdheSB5b3VyIGFjdGlvbiBoYW5kbGVycyB3aGVuIGZvcmNlU3RvcCgpIGlzIGNhbGxlZFxuICAgICAgICAtIENoZWNrIGFjdGlvbnMuaXNBY3RpdmUoKSBpZiB5b3UgcmVhbGx5IG5lZWQgdG9cbiAgICAgIGApIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV4cGVjdGVkICE9PSBwaGFzZSkge1xuICAgIGlmIChzaG91bGRXYXJuKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxuICAgICAgICBUaGUgYWN0aW9ucyB5b3UgdXNlZCBiZWxvbmcgdG8gYW4gb3V0ZGF0ZWQgcGhhc2VcblxuICAgICAgICBDdXJyZW50IHBoYXNlOiAke2V4cGVjdGVkfVxuICAgICAgICBZb3UgY2FsbGVkIGFuIGFjdGlvbiBmcm9tIG91dGRhdGVkIHBoYXNlOiAke3BoYXNlfVxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBEbyBub3QgdXNlIHByZURyYWdBY3Rpb25zIGFjdGlvbnMgYWZ0ZXIgY2FsbGluZyBwcmVEcmFnQWN0aW9ucy5saWZ0KClcbiAgICAgIGApIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5TdGFydCh7XG4gIGxvY2tBUEksXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgZHJhZ2dhYmxlSWRcbn0pIHtcbiAgaWYgKGxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIHdpdGggaWQ6ICR7ZHJhZ2dhYmxlSWR9YCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZW50cnkub3B0aW9ucy5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFjYW5TdGFydERyYWcoc3RvcmUuZ2V0U3RhdGUoKSwgZHJhZ2dhYmxlSWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdHJ5U3RhcnQoe1xuICBsb2NrQVBJLFxuICBjb250ZXh0SWQsXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgZHJhZ2dhYmxlSWQsXG4gIGZvcmNlU2Vuc29yU3RvcCxcbiAgc291cmNlRXZlbnRcbn0pIHtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSBjYW5TdGFydCh7XG4gICAgbG9ja0FQSSxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBkcmFnZ2FibGVJZFxuICB9KTtcbiAgaWYgKCFzaG91bGRTdGFydCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICBjb25zdCBlbCA9IGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBlbnRyeS5kZXNjcmlwdG9yLmlkKTtcbiAgaWYgKCFlbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSBlbGVtZW50IHdpdGggaWQ6ICR7ZHJhZ2dhYmxlSWR9YCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNvdXJjZUV2ZW50ICYmICFlbnRyeS5vcHRpb25zLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzICYmIGlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudChlbCwgc291cmNlRXZlbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jayA9IGxvY2tBUEkuY2xhaW0oZm9yY2VTZW5zb3JTdG9wIHx8IG5vb3AkMik7XG4gIGxldCBwaGFzZSA9ICdQUkVfRFJBRyc7XG4gIGZ1bmN0aW9uIGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkge1xuICAgIHJldHVybiBlbnRyeS5vcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzO1xuICB9XG4gIGZ1bmN0aW9uIGlzTG9ja0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gbG9ja0FQSS5pc0FjdGl2ZShsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiB0cnlEaXNwYXRjaChleHBlY3RlZCwgZ2V0QWN0aW9uKSB7XG4gICAgaWYgKGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGdldEFjdGlvbigpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcgPSB0cnlEaXNwYXRjaC5iaW5kKG51bGwsICdEUkFHR0lORycpO1xuICBmdW5jdGlvbiBsaWZ0KGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICAgIHBoYXNlID0gJ0NPTVBMRVRFRCc7XG4gICAgfVxuICAgIGlmIChwaGFzZSAhPT0gJ1BSRV9EUkFHJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbGlmdCBpbiBwaGFzZSAke3BoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA7XG4gICAgfVxuICAgIHN0b3JlLmRpc3BhdGNoKGxpZnQkMShhcmdzLmxpZnRBY3Rpb25BcmdzKSk7XG4gICAgcGhhc2UgPSAnRFJBR0dJTkcnO1xuICAgIGZ1bmN0aW9uIGZpbmlzaChyZWFzb24sIG9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRCbG9ja05leHRDbGljazogZmFsc2VcbiAgICB9KSB7XG4gICAgICBhcmdzLmNsZWFudXAoKTtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZEJsb2NrTmV4dENsaWNrKSB7XG4gICAgICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICBmbjogcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgICBzZXRUaW1lb3V0KHVuYmluZCk7XG4gICAgICB9XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3AkMSh7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6ICgpID0+IGlzQWN0aXZlKHtcbiAgICAgICAgZXhwZWN0ZWQ6ICdEUkFHR0lORycsXG4gICAgICAgIHBoYXNlLFxuICAgICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGRyb3A6IG9wdGlvbnMgPT4gZmluaXNoKCdEUk9QJywgb3B0aW9ucyksXG4gICAgICBjYW5jZWw6IG9wdGlvbnMgPT4gZmluaXNoKCdDQU5DRUwnLCBvcHRpb25zKSxcbiAgICAgIC4uLmFyZ3MuYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmx1aWRMaWZ0KGNsaWVudFNlbGVjdGlvbikge1xuICAgIGNvbnN0IG1vdmUkMSA9IHJhZlNjaGQoY2xpZW50ID0+IHtcbiAgICAgIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKCgpID0+IG1vdmUoe1xuICAgICAgICBjbGllbnRcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcGkgPSBsaWZ0KHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdGTFVJRCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiAoKSA9PiBtb3ZlJDEuY2FuY2VsKCksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIG1vdmU6IG1vdmUkMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hcGksXG4gICAgICBtb3ZlOiBtb3ZlJDFcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNuYXBMaWZ0KCkge1xuICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICBtb3ZlVXA6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVVcCksXG4gICAgICBtb3ZlUmlnaHQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVSaWdodCksXG4gICAgICBtb3ZlRG93bjogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZURvd24pLFxuICAgICAgbW92ZUxlZnQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVMZWZ0KVxuICAgIH07XG4gICAgcmV0dXJuIGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb246IGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uKGVsKSxcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnU05BUCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiBub29wJDIsXG4gICAgICBhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRQcmVEcmFnKCkge1xuICAgIGNvbnN0IHNob3VsZFJlbGVhc2UgPSBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChzaG91bGRSZWxlYXNlKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJlRHJhZyA9IHtcbiAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgfSksXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGZsdWlkTGlmdCxcbiAgICBzbmFwTGlmdCxcbiAgICBhYm9ydDogYWJvcnRQcmVEcmFnXG4gIH07XG4gIHJldHVybiBwcmVEcmFnO1xufVxuY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbdXNlTW91c2VTZW5zb3IsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VUb3VjaFNlbnNvcl07XG5mdW5jdGlvbiB1c2VTZW5zb3JNYXJzaGFsKHtcbiAgY29udGV4dElkLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGN1c3RvbVNlbnNvcnMsXG4gIGVuYWJsZURlZmF1bHRTZW5zb3JzXG59KSB7XG4gIGNvbnN0IHVzZVNlbnNvcnMgPSBbLi4uKGVuYWJsZURlZmF1bHRTZW5zb3JzID8gZGVmYXVsdFNlbnNvcnMgOiBbXSksIC4uLihjdXN0b21TZW5zb3JzIHx8IFtdKV07XG4gIGNvbnN0IGxvY2tBUEkgPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGUoKSlbMF07XG4gIGNvbnN0IHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAoaXNEcmFnZ2luZyhwcmV2aW91cykgJiYgIWlzRHJhZ2dpbmcoY3VycmVudCkpIHtcbiAgICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEldKTtcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIGxpc3RlblRvU3RvcmUoKSB7XG4gICAgbGV0IHByZXZpb3VzID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtsb2NrQVBJLCBzdG9yZSwgdHJ5QWJhbmRvbkxvY2tdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbG9ja0FQSS50cnlBYmFuZG9uO1xuICB9LCBbbG9ja0FQSS50cnlBYmFuZG9uXSk7XG4gIGNvbnN0IGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhkcmFnZ2FibGVJZCA9PiB7XG4gICAgcmV0dXJuIGNhblN0YXJ0KHtcbiAgICAgIGxvY2tBUEksXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWRcbiAgICB9KTtcbiAgfSwgW2xvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICBjb25zdCB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpID0+IHRyeVN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBmb3JjZVNlbnNvclN0b3A6IGZvcmNlU3RvcCB8fCBudWxsLFxuICAgIHNvdXJjZUV2ZW50OiBvcHRpb25zICYmIG9wdGlvbnMuc291cmNlRXZlbnQgPyBvcHRpb25zLnNvdXJjZUV2ZW50IDogbnVsbFxuICB9KSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIGNvbnN0IHRyeVJlbGVhc2VMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVsZWFzZUxvY2soKSB7XG4gICAgaWYgKCFsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIGlmIChzdG9yZS5nZXRTdGF0ZSgpLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEksIHN0b3JlXSk7XG4gIGNvbnN0IGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBsb2NrQVBJLmlzQ2xhaW1lZCgpLCBbbG9ja0FQSV0pO1xuICBjb25zdCBhcGkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuR2V0TG9jayxcbiAgICB0cnlHZXRMb2NrLFxuICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgdHJ5UmVsZWFzZUxvY2ssXG4gICAgaXNMb2NrQ2xhaW1lZFxuICB9KSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZVNlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB1c2VTZW5zb3JzW2ldKGFwaSk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUmVzcG9uZGVycyA9IHByb3BzID0+ICh7XG4gIG9uQmVmb3JlQ2FwdHVyZTogdCA9PiB7XG4gICAgY29uc3Qgb25CZWZvcmVDYXB1cmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy5vbkJlZm9yZUNhcHR1cmUpIHtcbiAgICAgICAgcHJvcHMub25CZWZvcmVDYXB0dXJlKHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aCgnMTYnKSB8fCBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3JykpIHtcbiAgICAgIG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hTeW5jKG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2spO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZVxufSk7XG5jb25zdCBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zID0gcHJvcHMgPT4gKHtcbiAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIC4uLnByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcsXG4gICAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFN0b3JlKGxhenlSZWYpIHtcbiAgIWxhenlSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHN0b3JlIGZyb20gbGF6eSByZWYnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBsYXp5UmVmLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3MsXG4gICAgc2Vuc29ycyxcbiAgICBub25jZSxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXp5U3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCk7XG4gIGNvbnN0IGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgY29uc3QgZ2V0UmVzcG9uZGVycyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUmVzcG9uZGVycyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VBbm5vdW5jZXIoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkLFxuICAgIHRleHQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9KTtcbiAgY29uc3Qgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICBjb25zdCBsYXp5RGlzcGF0Y2ggPSB1c2VDYWxsYmFjayhhY3Rpb24gPT4ge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsQ2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgIHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBjb2xsZWN0aW9uU3RhcnRpbmdcbiAgfSwgbGF6eURpc3BhdGNoKSwgW2xhenlEaXNwYXRjaF0pO1xuICBjb25zdCByZWdpc3RyeSA9IHVzZVJlZ2lzdHJ5KCk7XG4gIGNvbnN0IGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICBjb25zdCBhdXRvU2Nyb2xsZXIgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUF1dG9TY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgICAuLi5iaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaClcbiAgfSksIFtkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSwgbGF6eURpc3BhdGNoLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXSk7XG4gIGNvbnN0IGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICBjb25zdCBzdG9yZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RvcmUoe1xuICAgIGFubm91bmNlLFxuICAgIGF1dG9TY3JvbGxlcixcbiAgICBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzTWFyc2hhbCxcbiAgICBnZXRSZXNwb25kZXJzLFxuICAgIHN0eWxlTWFyc2hhbFxuICB9KSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGxhenlTdG9yZVJlZi5jdXJyZW50ICYmIGxhenlTdG9yZVJlZi5jdXJyZW50ICE9PSBzdG9yZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygndW5leHBlY3RlZCBzdG9yZSBjaGFuZ2UnKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGF6eVN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZTtcbiAgY29uc3QgdHJ5UmVzZXRTdG9yZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICBjb25zdCBzdGF0ZSA9IGN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbiAgfSwgW10pO1xuICBjb25zdCBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZyxcbiAgICB0cnlBYm9ydDogdHJ5UmVzZXRTdG9yZVxuICB9KSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIGNvbnN0IGdldENhbkxpZnQgPSB1c2VDYWxsYmFjayhpZCA9PiBjYW5TdGFydERyYWcoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpLCBpZCksIFtdKTtcbiAgY29uc3QgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBpc01vdmVtZW50QWxsb3dlZChnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCkpLCBbXSk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICBmb2N1czogZm9jdXNNYXJzaGFsLFxuICAgIGNvbnRleHRJZCxcbiAgICBjYW5MaWZ0OiBnZXRDYW5MaWZ0LFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkOiBnZXRJc01vdmVtZW50QWxsb3dlZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9KSwgW2NvbnRleHRJZCwgZGltZW5zaW9uTWFyc2hhbCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGZvY3VzTWFyc2hhbCwgZ2V0Q2FuTGlmdCwgZ2V0SXNNb3ZlbWVudEFsbG93ZWQsIHJlZ2lzdHJ5XSk7XG4gIHVzZVNlbnNvck1hcnNoYWwoe1xuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzIHx8IG51bGwsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzICE9PSBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdHJ5UmVzZXRTdG9yZTtcbiAgfSwgW3RyeVJlc2V0U3RvcmVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcHBDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gICAgc3RvcmU6IHN0b3JlXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmxldCBjb3VudCA9IDA7XG5mdW5jdGlvbiByZXNldERlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKSB7XG4gIGNvdW50ID0gMDtcbn1cbmZ1bmN0aW9uIHVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGAke2NvdW50Kyt9YCwgW10pO1xufVxuZnVuY3Rpb24gdXNlVW5pcXVlQ29udGV4dElkKCkge1xuICByZXR1cm4gUmVhY3QudXNlSWQoKTtcbn1cbnZhciB1c2VVbmlxdWVDb250ZXh0SWQkMSA9ICd1c2VJZCcgaW4gUmVhY3QgPyB1c2VVbmlxdWVDb250ZXh0SWQgOiB1c2VEZXByZWNhdGVkVW5pcXVlQ29udGV4dElkO1xuXG5mdW5jdGlvbiByZXNldFNlcnZlckNvbnRleHQoKSB7XG4gIGlmICgndXNlSWQnIGluIFJlYWN0KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjYWxsIHJlc2V0U2VydmVyQ29udGV4dCB3aGVuIHVzaW5nIFJlYWN0IDE4K2ApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICByZXNldERlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKTtcbiAgcmVzZXREZXByZWNhdGVkVW5pcXVlSWQoKTtcbn1cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICBjb25zdCBjb250ZXh0SWQgPSB1c2VVbmlxdWVDb250ZXh0SWQkMSgpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBwcm9wcy5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgfHwgcHJlc2V0JDEuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCBudWxsLCBzZXRDYWxsYmFja3MgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIHtcbiAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzLFxuICAgIHNlbnNvcnM6IHByb3BzLnNlbnNvcnMsXG4gICAgb25CZWZvcmVDYXB0dXJlOiBwcm9wcy5vbkJlZm9yZUNhcHR1cmUsXG4gICAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZSxcbiAgICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgICBhdXRvU2Nyb2xsZXJPcHRpb25zOiBwcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IHpJbmRleE9wdGlvbnMgPSB7XG4gIGRyYWdnaW5nOiA1MDAwLFxuICBkcm9wQW5pbWF0aW5nOiA0NTAwXG59O1xuY29uc3QgZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uID0gKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQsIGRyb3BwaW5nKSA9PiB7XG4gIGlmIChkcm9wcGluZykge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5kcm9wKGRyb3BwaW5nLmR1cmF0aW9uKTtcbiAgfVxuICBpZiAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5zbmFwO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucy5mbHVpZDtcbn07XG5jb25zdCBnZXREcmFnZ2luZ09wYWNpdHkgPSAoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZykgPT4ge1xuICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gaXNEcm9wQW5pbWF0aW5nID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBjb21iaW5lLm9wYWNpdHkuY29tYmluaW5nO1xufTtcbmNvbnN0IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSA9IGRyYWdnaW5nID0+IHtcbiAgaWYgKGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICByZXR1cm4gZHJhZ2dpbmcubW9kZSA9PT0gJ1NOQVAnO1xufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nU3R5bGUoZHJhZ2dpbmcpIHtcbiAgY29uc3QgZGltZW5zaW9uID0gZHJhZ2dpbmcuZGltZW5zaW9uO1xuICBjb25zdCBib3ggPSBkaW1lbnNpb24uY2xpZW50O1xuICBjb25zdCB7XG4gICAgb2Zmc2V0LFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRyb3BwaW5nXG4gIH0gPSBkcmFnZ2luZztcbiAgY29uc3QgaXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbWJpbmVXaXRoKTtcbiAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZShkcmFnZ2luZyk7XG4gIGNvbnN0IGlzRHJvcEFuaW1hdGluZyA9IEJvb2xlYW4oZHJvcHBpbmcpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBpc0Ryb3BBbmltYXRpbmcgPyB0cmFuc2Zvcm1zLmRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykgOiB0cmFuc2Zvcm1zLm1vdmVUbyhvZmZzZXQpO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB0b3A6IGJveC5tYXJnaW5Cb3gudG9wLFxuICAgIGxlZnQ6IGJveC5tYXJnaW5Cb3gubGVmdCxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogYm94LmJvcmRlckJveC53aWR0aCxcbiAgICBoZWlnaHQ6IGJveC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHRyYW5zaXRpb246IGdldERyYWdnaW5nVHJhbnNpdGlvbihzaG91bGRBbmltYXRlLCBkcm9wcGluZyksXG4gICAgdHJhbnNmb3JtLFxuICAgIG9wYWNpdHk6IGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSxcbiAgICB6SW5kZXg6IGlzRHJvcEFuaW1hdGluZyA/IHpJbmRleE9wdGlvbnMuZHJvcEFuaW1hdGluZyA6IHpJbmRleE9wdGlvbnMuZHJhZ2dpbmcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH07XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVN0eWxlKHNlY29uZGFyeSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtcy5tb3ZlVG8oc2Vjb25kYXJ5Lm9mZnNldCksXG4gICAgdHJhbnNpdGlvbjogc2Vjb25kYXJ5LnNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQgPyB1bmRlZmluZWQgOiAnbm9uZSdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlJDEobWFwcGVkKSB7XG4gIHJldHVybiBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyA/IGdldERyYWdnaW5nU3R5bGUobWFwcGVkKSA6IGdldFNlY29uZGFyeVN0eWxlKG1hcHBlZCk7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwgPSBvcmlnaW4pIHtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGJvcmRlckJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjbGllbnQgPSBjYWxjdWxhdGVCb3goYm9yZGVyQm94LCBjb21wdXRlZFN0eWxlcyk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSB7XG4gICAgY2xpZW50LFxuICAgIHRhZ05hbWU6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBkaXNwbGF5OiBjb21wdXRlZFN0eWxlcy5kaXNwbGF5XG4gIH07XG4gIGNvbnN0IGRpc3BsYWNlQnkgPSB7XG4gICAgeDogY2xpZW50Lm1hcmdpbkJveC53aWR0aCxcbiAgICB5OiBjbGllbnQubWFyZ2luQm94LmhlaWdodFxuICB9O1xuICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcixcbiAgICBwbGFjZWhvbGRlcixcbiAgICBkaXNwbGFjZUJ5LFxuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQkMSgnZHJhZ2dhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGdldERyYWdnYWJsZVJlZixcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSA9IGFyZ3M7XG4gIGNvbnN0IG9wdGlvbnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgaXNFbmFibGVkXG4gIH0pLCBbY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIGlzRW5hYmxlZCwgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NdKTtcbiAgY29uc3QgZ2V0RGltZW5zaW9uID0gdXNlQ2FsbGJhY2sod2luZG93U2Nyb2xsID0+IHtcbiAgICBjb25zdCBlbCA9IGdldERyYWdnYWJsZVJlZigpO1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgZGltZW5zaW9uIHdoZW4gbm8gcmVmIGlzIHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCk7XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREcmFnZ2FibGVSZWZdKTtcbiAgY29uc3QgZW50cnkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgdW5pcXVlSWQsXG4gICAgZGVzY3JpcHRvcixcbiAgICBvcHRpb25zLFxuICAgIGdldERpbWVuc2lvblxuICB9KSwgW2Rlc2NyaXB0b3IsIGdldERpbWVuc2lvbiwgb3B0aW9ucywgdW5pcXVlSWRdKTtcbiAgY29uc3QgcHVibGlzaGVkUmVmID0gdXNlUmVmKGVudHJ5KTtcbiAgY29uc3QgaXNGaXJzdFB1Ymxpc2hSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnJlZ2lzdGVyKHB1Ymxpc2hlZFJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gKCkgPT4gcmVnaXN0cnkuZHJhZ2dhYmxlLnVucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHB1Ymxpc2hlZFJlZi5jdXJyZW50O1xuICAgIHB1Ymxpc2hlZFJlZi5jdXJyZW50ID0gZW50cnk7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnVwZGF0ZShlbnRyeSwgbGFzdCk7XG4gIH0sIFtlbnRyeSwgcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG59XG5cbnZhciBEcm9wcGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZWwpIHtcbiAgIShlbCAmJiBpc0h0bWxFbGVtZW50KGVsKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBcbiAgICBwcm92aWRlZC5pbm5lclJlZiBoYXMgbm90IGJlZW4gcHJvdmlkZWQgd2l0aCBhIEhUTUxFbGVtZW50LlxuXG4gICAgWW91IGNhbiBmaW5kIGEgZ3VpZGUgb24gdXNpbmcgdGhlIGlubmVyUmVmIGNhbGxiYWNrIGZ1bmN0aW9ucyBhdDpcbiAgICBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvdXNpbmctaW5uZXItcmVmLm1kXG4gIGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZikge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHByZWZpeChpZCkge1xuICAgICAgcmV0dXJuIGBEcmFnZ2FibGVbaWQ6ICR7aWR9XTogYDtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBwcm9wcy5kcmFnZ2FibGVJZDtcbiAgICAhaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgcmVxdWlyZXMgYSBkcmFnZ2FibGVJZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgRHJhZ2dhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJhZ2dhYmxlSWQuXG4gICAgICBQcm92aWRlZDogW3R5cGU6ICR7dHlwZW9mIGlkfV0gKHZhbHVlOiAke2lkfSlgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIU51bWJlci5pc0ludGVnZXIocHJvcHMuaW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSByZXF1aXJlcyBhbiBpbnRlZ2VyIGluZGV4IHByb3BgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldFJlZigpKTtcbiAgICBpZiAocHJvcHMuaXNFbmFibGVkKSB7XG4gICAgICAhZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke3ByZWZpeChpZCl9IFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVmID0gdXNlUmVmKGlzQ2xvbmUpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKGlzQ2xvbmUgPT09IGluaXRpYWxSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgaXNDbG9uZSBwcm9wIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbXBvbmVudCBsaWZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0sIFtpc0Nsb25lXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXF1aXJlZENvbnRleHQoQ29udGV4dCkge1xuICBjb25zdCByZXN1bHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAhcmVzdWx0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgcmVxdWlyZWQgY29udGV4dCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcHJldmVudEh0bWw1RG5kKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5jb25zdCBEcmFnZ2FibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soKGVsID0gbnVsbCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICBpbmRleDogcHJvcHMuaW5kZXgsXG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9KSwgW3Byb3BzLmRyYWdnYWJsZUlkLCBwcm9wcy5pbmRleCwgdHlwZSwgZHJvcHBhYmxlSWRdKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGlzRW5hYmxlZCxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBpc0Nsb25lLFxuICAgIG1hcHBlZCxcbiAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvblxuICB9ID0gcHJvcHM7XG4gIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpO1xuICB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpO1xuICBpZiAoIWlzQ2xvbmUpIHtcbiAgICBjb25zdCBmb3JQdWJsaXNoZXIgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBnZXREcmFnZ2FibGVSZWY6IGdldFJlZixcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9KSwgW2Rlc2NyaXB0b3IsIHJlZ2lzdHJ5LCBnZXRSZWYsIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcywgaXNFbmFibGVkXSk7XG4gICAgdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGZvclB1Ymxpc2hlcik7XG4gIH1cbiAgY29uc3QgZHJhZ0hhbmRsZVByb3BzID0gdXNlTWVtbygoKSA9PiBpc0VuYWJsZWQgPyB7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgJ2RhdGEtcmZkLWRyYWctaGFuZGxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICBvbkRyYWdTdGFydDogcHJldmVudEh0bWw1RG5kXG4gIH0gOiBudWxsLCBbY29udGV4dElkLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZHJhZ2dhYmxlSWQsIGlzRW5hYmxlZF0pO1xuICBjb25zdCBvbk1vdmVFbmQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKG1hcHBlZC50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbWFwcGVkLmRyb3BwaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE2JykgfHwgUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKCcxNycpKSB7XG4gICAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hTeW5jKGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbik7XG4gICAgfVxuICB9LCBbZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uLCBtYXBwZWRdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IGdldFN0eWxlJDEobWFwcGVkKTtcbiAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyAmJiBtYXBwZWQuZHJvcHBpbmcgPyBvbk1vdmVFbmQgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgaW5uZXJSZWY6IHNldFJlZixcbiAgICAgIGRyYWdnYWJsZVByb3BzOiB7XG4gICAgICAgICdkYXRhLXJmZC1kcmFnZ2FibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kXG4gICAgICB9LFxuICAgICAgZHJhZ0hhbmRsZVByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlUHJvcHMsIGRyYWdnYWJsZUlkLCBtYXBwZWQsIG9uTW92ZUVuZCwgc2V0UmVmXSk7XG4gIGNvbnN0IHJ1YnJpYyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSwgW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWQsIGRlc2NyaXB0b3IuaWQsIGRlc2NyaXB0b3IuaW5kZXgsIGRlc2NyaXB0b3IudHlwZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4ocHJvdmlkZWQsIG1hcHBlZC5zbmFwc2hvdCwgcnVicmljKSk7XG59O1xudmFyIERyYWdnYWJsZSQxID0gRHJhZ2dhYmxlO1xuXG52YXIgaXNTdHJpY3RFcXVhbCA9ICgoYSwgYikgPT4gYSA9PT0gYik7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQgPSAocmVzdWx0ID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbWJpbmUsXG4gICAgZGVzdGluYXRpb25cbiAgfSA9IHJlc3VsdDtcbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KTtcblxuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGltcGFjdCA9PiB7XG4gIHJldHVybiBpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyA/IGltcGFjdC5hdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGRyb3BwaW5nID0gbnVsbCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgIGlzQ2xvbmUsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBCb29sZWFuKGRyb3BwaW5nKSxcbiAgICBkcm9wQW5pbWF0aW9uOiBkcm9wcGluZyxcbiAgICBtb2RlLFxuICAgIGRyYWdnaW5nT3ZlcixcbiAgICBjb21iaW5lV2l0aCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsXG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgbW9kZSwgZGltZW5zaW9uLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IG51bGwpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgZHJvcHBpbmc6IG51bGwsXG4gICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICBjb21iaW5lV2l0aCxcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXQsXG4gICAgICBkaW1lbnNpb24sXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBudWxsKVxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDbG9uZSA9IG93blByb3BzLmlzQ2xvbmU7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGNvbnN0IG1vZGUgPSByZXN1bHQubW9kZTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gc3RhdGUuZHJvcER1cmF0aW9uO1xuICAgICAgY29uc3QgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBjdXJ2ZTogY3VydmVzLmRyb3AsXG4gICAgICAgIG1vdmVUbzogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgb3BhY2l0eTogY29tYmluZVdpdGggPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IG51bGwsXG4gICAgICAgIHNjYWxlOiBjb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmcsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGRyb3BwaW5nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U25hcHNob3QoY29tYmluZVRhcmdldEZvciA9IG51bGwpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IGZhbHNlLFxuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGRyb3BBbmltYXRpb246IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZ092ZXI6IG51bGwsXG4gICAgY29tYmluZVRhcmdldEZvcixcbiAgICBjb21iaW5lV2l0aDogbnVsbFxuICB9O1xufVxuY29uc3QgYXRSZXN0ID0ge1xuICBtYXBwZWQ6IHtcbiAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICBvZmZzZXQ6IG9yaWdpbixcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQ6IHRydWUsXG4gICAgc25hcHNob3Q6IGdldFNlY29uZGFyeVNuYXBzaG90KG51bGwpXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGdldFNlY29uZGFyeVNuYXBzaG90KTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgY29tYmluZVRhcmdldEZvciA9IG51bGwsIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50LFxuICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QoY29tYmluZVRhcmdldEZvcilcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0RmFsbGJhY2sgPSBjb21iaW5lVGFyZ2V0Rm9yID0+IHtcbiAgICByZXR1cm4gY29tYmluZVRhcmdldEZvciA/IGdldE1lbW9pemVkUHJvcHMob3JpZ2luLCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKSA6IG51bGw7XG4gIH07XG4gIGNvbnN0IGdldFByb3BzID0gKG93bklkLCBkcmFnZ2luZ0lkLCBpbXBhY3QsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgICBjb25zdCB2aXN1YWxEaXNwbGFjZW1lbnQgPSBpbXBhY3QuZGlzcGxhY2VkLnZpc2libGVbb3duSWRdO1xuICAgIGNvbnN0IGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QgPSBCb29sZWFuKGFmdGVyQ3JpdGljYWwuaW5WaXJ0dWFsTGlzdCAmJiBhZnRlckNyaXRpY2FsLmVmZmVjdGVkW293bklkXSk7XG4gICAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICBjb25zdCBjb21iaW5lVGFyZ2V0Rm9yID0gY29tYmluZSAmJiBjb21iaW5lLmRyYWdnYWJsZUlkID09PSBvd25JZCA/IGRyYWdnaW5nSWQgOiBudWxsO1xuICAgIGlmICghdmlzdWFsRGlzcGxhY2VtZW50KSB7XG4gICAgICBpZiAoIWlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGltcGFjdC5kaXNwbGFjZWQuaW52aXNpYmxlW293bklkXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZSA9IG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGNoYW5nZS54LCBjaGFuZ2UueSk7XG4gICAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGFjZUJ5ID0gaW1wYWN0LmRpc3BsYWNlZEJ5LnBvaW50O1xuICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGRpc3BsYWNlQnkueCwgZGlzcGxhY2VCeS55KTtcbiAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHZpc3VhbERpc3BsYWNlbWVudC5zaG91bGRBbmltYXRlKTtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkLCBzdGF0ZS5pbXBhY3QsIHN0YXRlLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmIChjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCwgY29tcGxldGVkLmltcGFjdCwgY29tcGxldGVkLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyQxID0gKCkgPT4ge1xuICBjb25zdCBkcmFnZ2luZ1NlbGVjdG9yID0gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKTtcbiAgY29uc3Qgc2Vjb25kYXJ5U2VsZWN0b3IgPSBnZXRTZWNvbmRhcnlTZWxlY3RvcigpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IGRyYWdnaW5nU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBzZWNvbmRhcnlTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IGF0UmVzdDtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyQxID0ge1xuICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZFxufTtcbmNvbnN0IENvbm5lY3RlZERyYWdnYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcyQxLCBtYXBEaXNwYXRjaFRvUHJvcHMkMSwgbnVsbCwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJhZ2dhYmxlJDEpO1xudmFyIENvbm5lY3RlZERyYWdnYWJsZSQxID0gQ29ubmVjdGVkRHJhZ2dhYmxlO1xuXG5mdW5jdGlvbiBQcml2YXRlRHJhZ2dhYmxlKHByb3BzKSB7XG4gIGNvbnN0IGRyb3BwYWJsZUNvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGlzVXNpbmdDbG9uZUZvciA9IGRyb3BwYWJsZUNvbnRleHQuaXNVc2luZ0Nsb25lRm9yO1xuICBpZiAoaXNVc2luZ0Nsb25lRm9yID09PSBwcm9wcy5kcmFnZ2FibGVJZCAmJiAhcHJvcHMuaXNDbG9uZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3RlZERyYWdnYWJsZSQxLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBQdWJsaWNEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgaXNFbmFibGVkID0gdHlwZW9mIHByb3BzLmlzRHJhZ0Rpc2FibGVkID09PSAnYm9vbGVhbicgPyAhcHJvcHMuaXNEcmFnRGlzYWJsZWQgOiB0cnVlO1xuICBjb25zdCBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IEJvb2xlYW4ocHJvcHMuZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nKTtcbiAgY29uc3Qgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBCb29sZWFuKHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgaXNFbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc1xuICB9KSk7XG59XG5cbmNvbnN0IGlzRXF1YWwgPSBiYXNlID0+IHZhbHVlID0+IGJhc2UgPT09IHZhbHVlO1xuY29uc3QgaXNTY3JvbGwgPSBpc0VxdWFsKCdzY3JvbGwnKTtcbmNvbnN0IGlzQXV0byA9IGlzRXF1YWwoJ2F1dG8nKTtcbmNvbnN0IGlzVmlzaWJsZSA9IGlzRXF1YWwoJ3Zpc2libGUnKTtcbmNvbnN0IGlzRWl0aGVyID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSB8fCBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNCb3RoID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSAmJiBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNFbGVtZW50U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IG92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogc3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogc3R5bGUub3ZlcmZsb3dZXG4gIH07XG4gIHJldHVybiBpc0VpdGhlcihvdmVyZmxvdywgaXNTY3JvbGwpIHx8IGlzRWl0aGVyKG92ZXJmbG93LCBpc0F1dG8pO1xufTtcbmNvbnN0IGlzQm9keVNjcm9sbGFibGUgPSAoKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhaHRtbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoYm9keSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG4gIGNvbnN0IGh0bWxPdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IGh0bWxTdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBodG1sU3R5bGUub3ZlcmZsb3dZXG4gIH07XG4gIGlmIChpc0JvdGgoaHRtbE92ZXJmbG93LCBpc1Zpc2libGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFdlIGhhdmUgZGV0ZWN0ZWQgdGhhdCB5b3VyIDxib2R5PiBlbGVtZW50IG1pZ2h0IGJlIGEgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICBXZSBoYXZlIGZvdW5kIG5vIHJlbGlhYmxlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciB0aGUgPGJvZHk+IGVsZW1lbnQgaXMgYSBzY3JvbGwgY29udGFpbmVyLlxuICAgIFVuZGVyIG1vc3QgY2lyY3Vtc3RhbmNlcyBhIDxib2R5PiBzY3JvbGwgYmFyIHdpbGwgYmUgb24gdGhlIDxodG1sPiBlbGVtZW50IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpXG5cbiAgICBCZWNhdXNlIHdlIGNhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIDxib2R5PiBpcyBhIHNjcm9sbCBjb250YWluZXIsIGFuZCBnZW5lcmFsbHkgaXQgaXMgbm90IG9uZSxcbiAgICB3ZSB3aWxsIGJlIHRyZWF0aW5nIHRoZSA8Ym9keT4gYXMgKm5vdCogYSBzY3JvbGwgY29udGFpbmVyXG5cbiAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvaG93LXdlLWRldGVjdC1zY3JvbGwtY29udGFpbmVycy5tZFxuICBgKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlID0gZWwgPT4ge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBpc0JvZHlTY3JvbGxhYmxlKCkgPyBlbCA6IG51bGw7XG4gIH1cbiAgaWYgKGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoZWwpKSB7XG4gICAgcmV0dXJuIGdldENsb3Nlc3RTY3JvbGxhYmxlKGVsLnBhcmVudEVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG52YXIgZ2V0Q2xvc2VzdFNjcm9sbGFibGUkMSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlO1xuXG52YXIgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzID0gKHNjcm9sbGFibGUgPT4ge1xuICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5vdGhlclNjcm9sbFBhcmVudCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlJDEoc2Nyb2xsYWJsZS5wYXJlbnRFbGVtZW50KTtcbiAgaWYgKCFhbm90aGVyU2Nyb2xsUGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERyb3BwYWJsZTogdW5zdXBwb3J0ZWQgbmVzdGVkIHNjcm9sbCBjb250YWluZXIgZGV0ZWN0ZWQuXG4gICAgQSBEcm9wcGFibGUgY2FuIG9ubHkgaGF2ZSBvbmUgc2Nyb2xsIHBhcmVudCAod2hpY2ggY2FuIGJlIGl0c2VsZilcbiAgICBOZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuXG4gICAgV2UgaG9wZSB0byBzdXBwb3J0IG5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBzb29uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvaXNzdWVzLzEzMVxuICBgKSA6IHZvaWQgMDtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsID0gKGVsID0+ICh7XG4gIHg6IGVsLnNjcm9sbExlZnQsXG4gIHk6IGVsLnNjcm9sbFRvcFxufSkpO1xuXG5jb25zdCBnZXRJc0ZpeGVkID0gZWwgPT4ge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZ2V0SXNGaXhlZChlbC5wYXJlbnRFbGVtZW50KTtcbn07XG52YXIgZ2V0RW52ID0gKHN0YXJ0ID0+IHtcbiAgY29uc3QgY2xvc2VzdFNjcm9sbGFibGUgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZSQxKHN0YXJ0KTtcbiAgY29uc3QgaXNGaXhlZE9uUGFnZSA9IGdldElzRml4ZWQoc3RhcnQpO1xuICByZXR1cm4ge1xuICAgIGNsb3Nlc3RTY3JvbGxhYmxlLFxuICAgIGlzRml4ZWRPblBhZ2VcbiAgfTtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlRGltZW5zaW9uID0gKCh7XG4gIGRlc2NyaXB0b3IsXG4gIGlzRW5hYmxlZCxcbiAgaXNDb21iaW5lRW5hYmxlZCxcbiAgaXNGaXhlZE9uUGFnZSxcbiAgZGlyZWN0aW9uLFxuICBjbGllbnQsXG4gIHBhZ2UsXG4gIGNsb3Nlc3Rcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSAoKCkgPT4ge1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50XG4gICAgfSA9IGNsb3Nlc3Q7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsU2l6ZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogc2Nyb2xsU2l6ZS5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodDogZnJhbWVDbGllbnQucGFkZGluZ0JveC5oZWlnaHQsXG4gICAgICB3aWR0aDogZnJhbWVDbGllbnQucGFkZGluZ0JveC53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlTWFyZ2luQm94OiBjbG9zZXN0LnBhZ2UubWFyZ2luQm94LFxuICAgICAgZnJhbWVDbGllbnQsXG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IGNsb3Nlc3Quc2hvdWxkQ2xpcFN1YmplY3QsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgaW5pdGlhbDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIGN1cnJlbnQ6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgICAgZGlmZjoge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBheGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2UsXG4gICAgYXhpcyxcbiAgICBpc0VuYWJsZWQsXG4gICAgY2xpZW50LFxuICAgIHBhZ2UsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbmNvbnN0IGdldENsaWVudCA9ICh0YXJnZXRSZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcbiAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmICh0YXJnZXRSZWYgIT09IGNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgdG9wID0gYmFzZS5wYWRkaW5nQm94LnRvcCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgY29uc3QgbGVmdCA9IGJhc2UucGFkZGluZ0JveC5sZWZ0IC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aDtcbiAgY29uc3QgcGFkZGluZ0JveCA9IHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnRcbiAgfTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZXhwYW5kKHBhZGRpbmdCb3gsIGJhc2UuYm9yZGVyKTtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBiYXNlLm1hcmdpbixcbiAgICBib3JkZXI6IGJhc2UuYm9yZGVyLFxuICAgIHBhZGRpbmc6IGJhc2UucGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIGNsaWVudDtcbn07XG52YXIgZ2V0RGltZW5zaW9uID0gKCh7XG4gIHJlZixcbiAgZGVzY3JpcHRvcixcbiAgZW52LFxuICB3aW5kb3dTY3JvbGwsXG4gIGRpcmVjdGlvbixcbiAgaXNEcm9wRGlzYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIHNob3VsZENsaXBTdWJqZWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQocmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgY2xvc2VzdCA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lQ2xpZW50ID0gZ2V0Qm94KGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgICBjb25zdCBzY3JvbGxTaXplID0ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGhcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgcGFnZTogd2l0aFNjcm9sbChmcmFtZUNsaWVudCwgd2luZG93U2Nyb2xsKSxcbiAgICAgIHNjcm9sbDogZ2V0U2Nyb2xsKGNsb3Nlc3RTY3JvbGxhYmxlKSxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdFxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldERyb3BwYWJsZURpbWVuc2lvbih7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0VuYWJsZWQ6ICFpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2U6IGVudi5pc0ZpeGVkT25QYWdlLFxuICAgIGRpcmVjdGlvbixcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBjbG9zZXN0XG4gIH0pO1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbmNvbnN0IGltbWVkaWF0ZSA9IHtcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG5jb25zdCBkZWxheWVkID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xudmFyIGdldExpc3RlbmVyT3B0aW9ucyA9IChvcHRpb25zID0+IG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZCk7XG5cbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcgPSBkcmFnZ2luZyA9PiBkcmFnZ2luZyAmJiBkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUgfHwgbnVsbDtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHdoaWxlRHJhZ2dpbmdSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQkMSgnZHJvcHBhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RyeSxcbiAgICBtYXJzaGFsXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBhcmdzLmRyb3BwYWJsZUlkLFxuICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICBtb2RlOiBhcmdzLm1vZGVcbiAgfSksIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICBjb25zdCBwdWJsaXNoZWREZXNjcmlwdG9yUmVmID0gdXNlUmVmKGRlc2NyaXB0b3IpO1xuICBjb25zdCBtZW1vaXplZFVwZGF0ZVNjcm9sbCA9IHVzZU1lbW8oKCkgPT4gbWVtb2l6ZU9uZSgoeCwgeSkgPT4ge1xuICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2Nyb2xsID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGRlc2NyaXB0b3IuaWQsIHNjcm9sbCk7XG4gIH0pLCBbZGVzY3JpcHRvci5pZCwgbWFyc2hhbF0pO1xuICBjb25zdCBnZXRDbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGlmICghZHJhZ2dpbmcgfHwgIWRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgcmV0dXJuIGdldFNjcm9sbChkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVwZGF0ZVNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzY3JvbGwgPSBnZXRDbG9zZXN0U2Nyb2xsKCk7XG4gICAgbWVtb2l6ZWRVcGRhdGVTY3JvbGwoc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgfSwgW2dldENsb3Nlc3RTY3JvbGwsIG1lbW9pemVkVXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IHNjaGVkdWxlU2Nyb2xsVXBkYXRlID0gdXNlTWVtbygoKSA9PiByYWZTY2hkKHVwZGF0ZVNjcm9sbCksIFt1cGRhdGVTY3JvbGxdKTtcbiAgY29uc3Qgb25DbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc2Nyb2xsIG9wdGlvbnMgd2hpbGUgc2Nyb2xsaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSkge1xuICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlKCk7XG4gIH0sIFtzY2hlZHVsZVNjcm9sbFVwZGF0ZSwgdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsID0gdXNlQ2FsbGJhY2soKHdpbmRvd1Njcm9sbCwgb3B0aW9ucykgPT4ge1xuICAgICEhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3QgYSBkcm9wcGFibGUgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcmVmID0gcHJldmlvdXMuZ2V0RHJvcHBhYmxlUmVmKCk7XG4gICAgIXJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IHdpdGhvdXQgYSBkcm9wcGFibGUgcmVmJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudiA9IGdldEVudihyZWYpO1xuICAgIGNvbnN0IGRyYWdnaW5nID0ge1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHNjcm9sbE9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IGRyYWdnaW5nO1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGdldERpbWVuc2lvbih7XG4gICAgICByZWYsXG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgZW52LFxuICAgICAgd2luZG93U2Nyb2xsLFxuICAgICAgZGlyZWN0aW9uOiBwcmV2aW91cy5kaXJlY3Rpb24sXG4gICAgICBpc0Ryb3BEaXNhYmxlZDogcHJldmlvdXMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkOiBwcmV2aW91cy5pc0NvbWJpbmVFbmFibGVkLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6ICFwcmV2aW91cy5pZ25vcmVDb250YWluZXJDbGlwcGluZ1xuICAgIH0pO1xuICAgIGNvbnN0IHNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG4gICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgIHNjcm9sbGFibGUuc2V0QXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQsIGFwcENvbnRleHQuY29udGV4dElkKTtcbiAgICAgIHNjcm9sbGFibGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzKHNjcm9sbGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9LCBbYXBwQ29udGV4dC5jb250ZXh0SWQsIGRlc2NyaXB0b3IsIG9uQ2xvc2VzdFNjcm9sbCwgcHJldmlvdXNSZWZdKTtcbiAgY29uc3QgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHJlY29sbGVjdCBEcm9wcGFibGUgY2xpZW50IGZvciBEcm9wcGFibGVzIHRoYXQgaGF2ZSBhIHNjcm9sbCBjb250YWluZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbChjbG9zZXN0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBkcmFnIHdoZW4gbm8gYWN0aXZlIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICBjb25zdCBzY3JvbGwgPSB1c2VDYWxsYmFjayhjaGFuZ2UgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhY2xvc2VzdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgYSBkcm9wcGFibGUgd2l0aCBubyBjbG9zZXN0IHNjcm9sbGFibGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2xvc2VzdC5zY3JvbGxUb3AgKz0gY2hhbmdlLnk7XG4gICAgY2xvc2VzdC5zY3JvbGxMZWZ0ICs9IGNoYW5nZS54O1xuICB9LCBbXSk7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCxcbiAgICAgIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsXG4gICAgICBkcmFnU3RvcHBlZCxcbiAgICAgIHNjcm9sbFxuICAgIH07XG4gIH0sIFtkcmFnU3RvcHBlZCwgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsIHNjcm9sbF0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIGNhbGxiYWNrc1xuICB9KSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgdW5pcXVlSWRdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5yZWdpc3RlcihlbnRyeSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnVW5zdXBwb3J0ZWQ6IGNoYW5naW5nIHRoZSBkcm9wcGFibGVJZCBvciB0eXBlIG9mIGEgRHJvcHBhYmxlIGR1cmluZyBhIGRyYWcnKSA6IHZvaWQgMDtcbiAgICAgICAgZHJhZ1N0b3BwZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS51bnJlZ2lzdGVyKGVudHJ5KTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCBkcmFnU3RvcHBlZCwgZW50cnksIG1hcnNoYWwsIHJlZ2lzdHJ5LmRyb3BwYWJsZV0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgIWFyZ3MuaXNEcm9wRGlzYWJsZWQpO1xuICB9LCBbYXJncy5pc0Ryb3BEaXNhYmxlZCwgbWFyc2hhbF0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsIGFyZ3MuaXNDb21iaW5lRW5hYmxlZCk7XG4gIH0sIFthcmdzLmlzQ29tYmluZUVuYWJsZWQsIG1hcnNoYWxdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5jb25zdCBnZXRTaXplID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFN0eWxlID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBwbGFjZWhvbGRlci5kaXNwbGF5LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgbWFyZ2luVG9wOiBzaXplLm1hcmdpbi50b3AsXG4gICAgbWFyZ2luUmlnaHQ6IHNpemUubWFyZ2luLnJpZ2h0LFxuICAgIG1hcmdpbkJvdHRvbTogc2l6ZS5tYXJnaW4uYm90dG9tLFxuICAgIG1hcmdpbkxlZnQ6IHNpemUubWFyZ2luLmxlZnQsXG4gICAgZmxleFNocmluazogJzAnLFxuICAgIGZsZXhHcm93OiAnMCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHRyYW5zaXRpb246IGFuaW1hdGUgIT09ICdub25lJyA/IHRyYW5zaXRpb25zLnBsYWNlaG9sZGVyIDogbnVsbFxuICB9O1xufTtcbmNvbnN0IFBsYWNlaG9sZGVyID0gcHJvcHMgPT4ge1xuICBjb25zdCBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICBjb25zdCB7XG4gICAgYW5pbWF0ZSxcbiAgICBvblRyYW5zaXRpb25FbmQsXG4gICAgb25DbG9zZSxcbiAgICBjb250ZXh0SWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudF0gPSB1c2VTdGF0ZShwcm9wcy5hbmltYXRlID09PSAnb3BlbicpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXI7XG4gIH0sIFthbmltYXRlLCBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXJdKTtcbiAgY29uc3Qgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgYW5pbWF0ZTogcHJvcHMuYW5pbWF0ZSxcbiAgICBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXJcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzLnBsYWNlaG9sZGVyLnRhZ05hbWUsIHtcbiAgICBzdHlsZSxcbiAgICAnZGF0YS1yZmQtcGxhY2Vob2xkZXItY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uU2l6ZUNoYW5nZUVuZCxcbiAgICByZWY6IHByb3BzLmlubmVyUmVmXG4gIH0pO1xufTtcbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBydW5DaGVja3MoYXJncywgY2hlY2tzKSB7XG4gIGNoZWNrcy5mb3JFYWNoKGNoZWNrID0+IGNoZWNrKGFyZ3MpKTtcbn1cbmNvbnN0IHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZCh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEEgRHJvcHBhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJvcHBhYmxlSWQuIFByb3ZpZGVkOiBbJHt0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWR9XWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGJvb2xlYW4oe1xuICBwcm9wc1xufSkge1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZih7XG4gIGdldERyb3BwYWJsZVJlZlxufSkge1xuICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXREcm9wcGFibGVSZWYoKSk7XG59XTtcbmNvbnN0IHN0YW5kYXJkID0gW2Z1bmN0aW9uIHBsYWNlaG9sZGVyKHtcbiAgcHJvcHMsXG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gIGlmICghcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmID0gZ2V0UGxhY2Vob2xkZXJSZWYoKTtcbiAgaWYgKHJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIERyb3BwYWJsZSBzZXR1cCBpc3N1ZSBbZHJvcHBhYmxlSWQ6IFwiJHtwcm9wcy5kcm9wcGFibGVJZH1cIl06XG4gICAgICBEcm9wcGFibGVQcm92aWRlZCA+IHBsYWNlaG9sZGVyIGNvdWxkIG5vdCBiZSBmb3VuZC5cblxuICAgICAgUGxlYXNlIGJlIHN1cmUgdG8gYWRkIHRoZSB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9IFJlYWN0IE5vZGUgYXMgYSBjaGlsZCBvZiB5b3VyIERyb3BwYWJsZS5cbiAgICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2FwaS9kcm9wcGFibGUubWRcbiAgICBgKSA6IHZvaWQgMDtcbn1dO1xuY29uc3QgdmlydHVhbCA9IFtmdW5jdGlvbiBoYXNDbG9uZSh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5yZW5kZXJDbG9uZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgcHJvdmlkZSBhIGNsb25lIHJlbmRlciBmdW5jdGlvbiAocmVuZGVyQ2xvbmUpIGZvciB2aXJ0dWFsIGxpc3RzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gaGFzTm9QbGFjZWhvbGRlcih7XG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgc3RhbmRhcmQpO1xuICAgIH1cbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCB2aXJ0dWFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jbGFzcyBBbmltYXRlSW5PdXQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiB0aGlzLnByb3BzLm9uLFxuICAgICAgYW5pbWF0ZTogdGhpcy5wcm9wcy5zaG91bGRBbmltYXRlICYmIHRoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuICAgIHRoaXMub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGUgIT09ICdjbG9zZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcm9wcy5vbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ29wZW4nXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEsXG4gICAgICAgIGFuaW1hdGU6ICdjbG9zZSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgICBvbkNsb3NlOiB0aGlzLm9uQ2xvc2UsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmRhdGEsXG4gICAgICBhbmltYXRlOiB0aGlzLnN0YXRlLmFuaW1hdGVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHByb3ZpZGVkKTtcbiAgfVxufVxuXG5jb25zdCBEcm9wcGFibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAhYXBwQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGFwcCBjb250ZXh0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBkcm9wcGFibGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBtb2RlLFxuICAgIGRpcmVjdGlvbixcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIHNuYXBzaG90LFxuICAgIHVzZUNsb25lLFxuICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsLFxuICAgIGdldENvbnRhaW5lckZvckNsb25lXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZ2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gZHJvcHBhYmxlUmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qgc2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGRyb3BwYWJsZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBwbGFjZWhvbGRlclJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHNldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICB1c2VWYWxpZGF0aW9uKHtcbiAgICBwcm9wcyxcbiAgICBnZXREcm9wcGFibGVSZWYsXG4gICAgZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSk7XG4gIGNvbnN0IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBnZXREcm9wcGFibGVSZWZcbiAgfSk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgKHtcbiAgICBvbkNsb3NlLFxuICAgIGRhdGEsXG4gICAgYW5pbWF0ZVxuICB9KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYWNlaG9sZGVyJDEsIHtcbiAgICBwbGFjZWhvbGRlcjogZGF0YSxcbiAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgIGlubmVyUmVmOiBzZXRQbGFjZWhvbGRlclJlZixcbiAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmRcbiAgfSkpLCBbY29udGV4dElkLCBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCwgcHJvcHMucGxhY2Vob2xkZXIsIHByb3BzLnNob3VsZEFuaW1hdGVQbGFjZWhvbGRlciwgc2V0UGxhY2Vob2xkZXJSZWZdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaW5uZXJSZWY6IHNldERyb3BwYWJsZVJlZixcbiAgICBwbGFjZWhvbGRlcixcbiAgICBkcm9wcGFibGVQcm9wczoge1xuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1pZCc6IGRyb3BwYWJsZUlkLFxuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkXG4gICAgfVxuICB9KSwgW2NvbnRleHRJZCwgZHJvcHBhYmxlSWQsIHBsYWNlaG9sZGVyLCBzZXREcm9wcGFibGVSZWZdKTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gdXNlQ2xvbmUgPyB1c2VDbG9uZS5kcmFnZ2luZy5kcmFnZ2FibGVJZCA6IG51bGw7XG4gIGNvbnN0IGRyb3BwYWJsZUNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBpc1VzaW5nQ2xvbmVGb3JcbiAgfSksIFtkcm9wcGFibGVJZCwgaXNVc2luZ0Nsb25lRm9yLCB0eXBlXSk7XG4gIGZ1bmN0aW9uIGdldENsb25lKCkge1xuICAgIGlmICghdXNlQ2xvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkcmFnZ2luZyxcbiAgICAgIHJlbmRlclxuICAgIH0gPSB1c2VDbG9uZTtcbiAgICBjb25zdCBub2RlID0gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCB7XG4gICAgICBkcmFnZ2FibGVJZDogZHJhZ2dpbmcuZHJhZ2dhYmxlSWQsXG4gICAgICBpbmRleDogZHJhZ2dpbmcuc291cmNlLmluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBmYWxzZSxcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiB0cnVlXG4gICAgfSwgKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCkgPT4gcmVuZGVyKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCwgZHJhZ2dpbmcpKTtcbiAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKG5vZGUsIGdldENvbnRhaW5lckZvckNsb25lKCkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3BwYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZHJvcHBhYmxlQ29udGV4dFxuICB9LCBjaGlsZHJlbihwcm92aWRlZCwgc25hcHNob3QpLCBnZXRDbG9uZSgpKTtcbn07XG52YXIgRHJvcHBhYmxlJDEgPSBEcm9wcGFibGU7XG5cbmZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICFkb2N1bWVudC5ib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnZG9jdW1lbnQuYm9keSBpcyBub3QgcmVhZHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufVxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtb2RlOiAnc3RhbmRhcmQnLFxuICB0eXBlOiAnREVGQVVMVCcsXG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgaXNEcm9wRGlzYWJsZWQ6IGZhbHNlLFxuICBpc0NvbWJpbmVFbmFibGVkOiBmYWxzZSxcbiAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGZhbHNlLFxuICByZW5kZXJDbG9uZTogbnVsbCxcbiAgZ2V0Q29udGFpbmVyRm9yQ2xvbmU6IGdldEJvZHlcbn07XG5jb25zdCBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzID0gb3duUHJvcHMgPT4ge1xuICBsZXQgbWVyZ2VkUHJvcHMgPSB7XG4gICAgLi4ub3duUHJvcHNcbiAgfTtcbiAgbGV0IGRlZmF1bHRQcm9wS2V5O1xuICBmb3IgKGRlZmF1bHRQcm9wS2V5IGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChvd25Qcm9wc1tkZWZhdWx0UHJvcEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVyZ2VkUHJvcHMgPSB7XG4gICAgICAgIC4uLm1lcmdlZFByb3BzLFxuICAgICAgICBbZGVmYXVsdFByb3BLZXldOiBkZWZhdWx0UHJvcHNbZGVmYXVsdFByb3BLZXldXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkUHJvcHM7XG59O1xuY29uc3QgaXNNYXRjaGluZ1R5cGUgPSAodHlwZSwgY3JpdGljYWwpID0+IHR5cGUgPT09IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlO1xuY29uc3QgZ2V0RHJhZ2dhYmxlID0gKGNyaXRpY2FsLCBkaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSAoKSA9PiB7XG4gIGNvbnN0IGlkbGVXaXRoQW5pbWF0aW9uID0ge1xuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICBzbmFwc2hvdDoge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGZhbHNlLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogbnVsbCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiBmYWxzZVxuICAgIH0sXG4gICAgdXNlQ2xvbmU6IG51bGxcbiAgfTtcbiAgY29uc3QgaWRsZVdpdGhvdXRBbmltYXRpb24gPSB7XG4gICAgLi4uaWRsZVdpdGhBbmltYXRpb24sXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9O1xuICBjb25zdCBnZXREcmFnZ2FibGVSdWJyaWMgPSBtZW1vaXplT25lKGRlc2NyaXB0b3IgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZSgoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkgPT4ge1xuICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZHJhZ2dpbmcuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBpc0hvbWUgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBpZDtcbiAgICBpZiAoaXNIb21lKSB7XG4gICAgICBjb25zdCB1c2VDbG9uZSA9IHJlbmRlckNsb25lID8ge1xuICAgICAgICByZW5kZXI6IHJlbmRlckNsb25lLFxuICAgICAgICBkcmFnZ2luZzogZ2V0RHJhZ2dhYmxlUnVicmljKGRyYWdnaW5nLmRlc2NyaXB0b3IpXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICBpc0RyYWdnaW5nT3ZlcjogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lcixcbiAgICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciA/IGRyYWdnYWJsZUlkIDogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IGRyYWdnYWJsZUlkLFxuICAgICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlcjogZHJhZ2dpbmcucGxhY2Vob2xkZXIsXG4gICAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0RyYWdnaW5nT3ZlckZvckltcGFjdCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBzbmFwc2hvdCA9IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgY29uc3Qgb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzID0gYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyk7XG4gICAgY29uc3QgaWQgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgdHlwZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy50eXBlO1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9ICFvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuaXNEcm9wRGlzYWJsZWQ7XG4gICAgY29uc3QgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMucmVuZGVyQ2xvbmU7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgY29uc3QgaXNEcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpID09PSBpZDtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlciwgaXNEcmFnZ2luZ092ZXIsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNvbXBsZXRlZC5jcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIGNvbnN0IHdhc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tcGxldGVkLmltcGFjdC5hdCAmJiBjb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICBjb25zdCBpc0hvbWUgPSBjb21wbGV0ZWQuY3JpdGljYWwuZHJvcHBhYmxlLmlkID09PSBpZDtcbiAgICAgIGlmICh3YXNPdmVyKSB7XG4gICAgICAgIHJldHVybiB3YXNDb21iaW5pbmcgPyBpZGxlV2l0aEFuaW1hdGlvbiA6IGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuY29uc3QgQ29ubmVjdGVkRHJvcHBhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIChzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMob3duUHJvcHMpLFxuICAgIC4uLnN0YXRlUHJvcHMsXG4gICAgLi4uZGlzcGF0Y2hQcm9wc1xuICB9O1xufSwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlJDEpO1xudmFyIENvbm5lY3RlZERyb3BwYWJsZSQxID0gQ29ubmVjdGVkRHJvcHBhYmxlO1xuXG5leHBvcnQgeyBEcmFnRHJvcENvbnRleHQsIFB1YmxpY0RyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIENvbm5lY3RlZERyb3BwYWJsZSQxIGFzIERyb3BwYWJsZSwgcmVzZXRTZXJ2ZXJDb250ZXh0LCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IsIHVzZVRvdWNoU2Vuc29yIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QkMSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ29udGV4dCIsIlJlYWN0RE9NIiwiZmx1c2hTeW5jIiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVTdG9yZSQxIiwiYXBwbHlNaWRkbGV3YXJlIiwiY29tcG9zZSIsImJpbmRBY3Rpb25DcmVhdG9ycyIsIlByb3ZpZGVyIiwiY29ubmVjdCIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImdldFJlY3QiLCJleHBhbmQiLCJvZmZzZXQiLCJ3aXRoU2Nyb2xsIiwiY2FsY3VsYXRlQm94IiwiZ2V0Qm94IiwiY3JlYXRlQm94IiwibWVtb2l6ZU9uZSIsInJhZlNjaGQiLCJfZXh0ZW5kcyIsImlzUHJvZHVjdGlvbiQxIiwicHJvY2VzcyIsInNwYWNlc0FuZFRhYnMiLCJsaW5lU3RhcnRXaXRoU3BhY2VzIiwiY2xlYW4kMiIsInZhbHVlIiwicmVwbGFjZSIsInRyaW0iLCJnZXREZXZNZXNzYWdlIiwibWVzc2FnZSIsImdldEZvcm1hdHRlZE1lc3NhZ2UiLCJpc0Rpc2FibGVkRmxhZyIsImxvZyIsInR5cGUiLCJ3aW5kb3ciLCJjb25zb2xlIiwid2FybmluZyIsImJpbmQiLCJlcnJvciIsIm5vb3AkMiIsImdldE9wdGlvbnMiLCJzaGFyZWQiLCJmcm9tQmluZGluZyIsImJpbmRFdmVudHMiLCJlbCIsImJpbmRpbmdzIiwic2hhcmVkT3B0aW9ucyIsInVuYmluZGluZ3MiLCJtYXAiLCJiaW5kaW5nIiwib3B0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJmbiIsInVuYmluZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bmJpbmRBbGwiLCJmb3JFYWNoIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4JDEiLCJSYmRJbnZhcmlhbnQiLCJFcnJvciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiYXJncyIsImNhbGxiYWNrcyIsIm9uV2luZG93RXJyb3IiLCJldmVudCIsImdldENhbGxiYWNrcyIsImlzRHJhZ2dpbmciLCJ0cnlBYm9ydCIsImVyciIsInByZXZlbnREZWZhdWx0Iiwic2V0Q2FsbGJhY2tzIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRDYXRjaCIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIiwicG9zaXRpb24iLCJpbmRleCIsIm9uRHJhZ1N0YXJ0Iiwic3RhcnQiLCJzb3VyY2UiLCJ3aXRoTG9jYXRpb24iLCJkZXN0aW5hdGlvbiIsImlzSW5Ib21lTGlzdCIsImRyb3BwYWJsZUlkIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0aW9uIiwid2l0aENvbWJpbmUiLCJpZCIsImNvbWJpbmUiLCJpbkhvbWVMaXN0IiwiZHJhZ2dhYmxlSWQiLCJvbkRyYWdVcGRhdGUiLCJ1cGRhdGUiLCJsb2NhdGlvbiIsInJldHVybmVkVG9TdGFydCIsIm9uRHJhZ0VuZCIsInJlc3VsdCIsInJlYXNvbiIsInByZXNldCIsInByZXNldCQxIiwib3JpZ2luIiwieCIsInkiLCJhZGQiLCJwb2ludDEiLCJwb2ludDIiLCJzdWJ0cmFjdCIsImlzRXF1YWwkMSIsIm5lZ2F0ZSIsInBvaW50IiwicGF0Y2giLCJsaW5lIiwib3RoZXJWYWx1ZSIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJjbG9zZXN0JDEiLCJ0YXJnZXQiLCJwb2ludHMiLCJtaW4iLCJhcHBseSIsImV4ZWN1dGVDbGlwIiwiZnJhbWUiLCJzdWJqZWN0IiwidG9wIiwibWF4IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRCeVBvc2l0aW9uIiwic3BhY2luZyIsImdldENvcm5lcnMiLCJub1NwYWNpbmciLCJzY3JvbGwkMSIsInNjcm9sbCIsImRpZmYiLCJkaXNwbGFjZW1lbnQiLCJpbmNyZWFzZSIsImF4aXMiLCJ3aXRoUGxhY2Vob2xkZXIiLCJpbmNyZWFzZWRCeSIsImVuZCIsImNsaXAiLCJzaG91bGRDbGlwU3ViamVjdCIsInBhZ2VNYXJnaW5Cb3giLCJnZXRTdWJqZWN0IiwicGFnZSIsInNjcm9sbGVkIiwibWFyZ2luQm94IiwiaW5jcmVhc2VkIiwiY2xpcHBlZCIsImFjdGl2ZSIsInNjcm9sbERyb3BwYWJsZSIsImRyb3BwYWJsZSIsIm5ld1Njcm9sbCIsInNjcm9sbGFibGUiLCJzY3JvbGxEaWZmIiwiaW5pdGlhbCIsInNjcm9sbERpc3BsYWNlbWVudCIsImN1cnJlbnQiLCJ0b0Ryb3BwYWJsZU1hcCIsImRyb3BwYWJsZXMiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImRlc2NyaXB0b3IiLCJ0b0RyYWdnYWJsZU1hcCIsImRyYWdnYWJsZXMiLCJ0b0Ryb3BwYWJsZUxpc3QiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ0b0RyYWdnYWJsZUxpc3QiLCJnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlIiwiZmlsdGVyIiwiZHJhZ2dhYmxlIiwic29ydCIsImEiLCJiIiwidHJ5R2V0RGVzdGluYXRpb24iLCJpbXBhY3QiLCJhdCIsInRyeUdldENvbWJpbmUiLCJyZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCIsInJlbW92ZSIsImxpc3QiLCJpdGVtIiwibW92ZVRvTmV4dENvbWJpbmUiLCJpc01vdmluZ0ZvcndhcmQiLCJpbnNpZGVEZXN0aW5hdGlvbiIsInByZXZpb3VzSW1wYWN0IiwiaXNDb21iaW5lRW5hYmxlZCIsImdldEltcGFjdCIsImFsbCIsImRpc3BsYWNlZCIsImNsb3Nlc3RJZCIsImxlbmd0aCIsIndpdGhvdXREcmFnZ2FibGUiLCJsYXN0IiwiaW5kZXhPZkNsb3Nlc3QiLCJmaW5kSW5kZXgiLCJkIiwicHJvcG9zZWRJbmRleCIsImJlZm9yZSIsImlzSG9tZU9mIiwibm9EaXNwbGFjZWRCeSIsImVtcHR5R3JvdXBzIiwiaW52aXNpYmxlIiwidmlzaWJsZSIsIm5vSW1wYWN0IiwiZGlzcGxhY2VkQnkiLCJub0ltcGFjdCQxIiwiaXNXaXRoaW4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsImlzV2l0aGluVmVydGljYWwiLCJpc1dpdGhpbkhvcml6b250YWwiLCJpc0NvbnRhaW5lZCIsImlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkiLCJpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkiLCJpc1BhcnRpYWxseUNvbnRhaW5lZCIsImlzQmlnZ2VyVmVydGljYWxseSIsImlzQmlnZ2VySG9yaXpvbnRhbGx5IiwiaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUiLCJpc1RhcmdldEJpZ2dlck9uT25lQXhpcyIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUiLCJ2ZXJ0aWNhbCIsImRpcmVjdGlvbiIsImNyb3NzQXhpc0xpbmUiLCJzaXplIiwiY3Jvc3NBeGlzU3RhcnQiLCJjcm9zc0F4aXNFbmQiLCJjcm9zc0F4aXNTaXplIiwiaG9yaXpvbnRhbCIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMiLCJnZXREcm9wcGFibGVEaXNwbGFjZWQiLCJpc1Zpc2libGVJbkRyb3BwYWJsZSIsImlzVmlzaWJsZVRocm91Z2hGcmFtZUZuIiwiaXNWaXNpYmxlSW5WaWV3cG9ydCIsInZpZXdwb3J0IiwiaXNWaXNpYmxlJDEiLCJ0b0JlRGlzcGxhY2VkIiwid2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCIsImRpc3BsYWNlZFRhcmdldCIsImlzUGFydGlhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGUiLCJpc1RvdGFsbHlWaXNpYmxlT25BeGlzIiwiZ2V0U2hvdWxkQW5pbWF0ZSIsImZvcmNlU2hvdWxkQW5pbWF0ZSIsInNob3VsZEFuaW1hdGUiLCJnZXRUYXJnZXQiLCJleHBhbmRCeSIsImdldERpc3BsYWNlbWVudEdyb3VwcyIsImFmdGVyRHJhZ2dpbmciLCJncm91cHMiLCJwdXNoIiwiaXNWaXNpYmxlIiwiZ2V0SW5kZXhPZkxhc3RJdGVtIiwiaW5kZXhPZkxhc3RJdGVtIiwiZ29BdEVuZCIsIm5ld0luZGV4IiwiY2FsY3VsYXRlUmVvcmRlckltcGFjdCIsIm1hdGNoIiwiZmluZCIsIndpdGhvdXREcmFnZ2luZyIsInNsaWNlRnJvbSIsImluZGV4T2YiLCJpbXBhY3RlZCIsInNsaWNlIiwiZGlkU3RhcnRBZnRlckNyaXRpY2FsIiwiYWZ0ZXJDcml0aWNhbCIsIkJvb2xlYW4iLCJlZmZlY3RlZCIsImZyb21Db21iaW5lIiwiY29tYmluZUlkIiwiY29tYmluZVdpdGgiLCJjb21iaW5lV2l0aEluZGV4IiwiZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwiLCJmcm9tUmVvcmRlciIsImN1cnJlbnRJbmRleCIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJtb3ZlVG9OZXh0SW5kZXgiLCJ3YXNBdCIsImdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCIsImlzRGlzcGxhY2VkIiwid2hlbkNvbWJpbmluZyIsImNlbnRlciIsImJvcmRlckJveCIsImRpc3BsYWNlQnkiLCJkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyIiwiYm94IiwibWFyZ2luIiwiZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIiLCJnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIiLCJpc01vdmluZyIsImdvQWZ0ZXIiLCJtb3ZlUmVsYXRpdmVUbyIsImdvQmVmb3JlIiwiZ29JbnRvU3RhcnQiLCJtb3ZlSW50byIsImNvbnRlbnRCb3giLCJ3aGVuUmVvcmRlcmluZyIsImRyYWdnYWJsZVBhZ2UiLCJjbG9zZXN0QWZ0ZXIiLCJjbG9zZXN0Iiwid2l0aERpc3BsYWNlbWVudCIsImdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQiLCJvcmlnaW5hbCIsImdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0Iiwid2l0aG91dERpc3BsYWNlbWVudCIsInNjcm9sbFZpZXdwb3J0IiwidXBkYXRlZCIsImdldERyYWdnYWJsZXMkMSIsImlkcyIsInRyeUdldFZpc2libGUiLCJpIiwic3BlY3VsYXRpdmVseUluY3JlYXNlIiwibWF4U2Nyb2xsQ2hhbmdlIiwic2Nyb2xsZWRWaWV3cG9ydCIsInNjcm9sbGVkRHJvcHBhYmxlIiwid2l0aFZpZXdwb3J0U2Nyb2xsIiwid2l0aERyb3BwYWJsZVNjcm9sbCIsIm5ld0ltcGFjdCIsIndpdGhWaWV3cG9ydERpc3BsYWNlbWVudCIsImdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyIiwicGFnZUJvcmRlckJveENlbnRlciIsIndpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlIiwiY2xpZW50IiwiaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24iLCJuZXdQYWdlQm9yZGVyQm94Q2VudGVyIiwib25seU9uTWFpbkF4aXMiLCJjaGFuZ2VOZWVkZWQiLCJzaGlmdGVkIiwibW92ZVRvTmV4dFBsYWNlIiwicHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyIiwicHJldmlvdXNDbGllbnRTZWxlY3Rpb24iLCJpc0VuYWJsZWQiLCJpc1Zpc2libGVJbk5ld0xvY2F0aW9uIiwiY2xpZW50U2VsZWN0aW9uIiwic2Nyb2xsSnVtcFJlcXVlc3QiLCJjYXV0aW91cyIsImdldEtub3duQWN0aXZlIiwicmVjdCIsImdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUiLCJpc0JldHdlZW5Tb3VyY2VDbGlwcGVkIiwiY2FuZGlkYXRlcyIsImFjdGl2ZU9mVGFyZ2V0IiwiaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkIiwiZmlyc3QiLCJzZWNvbmQiLCJhcnJheSIsImNvbnRhaW5zIiwiaXNXaXRoaW5Ecm9wcGFibGUiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciIsImdldEN1cnJlbnRQYWdlQm9yZGVyQm94IiwiZ2V0Q2xvc2VzdERyYWdnYWJsZSIsInNvcnRlZCIsImRpc3RhbmNlVG9BIiwiZGlzdGFuY2VUb0IiLCJnZXREaXNwbGFjZWRCeSIsImdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlclNpemUiLCJtb2RlIiwiYXZhaWxhYmxlU3BhY2UiLCJpbnNpZGVEcm9wcGFibGUiLCJzcGFjZVVzZWQiLCJzdW0iLCJkaW1lbnNpb24iLCJyZXF1aXJlZFNwYWNlIiwibmVlZHNUb0dyb3dCeSIsIndpdGhNYXhTY3JvbGwiLCJhZGRQbGFjZWhvbGRlciIsInJlcXVpcmVkR3Jvd3RoIiwiYWRkZWQiLCJvbGRGcmFtZU1heFNjcm9sbCIsIm1heFNjcm9sbCIsIm5ld0ZyYW1lIiwicmVtb3ZlUGxhY2Vob2xkZXIiLCJvbGRNYXhTY3JvbGwiLCJtb3ZlVG9OZXdEcm9wcGFibGUiLCJwcm9wb3NlZCIsInByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciIsImlzR29pbmdCZWZvcmVUYXJnZXQiLCJyZWxhdGl2ZVRvIiwibW92ZUNyb3NzQXhpcyIsImlzT3ZlciIsIndoYXRJc0RyYWdnZWRPdmVyIiwiZ2V0RHJvcHBhYmxlT3ZlciQxIiwibW92ZUluRGlyZWN0aW9uIiwic3RhdGUiLCJpc0FjdHVhbGx5T3ZlciIsImRpbWVuc2lvbnMiLCJpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkIiwiaG9tZSIsImNyaXRpY2FsIiwiaXNNb3ZpbmdPbk1haW5BeGlzIiwiYm9yZGVyQm94Q2VudGVyIiwic2VsZWN0aW9uIiwiaXNNb3ZlbWVudEFsbG93ZWQiLCJwaGFzZSIsImlzUG9zaXRpb25JbkZyYW1lIiwicnVuIiwiZ2V0SGFzT3ZlcmxhcCIsImdldEZ1cnRoZXN0QXdheSIsInBhZ2VCb3JkZXJCb3giLCJzdGFydENlbnRlciIsImNhbmRpZGF0ZSIsImdldERyb3BwYWJsZU92ZXIiLCJjaGlsZENlbnRlciIsImlzU3RhcnRDb250YWluZWQiLCJpc0VuZENvbnRhaW5lZCIsIm9mZnNldFJlY3RCeVBvc2l0aW9uIiwiYXJlYSIsImdldElzRGlzcGxhY2VkIiwiYXRJbmRleCIsImdldFJlb3JkZXJJbXBhY3QiLCJwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCIsInRhcmdldFJlY3QiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsImNoaWxkIiwiZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEiLCJjb21iaW5lVGhyZXNob2xkRGl2aXNvciIsImdldENvbWJpbmVJbXBhY3QiLCJjaGlsZFJlY3QiLCJjaGlsZFNpemUiLCJ0aHJlc2hvbGQiLCJnZXREcmFnSW1wYWN0IiwicGFnZU9mZnNldCIsImRlc3RpbmF0aW9uSWQiLCJwYXRjaERyb3BwYWJsZU1hcCIsImNsZWFyVW51c2VkUGxhY2Vob2xkZXIiLCJub3ciLCJsYXN0RHJvcHBhYmxlIiwicmVjb21wdXRlUGxhY2Vob2xkZXJzIiwiY2xlYW5lZCIsInBhdGNoZWQiLCJmb3JjZWRDbGllbnRTZWxlY3Rpb24iLCJmb3JjZWREaW1lbnNpb25zIiwiZm9yY2VkVmlld3BvcnQiLCJmb3JjZWRJbXBhY3QiLCJ3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyIsImdldERyYWdnYWJsZXMiLCJyZWNvbXB1dGUiLCJnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIiLCJyZWZyZXNoU25hcCIsIm1vdmVtZW50TW9kZSIsIm5lZWRzVmlzaWJpbGl0eUNoZWNrIiwiZ2V0SG9tZUxvY2F0aW9uIiwiZ2V0TGlmdEVmZmVjdCIsImluc2lkZUhvbWUiLCJyYXdJbmRleCIsImluVmlydHVhbExpc3QiLCJwYXRjaERpbWVuc2lvbk1hcCIsImtleSIsImZpbmlzaCIsIm9mZnNldERyYWdnYWJsZSIsIm9mZnNldCQxIiwiaW5pdGlhbFdpbmRvd1Njcm9sbCIsIm1vdmVkIiwicGxhY2Vob2xkZXIiLCJnZXRGcmFtZSIsImFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMiLCJhZGRpdGlvbnMiLCJ1cGRhdGVkRHJvcHBhYmxlcyIsIndpbmRvd1Njcm9sbENoYW5nZSIsIm1vZGlmaWVkIiwiZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlIiwidG90YWxDaGFuZ2UiLCJ0aW1pbmdzS2V5IiwicHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwiLCJwdWJsaXNoZWQiLCJ3aXRoU2Nyb2xsQ2hhbmdlIiwiZXhpc3RpbmciLCJ1cGRhdGVkQWRkaXRpb25zIiwicmVtb3ZhbHMiLCJ3YXNPdmVySWQiLCJ3YXNPdmVyIiwib25MaWZ0SW1wYWN0IiwiZHJhZ2dpbmdTdGF0ZSIsImRyb3BQZW5kaW5nIiwiaXNXYWl0aW5nIiwiaXNTbmFwcGluZyIsInBvc3REcm9wcGFibGVDaGFuZ2UiLCJpc0VuYWJsZWRDaGFuZ2luZyIsInJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0IiwiaWRsZSQyIiwiY29tcGxldGVkIiwic2hvdWxkRmx1c2giLCJyZWR1Y2VyIiwiYWN0aW9uIiwicGF5bG9hZCIsImlzV2luZG93U2Nyb2xsQWxsb3dlZCIsImV2ZXJ5IiwiaXNGaXhlZE9uUGFnZSIsIlN0cmluZyIsIm5ld1N0YXRlIiwiZHJvcER1cmF0aW9uIiwibmV3SG9tZUNsaWVudE9mZnNldCIsImJlZm9yZUluaXRpYWxDYXB0dXJlIiwibGlmdCQxIiwiaW5pdGlhbFB1Ymxpc2giLCJwdWJsaXNoV2hpbGVEcmFnZ2luZyIsImNvbGxlY3Rpb25TdGFydGluZyIsInVwZGF0ZURyb3BwYWJsZVNjcm9sbCIsInVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCIsInVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQiLCJtb3ZlIiwibW92ZUJ5V2luZG93U2Nyb2xsIiwidXBkYXRlVmlld3BvcnRNYXhTY3JvbGwiLCJtb3ZlVXAiLCJtb3ZlRG93biIsIm1vdmVSaWdodCIsIm1vdmVMZWZ0IiwiZmx1c2giLCJhbmltYXRlRHJvcCIsImNvbXBsZXRlRHJvcCIsImRyb3AkMSIsImRyb3BBbmltYXRpb25GaW5pc2hlZCIsImNoZWNrSW5kZXhlcyIsImluZGV4ZXMiLCJlcnJvcnMiLCJrZXlzIiwiZm9ybWF0dGVkIiwiaGFzRXJyb3IiLCJqb2luIiwidmFsaWRhdGVEaW1lbnNpb25zIiwibGlmdCIsIm1hcnNoYWwiLCJnZXRTdGF0ZSIsImRpc3BhdGNoIiwibmV4dCIsInNjcm9sbE9wdGlvbnMiLCJzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkiLCJyZXF1ZXN0Iiwic3RhcnRQdWJsaXNoaW5nIiwic3R5bGUiLCJkcmFnZ2luZyIsImRyb3BwaW5nIiwicmVzdGluZyIsImN1cnZlcyIsIm91dE9mVGhlV2F5IiwiZHJvcCIsIm9wYWNpdHkiLCJjb21iaW5pbmciLCJzY2FsZSIsInRpbWluZ3MiLCJtaW5Ecm9wVGltZSIsIm1heERyb3BUaW1lIiwib3V0T2ZUaGVXYXlUaW1pbmciLCJ0cmFuc2l0aW9ucyIsImZsdWlkIiwic25hcCIsImR1cmF0aW9uIiwidGltaW5nIiwibW92ZVRvIiwidW5kZWZpbmVkIiwidHJhbnNmb3JtcyIsImlzQ29tYmluaW5nIiwidHJhbnNsYXRlIiwiZHJvcFRpbWVSYW5nZSIsIm1heERyb3BUaW1lQXREaXN0YW5jZSIsImNhbmNlbERyb3BNb2RpZmllciIsImdldERyb3BEdXJhdGlvbiIsImRpc3RhbmNlJDEiLCJwZXJjZW50YWdlIiwid2l0aER1cmF0aW9uIiwiTnVtYmVyIiwidG9GaXhlZCIsImdldE5ld0hvbWVDbGllbnRPZmZzZXQiLCJuZXdDbGllbnRDZW50ZXIiLCJnZXREcm9wSW1wYWN0IiwibGFzdEltcGFjdCIsInJlY29tcHV0ZWRIb21lSW1wYWN0IiwiZGlkRHJvcEluc2lkZURyb3BwYWJsZSIsIndpdGhvdXRNb3ZlbWVudCIsImRyb3BNaWRkbGV3YXJlIiwiaXNXYWl0aW5nRm9yRHJvcCIsImlzQW5pbWF0aW9uUmVxdWlyZWQiLCJnZXRXaW5kb3dTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmluZGluZyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxMaXN0ZW5lciIsIm9uV2luZG93U2Nyb2xsIiwidXBkYXRlU2Nyb2xsIiwic2NoZWR1bGVkIiwiaXNBY3RpdmUiLCJzdG9wIiwiY2FuY2VsIiwic2hvdWxkRW5kIiwic2Nyb2xsTGlzdGVuZXIiLCJzdG9yZSIsImxpc3RlbmVyIiwic2Nyb2xsTGlzdGVuZXIkMSIsImdldEV4cGlyaW5nQW5ub3VuY2UiLCJhbm5vdW5jZSIsIndhc0NhbGxlZCIsImlzRXhwaXJlZCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRBc3luY01hcnNoYWwiLCJlbnRyaWVzIiwiZXhlY3V0ZSIsInRpbWVySWQiLCJlbnRyeSIsInNwbGljZSIsImNhbGxiYWNrIiwic2hhbGxvdyIsImFyZUxvY2F0aW9uc0VxdWFsIiwiaXNDb21iaW5lRXF1YWwiLCJpc0NyaXRpY2FsRXF1YWwiLCJpc0RyYWdnYWJsZUVxdWFsIiwiaXNEcm9wcGFibGVFcXVhbCIsIndpdGhUaW1pbmdzIiwiZ2V0RHJhZ1N0YXJ0IiwicmVzcG9uZGVyIiwiZGF0YSIsImdldERlZmF1bHRNZXNzYWdlIiwid2lsbEV4cGlyZSIsInByb3ZpZGVkIiwiZ2V0UHVibGlzaGVyIiwiZ2V0UmVzcG9uZGVycyIsImFzeW5jTWFyc2hhbCIsImJlZm9yZUNhcHR1cmUiLCJvbkJlZm9yZUNhcHR1cmUiLCJiZWZvcmVTdGFydCIsIm9uQmVmb3JlRHJhZ1N0YXJ0IiwibGFzdENyaXRpY2FsIiwibGFzdExvY2F0aW9uIiwibGFzdENvbWJpbmUiLCJoYXNDcml0aWNhbENoYW5nZWQiLCJoYXNMb2NhdGlvbkNoYW5nZWQiLCJoYXNHcm91cGluZ0NoYW5nZWQiLCJhYm9ydCIsInJlc3BvbmRlcnMiLCJwdWJsaXNoZXIiLCJkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSIsImRyb3BBbmltYXRpb25GaW5pc2giLCJkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUiLCJmcmFtZUlkIiwiY2xlYXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uY2UiLCJmbHVzaERyb3BBbmltYXRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCIsImRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyIiwic3RvcFB1Ymxpc2hpbmciLCJmb2N1cyIsImlzV2F0Y2hpbmciLCJ0cnlSZWNvcmRGb2N1cyIsInRyeVJlc3RvcmVGb2N1c1JlY29yZGVkIiwidHJ5U2hpZnRSZWNvcmQiLCJzaG91bGRTdG9wIiwiYXV0b1Njcm9sbCIsImF1dG9TY3JvbGxlciIsInBlbmRpbmdEcm9wIiwicG9zdEFjdGlvblN0YXRlIiwicGVuZGluZ0Ryb3AkMSIsImNvbXBvc2VFbmhhbmNlcnMiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJuYW1lIiwiZGltZW5zaW9uTWFyc2hhbCIsImZvY3VzTWFyc2hhbCIsInN0eWxlTWFyc2hhbCIsImNsZWFuJDEiLCJjcmVhdGVQdWJsaXNoZXIiLCJyZWdpc3RyeSIsInN0YWdpbmciLCJjb2xsZWN0IiwiZ2V0QnlJZCIsImdldERpbWVuc2lvbiIsImdldFNjcm9sbFdoaWxlRHJhZ2dpbmciLCJwdWJsaXNoIiwiZ2V0TWF4U2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJhZGp1c3RlZE1heFNjcm9sbCIsImdldERvY3VtZW50RWxlbWVudCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsImdldE1heFdpbmRvd1Njcm9sbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Vmlld3BvcnQiLCJnZXRJbml0aWFsUHVibGlzaCIsIndpbmRvd1Njcm9sbCIsImdldEFsbEJ5VHlwZSIsImdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsIiwic2hvdWxkUHVibGlzaFVwZGF0ZSIsImNyZWF0ZURpbWVuc2lvbk1hcnNoYWwiLCJjb2xsZWN0aW9uIiwiZXhpc3RzIiwiY2hhbmdlIiwiZHJhZ1N0b3BwZWQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5TdGFydERyYWciLCJzY3JvbGxXaW5kb3ciLCJzY3JvbGxCeSIsImdldFNjcm9sbGFibGVEcm9wcGFibGVzIiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIiLCJtYXliZSIsImdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlIiwiZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMiLCJzdGFydEZyb21QZXJjZW50YWdlIiwibWF4U2Nyb2xsQXRQZXJjZW50YWdlIiwibWF4UGl4ZWxTY3JvbGwiLCJlYXNlIiwiZHVyYXRpb25EYW1wZW5pbmciLCJzdG9wRGFtcGVuaW5nQXQiLCJhY2NlbGVyYXRlQXQiLCJkaXNhYmxlZCIsImdldERpc3RhbmNlVGhyZXNob2xkcyIsImNvbnRhaW5lciIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJhdXRvU2Nyb2xsZXJPcHRpb25zIiwic3RhcnRTY3JvbGxpbmdGcm9tIiwibWF4U2Nyb2xsVmFsdWVBdCIsInRocmVzaG9sZHMiLCJnZXRQZXJjZW50YWdlIiwic3RhcnRPZlJhbmdlIiwiZW5kT2ZSYW5nZSIsInJhbmdlIiwiY3VycmVudEluUmFuZ2UiLCJtaW5TY3JvbGwiLCJnZXRWYWx1ZUZyb21EaXN0YW5jZSIsImRpc3RhbmNlVG9FZGdlIiwicGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0IiwicGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20iLCJjZWlsIiwiZGFtcGVuVmFsdWVCeVRpbWUiLCJwcm9wb3NlZFNjcm9sbCIsImRyYWdTdGFydFRpbWUiLCJzdG9wQXQiLCJEYXRlIiwicnVuVGltZSIsImJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlIiwiZ2V0VmFsdWUiLCJzaG91bGRVc2VUaW1lRGFtcGVuaW5nIiwiZ2V0U2Nyb2xsT25BeGlzIiwiZGlzdGFuY2VUb0VkZ2VzIiwiaXNDbG9zZXJUb0VuZCIsImFkanVzdEZvclNpemVMaW1pdHMiLCJpc1Rvb0JpZ1ZlcnRpY2FsbHkiLCJpc1Rvb0JpZ0hvcml6b250YWxseSIsImNsZWFuIiwiZ2V0U2Nyb2xsJDEiLCJyZXF1aXJlZCIsImxpbWl0ZWQiLCJzbWFsbGVzdFNpZ25lZCIsImdldE92ZXJsYXAiLCJnZXRSZW1haW5kZXIiLCJ0YXJnZXRTY3JvbGwiLCJvdmVybGFwIiwiY2FuUGFydGlhbGx5U2Nyb2xsIiwicmF3TWF4Iiwic21hbGxlc3RDaGFuZ2UiLCJjYW5TY3JvbGxXaW5kb3ciLCJnZXRXaW5kb3dPdmVybGFwIiwiY2FuU2Nyb2xsRHJvcHBhYmxlIiwiZ2V0RHJvcHBhYmxlT3ZlcmxhcCIsImdldFdpbmRvd1Njcm9sbENoYW5nZSIsImdldERyb3BwYWJsZVNjcm9sbENoYW5nZSIsImNyZWF0ZUZsdWlkU2Nyb2xsZXIiLCJzY2hlZHVsZVdpbmRvd1Njcm9sbCIsInNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsIiwidHJ5U2Nyb2xsIiwic3RhcnQkMSIsIndhc1Njcm9sbE5lZWRlZCIsImZha2VTY3JvbGxDYWxsYmFjayIsImNyZWF0ZUp1bXBTY3JvbGxlciIsIm1vdmVCeU9mZnNldCIsInNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsIiwicmVtYWluZGVyIiwic2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiIsIndoYXRUaGVXaW5kb3dDYW5TY3JvbGwiLCJqdW1wU2Nyb2xsZXIiLCJkcm9wcGFibGVSZW1haW5kZXIiLCJ3aW5kb3dSZW1haW5kZXIiLCJjcmVhdGVBdXRvU2Nyb2xsZXIiLCJmbHVpZFNjcm9sbGVyIiwianVtcFNjcm9sbCIsInNjcm9sbGVyIiwicHJlZml4IiwiZHJhZ0hhbmRsZSIsImJhc2UiLCJjb250ZXh0SWQiLCJzY3JvbGxDb250YWluZXIiLCJtYWtlR2V0U2VsZWN0b3IiLCJjb250ZXh0IiwiYXR0cmlidXRlIiwiZ2V0U3R5bGVzIiwicnVsZXMiLCJwcm9wZXJ0eSIsInJ1bGUiLCJzdHlsZXMiLCJzZWxlY3RvciIsIm5vUG9pbnRlckV2ZW50cyIsImdldFN0eWxlcyQxIiwiZ2V0U2VsZWN0b3IiLCJkcmFnSGFuZGxlJDEiLCJncmFiQ3Vyc29yIiwiYWx3YXlzIiwiZHJvcEFuaW1hdGluZyIsImRyYWdnYWJsZSQxIiwidHJhbnNpdGlvbiIsInVzZXJDYW5jZWwiLCJkcm9wcGFibGUkMSIsImJvZHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImdldEhlYWQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZVN0eWxlRWwiLCJub25jZSIsInNldEF0dHJpYnV0ZSIsInVzZVN0eWxlTWFyc2hhbCIsImFsd2F5c1JlZiIsImR5bmFtaWNSZWYiLCJzZXREeW5hbWljU3R5bGUiLCJ0ZXh0Q29udGVudCIsInNldEFsd2F5c1N0eWxlIiwiZHluYW1pYyIsImFwcGVuZENoaWxkIiwicmVmIiwicmVtb3ZlQ2hpbGQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyZW50Tm9kZSIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd0Zyb21FbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzSHRtbEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZpbmREcmFnSGFuZGxlIiwicG9zc2libGUiLCJoYW5kbGUiLCJnZXRBdHRyaWJ1dGUiLCJ1c2VGb2N1c01hcnNoYWwiLCJlbnRyaWVzUmVmIiwicmVjb3JkUmVmIiwicmVzdG9yZUZvY3VzRnJhbWVSZWYiLCJpc01vdW50ZWRSZWYiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJ0cnlHaXZlRm9jdXMiLCJ0cnlHaXZlRm9jdXNUbyIsImFjdGl2ZUVsZW1lbnQiLCJyZWRpcmVjdFRvIiwicmVjb3JkIiwiZm9jdXNlZCIsImNsZWFyRnJhbWVPblVubW91bnQiLCJjcmVhdGVSZWdpc3RyeSIsInN1YnNjcmliZXJzIiwiY2IiLCJub3RpZnkiLCJmaW5kRHJhZ2dhYmxlQnlJZCIsImdldERyYWdnYWJsZUJ5SWQiLCJkcmFnZ2FibGVBUEkiLCJ1bmlxdWVJZCIsImZpbmRCeUlkIiwiZmluZERyb3BwYWJsZUJ5SWQiLCJnZXREcm9wcGFibGVCeUlkIiwiZHJvcHBhYmxlQVBJIiwidXNlUmVnaXN0cnkiLCJ1bm1vdW50IiwidmVyc2lvbiIsInN0YXJ0c1dpdGgiLCJTdG9yZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZ2V0Qm9keUVsZW1lbnQiLCJ2aXN1YWxseUhpZGRlbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsInZpc3VhbGx5SGlkZGVuJDEiLCJnZXRJZCIsInVzZUFubm91bmNlciIsInNldHVwIiwiY2xlYW51cCIsImNvdW50JDEiLCJkZWZhdWx0cyIsInNlcGFyYXRvciIsInJlc2V0RGVwcmVjYXRlZFVuaXF1ZUlkIiwidXNlRGVwcmVjYXRlZFVuaXF1ZUlkIiwidXNlVW5pcXVlSWQiLCJ1c2VJZCIsInVzZVVuaXF1ZUlkJDEiLCJnZXRFbGVtZW50SWQiLCJ1c2VIaWRkZW5UZXh0RWxlbWVudCIsInRleHQiLCJtb3VudCIsImRpc3BsYXkiLCJBcHBDb250ZXh0IiwicGVlckRlcGVuZGVuY2llcyIsInJlYWN0Iiwic2VtdmVyIiwiZ2V0VmVyc2lvbiIsImV4ZWMiLCJtYWpvciIsIm1pbm9yIiwicmF3IiwiaXNTYXRpc2ZpZWQiLCJleHBlY3RlZCIsImFjdHVhbCIsImNoZWNrUmVhY3RWZXJzaW9uIiwicGVlckRlcFZhbHVlIiwiYWN0dWFsVmFsdWUiLCJwZWVyRGVwIiwic3VmZml4IiwiY2hlY2tEb2N0eXBlIiwiZG9jdHlwZSIsInRvTG93ZXJDYXNlIiwicHVibGljSWQiLCJ1c2VEZXYiLCJ1c2VIb29rIiwidXNlRGV2U2V0dXBXYXJuaW5nIiwiaW5wdXRzIiwiZSIsInVzZVN0YXJ0dXBWYWxpZGF0aW9uIiwidXNlUHJldmlvdXMiLCJjcmVhdGUiLCJsb2NrIiwiaXNDbGFpbWVkIiwiY2xhaW0iLCJhYmFuZG9uIiwibmV3TG9jayIsInJlbGVhc2UiLCJ0cnlBYmFuZG9uIiwidGFiIiwiZW50ZXIiLCJlc2NhcGUiLCJzcGFjZSIsInBhZ2VVcCIsInBhZ2VEb3duIiwiYXJyb3dMZWZ0IiwiYXJyb3dVcCIsImFycm93UmlnaHQiLCJhcnJvd0Rvd24iLCJwcmV2ZW50ZWRLZXlzIiwicHJldmVudFN0YW5kYXJkS2V5RXZlbnRzIiwia2V5Q29kZSIsInN1cHBvcnRlZEV2ZW50TmFtZSIsInN1cHBvcnRlZCIsInN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lIiwicHJpbWFyeUJ1dHRvbiIsInNsb3BweUNsaWNrVGhyZXNob2xkIiwiaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkIiwiYWJzIiwiaWRsZSQxIiwiZ2V0Q2FwdHVyZUJpbmRpbmdzIiwiZ2V0UGhhc2UiLCJzZXRQaGFzZSIsImJ1dHRvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiYWN0aW9ucyIsInBlbmRpbmciLCJmbHVpZExpZnQiLCJzaG91bGRCbG9ja05leHRDbGljayIsInNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidXNlTW91c2VTZW5zb3IiLCJhcGkiLCJwaGFzZVJlZiIsInVuYmluZEV2ZW50c1JlZiIsInN0YXJ0Q2FwdHVyZUJpbmRpbmciLCJvbk1vdXNlRG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiZmluZENsb3Nlc3REcmFnZ2FibGVJZCIsInRyeUdldExvY2siLCJzb3VyY2VFdmVudCIsInN0YXJ0UGVuZGluZ0RyYWciLCJwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmciLCJmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSIsImNhbkdldExvY2siLCJsaXN0ZW5Gb3JDYXB0dXJlIiwiYmluZENhcHR1cmluZ0V2ZW50cyIsIm5vb3AkMSIsInNjcm9sbEp1bXBLZXlzIiwiZ2V0RHJhZ2dpbmdCaW5kaW5ncyIsInVzZUtleWJvYXJkU2Vuc29yIiwib25LZXlEb3duIiwicHJlRHJhZyIsImlzQ2FwdHVyaW5nIiwic25hcExpZnQiLCJ0cnlTdGFydENhcHR1cmUiLCJpZGxlIiwidGltZUZvckxvbmdQcmVzcyIsImZvcmNlUHJlc3NUaHJlc2hvbGQiLCJnZXRXaW5kb3dCaW5kaW5ncyIsImdldEhhbmRsZUJpbmRpbmdzIiwiaGFzTW92ZWQiLCJ0b3VjaGVzIiwidG91Y2giLCJpc0ZvcmNlUHJlc3MiLCJmb3JjZSIsInNob3VsZFJlc3BlY3QiLCJ1c2VUb3VjaFNlbnNvciIsIm9uVG91Y2hTdGFydCIsImxvbmdQcmVzc1RpbWVySWQiLCJ1bmJpbmRUYXJnZXQiLCJ1bmJpbmRXaW5kb3ciLCJzdGFydERyYWdnaW5nIiwid2Via2l0SGFjayIsInVzZVZhbGlkYXRlU2Vuc29ySG9va3MiLCJzZW5zb3JIb29rcyIsInByZXZpb3VzUmVmIiwiaW50ZXJhY3RpdmVUYWdOYW1lcyIsImlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJwYXJlbnQiLCJoYXNBbkludGVyYWN0aXZlVGFnIiwiaW5jbHVkZXMiLCJ0YWdOYW1lIiwicGFyZW50RWxlbWVudCIsImlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudCIsImdldEJvcmRlckJveENlbnRlclBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsInN1cHBvcnRlZE1hdGNoZXNOYW1lIiwiY2xvc2VzdFBvbnlmaWxsIiwiZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50IiwidHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50IiwiZmluZERyYWdnYWJsZSIsImlzTG9ja0FjdGl2ZSIsInNob3VsZFdhcm4iLCJjYW5TdGFydCIsImxvY2tBUEkiLCJ0cnlTdGFydCIsImZvcmNlU2Vuc29yU3RvcCIsInNob3VsZFN0YXJ0IiwiY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMiLCJnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInRyeURpc3BhdGNoIiwiZ2V0QWN0aW9uIiwidHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmciLCJsaWZ0QWN0aW9uQXJncyIsIm1vdmUkMSIsImFib3J0UHJlRHJhZyIsInNob3VsZFJlbGVhc2UiLCJkZWZhdWx0U2Vuc29ycyIsInVzZVNlbnNvck1hcnNoYWwiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsInQiLCJvbkJlZm9yZUNhcHVyZUNhbGxiYWNrIiwiY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJjb3VudCIsInJlc2V0RGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCIsInVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQkMSIsInJlc2V0U2VydmVyQ29udGV4dCIsIkRyYWdEcm9wQ29udGV4dCIsInpJbmRleE9wdGlvbnMiLCJnZXREcmFnZ2luZ1RyYW5zaXRpb24iLCJzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50IiwiZ2V0RHJhZ2dpbmdPcGFjaXR5IiwiaXNEcm9wQW5pbWF0aW5nIiwiZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlIiwiZ2V0RHJhZ2dpbmdTdHlsZSIsInRyYW5zZm9ybSIsImJveFNpemluZyIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiLCJnZXRTZWNvbmRhcnlTdHlsZSIsInNlY29uZGFyeSIsInNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQiLCJnZXRTdHlsZSQxIiwibWFwcGVkIiwiZ2V0RGltZW5zaW9uJDEiLCJjb21wdXRlZFN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ1c2VEcmFnZ2FibGVQdWJsaXNoZXIiLCJnZXREcmFnZ2FibGVSZWYiLCJwdWJsaXNoZWRSZWYiLCJpc0ZpcnN0UHVibGlzaFJlZiIsIkRyb3BwYWJsZUNvbnRleHQiLCJjaGVja0lzVmFsaWRJbm5lclJlZiIsInVzZVZhbGlkYXRpb24kMSIsImdldFJlZiIsImlzSW50ZWdlciIsInVzZUNsb25lUHJvcFZhbGlkYXRpb24iLCJpc0Nsb25lIiwiaW5pdGlhbFJlZiIsInVzZVJlcXVpcmVkQ29udGV4dCIsIkNvbnRleHQiLCJwcmV2ZW50SHRtbDVEbmQiLCJEcmFnZ2FibGUiLCJzZXRSZWYiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24iLCJmb3JQdWJsaXNoZXIiLCJkcmFnSGFuZGxlUHJvcHMiLCJ0YWJJbmRleCIsInJvbGUiLCJvbk1vdmVFbmQiLCJwcm9wZXJ0eU5hbWUiLCJvblRyYW5zaXRpb25FbmQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwicnVicmljIiwiRnJhZ21lbnQiLCJzbmFwc2hvdCIsIkRyYWdnYWJsZSQxIiwiaXNTdHJpY3RFcXVhbCIsIndoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbUltcGFjdCIsImdldERyYWdnYWJsZVNlbGVjdG9yIiwibWVtb2l6ZWRPZmZzZXQiLCJnZXRNZW1vaXplZFNuYXBzaG90IiwiZHJhZ2dpbmdPdmVyIiwiZHJvcEFuaW1hdGlvbiIsImNvbWJpbmVUYXJnZXRGb3IiLCJnZXRNZW1vaXplZFByb3BzIiwib3duUHJvcHMiLCJjdXJ2ZSIsImdldFNlY29uZGFyeVNuYXBzaG90IiwiYXRSZXN0IiwiZ2V0U2Vjb25kYXJ5U2VsZWN0b3IiLCJnZXRGYWxsYmFjayIsImdldFByb3BzIiwib3duSWQiLCJkcmFnZ2luZ0lkIiwidmlzdWFsRGlzcGxhY2VtZW50IiwiaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMkMSIsImRyYWdnaW5nU2VsZWN0b3IiLCJzZWNvbmRhcnlTZWxlY3RvciIsIm1hcERpc3BhdGNoVG9Qcm9wcyQxIiwiQ29ubmVjdGVkRHJhZ2dhYmxlIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiQ29ubmVjdGVkRHJhZ2dhYmxlJDEiLCJQcml2YXRlRHJhZ2dhYmxlIiwiZHJvcHBhYmxlQ29udGV4dCIsImlzVXNpbmdDbG9uZUZvciIsIlB1YmxpY0RyYWdnYWJsZSIsImlzRHJhZ0Rpc2FibGVkIiwiZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nIiwiaXNFcXVhbCIsImlzU2Nyb2xsIiwiaXNBdXRvIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiaXNCb2R5U2Nyb2xsYWJsZSIsImh0bWwiLCJodG1sU3R5bGUiLCJodG1sT3ZlcmZsb3ciLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZSIsImdldENsb3Nlc3RTY3JvbGxhYmxlJDEiLCJjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMiLCJhbm90aGVyU2Nyb2xsUGFyZW50IiwiZ2V0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldElzRml4ZWQiLCJnZXRFbnYiLCJjbG9zZXN0U2Nyb2xsYWJsZSIsImdldERyb3BwYWJsZURpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJmcmFtZUNsaWVudCIsInBhZGRpbmdCb3giLCJnZXRDbGllbnQiLCJ0YXJnZXRSZWYiLCJlbnYiLCJpc0Ryb3BEaXNhYmxlZCIsImltbWVkaWF0ZSIsImRlbGF5ZWQiLCJnZXRMaXN0ZW5lck9wdGlvbnMiLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnIiwidXNlRHJvcHBhYmxlUHVibGlzaGVyIiwid2hpbGVEcmFnZ2luZ1JlZiIsInB1Ymxpc2hlZERlc2NyaXB0b3JSZWYiLCJtZW1vaXplZFVwZGF0ZVNjcm9sbCIsImdldENsb3Nlc3RTY3JvbGwiLCJzY2hlZHVsZVNjcm9sbFVwZGF0ZSIsIm9uQ2xvc2VzdFNjcm9sbCIsImdldERyb3BwYWJsZVJlZiIsImlnbm9yZUNvbnRhaW5lckNsaXBwaW5nIiwicmVtb3ZlQXR0cmlidXRlIiwibm9vcCIsImVtcHR5IiwiZ2V0U2l6ZSIsImlzQW5pbWF0aW5nT3Blbk9uTW91bnQiLCJhbmltYXRlIiwiZ2V0U3R5bGUiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJmbGV4U2hyaW5rIiwiZmxleEdyb3ciLCJQbGFjZWhvbGRlciIsImFuaW1hdGVPcGVuVGltZXJSZWYiLCJ0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIiLCJvbkNsb3NlIiwic2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudCIsIm9uU2l6ZUNoYW5nZUVuZCIsIlBsYWNlaG9sZGVyJDEiLCJtZW1vIiwiaXNCb29sZWFuIiwicnVuQ2hlY2tzIiwiY2hlY2tzIiwiY2hlY2siLCJib29sZWFuIiwic3RhbmRhcmQiLCJnZXRQbGFjZWhvbGRlclJlZiIsInZpcnR1YWwiLCJoYXNDbG9uZSIsInJlbmRlckNsb25lIiwiaGFzTm9QbGFjZWhvbGRlciIsInVzZVZhbGlkYXRpb24iLCJBbmltYXRlSW5PdXQiLCJQdXJlQ29tcG9uZW50Iiwib24iLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJEcm9wcGFibGUiLCJkcm9wcGFibGVSZWYiLCJwbGFjZWhvbGRlclJlZiIsInVzZUNsb25lIiwiZ2V0Q29udGFpbmVyRm9yQ2xvbmUiLCJzZXREcm9wcGFibGVSZWYiLCJzZXRQbGFjZWhvbGRlclJlZiIsIm9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kIiwic2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyIiwiZHJvcHBhYmxlUHJvcHMiLCJnZXRDbG9uZSIsIm5vZGUiLCJkcmFnZ2FibGVQcm92aWRlZCIsImRyYWdnYWJsZVNuYXBzaG90IiwiY3JlYXRlUG9ydGFsIiwiRHJvcHBhYmxlJDEiLCJnZXRCb2R5IiwiZGVmYXVsdFByb3BzIiwiYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyIsIm1lcmdlZFByb3BzIiwiZGVmYXVsdFByb3BLZXkiLCJpc01hdGNoaW5nVHlwZSIsImdldERyYWdnYWJsZSIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMiLCJpZGxlV2l0aEFuaW1hdGlvbiIsImlzRHJhZ2dpbmdPdmVyIiwiZHJhZ2dpbmdPdmVyV2l0aCIsImRyYWdnaW5nRnJvbVRoaXNXaXRoIiwiaXNVc2luZ1BsYWNlaG9sZGVyIiwiaWRsZVdpdGhvdXRBbmltYXRpb24iLCJnZXREcmFnZ2FibGVSdWJyaWMiLCJnZXRNYXBQcm9wcyIsImlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIiLCJpc0RyYWdnaW5nT3ZlckZvckltcGFjdCIsImlzSG9tZSIsIm93blByb3BzV2l0aERlZmF1bHRQcm9wcyIsIndhc0NvbWJpbmluZyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIkNvbm5lY3RlZERyb3BwYWJsZSIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwiQ29ubmVjdGVkRHJvcHBhYmxlJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;
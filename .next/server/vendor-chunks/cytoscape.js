"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape";
exports.ids = ["vendor-chunks/cytoscape"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape/dist/cytoscape.umd.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.umd.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n/**\n * Copyright (c) 2016-2023, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ (function(global1, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n        return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n            return typeof obj;\n        } : function(obj) {\n            return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n    function _defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        Object.defineProperty(Constructor, \"prototype\", {\n            writable: false\n        });\n        return Constructor;\n    }\n    function _defineProperty$1(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n            });\n        } else {\n            obj[key] = value;\n        }\n        return obj;\n    }\n    function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n    function _iterableToArrayLimit(arr, i) {\n        var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n        if (_i == null) return;\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _s, _e;\n        try {\n            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                _arr.push(_s.value);\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally{\n            try {\n                if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n        return arr2;\n    }\n    function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var window$1 =  true ? null : 0; // eslint-disable-line no-undef\n    var navigator = window$1 ? window$1.navigator : null;\n    window$1 ? window$1.document : null;\n    var typeofstr = _typeof(\"\");\n    var typeofobj = _typeof({});\n    var typeoffn = _typeof(function() {});\n    var typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\n    var instanceStr = function instanceStr(obj) {\n        return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n    };\n    var string = function string(obj) {\n        return obj != null && _typeof(obj) == typeofstr;\n    };\n    var fn$6 = function fn(obj) {\n        return obj != null && _typeof(obj) === typeoffn;\n    };\n    var array = function array(obj) {\n        return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n    };\n    var plainObject = function plainObject(obj) {\n        return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n    };\n    var object = function object(obj) {\n        return obj != null && _typeof(obj) === typeofobj;\n    };\n    var number$1 = function number(obj) {\n        return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n    };\n    var integer = function integer(obj) {\n        return number$1(obj) && Math.floor(obj) === obj;\n    };\n    var htmlElement = function htmlElement(obj) {\n        if (\"undefined\" === typeofhtmlele) {\n            return undefined;\n        } else {\n            return null != obj && obj instanceof HTMLElement;\n        }\n    };\n    var elementOrCollection = function elementOrCollection(obj) {\n        return element(obj) || collection(obj);\n    };\n    var element = function element(obj) {\n        return instanceStr(obj) === \"collection\" && obj._private.single;\n    };\n    var collection = function collection(obj) {\n        return instanceStr(obj) === \"collection\" && !obj._private.single;\n    };\n    var core = function core(obj) {\n        return instanceStr(obj) === \"core\";\n    };\n    var stylesheet = function stylesheet(obj) {\n        return instanceStr(obj) === \"stylesheet\";\n    };\n    var event = function event(obj) {\n        return instanceStr(obj) === \"event\";\n    };\n    var emptyString = function emptyString(obj) {\n        if (obj === undefined || obj === null) {\n            // null is empty\n            return true;\n        } else if (obj === \"\" || obj.match(/^\\s+$/)) {\n            return true; // empty string is empty\n        }\n        return false; // otherwise, we don't know what we've got\n    };\n    var domElement = function domElement(obj) {\n        if (typeof HTMLElement === \"undefined\") {\n            return false; // we're not in a browser so it doesn't matter\n        } else {\n            return obj instanceof HTMLElement;\n        }\n    };\n    var boundingBox = function boundingBox(obj) {\n        return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n    };\n    var promise = function promise(obj) {\n        return object(obj) && fn$6(obj.then);\n    };\n    var ms = function ms() {\n        return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n    }; // probably a better way to detect this...\n    var memoize$1 = function memoize(fn, keyFn) {\n        if (!keyFn) {\n            keyFn = function keyFn() {\n                if (arguments.length === 1) {\n                    return arguments[0];\n                } else if (arguments.length === 0) {\n                    return \"undefined\";\n                }\n                var args = [];\n                for(var i = 0; i < arguments.length; i++){\n                    args.push(arguments[i]);\n                }\n                return args.join(\"$\");\n            };\n        }\n        var memoizedFn = function memoizedFn() {\n            var self1 = this;\n            var args = arguments;\n            var ret;\n            var k = keyFn.apply(self1, args);\n            var cache = memoizedFn.cache;\n            if (!(ret = cache[k])) {\n                ret = cache[k] = fn.apply(self1, args);\n            }\n            return ret;\n        };\n        memoizedFn.cache = {};\n        return memoizedFn;\n    };\n    var camel2dash = memoize$1(function(str) {\n        return str.replace(/([A-Z])/g, function(v) {\n            return \"-\" + v.toLowerCase();\n        });\n    });\n    var dash2camel = memoize$1(function(str) {\n        return str.replace(/(-\\w)/g, function(v) {\n            return v[1].toUpperCase();\n        });\n    });\n    var prependCamel = memoize$1(function(prefix, str) {\n        return prefix + str[0].toUpperCase() + str.substring(1);\n    }, function(prefix, str) {\n        return prefix + \"$\" + str;\n    });\n    var capitalize = function capitalize(str) {\n        if (emptyString(str)) {\n            return str;\n        }\n        return str.charAt(0).toUpperCase() + str.substring(1);\n    };\n    var number = \"(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))\";\n    var rgba = \"rgb[a]?\\\\((\" + number + \"[%]?)\\\\s*,\\\\s*(\" + number + \"[%]?)\\\\s*,\\\\s*(\" + number + \"[%]?)(?:\\\\s*,\\\\s*(\" + number + \"))?\\\\)\";\n    var rgbaNoBackRefs = \"rgb[a]?\\\\((?:\" + number + \"[%]?)\\\\s*,\\\\s*(?:\" + number + \"[%]?)\\\\s*,\\\\s*(?:\" + number + \"[%]?)(?:\\\\s*,\\\\s*(?:\" + number + \"))?\\\\)\";\n    var hsla = \"hsl[a]?\\\\((\" + number + \")\\\\s*,\\\\s*(\" + number + \"[%])\\\\s*,\\\\s*(\" + number + \"[%])(?:\\\\s*,\\\\s*(\" + number + \"))?\\\\)\";\n    var hslaNoBackRefs = \"hsl[a]?\\\\((?:\" + number + \")\\\\s*,\\\\s*(?:\" + number + \"[%])\\\\s*,\\\\s*(?:\" + number + \"[%])(?:\\\\s*,\\\\s*(?:\" + number + \"))?\\\\)\";\n    var hex3 = \"\\\\#[0-9a-fA-F]{3}\";\n    var hex6 = \"\\\\#[0-9a-fA-F]{6}\";\n    var ascending = function ascending(a, b) {\n        if (a < b) {\n            return -1;\n        } else if (a > b) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n    var descending = function descending(a, b) {\n        return -1 * ascending(a, b);\n    };\n    var extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n        var args = arguments;\n        for(var i = 1; i < args.length; i++){\n            var obj = args[i];\n            if (obj == null) {\n                continue;\n            }\n            var keys = Object.keys(obj);\n            for(var j = 0; j < keys.length; j++){\n                var k = keys[j];\n                tgt[k] = obj[k];\n            }\n        }\n        return tgt;\n    };\n    var hex2tuple = function hex2tuple(hex) {\n        if (!(hex.length === 4 || hex.length === 7) || hex[0] !== \"#\") {\n            return;\n        }\n        var shortHex = hex.length === 4;\n        var r, g, b;\n        var base = 16;\n        if (shortHex) {\n            r = parseInt(hex[1] + hex[1], base);\n            g = parseInt(hex[2] + hex[2], base);\n            b = parseInt(hex[3] + hex[3], base);\n        } else {\n            r = parseInt(hex[1] + hex[2], base);\n            g = parseInt(hex[3] + hex[4], base);\n            b = parseInt(hex[5] + hex[6], base);\n        }\n        return [\n            r,\n            g,\n            b\n        ];\n    }; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n    var hsl2tuple = function hsl2tuple(hsl) {\n        var ret;\n        var h, s, l, a, r, g, b;\n        function hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        var m1 = new RegExp(\"^\" + hsla + \"$\").exec(hsl);\n        if (m1) {\n            // get hue\n            h = parseInt(m1[1]);\n            if (h < 0) {\n                h = (360 - -1 * h % 360) % 360;\n            } else if (h > 360) {\n                h = h % 360;\n            }\n            h /= 360; // normalise on [0, 1]\n            s = parseFloat(m1[2]);\n            if (s < 0 || s > 100) {\n                return;\n            } // saturation is [0, 100]\n            s = s / 100; // normalise on [0, 1]\n            l = parseFloat(m1[3]);\n            if (l < 0 || l > 100) {\n                return;\n            } // lightness is [0, 100]\n            l = l / 100; // normalise on [0, 1]\n            a = m1[4];\n            if (a !== undefined) {\n                a = parseFloat(a);\n                if (a < 0 || a > 1) {\n                    return;\n                } // alpha is [0, 1]\n            } // now, convert to rgb\n            // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n            if (s === 0) {\n                r = g = b = Math.round(l * 255); // achromatic\n            } else {\n                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                var p = 2 * l - q;\n                r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n                g = Math.round(255 * hue2rgb(p, q, h));\n                b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n            }\n            ret = [\n                r,\n                g,\n                b,\n                a\n            ];\n        }\n        return ret;\n    }; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n    var rgb2tuple = function rgb2tuple(rgb) {\n        var ret;\n        var m1 = new RegExp(\"^\" + rgba + \"$\").exec(rgb);\n        if (m1) {\n            ret = [];\n            var isPct = [];\n            for(var i = 1; i <= 3; i++){\n                var channel = m1[i];\n                if (channel[channel.length - 1] === \"%\") {\n                    isPct[i] = true;\n                }\n                channel = parseFloat(channel);\n                if (isPct[i]) {\n                    channel = channel / 100 * 255; // normalise to [0, 255]\n                }\n                if (channel < 0 || channel > 255) {\n                    return;\n                } // invalid channel value\n                ret.push(Math.floor(channel));\n            }\n            var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n            var allArePct = isPct[1] && isPct[2] && isPct[3];\n            if (atLeastOneIsPct && !allArePct) {\n                return;\n            } // must all be percent values if one is\n            var alpha = m1[4];\n            if (alpha !== undefined) {\n                alpha = parseFloat(alpha);\n                if (alpha < 0 || alpha > 1) {\n                    return;\n                } // invalid alpha value\n                ret.push(alpha);\n            }\n        }\n        return ret;\n    };\n    var colorname2tuple = function colorname2tuple(color) {\n        return colors[color.toLowerCase()];\n    };\n    var color2tuple = function color2tuple(color) {\n        return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n    };\n    var colors = {\n        // special colour names\n        transparent: [\n            0,\n            0,\n            0,\n            0\n        ],\n        // NB alpha === 0\n        // regular colours\n        aliceblue: [\n            240,\n            248,\n            255\n        ],\n        antiquewhite: [\n            250,\n            235,\n            215\n        ],\n        aqua: [\n            0,\n            255,\n            255\n        ],\n        aquamarine: [\n            127,\n            255,\n            212\n        ],\n        azure: [\n            240,\n            255,\n            255\n        ],\n        beige: [\n            245,\n            245,\n            220\n        ],\n        bisque: [\n            255,\n            228,\n            196\n        ],\n        black: [\n            0,\n            0,\n            0\n        ],\n        blanchedalmond: [\n            255,\n            235,\n            205\n        ],\n        blue: [\n            0,\n            0,\n            255\n        ],\n        blueviolet: [\n            138,\n            43,\n            226\n        ],\n        brown: [\n            165,\n            42,\n            42\n        ],\n        burlywood: [\n            222,\n            184,\n            135\n        ],\n        cadetblue: [\n            95,\n            158,\n            160\n        ],\n        chartreuse: [\n            127,\n            255,\n            0\n        ],\n        chocolate: [\n            210,\n            105,\n            30\n        ],\n        coral: [\n            255,\n            127,\n            80\n        ],\n        cornflowerblue: [\n            100,\n            149,\n            237\n        ],\n        cornsilk: [\n            255,\n            248,\n            220\n        ],\n        crimson: [\n            220,\n            20,\n            60\n        ],\n        cyan: [\n            0,\n            255,\n            255\n        ],\n        darkblue: [\n            0,\n            0,\n            139\n        ],\n        darkcyan: [\n            0,\n            139,\n            139\n        ],\n        darkgoldenrod: [\n            184,\n            134,\n            11\n        ],\n        darkgray: [\n            169,\n            169,\n            169\n        ],\n        darkgreen: [\n            0,\n            100,\n            0\n        ],\n        darkgrey: [\n            169,\n            169,\n            169\n        ],\n        darkkhaki: [\n            189,\n            183,\n            107\n        ],\n        darkmagenta: [\n            139,\n            0,\n            139\n        ],\n        darkolivegreen: [\n            85,\n            107,\n            47\n        ],\n        darkorange: [\n            255,\n            140,\n            0\n        ],\n        darkorchid: [\n            153,\n            50,\n            204\n        ],\n        darkred: [\n            139,\n            0,\n            0\n        ],\n        darksalmon: [\n            233,\n            150,\n            122\n        ],\n        darkseagreen: [\n            143,\n            188,\n            143\n        ],\n        darkslateblue: [\n            72,\n            61,\n            139\n        ],\n        darkslategray: [\n            47,\n            79,\n            79\n        ],\n        darkslategrey: [\n            47,\n            79,\n            79\n        ],\n        darkturquoise: [\n            0,\n            206,\n            209\n        ],\n        darkviolet: [\n            148,\n            0,\n            211\n        ],\n        deeppink: [\n            255,\n            20,\n            147\n        ],\n        deepskyblue: [\n            0,\n            191,\n            255\n        ],\n        dimgray: [\n            105,\n            105,\n            105\n        ],\n        dimgrey: [\n            105,\n            105,\n            105\n        ],\n        dodgerblue: [\n            30,\n            144,\n            255\n        ],\n        firebrick: [\n            178,\n            34,\n            34\n        ],\n        floralwhite: [\n            255,\n            250,\n            240\n        ],\n        forestgreen: [\n            34,\n            139,\n            34\n        ],\n        fuchsia: [\n            255,\n            0,\n            255\n        ],\n        gainsboro: [\n            220,\n            220,\n            220\n        ],\n        ghostwhite: [\n            248,\n            248,\n            255\n        ],\n        gold: [\n            255,\n            215,\n            0\n        ],\n        goldenrod: [\n            218,\n            165,\n            32\n        ],\n        gray: [\n            128,\n            128,\n            128\n        ],\n        grey: [\n            128,\n            128,\n            128\n        ],\n        green: [\n            0,\n            128,\n            0\n        ],\n        greenyellow: [\n            173,\n            255,\n            47\n        ],\n        honeydew: [\n            240,\n            255,\n            240\n        ],\n        hotpink: [\n            255,\n            105,\n            180\n        ],\n        indianred: [\n            205,\n            92,\n            92\n        ],\n        indigo: [\n            75,\n            0,\n            130\n        ],\n        ivory: [\n            255,\n            255,\n            240\n        ],\n        khaki: [\n            240,\n            230,\n            140\n        ],\n        lavender: [\n            230,\n            230,\n            250\n        ],\n        lavenderblush: [\n            255,\n            240,\n            245\n        ],\n        lawngreen: [\n            124,\n            252,\n            0\n        ],\n        lemonchiffon: [\n            255,\n            250,\n            205\n        ],\n        lightblue: [\n            173,\n            216,\n            230\n        ],\n        lightcoral: [\n            240,\n            128,\n            128\n        ],\n        lightcyan: [\n            224,\n            255,\n            255\n        ],\n        lightgoldenrodyellow: [\n            250,\n            250,\n            210\n        ],\n        lightgray: [\n            211,\n            211,\n            211\n        ],\n        lightgreen: [\n            144,\n            238,\n            144\n        ],\n        lightgrey: [\n            211,\n            211,\n            211\n        ],\n        lightpink: [\n            255,\n            182,\n            193\n        ],\n        lightsalmon: [\n            255,\n            160,\n            122\n        ],\n        lightseagreen: [\n            32,\n            178,\n            170\n        ],\n        lightskyblue: [\n            135,\n            206,\n            250\n        ],\n        lightslategray: [\n            119,\n            136,\n            153\n        ],\n        lightslategrey: [\n            119,\n            136,\n            153\n        ],\n        lightsteelblue: [\n            176,\n            196,\n            222\n        ],\n        lightyellow: [\n            255,\n            255,\n            224\n        ],\n        lime: [\n            0,\n            255,\n            0\n        ],\n        limegreen: [\n            50,\n            205,\n            50\n        ],\n        linen: [\n            250,\n            240,\n            230\n        ],\n        magenta: [\n            255,\n            0,\n            255\n        ],\n        maroon: [\n            128,\n            0,\n            0\n        ],\n        mediumaquamarine: [\n            102,\n            205,\n            170\n        ],\n        mediumblue: [\n            0,\n            0,\n            205\n        ],\n        mediumorchid: [\n            186,\n            85,\n            211\n        ],\n        mediumpurple: [\n            147,\n            112,\n            219\n        ],\n        mediumseagreen: [\n            60,\n            179,\n            113\n        ],\n        mediumslateblue: [\n            123,\n            104,\n            238\n        ],\n        mediumspringgreen: [\n            0,\n            250,\n            154\n        ],\n        mediumturquoise: [\n            72,\n            209,\n            204\n        ],\n        mediumvioletred: [\n            199,\n            21,\n            133\n        ],\n        midnightblue: [\n            25,\n            25,\n            112\n        ],\n        mintcream: [\n            245,\n            255,\n            250\n        ],\n        mistyrose: [\n            255,\n            228,\n            225\n        ],\n        moccasin: [\n            255,\n            228,\n            181\n        ],\n        navajowhite: [\n            255,\n            222,\n            173\n        ],\n        navy: [\n            0,\n            0,\n            128\n        ],\n        oldlace: [\n            253,\n            245,\n            230\n        ],\n        olive: [\n            128,\n            128,\n            0\n        ],\n        olivedrab: [\n            107,\n            142,\n            35\n        ],\n        orange: [\n            255,\n            165,\n            0\n        ],\n        orangered: [\n            255,\n            69,\n            0\n        ],\n        orchid: [\n            218,\n            112,\n            214\n        ],\n        palegoldenrod: [\n            238,\n            232,\n            170\n        ],\n        palegreen: [\n            152,\n            251,\n            152\n        ],\n        paleturquoise: [\n            175,\n            238,\n            238\n        ],\n        palevioletred: [\n            219,\n            112,\n            147\n        ],\n        papayawhip: [\n            255,\n            239,\n            213\n        ],\n        peachpuff: [\n            255,\n            218,\n            185\n        ],\n        peru: [\n            205,\n            133,\n            63\n        ],\n        pink: [\n            255,\n            192,\n            203\n        ],\n        plum: [\n            221,\n            160,\n            221\n        ],\n        powderblue: [\n            176,\n            224,\n            230\n        ],\n        purple: [\n            128,\n            0,\n            128\n        ],\n        red: [\n            255,\n            0,\n            0\n        ],\n        rosybrown: [\n            188,\n            143,\n            143\n        ],\n        royalblue: [\n            65,\n            105,\n            225\n        ],\n        saddlebrown: [\n            139,\n            69,\n            19\n        ],\n        salmon: [\n            250,\n            128,\n            114\n        ],\n        sandybrown: [\n            244,\n            164,\n            96\n        ],\n        seagreen: [\n            46,\n            139,\n            87\n        ],\n        seashell: [\n            255,\n            245,\n            238\n        ],\n        sienna: [\n            160,\n            82,\n            45\n        ],\n        silver: [\n            192,\n            192,\n            192\n        ],\n        skyblue: [\n            135,\n            206,\n            235\n        ],\n        slateblue: [\n            106,\n            90,\n            205\n        ],\n        slategray: [\n            112,\n            128,\n            144\n        ],\n        slategrey: [\n            112,\n            128,\n            144\n        ],\n        snow: [\n            255,\n            250,\n            250\n        ],\n        springgreen: [\n            0,\n            255,\n            127\n        ],\n        steelblue: [\n            70,\n            130,\n            180\n        ],\n        tan: [\n            210,\n            180,\n            140\n        ],\n        teal: [\n            0,\n            128,\n            128\n        ],\n        thistle: [\n            216,\n            191,\n            216\n        ],\n        tomato: [\n            255,\n            99,\n            71\n        ],\n        turquoise: [\n            64,\n            224,\n            208\n        ],\n        violet: [\n            238,\n            130,\n            238\n        ],\n        wheat: [\n            245,\n            222,\n            179\n        ],\n        white: [\n            255,\n            255,\n            255\n        ],\n        whitesmoke: [\n            245,\n            245,\n            245\n        ],\n        yellow: [\n            255,\n            255,\n            0\n        ],\n        yellowgreen: [\n            154,\n            205,\n            50\n        ]\n    };\n    var setMap = function setMap(options) {\n        var obj = options.map;\n        var keys = options.keys;\n        var l = keys.length;\n        for(var i = 0; i < l; i++){\n            var key = keys[i];\n            if (plainObject(key)) {\n                throw Error(\"Tried to set map with object key\");\n            }\n            if (i < keys.length - 1) {\n                // extend the map if necessary\n                if (obj[key] == null) {\n                    obj[key] = {};\n                }\n                obj = obj[key];\n            } else {\n                // set the value\n                obj[key] = options.value;\n            }\n        }\n    }; // gets the value in a map even if it's not built in places\n    var getMap = function getMap(options) {\n        var obj = options.map;\n        var keys = options.keys;\n        var l = keys.length;\n        for(var i = 0; i < l; i++){\n            var key = keys[i];\n            if (plainObject(key)) {\n                throw Error(\"Tried to get map with object key\");\n            }\n            obj = obj[key];\n            if (obj == null) {\n                return obj;\n            }\n        }\n        return obj;\n    }; // deletes the entry in the map\n    /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */ function isObject(value) {\n        var type = typeof value;\n        return value != null && (type == \"object\" || type == \"function\");\n    }\n    var isObject_1 = isObject;\n    var commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\n    function createCommonjsModule(fn, module1) {\n        return module1 = {\n            exports: {}\n        }, fn(module1, module1.exports), module1.exports;\n    }\n    /** Detect free variable `global` from Node.js. */ var freeGlobal = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    var _freeGlobal = freeGlobal;\n    /** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */ var root = _freeGlobal || freeSelf || Function(\"return this\")();\n    var _root = root;\n    /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */ var now = function() {\n        return _root.Date.now();\n    };\n    var now_1 = now;\n    /** Used to match a single whitespace character. */ var reWhitespace = /\\s/;\n    /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */ function trimmedEndIndex(string) {\n        var index = string.length;\n        while(index-- && reWhitespace.test(string.charAt(index))){}\n        return index;\n    }\n    var _trimmedEndIndex = trimmedEndIndex;\n    /** Used to match leading whitespace. */ var reTrimStart = /^\\s+/;\n    /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */ function baseTrim(string) {\n        return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n    }\n    var _baseTrim = baseTrim;\n    /** Built-in value references. */ var Symbol$1 = _root.Symbol;\n    var _Symbol = Symbol$1;\n    /** Used for built-in method references. */ var objectProto$5 = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n    /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */ var nativeObjectToString$1 = objectProto$5.toString;\n    /** Built-in value references. */ var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n    /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */ function getRawTag(value) {\n        var isOwn = hasOwnProperty$4.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n        try {\n            value[symToStringTag$1] = undefined;\n            var unmasked = true;\n        } catch (e) {}\n        var result = nativeObjectToString$1.call(value);\n        if (unmasked) {\n            if (isOwn) {\n                value[symToStringTag$1] = tag;\n            } else {\n                delete value[symToStringTag$1];\n            }\n        }\n        return result;\n    }\n    var _getRawTag = getRawTag;\n    /** Used for built-in method references. */ var objectProto$4 = Object.prototype;\n    /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */ var nativeObjectToString = objectProto$4.toString;\n    /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */ function objectToString(value) {\n        return nativeObjectToString.call(value);\n    }\n    var _objectToString = objectToString;\n    /** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n    /** Built-in value references. */ var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n    /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */ function baseGetTag(value) {\n        if (value == null) {\n            return value === undefined ? undefinedTag : nullTag;\n        }\n        return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);\n    }\n    var _baseGetTag = baseGetTag;\n    /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */ function isObjectLike(value) {\n        return value != null && typeof value == \"object\";\n    }\n    var isObjectLike_1 = isObjectLike;\n    /** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n    /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */ function isSymbol(value) {\n        return typeof value == \"symbol\" || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;\n    }\n    var isSymbol_1 = isSymbol;\n    /** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n    /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n    /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n    /** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n    /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */ function toNumber(value) {\n        if (typeof value == \"number\") {\n            return value;\n        }\n        if (isSymbol_1(value)) {\n            return NAN;\n        }\n        if (isObject_1(value)) {\n            var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n            value = isObject_1(other) ? other + \"\" : other;\n        }\n        if (typeof value != \"string\") {\n            return value === 0 ? value : +value;\n        }\n        value = _baseTrim(value);\n        var isBinary = reIsBinary.test(value);\n        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    var toNumber_1 = toNumber;\n    /** Error message constants. */ var FUNC_ERROR_TEXT$1 = \"Expected a function\";\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n    /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */ function debounce(func, wait, options) {\n        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n        if (typeof func != \"function\") {\n            throw new TypeError(FUNC_ERROR_TEXT$1);\n        }\n        wait = toNumber_1(wait) || 0;\n        if (isObject_1(options)) {\n            leading = !!options.leading;\n            maxing = \"maxWait\" in options;\n            maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n            trailing = \"trailing\" in options ? !!options.trailing : trailing;\n        }\n        function invokeFunc(time) {\n            var args = lastArgs, thisArg = lastThis;\n            lastArgs = lastThis = undefined;\n            lastInvokeTime = time;\n            result = func.apply(thisArg, args);\n            return result;\n        }\n        function leadingEdge(time) {\n            // Reset any `maxWait` timer.\n            lastInvokeTime = time;\n            // Start the timer for the trailing edge.\n            timerId = setTimeout(timerExpired, wait);\n            // Invoke the leading edge.\n            return leading ? invokeFunc(time) : result;\n        }\n        function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n        }\n        function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n            // Either this is the first call, activity has stopped and we're at the\n            // trailing edge, the system time has gone backwards and we're treating\n            // it as the trailing edge, or we've hit the `maxWait` limit.\n            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n        function timerExpired() {\n            var time = now_1();\n            if (shouldInvoke(time)) {\n                return trailingEdge(time);\n            }\n            // Restart the timer.\n            timerId = setTimeout(timerExpired, remainingWait(time));\n        }\n        function trailingEdge(time) {\n            timerId = undefined;\n            // Only invoke if we have `lastArgs` which means `func` has been\n            // debounced at least once.\n            if (trailing && lastArgs) {\n                return invokeFunc(time);\n            }\n            lastArgs = lastThis = undefined;\n            return result;\n        }\n        function cancel() {\n            if (timerId !== undefined) {\n                clearTimeout(timerId);\n            }\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined;\n        }\n        function flush() {\n            return timerId === undefined ? result : trailingEdge(now_1());\n        }\n        function debounced() {\n            var time = now_1(), isInvoking = shouldInvoke(time);\n            lastArgs = arguments;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n                if (timerId === undefined) {\n                    return leadingEdge(lastCallTime);\n                }\n                if (maxing) {\n                    // Handle invocations in a tight loop.\n                    clearTimeout(timerId);\n                    timerId = setTimeout(timerExpired, wait);\n                    return invokeFunc(lastCallTime);\n                }\n            }\n            if (timerId === undefined) {\n                timerId = setTimeout(timerExpired, wait);\n            }\n            return result;\n        }\n        debounced.cancel = cancel;\n        debounced.flush = flush;\n        return debounced;\n    }\n    var debounce_1 = debounce;\n    var performance = window$1 ? window$1.performance : null;\n    var pnow = performance && performance.now ? function() {\n        return performance.now();\n    } : function() {\n        return Date.now();\n    };\n    var raf = function() {\n        if (window$1) {\n            if (window$1.requestAnimationFrame) {\n                return function(fn) {\n                    window$1.requestAnimationFrame(fn);\n                };\n            } else if (window$1.mozRequestAnimationFrame) {\n                return function(fn) {\n                    window$1.mozRequestAnimationFrame(fn);\n                };\n            } else if (window$1.webkitRequestAnimationFrame) {\n                return function(fn) {\n                    window$1.webkitRequestAnimationFrame(fn);\n                };\n            } else if (window$1.msRequestAnimationFrame) {\n                return function(fn) {\n                    window$1.msRequestAnimationFrame(fn);\n                };\n            }\n        }\n        return function(fn) {\n            if (fn) {\n                setTimeout(function() {\n                    fn(pnow());\n                }, 1000 / 60);\n            }\n        };\n    }();\n    var requestAnimationFrame = function requestAnimationFrame(fn) {\n        return raf(fn);\n    };\n    var performanceNow = pnow;\n    var DEFAULT_HASH_SEED = 9261;\n    var K = 65599; // 37 also works pretty well\n    var DEFAULT_HASH_SEED_ALT = 5381;\n    var hashIterableInts = function hashIterableInts(iterator) {\n        var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n        // sdbm/string-hash\n        var hash = seed;\n        var entry;\n        for(;;){\n            entry = iterator.next();\n            if (entry.done) {\n                break;\n            }\n            hash = hash * K + entry.value | 0;\n        }\n        return hash;\n    };\n    var hashInt = function hashInt(num) {\n        var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n        // sdbm/string-hash\n        return seed * K + num | 0;\n    };\n    var hashIntAlt = function hashIntAlt(num) {\n        var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n        // djb2/string-hash\n        return (seed << 5) + seed + num | 0;\n    };\n    var combineHashes = function combineHashes(hash1, hash2) {\n        return hash1 * 0x200000 + hash2;\n    };\n    var combineHashesArray = function combineHashesArray(hashes) {\n        return hashes[0] * 0x200000 + hashes[1];\n    };\n    var hashArrays = function hashArrays(hashes1, hashes2) {\n        return [\n            hashInt(hashes1[0], hashes2[0]),\n            hashIntAlt(hashes1[1], hashes2[1])\n        ];\n    };\n    var hashIntsArray = function hashIntsArray(ints, seed) {\n        var entry = {\n            value: 0,\n            done: false\n        };\n        var i = 0;\n        var length = ints.length;\n        var iterator = {\n            next: function next() {\n                if (i < length) {\n                    entry.value = ints[i++];\n                } else {\n                    entry.done = true;\n                }\n                return entry;\n            }\n        };\n        return hashIterableInts(iterator, seed);\n    };\n    var hashString = function hashString(str, seed) {\n        var entry = {\n            value: 0,\n            done: false\n        };\n        var i = 0;\n        var length = str.length;\n        var iterator = {\n            next: function next() {\n                if (i < length) {\n                    entry.value = str.charCodeAt(i++);\n                } else {\n                    entry.done = true;\n                }\n                return entry;\n            }\n        };\n        return hashIterableInts(iterator, seed);\n    };\n    var hashStrings = function hashStrings() {\n        return hashStringsArray(arguments);\n    };\n    var hashStringsArray = function hashStringsArray(strs) {\n        var hash;\n        for(var i = 0; i < strs.length; i++){\n            var str = strs[i];\n            if (i === 0) {\n                hash = hashString(str);\n            } else {\n                hash = hashString(str, hash);\n            }\n        }\n        return hash;\n    };\n    /*global console */ var warningsEnabled = true;\n    var warnSupported = console.warn != null; // eslint-disable-line no-console\n    var traceSupported = console.trace != null; // eslint-disable-line no-console\n    var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    var trueify = function trueify() {\n        return true;\n    };\n    var falsify = function falsify() {\n        return false;\n    };\n    var zeroify = function zeroify() {\n        return 0;\n    };\n    var noop$1 = function noop() {};\n    var error = function error(msg) {\n        throw new Error(msg);\n    };\n    var warnings = function warnings(enabled) {\n        if (enabled !== undefined) {\n            warningsEnabled = !!enabled;\n        } else {\n            return warningsEnabled;\n        }\n    };\n    var warn = function warn(msg) {\n        /* eslint-disable no-console */ if (!warnings()) {\n            return;\n        }\n        if (warnSupported) {\n            console.warn(msg);\n        } else {\n            console.log(msg);\n            if (traceSupported) {\n                console.trace();\n            }\n        }\n    };\n    /* eslint-enable */ var clone = function clone(obj) {\n        return extend({}, obj);\n    }; // gets a shallow copy of the argument\n    var copy = function copy(obj) {\n        if (obj == null) {\n            return obj;\n        }\n        if (array(obj)) {\n            return obj.slice();\n        } else if (plainObject(obj)) {\n            return clone(obj);\n        } else {\n            return obj;\n        }\n    };\n    var copyArray$1 = function copyArray(arr) {\n        return arr.slice();\n    };\n    var uuid = function uuid(a, b) {\n        for(b = a = \"\"; a++ < 36; b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n         ? (a ^ 15 // if \"a\" is not 15\n         ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4 // unless \"a\" is 20, in which case a random number from 8 to 11\n        ) : 4 //  otherwise 4\n        ).toString(16) : \"-\" //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n        ){}\n        return b;\n    };\n    var _staticEmptyObject = {};\n    var staticEmptyObject = function staticEmptyObject() {\n        return _staticEmptyObject;\n    };\n    var defaults$g = function defaults(_defaults) {\n        var keys = Object.keys(_defaults);\n        return function(opts) {\n            var filledOpts = {};\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                var optVal = opts == null ? undefined : opts[key];\n                filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n            }\n            return filledOpts;\n        };\n    };\n    var removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n        for(var i = arr.length - 1; i >= 0; i--){\n            if (arr[i] === ele) {\n                arr.splice(i, 1);\n                if (oneCopy) {\n                    break;\n                }\n            }\n        }\n    };\n    var clearArray = function clearArray(arr) {\n        arr.splice(0, arr.length);\n    };\n    var push = function push(arr, otherArr) {\n        for(var i = 0; i < otherArr.length; i++){\n            var el = otherArr[i];\n            arr.push(el);\n        }\n    };\n    var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n        if (prefix) {\n            propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n        }\n        return obj[propName];\n    };\n    var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n        if (prefix) {\n            propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n        }\n        obj[propName] = value;\n    };\n    /* global Map */ var ObjectMap = /*#__PURE__*/ function() {\n        function ObjectMap() {\n            _classCallCheck(this, ObjectMap);\n            this._obj = {};\n        }\n        _createClass(ObjectMap, [\n            {\n                key: \"set\",\n                value: function set(key, val) {\n                    this._obj[key] = val;\n                    return this;\n                }\n            },\n            {\n                key: \"delete\",\n                value: function _delete(key) {\n                    this._obj[key] = undefined;\n                    return this;\n                }\n            },\n            {\n                key: \"clear\",\n                value: function clear() {\n                    this._obj = {};\n                }\n            },\n            {\n                key: \"has\",\n                value: function has(key) {\n                    return this._obj[key] !== undefined;\n                }\n            },\n            {\n                key: \"get\",\n                value: function get(key) {\n                    return this._obj[key];\n                }\n            }\n        ]);\n        return ObjectMap;\n    }();\n    var Map$2 = typeof Map !== \"undefined\" ? Map : ObjectMap;\n    /* global Set */ var undef = \"undefined\";\n    var ObjectSet = /*#__PURE__*/ function() {\n        function ObjectSet(arrayOrObjectSet) {\n            _classCallCheck(this, ObjectSet);\n            this._obj = Object.create(null);\n            this.size = 0;\n            if (arrayOrObjectSet != null) {\n                var arr;\n                if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n                    arr = arrayOrObjectSet.toArray();\n                } else {\n                    arr = arrayOrObjectSet;\n                }\n                for(var i = 0; i < arr.length; i++){\n                    this.add(arr[i]);\n                }\n            }\n        }\n        _createClass(ObjectSet, [\n            {\n                key: \"instanceString\",\n                value: function instanceString() {\n                    return \"set\";\n                }\n            },\n            {\n                key: \"add\",\n                value: function add(val) {\n                    var o = this._obj;\n                    if (o[val] !== 1) {\n                        o[val] = 1;\n                        this.size++;\n                    }\n                }\n            },\n            {\n                key: \"delete\",\n                value: function _delete(val) {\n                    var o = this._obj;\n                    if (o[val] === 1) {\n                        o[val] = 0;\n                        this.size--;\n                    }\n                }\n            },\n            {\n                key: \"clear\",\n                value: function clear() {\n                    this._obj = Object.create(null);\n                }\n            },\n            {\n                key: \"has\",\n                value: function has(val) {\n                    return this._obj[val] === 1;\n                }\n            },\n            {\n                key: \"toArray\",\n                value: function toArray() {\n                    var _this = this;\n                    return Object.keys(this._obj).filter(function(key) {\n                        return _this.has(key);\n                    });\n                }\n            },\n            {\n                key: \"forEach\",\n                value: function forEach(callback, thisArg) {\n                    return this.toArray().forEach(callback, thisArg);\n                }\n            }\n        ]);\n        return ObjectSet;\n    }();\n    var Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n    var Element = function Element(cy, params) {\n        var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        if (cy === undefined || params === undefined || !core(cy)) {\n            error(\"An element must have a core reference and parameters set\");\n            return;\n        }\n        var group = params.group; // try to automatically infer the group if unspecified\n        if (group == null) {\n            if (params.data && params.data.source != null && params.data.target != null) {\n                group = \"edges\";\n            } else {\n                group = \"nodes\";\n            }\n        } // validate group\n        if (group !== \"nodes\" && group !== \"edges\") {\n            error(\"An element must be of type `nodes` or `edges`; you specified `\" + group + \"`\");\n            return;\n        } // make the element array-like, just like a collection\n        this.length = 1;\n        this[0] = this; // NOTE: when something is added here, add also to ele.json()\n        var _p = this._private = {\n            cy: cy,\n            single: true,\n            // indicates this is an element\n            data: params.data || {},\n            // data object\n            position: params.position || {\n                x: 0,\n                y: 0\n            },\n            // (x, y) position pair\n            autoWidth: undefined,\n            // width and height of nodes calculated by the renderer when set to special 'auto' value\n            autoHeight: undefined,\n            autoPadding: undefined,\n            compoundBoundsClean: false,\n            // whether the compound dimensions need to be recalculated the next time dimensions are read\n            listeners: [],\n            // array of bound listeners\n            group: group,\n            // string; 'nodes' or 'edges'\n            style: {},\n            // properties as set by the style\n            rstyle: {},\n            // properties for style sent from the renderer to the core\n            styleCxts: [],\n            // applied style contexts from the styler\n            styleKeys: {},\n            // per-group keys of style property values\n            removed: true,\n            // whether it's inside the vis; true if removed (set true here since we call restore)\n            selected: params.selected ? true : false,\n            // whether it's selected\n            selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n            // whether it's selectable\n            locked: params.locked ? true : false,\n            // whether the element is locked (cannot be moved)\n            grabbed: false,\n            // whether the element is grabbed by the mouse; renderer sets this privately\n            grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n            // whether the element can be grabbed\n            pannable: params.pannable === undefined ? group === \"edges\" ? true : false : params.pannable ? true : false,\n            // whether the element has passthrough panning enabled\n            active: false,\n            // whether the element is active from user interaction\n            classes: new Set$1(),\n            // map ( className => true )\n            animation: {\n                // object for currently-running animations\n                current: [],\n                queue: []\n            },\n            rscratch: {},\n            // object in which the renderer can store information\n            scratch: params.scratch || {},\n            // scratch objects\n            edges: [],\n            // array of connected edges\n            children: [],\n            // array of children\n            parent: params.parent && params.parent.isNode() ? params.parent : null,\n            // parent ref\n            traversalCache: {},\n            // cache of output of traversal functions\n            backgrounding: false,\n            // whether background images are loading\n            bbCache: null,\n            // cache of the current bounding box\n            bbCacheShift: {\n                x: 0,\n                y: 0\n            },\n            // shift applied to cached bb to be applied on next get\n            bodyBounds: null,\n            // bounds cache of element body, w/o overlay\n            overlayBounds: null,\n            // bounds cache of element body, including overlay\n            labelBounds: {\n                // bounds cache of labels\n                all: null,\n                source: null,\n                target: null,\n                main: null\n            },\n            arrowBounds: {\n                // bounds cache of edge arrows\n                source: null,\n                target: null,\n                \"mid-source\": null,\n                \"mid-target\": null\n            }\n        };\n        if (_p.position.x == null) {\n            _p.position.x = 0;\n        }\n        if (_p.position.y == null) {\n            _p.position.y = 0;\n        } // renderedPosition overrides if specified\n        if (params.renderedPosition) {\n            var rpos = params.renderedPosition;\n            var pan = cy.pan();\n            var zoom = cy.zoom();\n            _p.position = {\n                x: (rpos.x - pan.x) / zoom,\n                y: (rpos.y - pan.y) / zoom\n            };\n        }\n        var classes = [];\n        if (array(params.classes)) {\n            classes = params.classes;\n        } else if (string(params.classes)) {\n            classes = params.classes.split(/\\s+/);\n        }\n        for(var i = 0, l = classes.length; i < l; i++){\n            var cls = classes[i];\n            if (!cls || cls === \"\") {\n                continue;\n            }\n            _p.classes.add(cls);\n        }\n        this.createEmitter();\n        var bypass = params.style || params.css;\n        if (bypass) {\n            warn(\"Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.\");\n            this.style(bypass);\n        }\n        if (restore === undefined || restore) {\n            this.restore();\n        }\n    };\n    var defineSearch = function defineSearch(params) {\n        params = {\n            bfs: params.bfs || !params.dfs,\n            dfs: params.dfs || !params.bfs\n        }; // from pseudocode on wikipedia\n        return function searchFn(roots, fn, directed) {\n            var options;\n            if (plainObject(roots) && !elementOrCollection(roots)) {\n                options = roots;\n                roots = options.roots || options.root;\n                fn = options.visit;\n                directed = options.directed;\n            }\n            directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n            fn = fn$6(fn) ? fn : function() {};\n            var cy = this._private.cy;\n            var v = roots = string(roots) ? this.filter(roots) : roots;\n            var Q = [];\n            var connectedNodes = [];\n            var connectedBy = {};\n            var id2depth = {};\n            var V = {};\n            var j = 0;\n            var found;\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges; // enqueue v\n            for(var i = 0; i < v.length; i++){\n                var vi = v[i];\n                var viId = vi.id();\n                if (vi.isNode()) {\n                    Q.unshift(vi);\n                    if (params.bfs) {\n                        V[viId] = true;\n                        connectedNodes.push(vi);\n                    }\n                    id2depth[viId] = 0;\n                }\n            }\n            var _loop = function _loop() {\n                var v = params.bfs ? Q.shift() : Q.pop();\n                var vId = v.id();\n                if (params.dfs) {\n                    if (V[vId]) {\n                        return \"continue\";\n                    }\n                    V[vId] = true;\n                    connectedNodes.push(v);\n                }\n                var depth = id2depth[vId];\n                var prevEdge = connectedBy[vId];\n                var src = prevEdge != null ? prevEdge.source() : null;\n                var tgt = prevEdge != null ? prevEdge.target() : null;\n                var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n                var ret = void 0;\n                ret = fn(v, prevEdge, prevNode, j++, depth);\n                if (ret === true) {\n                    found = v;\n                    return \"break\";\n                }\n                if (ret === false) {\n                    return \"break\";\n                }\n                var vwEdges = v.connectedEdges().filter(function(e) {\n                    return (!directed || e.source().same(v)) && edges.has(e);\n                });\n                for(var _i2 = 0; _i2 < vwEdges.length; _i2++){\n                    var e = vwEdges[_i2];\n                    var w = e.connectedNodes().filter(function(n) {\n                        return !n.same(v) && nodes.has(n);\n                    });\n                    var wId = w.id();\n                    if (w.length !== 0 && !V[wId]) {\n                        w = w[0];\n                        Q.push(w);\n                        if (params.bfs) {\n                            V[wId] = true;\n                            connectedNodes.push(w);\n                        }\n                        connectedBy[wId] = e;\n                        id2depth[wId] = id2depth[vId] + 1;\n                    }\n                }\n            };\n            while(Q.length !== 0){\n                var _ret = _loop();\n                if (_ret === \"continue\") continue;\n                if (_ret === \"break\") break;\n            }\n            var connectedEles = cy.collection();\n            for(var _i = 0; _i < connectedNodes.length; _i++){\n                var node = connectedNodes[_i];\n                var edge = connectedBy[node.id()];\n                if (edge != null) {\n                    connectedEles.push(edge);\n                }\n                connectedEles.push(node);\n            }\n            return {\n                path: cy.collection(connectedEles),\n                found: cy.collection(found)\n            };\n        };\n    }; // search, spanning trees, etc\n    var elesfn$v = {\n        breadthFirstSearch: defineSearch({\n            bfs: true\n        }),\n        depthFirstSearch: defineSearch({\n            dfs: true\n        })\n    }; // nice, short mathematical alias\n    elesfn$v.bfs = elesfn$v.breadthFirstSearch;\n    elesfn$v.dfs = elesfn$v.depthFirstSearch;\n    var heap$1 = createCommonjsModule(function(module1, exports1) {\n        // Generated by CoffeeScript 1.8.0\n        (function() {\n            var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n            floor = Math.floor, min = Math.min;\n            /*\n    Default comparison function to be used\n     */ defaultCmp = function(x, y) {\n                if (x < y) {\n                    return -1;\n                }\n                if (x > y) {\n                    return 1;\n                }\n                return 0;\n            };\n            /*\n    Insert item x in list a, and keep it sorted assuming a is sorted.\n    \n    If x is already in a, insert it to the right of the rightmost x.\n    \n    Optional args lo (default 0) and hi (default a.length) bound the slice\n    of a to be searched.\n     */ insort = function(a, x, lo, hi, cmp) {\n                var mid;\n                if (lo == null) {\n                    lo = 0;\n                }\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (lo < 0) {\n                    throw new Error(\"lo must be non-negative\");\n                }\n                if (hi == null) {\n                    hi = a.length;\n                }\n                while(lo < hi){\n                    mid = floor((lo + hi) / 2);\n                    if (cmp(x, a[mid]) < 0) {\n                        hi = mid;\n                    } else {\n                        lo = mid + 1;\n                    }\n                }\n                return [].splice.apply(a, [\n                    lo,\n                    lo - lo\n                ].concat(x)), x;\n            };\n            /*\n    Push item onto heap, maintaining the heap invariant.\n     */ heappush = function(array, item, cmp) {\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                array.push(item);\n                return _siftdown(array, 0, array.length - 1, cmp);\n            };\n            /*\n    Pop the smallest item off the heap, maintaining the heap invariant.\n     */ heappop = function(array, cmp) {\n                var lastelt, returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                lastelt = array.pop();\n                if (array.length) {\n                    returnitem = array[0];\n                    array[0] = lastelt;\n                    _siftup(array, 0, cmp);\n                } else {\n                    returnitem = lastelt;\n                }\n                return returnitem;\n            };\n            /*\n    Pop and return the current smallest value, and add the new item.\n    \n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed size heap. Note that the value\n    returned may be larger than item! That constrains reasonable use of\n    this routine unless written as part of a conditional replacement:\n        if item > array[0]\n          item = heapreplace(array, item)\n     */ heapreplace = function(array, item, cmp) {\n                var returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                returnitem = array[0];\n                array[0] = item;\n                _siftup(array, 0, cmp);\n                return returnitem;\n            };\n            /*\n    Fast version of a heappush followed by a heappop.\n     */ heappushpop = function(array, item, cmp) {\n                var _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (array.length && cmp(array[0], item) < 0) {\n                    _ref = [\n                        array[0],\n                        item\n                    ], item = _ref[0], array[0] = _ref[1];\n                    _siftup(array, 0, cmp);\n                }\n                return item;\n            };\n            /*\n    Transform list into a heap, in-place, in O(array.length) time.\n     */ heapify = function(array, cmp) {\n                var i, _i, _len, _ref1, _results, _results1;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                _ref1 = (function() {\n                    _results1 = [];\n                    for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){\n                        _results1.push(_j);\n                    }\n                    return _results1;\n                }).apply(this).reverse();\n                _results = [];\n                for(_i = 0, _len = _ref1.length; _i < _len; _i++){\n                    i = _ref1[_i];\n                    _results.push(_siftup(array, i, cmp));\n                }\n                return _results;\n            };\n            /*\n    Update the position of the given item in the heap.\n    This function should be called every time the item is being modified.\n     */ updateItem = function(array, item, cmp) {\n                var pos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                pos = array.indexOf(item);\n                if (pos === -1) {\n                    return;\n                }\n                _siftdown(array, 0, pos, cmp);\n                return _siftup(array, pos, cmp);\n            };\n            /*\n    Find the n largest elements in a dataset.\n     */ nlargest = function(array, n, cmp) {\n                var elem, result, _i, _len, _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                result = array.slice(0, n);\n                if (!result.length) {\n                    return result;\n                }\n                heapify(result, cmp);\n                _ref = array.slice(n);\n                for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                    elem = _ref[_i];\n                    heappushpop(result, elem, cmp);\n                }\n                return result.sort(cmp).reverse();\n            };\n            /*\n    Find the n smallest elements in a dataset.\n     */ nsmallest = function(array, n, cmp) {\n                var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (n * 10 <= array.length) {\n                    result = array.slice(0, n).sort(cmp);\n                    if (!result.length) {\n                        return result;\n                    }\n                    los = result[result.length - 1];\n                    _ref = array.slice(n);\n                    for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                        elem = _ref[_i];\n                        if (cmp(elem, los) < 0) {\n                            insort(result, elem, 0, null, cmp);\n                            result.pop();\n                            los = result[result.length - 1];\n                        }\n                    }\n                    return result;\n                }\n                heapify(array, cmp);\n                _results = [];\n                for(_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j){\n                    _results.push(heappop(array, cmp));\n                }\n                return _results;\n            };\n            _siftdown = function(array, startpos, pos, cmp) {\n                var newitem, parent, parentpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                newitem = array[pos];\n                while(pos > startpos){\n                    parentpos = pos - 1 >> 1;\n                    parent = array[parentpos];\n                    if (cmp(newitem, parent) < 0) {\n                        array[pos] = parent;\n                        pos = parentpos;\n                        continue;\n                    }\n                    break;\n                }\n                return array[pos] = newitem;\n            };\n            _siftup = function(array, pos, cmp) {\n                var childpos, endpos, newitem, rightpos, startpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                endpos = array.length;\n                startpos = pos;\n                newitem = array[pos];\n                childpos = 2 * pos + 1;\n                while(childpos < endpos){\n                    rightpos = childpos + 1;\n                    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n                        childpos = rightpos;\n                    }\n                    array[pos] = array[childpos];\n                    pos = childpos;\n                    childpos = 2 * pos + 1;\n                }\n                array[pos] = newitem;\n                return _siftdown(array, startpos, pos, cmp);\n            };\n            Heap = function() {\n                Heap.push = heappush;\n                Heap.pop = heappop;\n                Heap.replace = heapreplace;\n                Heap.pushpop = heappushpop;\n                Heap.heapify = heapify;\n                Heap.updateItem = updateItem;\n                Heap.nlargest = nlargest;\n                Heap.nsmallest = nsmallest;\n                function Heap(cmp) {\n                    this.cmp = cmp != null ? cmp : defaultCmp;\n                    this.nodes = [];\n                }\n                Heap.prototype.push = function(x) {\n                    return heappush(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pop = function() {\n                    return heappop(this.nodes, this.cmp);\n                };\n                Heap.prototype.peek = function() {\n                    return this.nodes[0];\n                };\n                Heap.prototype.contains = function(x) {\n                    return this.nodes.indexOf(x) !== -1;\n                };\n                Heap.prototype.replace = function(x) {\n                    return heapreplace(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pushpop = function(x) {\n                    return heappushpop(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.heapify = function() {\n                    return heapify(this.nodes, this.cmp);\n                };\n                Heap.prototype.updateItem = function(x) {\n                    return updateItem(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.clear = function() {\n                    return this.nodes = [];\n                };\n                Heap.prototype.empty = function() {\n                    return this.nodes.length === 0;\n                };\n                Heap.prototype.size = function() {\n                    return this.nodes.length;\n                };\n                Heap.prototype.clone = function() {\n                    var heap;\n                    heap = new Heap();\n                    heap.nodes = this.nodes.slice(0);\n                    return heap;\n                };\n                Heap.prototype.toArray = function() {\n                    return this.nodes.slice(0);\n                };\n                Heap.prototype.insert = Heap.prototype.push;\n                Heap.prototype.top = Heap.prototype.peek;\n                Heap.prototype.front = Heap.prototype.peek;\n                Heap.prototype.has = Heap.prototype.contains;\n                Heap.prototype.copy = Heap.prototype.clone;\n                return Heap;\n            }();\n            (function(root, factory) {\n                {\n                    return module1.exports = factory();\n                }\n            })(this, function() {\n                return Heap;\n            });\n        }).call(commonjsGlobal);\n    });\n    var heap = heap$1;\n    var dijkstraDefaults = defaults$g({\n        root: null,\n        weight: function weight(edge) {\n            return 1;\n        },\n        directed: false\n    });\n    var elesfn$u = {\n        dijkstra: function dijkstra(options) {\n            if (!plainObject(options)) {\n                var args = arguments;\n                options = {\n                    root: args[0],\n                    weight: args[1],\n                    directed: args[2]\n                };\n            }\n            var _dijkstraDefaults = dijkstraDefaults(options), root = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;\n            var eles = this;\n            var weightFn = weight;\n            var source = string(root) ? this.filter(root)[0] : root[0];\n            var dist = {};\n            var prev = {};\n            var knownDist = {};\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n            edges.unmergeBy(function(ele) {\n                return ele.isLoop();\n            });\n            var getDist = function getDist(node) {\n                return dist[node.id()];\n            };\n            var setDist = function setDist(node, d) {\n                dist[node.id()] = d;\n                Q.updateItem(node);\n            };\n            var Q = new heap(function(a, b) {\n                return getDist(a) - getDist(b);\n            });\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                dist[node.id()] = node.same(source) ? 0 : Infinity;\n                Q.push(node);\n            }\n            var distBetween = function distBetween(u, v) {\n                var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n                var smallestDistance = Infinity;\n                var smallestEdge;\n                for(var _i = 0; _i < uvs.length; _i++){\n                    var edge = uvs[_i];\n                    var _weight = weightFn(edge);\n                    if (_weight < smallestDistance || !smallestEdge) {\n                        smallestDistance = _weight;\n                        smallestEdge = edge;\n                    }\n                }\n                return {\n                    edge: smallestEdge,\n                    dist: smallestDistance\n                };\n            };\n            while(Q.size() > 0){\n                var u = Q.pop();\n                var smalletsDist = getDist(u);\n                var uid = u.id();\n                knownDist[uid] = smalletsDist;\n                if (smalletsDist === Infinity) {\n                    continue;\n                }\n                var neighbors = u.neighborhood().intersect(nodes);\n                for(var _i2 = 0; _i2 < neighbors.length; _i2++){\n                    var v = neighbors[_i2];\n                    var vid = v.id();\n                    var vDist = distBetween(u, v);\n                    var alt = smalletsDist + vDist.dist;\n                    if (alt < getDist(v)) {\n                        setDist(v, alt);\n                        prev[vid] = {\n                            node: u,\n                            edge: vDist.edge\n                        };\n                    }\n                } // for\n            } // while\n            return {\n                distanceTo: function distanceTo(node) {\n                    var target = string(node) ? nodes.filter(node)[0] : node[0];\n                    return knownDist[target.id()];\n                },\n                pathTo: function pathTo(node) {\n                    var target = string(node) ? nodes.filter(node)[0] : node[0];\n                    var S = [];\n                    var u = target;\n                    var uid = u.id();\n                    if (target.length > 0) {\n                        S.unshift(target);\n                        while(prev[uid]){\n                            var p = prev[uid];\n                            S.unshift(p.edge);\n                            S.unshift(p.node);\n                            u = p.node;\n                            uid = u.id();\n                        }\n                    }\n                    return eles.spawn(S);\n                }\n            };\n        }\n    };\n    var elesfn$t = {\n        // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n        // implemented from pseudocode from wikipedia\n        kruskal: function kruskal(weightFn) {\n            weightFn = weightFn || function(edge) {\n                return 1;\n            };\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n            var numNodes = nodes.length;\n            var forest = new Array(numNodes);\n            var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n            var findSetIndex = function findSetIndex(ele) {\n                for(var i = 0; i < forest.length; i++){\n                    var eles = forest[i];\n                    if (eles.has(ele)) {\n                        return i;\n                    }\n                }\n            }; // start with one forest per node\n            for(var i = 0; i < numNodes; i++){\n                forest[i] = this.spawn(nodes[i]);\n            }\n            var S = edges.sort(function(a, b) {\n                return weightFn(a) - weightFn(b);\n            });\n            for(var _i = 0; _i < S.length; _i++){\n                var edge = S[_i];\n                var u = edge.source()[0];\n                var v = edge.target()[0];\n                var setUIndex = findSetIndex(u);\n                var setVIndex = findSetIndex(v);\n                var setU = forest[setUIndex];\n                var setV = forest[setVIndex];\n                if (setUIndex !== setVIndex) {\n                    A.merge(edge); // combine forests for u and v\n                    setU.merge(setV);\n                    forest.splice(setVIndex, 1);\n                }\n            }\n            return A;\n        }\n    };\n    var aStarDefaults = defaults$g({\n        root: null,\n        goal: null,\n        weight: function weight(edge) {\n            return 1;\n        },\n        heuristic: function heuristic(edge) {\n            return 0;\n        },\n        directed: false\n    });\n    var elesfn$s = {\n        // Implemented from pseudocode from wikipedia\n        aStar: function aStar(options) {\n            var cy = this.cy();\n            var _aStarDefaults = aStarDefaults(options), root = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;\n            root = cy.collection(root)[0];\n            goal = cy.collection(goal)[0];\n            var sid = root.id();\n            var tid = goal.id();\n            var gScore = {};\n            var fScore = {};\n            var closedSetIds = {};\n            var openSet = new heap(function(a, b) {\n                return fScore[a.id()] - fScore[b.id()];\n            });\n            var openSetIds = new Set$1();\n            var cameFrom = {};\n            var cameFromEdge = {};\n            var addToOpenSet = function addToOpenSet(ele, id) {\n                openSet.push(ele);\n                openSetIds.add(id);\n            };\n            var cMin, cMinId;\n            var popFromOpenSet = function popFromOpenSet() {\n                cMin = openSet.pop();\n                cMinId = cMin.id();\n                openSetIds[\"delete\"](cMinId);\n            };\n            var isInOpenSet = function isInOpenSet(id) {\n                return openSetIds.has(id);\n            };\n            addToOpenSet(root, sid);\n            gScore[sid] = 0;\n            fScore[sid] = heuristic(root); // Counter\n            var steps = 0; // Main loop\n            while(openSet.size() > 0){\n                popFromOpenSet();\n                steps++; // If we've found our goal, then we are done\n                if (cMinId === tid) {\n                    var path = [];\n                    var pathNode = goal;\n                    var pathNodeId = tid;\n                    var pathEdge = cameFromEdge[pathNodeId];\n                    for(;;){\n                        path.unshift(pathNode);\n                        if (pathEdge != null) {\n                            path.unshift(pathEdge);\n                        }\n                        pathNode = cameFrom[pathNodeId];\n                        if (pathNode == null) {\n                            break;\n                        }\n                        pathNodeId = pathNode.id();\n                        pathEdge = cameFromEdge[pathNodeId];\n                    }\n                    return {\n                        found: true,\n                        distance: gScore[cMinId],\n                        path: this.spawn(path),\n                        steps: steps\n                    };\n                } // Add cMin to processed nodes\n                closedSetIds[cMinId] = true; // Update scores for neighbors of cMin\n                // Take into account if graph is directed or not\n                var vwEdges = cMin._private.edges;\n                for(var i = 0; i < vwEdges.length; i++){\n                    var e = vwEdges[i]; // edge must be in set of calling eles\n                    if (!this.hasElementWithId(e.id())) {\n                        continue;\n                    } // cMin must be the source of edge if directed\n                    if (directed && e.data(\"source\") !== cMinId) {\n                        continue;\n                    }\n                    var wSrc = e.source();\n                    var wTgt = e.target();\n                    var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n                    var wid = w.id(); // node must be in set of calling eles\n                    if (!this.hasElementWithId(wid)) {\n                        continue;\n                    } // if node is in closedSet, ignore it\n                    if (closedSetIds[wid]) {\n                        continue;\n                    } // New tentative score for node w\n                    var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:\n                    //   w not present in openSet\n                    // OR\n                    //   tentative gScore is less than previous value\n                    // w not in openSet\n                    if (!isInOpenSet(wid)) {\n                        gScore[wid] = tempScore;\n                        fScore[wid] = tempScore + heuristic(w);\n                        addToOpenSet(w, wid);\n                        cameFrom[wid] = cMin;\n                        cameFromEdge[wid] = e;\n                        continue;\n                    } // w already in openSet, but with greater gScore\n                    if (tempScore < gScore[wid]) {\n                        gScore[wid] = tempScore;\n                        fScore[wid] = tempScore + heuristic(w);\n                        cameFrom[wid] = cMin;\n                        cameFromEdge[wid] = e;\n                    }\n                } // End of neighbors update\n            } // End of main loop\n            // If we've reached here, then we've not reached our goal\n            return {\n                found: false,\n                distance: undefined,\n                path: undefined,\n                steps: steps\n            };\n        }\n    }; // elesfn\n    var floydWarshallDefaults = defaults$g({\n        weight: function weight(edge) {\n            return 1;\n        },\n        directed: false\n    });\n    var elesfn$r = {\n        // Implemented from pseudocode from wikipedia\n        floydWarshall: function floydWarshall(options) {\n            var cy = this.cy();\n            var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;\n            var weightFn = weight;\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n            var N = nodes.length;\n            var Nsq = N * N;\n            var indexOf = function indexOf(node) {\n                return nodes.indexOf(node);\n            };\n            var atIndex = function atIndex(i) {\n                return nodes[i];\n            }; // Initialize distance matrix\n            var dist = new Array(Nsq);\n            for(var n = 0; n < Nsq; n++){\n                var j = n % N;\n                var i = (n - j) / N;\n                if (i === j) {\n                    dist[n] = 0;\n                } else {\n                    dist[n] = Infinity;\n                }\n            } // Initialize matrix used for path reconstruction\n            // Initialize distance matrix\n            var next = new Array(Nsq);\n            var edgeNext = new Array(Nsq); // Process edges\n            for(var _i = 0; _i < edges.length; _i++){\n                var edge = edges[_i];\n                var src = edge.source()[0];\n                var tgt = edge.target()[0];\n                if (src === tgt) {\n                    continue;\n                } // exclude loops\n                var s = indexOf(src);\n                var t = indexOf(tgt);\n                var st = s * N + t; // source to target index\n                var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes\n                if (dist[st] > _weight) {\n                    dist[st] = _weight;\n                    next[st] = t;\n                    edgeNext[st] = edge;\n                } // If undirected graph, process 'reversed' edge\n                if (!directed) {\n                    var ts = t * N + s; // target to source index\n                    if (!directed && dist[ts] > _weight) {\n                        dist[ts] = _weight;\n                        next[ts] = s;\n                        edgeNext[ts] = edge;\n                    }\n                }\n            } // Main loop\n            for(var k = 0; k < N; k++){\n                for(var _i2 = 0; _i2 < N; _i2++){\n                    var ik = _i2 * N + k;\n                    for(var _j = 0; _j < N; _j++){\n                        var ij = _i2 * N + _j;\n                        var kj = k * N + _j;\n                        if (dist[ik] + dist[kj] < dist[ij]) {\n                            dist[ij] = dist[ik] + dist[kj];\n                            next[ij] = next[ik];\n                        }\n                    }\n                }\n            }\n            var getArgEle = function getArgEle(ele) {\n                return (string(ele) ? cy.filter(ele) : ele)[0];\n            };\n            var indexOfArgEle = function indexOfArgEle(ele) {\n                return indexOf(getArgEle(ele));\n            };\n            var res = {\n                distance: function distance(from, to) {\n                    var i = indexOfArgEle(from);\n                    var j = indexOfArgEle(to);\n                    return dist[i * N + j];\n                },\n                path: function path(from, to) {\n                    var i = indexOfArgEle(from);\n                    var j = indexOfArgEle(to);\n                    var fromNode = atIndex(i);\n                    if (i === j) {\n                        return fromNode.collection();\n                    }\n                    if (next[i * N + j] == null) {\n                        return cy.collection();\n                    }\n                    var path = cy.collection();\n                    var prev = i;\n                    var edge;\n                    path.merge(fromNode);\n                    while(i !== j){\n                        prev = i;\n                        i = next[i * N + j];\n                        edge = edgeNext[prev * N + i];\n                        path.merge(edge);\n                        path.merge(atIndex(i));\n                    }\n                    return path;\n                }\n            };\n            return res;\n        } // floydWarshall\n    }; // elesfn\n    var bellmanFordDefaults = defaults$g({\n        weight: function weight(edge) {\n            return 1;\n        },\n        directed: false,\n        root: null\n    });\n    var elesfn$q = {\n        // Implemented from pseudocode from wikipedia\n        bellmanFord: function bellmanFord(options) {\n            var _this = this;\n            var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root = _bellmanFordDefaults.root;\n            var weightFn = weight;\n            var eles = this;\n            var cy = this.cy();\n            var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes = _this$byGroup.nodes;\n            var numNodes = nodes.length;\n            var infoMap = new Map$2();\n            var hasNegativeWeightCycle = false;\n            var negativeWeightCycles = [];\n            root = cy.collection(root)[0]; // in case selector passed\n            edges.unmergeBy(function(edge) {\n                return edge.isLoop();\n            });\n            var numEdges = edges.length;\n            var getInfo = function getInfo(node) {\n                var obj = infoMap.get(node.id());\n                if (!obj) {\n                    obj = {};\n                    infoMap.set(node.id(), obj);\n                }\n                return obj;\n            };\n            var getNodeFromTo = function getNodeFromTo(to) {\n                return (string(to) ? cy.$(to) : to)[0];\n            };\n            var distanceTo = function distanceTo(to) {\n                return getInfo(getNodeFromTo(to)).dist;\n            };\n            var pathTo = function pathTo(to) {\n                var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n                var end = getNodeFromTo(to);\n                var path = [];\n                var node = end;\n                for(;;){\n                    if (node == null) {\n                        return _this.spawn();\n                    }\n                    var _getInfo = getInfo(node), edge = _getInfo.edge, pred = _getInfo.pred;\n                    path.unshift(node[0]);\n                    if (node.same(thisStart) && path.length > 0) {\n                        break;\n                    }\n                    if (edge != null) {\n                        path.unshift(edge);\n                    }\n                    node = pred;\n                }\n                return eles.spawn(path);\n            }; // Initializations { dist, pred, edge }\n            for(var i = 0; i < numNodes; i++){\n                var node = nodes[i];\n                var info = getInfo(node);\n                if (node.same(root)) {\n                    info.dist = 0;\n                } else {\n                    info.dist = Infinity;\n                }\n                info.pred = null;\n                info.edge = null;\n            } // Edges relaxation\n            var replacedEdge = false;\n            var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n                var dist = info1.dist + weight;\n                if (dist < info2.dist && !edge.same(info1.edge)) {\n                    info2.dist = dist;\n                    info2.pred = node1;\n                    info2.edge = edge;\n                    replacedEdge = true;\n                }\n            };\n            for(var _i = 1; _i < numNodes; _i++){\n                replacedEdge = false;\n                for(var e = 0; e < numEdges; e++){\n                    var edge = edges[e];\n                    var src = edge.source();\n                    var tgt = edge.target();\n                    var _weight = weightFn(edge);\n                    var srcInfo = getInfo(src);\n                    var tgtInfo = getInfo(tgt);\n                    checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge\n                    if (!directed) {\n                        checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n                    }\n                }\n                if (!replacedEdge) {\n                    break;\n                }\n            }\n            if (replacedEdge) {\n                // Check for negative weight cycles\n                var negativeWeightCycleIds = [];\n                for(var _e = 0; _e < numEdges; _e++){\n                    var _edge = edges[_e];\n                    var _src = _edge.source();\n                    var _tgt = _edge.target();\n                    var _weight2 = weightFn(_edge);\n                    var srcDist = getInfo(_src).dist;\n                    var tgtDist = getInfo(_tgt).dist;\n                    if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n                        if (!hasNegativeWeightCycle) {\n                            warn(\"Graph contains a negative weight cycle for Bellman-Ford\");\n                            hasNegativeWeightCycle = true;\n                        }\n                        if (options.findNegativeWeightCycles !== false) {\n                            var negativeNodes = [];\n                            if (srcDist + _weight2 < tgtDist) {\n                                negativeNodes.push(_src);\n                            }\n                            if (!directed && tgtDist + _weight2 < srcDist) {\n                                negativeNodes.push(_tgt);\n                            }\n                            var numNegativeNodes = negativeNodes.length;\n                            for(var n = 0; n < numNegativeNodes; n++){\n                                var start = negativeNodes[n];\n                                var cycle = [\n                                    start\n                                ];\n                                cycle.push(getInfo(start).edge);\n                                var _node = getInfo(start).pred;\n                                while(cycle.indexOf(_node) === -1){\n                                    cycle.push(_node);\n                                    cycle.push(getInfo(_node).edge);\n                                    _node = getInfo(_node).pred;\n                                }\n                                cycle = cycle.slice(cycle.indexOf(_node));\n                                var smallestId = cycle[0].id();\n                                var smallestIndex = 0;\n                                for(var c = 2; c < cycle.length; c += 2){\n                                    if (cycle[c].id() < smallestId) {\n                                        smallestId = cycle[c].id();\n                                        smallestIndex = c;\n                                    }\n                                }\n                                cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                                cycle.push(cycle[0]);\n                                var cycleId = cycle.map(function(el) {\n                                    return el.id();\n                                }).join(\",\");\n                                if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                                    negativeWeightCycles.push(eles.spawn(cycle));\n                                    negativeWeightCycleIds.push(cycleId);\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            return {\n                distanceTo: distanceTo,\n                pathTo: pathTo,\n                hasNegativeWeightCycle: hasNegativeWeightCycle,\n                negativeWeightCycles: negativeWeightCycles\n            };\n        } // bellmanFord\n    }; // elesfn\n    var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one\n    // Updates the remaining edge lists\n    // Receives as a paramater the edge which causes the collapse\n    var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n        if (remainingEdges.length === 0) {\n            error(\"Karger-Stein must be run on a connected (sub)graph\");\n        }\n        var edgeInfo = remainingEdges[edgeIndex];\n        var sourceIn = edgeInfo[1];\n        var targetIn = edgeInfo[2];\n        var partition1 = nodeMap[sourceIn];\n        var partition2 = nodeMap[targetIn];\n        var newEdges = remainingEdges; // re-use array\n        // Delete all edges between partition1 and partition2\n        for(var i = newEdges.length - 1; i >= 0; i--){\n            var edge = newEdges[i];\n            var src = edge[1];\n            var tgt = edge[2];\n            if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n                newEdges.splice(i, 1);\n            }\n        } // All edges pointing to partition2 should now point to partition1\n        for(var _i = 0; _i < newEdges.length; _i++){\n            var _edge = newEdges[_i];\n            if (_edge[1] === partition2) {\n                // Check source\n                newEdges[_i] = _edge.slice(); // copy\n                newEdges[_i][1] = partition1;\n            } else if (_edge[2] === partition2) {\n                // Check target\n                newEdges[_i] = _edge.slice(); // copy\n                newEdges[_i][2] = partition1;\n            }\n        } // Move all nodes from partition2 to partition1\n        for(var _i2 = 0; _i2 < nodeMap.length; _i2++){\n            if (nodeMap[_i2] === partition2) {\n                nodeMap[_i2] = partition1;\n            }\n        }\n        return newEdges;\n    }; // Contracts a graph until we reach a certain number of meta nodes\n    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n        while(size > sizeLimit){\n            // Choose an edge randomly\n            var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge\n            remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n            size--;\n        }\n        return remainingEdges;\n    };\n    var elesfn$p = {\n        // Computes the minimum cut of an undirected graph\n        // Returns the correct answer with high probability\n        kargerStein: function kargerStein() {\n            var _this = this;\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n            edges.unmergeBy(function(edge) {\n                return edge.isLoop();\n            });\n            var numNodes = nodes.length;\n            var numEdges = edges.length;\n            var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n            var stopSize = Math.floor(numNodes / sqrt2);\n            if (numNodes < 2) {\n                error(\"At least 2 nodes are required for Karger-Stein algorithm\");\n                return undefined;\n            } // Now store edge destination as indexes\n            // Format for each edge (edge index, source node index, target node index)\n            var edgeIndexes = [];\n            for(var i = 0; i < numEdges; i++){\n                var e = edges[i];\n                edgeIndexes.push([\n                    i,\n                    nodes.indexOf(e.source()),\n                    nodes.indexOf(e.target())\n                ]);\n            } // We will store the best cut found here\n            var minCutSize = Infinity;\n            var minCutEdgeIndexes = [];\n            var minCutNodeMap = new Array(numNodes); // Initial meta node partition\n            var metaNodeMap = new Array(numNodes);\n            var metaNodeMap2 = new Array(numNodes);\n            var copyNodesMap = function copyNodesMap(from, to) {\n                for(var _i3 = 0; _i3 < numNodes; _i3++){\n                    to[_i3] = from[_i3];\n                }\n            }; // Main loop\n            for(var iter = 0; iter <= numIter; iter++){\n                // Reset meta node partition\n                for(var _i4 = 0; _i4 < numNodes; _i4++){\n                    metaNodeMap[_i4] = _i4;\n                } // Contract until stop point (stopSize nodes)\n                var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n                var edgesState2 = edgesState.slice(); // copy\n                // Create a copy of the colapsed nodes state\n                copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state\n                var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n                var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?\n                if (res1.length <= res2.length && res1.length < minCutSize) {\n                    minCutSize = res1.length;\n                    minCutEdgeIndexes = res1;\n                    copyNodesMap(metaNodeMap, minCutNodeMap);\n                } else if (res2.length <= res1.length && res2.length < minCutSize) {\n                    minCutSize = res2.length;\n                    minCutEdgeIndexes = res2;\n                    copyNodesMap(metaNodeMap2, minCutNodeMap);\n                }\n            } // end of main loop\n            // Construct result\n            var cut = this.spawn(minCutEdgeIndexes.map(function(e) {\n                return edges[e[0]];\n            }));\n            var partition1 = this.spawn();\n            var partition2 = this.spawn(); // traverse metaNodeMap for best cut\n            var witnessNodePartition = minCutNodeMap[0];\n            for(var _i5 = 0; _i5 < minCutNodeMap.length; _i5++){\n                var partitionId = minCutNodeMap[_i5];\n                var node = nodes[_i5];\n                if (partitionId === witnessNodePartition) {\n                    partition1.merge(node);\n                } else {\n                    partition2.merge(node);\n                }\n            } // construct components corresponding to each disjoint subset of nodes\n            var constructComponent = function constructComponent(subset) {\n                var component = _this.spawn();\n                subset.forEach(function(node) {\n                    component.merge(node);\n                    node.connectedEdges().forEach(function(edge) {\n                        // ensure edge is within calling collection and edge is not in cut\n                        if (_this.contains(edge) && !cut.contains(edge)) {\n                            component.merge(edge);\n                        }\n                    });\n                });\n                return component;\n            };\n            var components = [\n                constructComponent(partition1),\n                constructComponent(partition2)\n            ];\n            var ret = {\n                cut: cut,\n                components: components,\n                // n.b. partitions are included to be compatible with the old api spec\n                // (could be removed in a future major version)\n                partition1: partition1,\n                partition2: partition2\n            };\n            return ret;\n        }\n    }; // elesfn\n    var copyPosition = function copyPosition(p) {\n        return {\n            x: p.x,\n            y: p.y\n        };\n    };\n    var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {\n        return {\n            x: p.x * zoom + pan.x,\n            y: p.y * zoom + pan.y\n        };\n    };\n    var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n        return {\n            x: (p.x - pan.x) / zoom,\n            y: (p.y - pan.y) / zoom\n        };\n    };\n    var array2point = function array2point(arr) {\n        return {\n            x: arr[0],\n            y: arr[1]\n        };\n    };\n    var min = function min(arr) {\n        var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n        var min = Infinity;\n        for(var i = begin; i < end; i++){\n            var val = arr[i];\n            if (isFinite(val)) {\n                min = Math.min(val, min);\n            }\n        }\n        return min;\n    };\n    var max = function max(arr) {\n        var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n        var max = -Infinity;\n        for(var i = begin; i < end; i++){\n            var val = arr[i];\n            if (isFinite(val)) {\n                max = Math.max(val, max);\n            }\n        }\n        return max;\n    };\n    var mean = function mean(arr) {\n        var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n        var total = 0;\n        var n = 0;\n        for(var i = begin; i < end; i++){\n            var val = arr[i];\n            if (isFinite(val)) {\n                total += val;\n                n++;\n            }\n        }\n        return total / n;\n    };\n    var median = function median(arr) {\n        var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n        var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        if (copy) {\n            arr = arr.slice(begin, end);\n        } else {\n            if (end < arr.length) {\n                arr.splice(end, arr.length - end);\n            }\n            if (begin > 0) {\n                arr.splice(0, begin);\n            }\n        } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n        var off = 0; // offset from non-finite values\n        for(var i = arr.length - 1; i >= 0; i--){\n            var v = arr[i];\n            if (includeHoles) {\n                if (!isFinite(v)) {\n                    arr[i] = -Infinity;\n                    off++;\n                }\n            } else {\n                // just remove it if we don't want to consider holes\n                arr.splice(i, 1);\n            }\n        }\n        if (sort) {\n            arr.sort(function(a, b) {\n                return a - b;\n            }); // requires copy = true if you don't want to change the orig\n        }\n        var len = arr.length;\n        var mid = Math.floor(len / 2);\n        if (len % 2 !== 0) {\n            return arr[mid + 1 + off];\n        } else {\n            return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n        }\n    };\n    var deg2rad = function deg2rad(deg) {\n        return Math.PI * deg / 180;\n    };\n    var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n        return Math.atan2(dispY, dispX) - Math.PI / 2;\n    };\n    var log2 = Math.log2 || function(n) {\n        return Math.log(n) / Math.log(2);\n    };\n    var signum = function signum(x) {\n        if (x > 0) {\n            return 1;\n        } else if (x < 0) {\n            return -1;\n        } else {\n            return 0;\n        }\n    };\n    var dist = function dist(p1, p2) {\n        return Math.sqrt(sqdist(p1, p2));\n    };\n    var sqdist = function sqdist(p1, p2) {\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        return dx * dx + dy * dy;\n    };\n    var inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n        var length = v.length; // First, get sum of all elements\n        var total = 0;\n        for(var i = 0; i < length; i++){\n            total += v[i];\n        } // Now, divide each by the sum of all elements\n        for(var _i = 0; _i < length; _i++){\n            v[_i] = v[_i] / total;\n        }\n        return v;\n    };\n    var qbezierAt = function qbezierAt(p0, p1, p2, t) {\n        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n    };\n    var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n        return {\n            x: qbezierAt(p0.x, p1.x, p2.x, t),\n            y: qbezierAt(p0.y, p1.y, p2.y, t)\n        };\n    };\n    var lineAt = function lineAt(p0, p1, t, d) {\n        var vec = {\n            x: p1.x - p0.x,\n            y: p1.y - p0.y\n        };\n        var vecDist = dist(p0, p1);\n        var normVec = {\n            x: vec.x / vecDist,\n            y: vec.y / vecDist\n        };\n        t = t == null ? 0 : t;\n        d = d != null ? d : t * vecDist;\n        return {\n            x: p0.x + normVec.x * d,\n            y: p0.y + normVec.y * d\n        };\n    };\n    var bound = function bound(min, val, max) {\n        return Math.max(min, Math.min(max, val));\n    }; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n    var makeBoundingBox = function makeBoundingBox(bb) {\n        if (bb == null) {\n            return {\n                x1: Infinity,\n                y1: Infinity,\n                x2: -Infinity,\n                y2: -Infinity,\n                w: 0,\n                h: 0\n            };\n        } else if (bb.x1 != null && bb.y1 != null) {\n            if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n                return {\n                    x1: bb.x1,\n                    y1: bb.y1,\n                    x2: bb.x2,\n                    y2: bb.y2,\n                    w: bb.x2 - bb.x1,\n                    h: bb.y2 - bb.y1\n                };\n            } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n                return {\n                    x1: bb.x1,\n                    y1: bb.y1,\n                    x2: bb.x1 + bb.w,\n                    y2: bb.y1 + bb.h,\n                    w: bb.w,\n                    h: bb.h\n                };\n            }\n        }\n    };\n    var copyBoundingBox = function copyBoundingBox(bb) {\n        return {\n            x1: bb.x1,\n            x2: bb.x2,\n            w: bb.w,\n            y1: bb.y1,\n            y2: bb.y2,\n            h: bb.h\n        };\n    };\n    var clearBoundingBox = function clearBoundingBox(bb) {\n        bb.x1 = Infinity;\n        bb.y1 = Infinity;\n        bb.x2 = -Infinity;\n        bb.y2 = -Infinity;\n        bb.w = 0;\n        bb.h = 0;\n    };\n    var updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n        // update bb1 with bb2 bounds\n        bb1.x1 = Math.min(bb1.x1, bb2.x1);\n        bb1.x2 = Math.max(bb1.x2, bb2.x2);\n        bb1.w = bb1.x2 - bb1.x1;\n        bb1.y1 = Math.min(bb1.y1, bb2.y1);\n        bb1.y2 = Math.max(bb1.y2, bb2.y2);\n        bb1.h = bb1.y2 - bb1.y1;\n    };\n    var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n        bb.x1 = Math.min(bb.x1, x);\n        bb.x2 = Math.max(bb.x2, x);\n        bb.w = bb.x2 - bb.x1;\n        bb.y1 = Math.min(bb.y1, y);\n        bb.y2 = Math.max(bb.y2, y);\n        bb.h = bb.y2 - bb.y1;\n    };\n    var expandBoundingBox = function expandBoundingBox(bb) {\n        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        bb.x1 -= padding;\n        bb.x2 += padding;\n        bb.y1 -= padding;\n        bb.y2 += padding;\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n        return bb;\n    };\n    var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\n            0\n        ];\n        var top, right, bottom, left;\n        if (padding.length === 1) {\n            top = right = bottom = left = padding[0];\n        } else if (padding.length === 2) {\n            top = bottom = padding[0];\n            left = right = padding[1];\n        } else if (padding.length === 4) {\n            var _padding = _slicedToArray(padding, 4);\n            top = _padding[0];\n            right = _padding[1];\n            bottom = _padding[2];\n            left = _padding[3];\n        }\n        bb.x1 -= left;\n        bb.x2 += right;\n        bb.y1 -= top;\n        bb.y2 += bottom;\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n        return bb;\n    };\n    var assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n        bb1.x1 = bb2.x1;\n        bb1.y1 = bb2.y1;\n        bb1.x2 = bb2.x2;\n        bb1.y2 = bb2.y2;\n        bb1.w = bb1.x2 - bb1.x1;\n        bb1.h = bb1.y2 - bb1.y1;\n    };\n    var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n        // case: one bb to right of other\n        if (bb1.x1 > bb2.x2) {\n            return false;\n        }\n        if (bb2.x1 > bb1.x2) {\n            return false;\n        } // case: one bb to left of other\n        if (bb1.x2 < bb2.x1) {\n            return false;\n        }\n        if (bb2.x2 < bb1.x1) {\n            return false;\n        } // case: one bb above other\n        if (bb1.y2 < bb2.y1) {\n            return false;\n        }\n        if (bb2.y2 < bb1.y1) {\n            return false;\n        } // case: one bb below other\n        if (bb1.y1 > bb2.y2) {\n            return false;\n        }\n        if (bb2.y1 > bb1.y2) {\n            return false;\n        } // otherwise, must have some overlap\n        return true;\n    };\n    var inBoundingBox = function inBoundingBox(bb, x, y) {\n        return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n    };\n    var pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n        return inBoundingBox(bb, pt.x, pt.y);\n    };\n    var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n        return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n    };\n    var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        var halfWidth = width / 2;\n        var halfHeight = height / 2; // Check intersections with straight line segments\n        var straightLineIntersections; // Top segment, left to right\n        {\n            var topStartX = nodeX - halfWidth + cornerRadius - padding;\n            var topStartY = nodeY - halfHeight - padding;\n            var topEndX = nodeX + halfWidth - cornerRadius + padding;\n            var topEndY = topStartY;\n            straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n            if (straightLineIntersections.length > 0) {\n                return straightLineIntersections;\n            }\n        }\n        {\n            var rightStartX = nodeX + halfWidth + padding;\n            var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n            var rightEndX = rightStartX;\n            var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n            straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n            if (straightLineIntersections.length > 0) {\n                return straightLineIntersections;\n            }\n        }\n        {\n            var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n            var bottomStartY = nodeY + halfHeight + padding;\n            var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n            var bottomEndY = bottomStartY;\n            straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n            if (straightLineIntersections.length > 0) {\n                return straightLineIntersections;\n            }\n        }\n        {\n            var leftStartX = nodeX - halfWidth - padding;\n            var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n            var leftEndX = leftStartX;\n            var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n            straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n            if (straightLineIntersections.length > 0) {\n                return straightLineIntersections;\n            }\n        }\n        var arcIntersections; // Top Left\n        {\n            var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n            var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n            arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n            if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n                return [\n                    arcIntersections[0],\n                    arcIntersections[1]\n                ];\n            }\n        }\n        {\n            var topRightCenterX = nodeX + halfWidth - cornerRadius;\n            var topRightCenterY = nodeY - halfHeight + cornerRadius;\n            arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n            if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n                return [\n                    arcIntersections[0],\n                    arcIntersections[1]\n                ];\n            }\n        }\n        {\n            var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n            var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n            arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n            if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n                return [\n                    arcIntersections[0],\n                    arcIntersections[1]\n                ];\n            }\n        }\n        {\n            var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n            var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n            arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n            if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n                return [\n                    arcIntersections[0],\n                    arcIntersections[1]\n                ];\n            }\n        }\n        return []; // if nothing\n    };\n    var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n        var t = tolerance;\n        var x1 = Math.min(lx1, lx2);\n        var x2 = Math.max(lx1, lx2);\n        var y1 = Math.min(ly1, ly2);\n        var y2 = Math.max(ly1, ly2);\n        return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n    };\n    var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n        var bb = {\n            x1: Math.min(x1, x3, x2) - tolerance,\n            x2: Math.max(x1, x3, x2) + tolerance,\n            y1: Math.min(y1, y3, y2) - tolerance,\n            y2: Math.max(y1, y3, y2) + tolerance\n        }; // if outside the rough bounding box for the bezier, then it can't be a hit\n        if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n            // console.log('bezier out of rough bb')\n            return false;\n        } else {\n            // console.log('do more expensive check');\n            return true;\n        }\n    };\n    var solveQuadratic = function solveQuadratic(a, b, c, val) {\n        c -= val;\n        var r = b * b - 4 * a * c;\n        if (r < 0) {\n            return [];\n        }\n        var sqrtR = Math.sqrt(r);\n        var denom = 2 * a;\n        var root1 = (-b + sqrtR) / denom;\n        var root2 = (-b - sqrtR) / denom;\n        return [\n            root1,\n            root2\n        ];\n    };\n    var solveCubic = function solveCubic(a, b, c, d, result) {\n        // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n        // r is the real component, i is the imaginary component\n        // An implementation of the Cardano method from the year 1545\n        // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n        var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value\n        if (a === 0) {\n            a = epsilon;\n        }\n        b /= a;\n        c /= a;\n        d /= a;\n        var discriminant, q, r, dum1, s, t, term1, r13;\n        q = (3.0 * c - b * b) / 9.0;\n        r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n        r /= 54.0;\n        discriminant = q * q * q + r * r;\n        result[1] = 0;\n        term1 = b / 3.0;\n        if (discriminant > 0) {\n            s = r + Math.sqrt(discriminant);\n            s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n            t = r - Math.sqrt(discriminant);\n            t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n            result[0] = -term1 + s + t;\n            term1 += (s + t) / 2.0;\n            result[4] = result[2] = -term1;\n            term1 = Math.sqrt(3.0) * (-t + s) / 2;\n            result[3] = term1;\n            result[5] = -term1;\n            return;\n        }\n        result[5] = result[3] = 0;\n        if (discriminant === 0) {\n            r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n            result[0] = -term1 + 2.0 * r13;\n            result[4] = result[2] = -(r13 + term1);\n            return;\n        }\n        q = -q;\n        dum1 = q * q * q;\n        dum1 = Math.acos(r / Math.sqrt(dum1));\n        r13 = 2.0 * Math.sqrt(q);\n        result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n        result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n        result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n        return;\n    };\n    var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n        // Find minimum distance by using the minimum of the distance\n        // function between the given point and the curve\n        // This gives the coefficients of the resulting cubic equation\n        // whose roots tell us where a possible minimum is\n        // (Coefficients are divided by 4)\n        var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n        var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n        var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n        var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n        var roots = []; // Use the cubic solving algorithm\n        solveCubic(a, b, c, d, roots);\n        var zeroThreshold = 0.0000001;\n        var params = [];\n        for(var index = 0; index < 6; index += 2){\n            if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n                params.push(roots[index]);\n            }\n        }\n        params.push(1.0);\n        params.push(0.0);\n        var minDistanceSquared = -1;\n        var curX, curY, distSquared;\n        for(var i = 0; i < params.length; i++){\n            curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n            curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n            distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n            if (minDistanceSquared >= 0) {\n                if (distSquared < minDistanceSquared) {\n                    minDistanceSquared = distSquared;\n                }\n            } else {\n                minDistanceSquared = distSquared;\n            }\n        }\n        return minDistanceSquared;\n    };\n    var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n        var offset = [\n            x - x1,\n            y - y1\n        ];\n        var line = [\n            x2 - x1,\n            y2 - y1\n        ];\n        var lineSq = line[0] * line[0] + line[1] * line[1];\n        var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n        var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n        var adjSq = dotProduct * dotProduct / lineSq;\n        if (dotProduct < 0) {\n            return hypSq;\n        }\n        if (adjSq > lineSq) {\n            return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n        }\n        return hypSq - adjSq;\n    };\n    var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n        var x1, y1, x2, y2;\n        var y3; // Intersect with vertical line through (x, y)\n        var up = 0; // let down = 0;\n        for(var i = 0; i < points.length / 2; i++){\n            x1 = points[i * 2];\n            y1 = points[i * 2 + 1];\n            if (i + 1 < points.length / 2) {\n                x2 = points[(i + 1) * 2];\n                y2 = points[(i + 1) * 2 + 1];\n            } else {\n                x2 = points[(i + 1 - points.length / 2) * 2];\n                y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n            }\n            if (x1 == x && x2 == x) ;\n            else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n                y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n                if (y3 > y) {\n                    up++;\n                } // if( y3 < y ){\n            // down++;\n            // }\n            } else {\n                continue;\n            }\n        }\n        if (up % 2 === 0) {\n            return false;\n        } else {\n            return true;\n        }\n    };\n    var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n        var transformedPoints = new Array(basePoints.length); // Gives negative angle\n        var angle;\n        if (direction[0] != null) {\n            angle = Math.atan(direction[1] / direction[0]);\n            if (direction[0] < 0) {\n                angle = angle + Math.PI / 2;\n            } else {\n                angle = -angle - Math.PI / 2;\n            }\n        } else {\n            angle = direction;\n        }\n        var cos = Math.cos(-angle);\n        var sin = Math.sin(-angle); //    console.log(\"base: \" + basePoints);\n        for(var i = 0; i < transformedPoints.length / 2; i++){\n            transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n            transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n            transformedPoints[i * 2] += centerX;\n            transformedPoints[i * 2 + 1] += centerY;\n        }\n        var points;\n        if (padding > 0) {\n            var expandedLineSet = expandPolygon(transformedPoints, -padding);\n            points = joinLines(expandedLineSet);\n        } else {\n            points = transformedPoints;\n        }\n        return pointInsidePolygonPoints(x, y, points);\n    };\n    var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {\n        var cutPolygonPoints = new Array(basePoints.length);\n        var halfW = width / 2;\n        var halfH = height / 2;\n        var cornerRadius = getRoundPolygonRadius(width, height);\n        var squaredCornerRadius = cornerRadius * cornerRadius;\n        for(var i = 0; i < basePoints.length / 4; i++){\n            var sourceUv = void 0, destUv = void 0;\n            if (i === 0) {\n                sourceUv = basePoints.length - 2;\n            } else {\n                sourceUv = i * 4 - 2;\n            }\n            destUv = i * 4 + 2;\n            var px = centerX + halfW * basePoints[i * 4];\n            var py = centerY + halfH * basePoints[i * 4 + 1];\n            var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n            var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n            var cp0x = px - offset * basePoints[sourceUv];\n            var cp0y = py - offset * basePoints[sourceUv + 1];\n            var cp1x = px + offset * basePoints[destUv];\n            var cp1y = py + offset * basePoints[destUv + 1];\n            cutPolygonPoints[i * 4] = cp0x;\n            cutPolygonPoints[i * 4 + 1] = cp0y;\n            cutPolygonPoints[i * 4 + 2] = cp1x;\n            cutPolygonPoints[i * 4 + 3] = cp1y;\n            var orthx = basePoints[sourceUv + 1];\n            var orthy = -basePoints[sourceUv];\n            var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n            if (cosAlpha < 0) {\n                orthx *= -1;\n                orthy *= -1;\n            }\n            var cx = cp0x + orthx * cornerRadius;\n            var cy = cp0y + orthy * cornerRadius;\n            var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);\n            if (squaredDistance <= squaredCornerRadius) {\n                return true;\n            }\n        }\n        return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n    };\n    var joinLines = function joinLines(lineSet) {\n        var vertices = new Array(lineSet.length / 2);\n        var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n        var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n        for(var i = 0; i < lineSet.length / 4; i++){\n            currentLineStartX = lineSet[i * 4];\n            currentLineStartY = lineSet[i * 4 + 1];\n            currentLineEndX = lineSet[i * 4 + 2];\n            currentLineEndY = lineSet[i * 4 + 3];\n            if (i < lineSet.length / 4 - 1) {\n                nextLineStartX = lineSet[(i + 1) * 4];\n                nextLineStartY = lineSet[(i + 1) * 4 + 1];\n                nextLineEndX = lineSet[(i + 1) * 4 + 2];\n                nextLineEndY = lineSet[(i + 1) * 4 + 3];\n            } else {\n                nextLineStartX = lineSet[0];\n                nextLineStartY = lineSet[1];\n                nextLineEndX = lineSet[2];\n                nextLineEndY = lineSet[3];\n            }\n            var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n            vertices[i * 2] = intersection[0];\n            vertices[i * 2 + 1] = intersection[1];\n        }\n        return vertices;\n    };\n    var expandPolygon = function expandPolygon(points, pad) {\n        var expandedLineSet = new Array(points.length * 2);\n        var currentPointX, currentPointY, nextPointX, nextPointY;\n        for(var i = 0; i < points.length / 2; i++){\n            currentPointX = points[i * 2];\n            currentPointY = points[i * 2 + 1];\n            if (i < points.length / 2 - 1) {\n                nextPointX = points[(i + 1) * 2];\n                nextPointY = points[(i + 1) * 2 + 1];\n            } else {\n                nextPointX = points[0];\n                nextPointY = points[1];\n            } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n            // Assume CCW polygon winding\n            var offsetX = nextPointY - currentPointY;\n            var offsetY = -(nextPointX - currentPointX); // Normalize\n            var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n            var normalizedOffsetX = offsetX / offsetLength;\n            var normalizedOffsetY = offsetY / offsetLength;\n            expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n            expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n            expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n            expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n        }\n        return expandedLineSet;\n    };\n    var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n        var dispX = centerX - x;\n        var dispY = centerY - y;\n        dispX /= ellipseWradius;\n        dispY /= ellipseHradius;\n        var len = Math.sqrt(dispX * dispX + dispY * dispY);\n        var newLength = len - 1;\n        if (newLength < 0) {\n            return [];\n        }\n        var lenProportion = newLength / len;\n        return [\n            (centerX - x) * lenProportion + x,\n            (centerY - y) * lenProportion + y\n        ];\n    };\n    var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n        x -= centerX;\n        y -= centerY;\n        x /= width / 2 + padding;\n        y /= height / 2 + padding;\n        return x * x + y * y <= 1;\n    }; // Returns intersections of increasing distance from line's start point\n    var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n        // Calculate d, direction vector of line\n        var d = [\n            x2 - x1,\n            y2 - y1\n        ]; // Direction vector of line\n        var f = [\n            x1 - centerX,\n            y1 - centerY\n        ];\n        var a = d[0] * d[0] + d[1] * d[1];\n        var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n        var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n        var discriminant = b * b - 4 * a * c;\n        if (discriminant < 0) {\n            return [];\n        }\n        var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n        var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n        var tMin = Math.min(t1, t2);\n        var tMax = Math.max(t1, t2);\n        var inRangeParams = [];\n        if (tMin >= 0 && tMin <= 1) {\n            inRangeParams.push(tMin);\n        }\n        if (tMax >= 0 && tMax <= 1) {\n            inRangeParams.push(tMax);\n        }\n        if (inRangeParams.length === 0) {\n            return [];\n        }\n        var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n        var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n        if (inRangeParams.length > 1) {\n            if (inRangeParams[0] == inRangeParams[1]) {\n                return [\n                    nearIntersectionX,\n                    nearIntersectionY\n                ];\n            } else {\n                var farIntersectionX = inRangeParams[1] * d[0] + x1;\n                var farIntersectionY = inRangeParams[1] * d[1] + y1;\n                return [\n                    nearIntersectionX,\n                    nearIntersectionY,\n                    farIntersectionX,\n                    farIntersectionY\n                ];\n            }\n        } else {\n            return [\n                nearIntersectionX,\n                nearIntersectionY\n            ];\n        }\n    };\n    var midOfThree = function midOfThree(a, b, c) {\n        if (b <= a && a <= c || c <= a && a <= b) {\n            return a;\n        } else if (a <= b && b <= c || c <= b && b <= a) {\n            return b;\n        } else {\n            return c;\n        }\n    }; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\n    var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n        var dx13 = x1 - x3;\n        var dx21 = x2 - x1;\n        var dx43 = x4 - x3;\n        var dy13 = y1 - y3;\n        var dy21 = y2 - y1;\n        var dy43 = y4 - y3;\n        var ua_t = dx43 * dy13 - dy43 * dx13;\n        var ub_t = dx21 * dy13 - dy21 * dx13;\n        var u_b = dy43 * dx21 - dx43 * dy21;\n        if (u_b !== 0) {\n            var ua = ua_t / u_b;\n            var ub = ub_t / u_b;\n            var flptThreshold = 0.001;\n            var _min = 0 - flptThreshold;\n            var _max = 1 + flptThreshold;\n            if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n                return [\n                    x1 + ua * dx21,\n                    y1 + ua * dy21\n                ];\n            } else {\n                if (!infiniteLines) {\n                    return [];\n                } else {\n                    return [\n                        x1 + ua * dx21,\n                        y1 + ua * dy21\n                    ];\n                }\n            }\n        } else {\n            if (ua_t === 0 || ub_t === 0) {\n                // Parallel, coincident lines. Check if overlap\n                // Check endpoint of second line\n                if (midOfThree(x1, x2, x4) === x4) {\n                    return [\n                        x4,\n                        y4\n                    ];\n                } // Check start point of second line\n                if (midOfThree(x1, x2, x3) === x3) {\n                    return [\n                        x3,\n                        y3\n                    ];\n                } // Endpoint of first line\n                if (midOfThree(x3, x4, x2) === x2) {\n                    return [\n                        x2,\n                        y2\n                    ];\n                }\n                return [];\n            } else {\n                // Parallel, non-coincident\n                return [];\n            }\n        }\n    }; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n    // intersect a node polygon (pts transformed)\n    //\n    // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n    // intersect the points (no transform)\n    var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n        var intersections = [];\n        var intersection;\n        var transformedPoints = new Array(basePoints.length);\n        var doTransform = true;\n        if (width == null) {\n            doTransform = false;\n        }\n        var points;\n        if (doTransform) {\n            for(var i = 0; i < transformedPoints.length / 2; i++){\n                transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n                transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n            }\n            if (padding > 0) {\n                var expandedLineSet = expandPolygon(transformedPoints, -padding);\n                points = joinLines(expandedLineSet);\n            } else {\n                points = transformedPoints;\n            }\n        } else {\n            points = basePoints;\n        }\n        var currentX, currentY, nextX, nextY;\n        for(var _i2 = 0; _i2 < points.length / 2; _i2++){\n            currentX = points[_i2 * 2];\n            currentY = points[_i2 * 2 + 1];\n            if (_i2 < points.length / 2 - 1) {\n                nextX = points[(_i2 + 1) * 2];\n                nextY = points[(_i2 + 1) * 2 + 1];\n            } else {\n                nextX = points[0];\n                nextY = points[1];\n            }\n            intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n            if (intersection.length !== 0) {\n                intersections.push(intersection[0], intersection[1]);\n            }\n        }\n        return intersections;\n    };\n    var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n        var intersections = [];\n        var intersection;\n        var lines = new Array(basePoints.length);\n        var halfW = width / 2;\n        var halfH = height / 2;\n        var cornerRadius = getRoundPolygonRadius(width, height);\n        for(var i = 0; i < basePoints.length / 4; i++){\n            var sourceUv = void 0, destUv = void 0;\n            if (i === 0) {\n                sourceUv = basePoints.length - 2;\n            } else {\n                sourceUv = i * 4 - 2;\n            }\n            destUv = i * 4 + 2;\n            var px = centerX + halfW * basePoints[i * 4];\n            var py = centerY + halfH * basePoints[i * 4 + 1];\n            var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n            var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n            var cp0x = px - offset * basePoints[sourceUv];\n            var cp0y = py - offset * basePoints[sourceUv + 1];\n            var cp1x = px + offset * basePoints[destUv];\n            var cp1y = py + offset * basePoints[destUv + 1];\n            if (i === 0) {\n                lines[basePoints.length - 2] = cp0x;\n                lines[basePoints.length - 1] = cp0y;\n            } else {\n                lines[i * 4 - 2] = cp0x;\n                lines[i * 4 - 1] = cp0y;\n            }\n            lines[i * 4] = cp1x;\n            lines[i * 4 + 1] = cp1y;\n            var orthx = basePoints[sourceUv + 1];\n            var orthy = -basePoints[sourceUv];\n            var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n            if (cosAlpha < 0) {\n                orthx *= -1;\n                orthy *= -1;\n            }\n            var cx = cp0x + orthx * cornerRadius;\n            var cy = cp0y + orthy * cornerRadius;\n            intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);\n            if (intersection.length !== 0) {\n                intersections.push(intersection[0], intersection[1]);\n            }\n        }\n        for(var _i3 = 0; _i3 < lines.length / 4; _i3++){\n            intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);\n            if (intersection.length !== 0) {\n                intersections.push(intersection[0], intersection[1]);\n            }\n        }\n        if (intersections.length > 2) {\n            var lowestIntersection = [\n                intersections[0],\n                intersections[1]\n            ];\n            var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n            for(var _i4 = 1; _i4 < intersections.length / 2; _i4++){\n                var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n                if (squaredDistance <= lowestSquaredDistance) {\n                    lowestIntersection[0] = intersections[_i4 * 2];\n                    lowestIntersection[1] = intersections[_i4 * 2 + 1];\n                    lowestSquaredDistance = squaredDistance;\n                }\n            }\n            return lowestIntersection;\n        }\n        return intersections;\n    };\n    var shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n        var disp = [\n            intersection[0] - offset[0],\n            intersection[1] - offset[1]\n        ];\n        var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n        var lenRatio = (length - amount) / length;\n        if (lenRatio < 0) {\n            lenRatio = 0.00001;\n        }\n        return [\n            offset[0] + lenRatio * disp[0],\n            offset[1] + lenRatio * disp[1]\n        ];\n    };\n    var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n        var points = generateUnitNgonPoints(sides, rotationRadians);\n        points = fitPolygonToSquare(points);\n        return points;\n    };\n    var fitPolygonToSquare = function fitPolygonToSquare(points) {\n        var x, y;\n        var sides = points.length / 2;\n        var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n        for(var i = 0; i < sides; i++){\n            x = points[2 * i];\n            y = points[2 * i + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        } // stretch factors\n        var sx = 2 / (maxX - minX);\n        var sy = 2 / (maxY - minY);\n        for(var _i5 = 0; _i5 < sides; _i5++){\n            x = points[2 * _i5] = points[2 * _i5] * sx;\n            y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        if (minY < -1) {\n            for(var _i6 = 0; _i6 < sides; _i6++){\n                y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n            }\n        }\n        return points;\n    };\n    var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n        var increment = 1.0 / sides * 2 * Math.PI;\n        var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n        startAngle += rotationRadians;\n        var points = new Array(sides * 2);\n        var currentAngle;\n        for(var i = 0; i < sides; i++){\n            currentAngle = i * increment + startAngle;\n            points[2 * i] = Math.cos(currentAngle); // x\n            points[2 * i + 1] = Math.sin(-currentAngle); // y\n        }\n        return points;\n    }; // Set the default radius, unless half of width or height is smaller than default\n    var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n        return Math.min(width / 4, height / 4, 8);\n    }; // Set the default radius\n    var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n        return Math.min(width / 10, height / 10, 8);\n    };\n    var getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n        return 8;\n    };\n    var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n        return [\n            p0 - 2 * p1 + p2,\n            2 * (p1 - p0),\n            p0\n        ];\n    }; // get curve width, height, and control point position offsets as a percentage of node height / width\n    var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n        return {\n            heightOffset: Math.min(15, 0.05 * height),\n            widthOffset: Math.min(100, 0.25 * width),\n            ctrlPtOffsetPct: 0.05\n        };\n    };\n    var pageRankDefaults = defaults$g({\n        dampingFactor: 0.8,\n        precision: 0.000001,\n        iterations: 200,\n        weight: function weight(edge) {\n            return 1;\n        }\n    });\n    var elesfn$o = {\n        pageRank: function pageRank(options) {\n            var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;\n            var cy = this._private.cy;\n            var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n            var numNodes = nodes.length;\n            var numNodesSqd = numNodes * numNodes;\n            var numEdges = edges.length; // Construct transposed adjacency matrix\n            // First lets have a zeroed matrix of the right size\n            // We'll also keep track of the sum of each column\n            var matrix = new Array(numNodesSqd);\n            var columnSum = new Array(numNodes);\n            var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix\n            for(var i = 0; i < numNodes; i++){\n                for(var j = 0; j < numNodes; j++){\n                    var n = i * numNodes + j;\n                    matrix[n] = 0;\n                }\n                columnSum[i] = 0;\n            } // Now, process edges\n            for(var _i = 0; _i < numEdges; _i++){\n                var edge = edges[_i];\n                var srcId = edge.data(\"source\");\n                var tgtId = edge.data(\"target\"); // Don't include loops in the matrix\n                if (srcId === tgtId) {\n                    continue;\n                }\n                var s = nodes.indexOfId(srcId);\n                var t = nodes.indexOfId(tgtId);\n                var w = weight(edge);\n                var _n = t * numNodes + s; // Update matrix\n                matrix[_n] += w; // Update column sum\n                columnSum[s] += w;\n            } // Add additional probability based on damping factor\n            // Also, take into account columns that have sum = 0\n            var p = 1.0 / numNodes + additionalProb; // Shorthand\n            // Traverse matrix, column by column\n            for(var _j = 0; _j < numNodes; _j++){\n                if (columnSum[_j] === 0) {\n                    // No 'links' out from node jth, assume equal probability for each possible node\n                    for(var _i2 = 0; _i2 < numNodes; _i2++){\n                        var _n2 = _i2 * numNodes + _j;\n                        matrix[_n2] = p;\n                    }\n                } else {\n                    // Node jth has outgoing link, compute normalized probabilities\n                    for(var _i3 = 0; _i3 < numNodes; _i3++){\n                        var _n3 = _i3 * numNodes + _j;\n                        matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n                    }\n                }\n            } // Compute dominant eigenvector using power method\n            var eigenvector = new Array(numNodes);\n            var temp = new Array(numNodes);\n            var previous; // Start with a vector of all 1's\n            // Also, initialize a null vector which will be used as shorthand\n            for(var _i4 = 0; _i4 < numNodes; _i4++){\n                eigenvector[_i4] = 1;\n            }\n            for(var iter = 0; iter < iterations; iter++){\n                // Temp array with all 0's\n                for(var _i5 = 0; _i5 < numNodes; _i5++){\n                    temp[_i5] = 0;\n                } // Multiply matrix with previous result\n                for(var _i6 = 0; _i6 < numNodes; _i6++){\n                    for(var _j2 = 0; _j2 < numNodes; _j2++){\n                        var _n4 = _i6 * numNodes + _j2;\n                        temp[_i6] += matrix[_n4] * eigenvector[_j2];\n                    }\n                }\n                inPlaceSumNormalize(temp);\n                previous = eigenvector;\n                eigenvector = temp;\n                temp = previous;\n                var diff = 0; // Compute difference (squared module) of both vectors\n                for(var _i7 = 0; _i7 < numNodes; _i7++){\n                    var delta = previous[_i7] - eigenvector[_i7];\n                    diff += delta * delta;\n                } // If difference is less than the desired threshold, stop iterating\n                if (diff < precision) {\n                    break;\n                }\n            } // Construct result\n            var res = {\n                rank: function rank(node) {\n                    node = cy.collection(node)[0];\n                    return eigenvector[nodes.indexOf(node)];\n                }\n            };\n            return res;\n        } // pageRank\n    }; // elesfn\n    var defaults$f = defaults$g({\n        root: null,\n        weight: function weight(edge) {\n            return 1;\n        },\n        directed: false,\n        alpha: 0\n    });\n    var elesfn$n = {\n        degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n            options = defaults$f(options);\n            var cy = this.cy();\n            var nodes = this.nodes();\n            var numNodes = nodes.length;\n            if (!options.directed) {\n                var degrees = {};\n                var maxDegree = 0;\n                for(var i = 0; i < numNodes; i++){\n                    var node = nodes[i]; // add current node to the current options object and call degreeCentrality\n                    options.root = node;\n                    var currDegree = this.degreeCentrality(options);\n                    if (maxDegree < currDegree.degree) {\n                        maxDegree = currDegree.degree;\n                    }\n                    degrees[node.id()] = currDegree.degree;\n                }\n                return {\n                    degree: function degree(node) {\n                        if (maxDegree === 0) {\n                            return 0;\n                        }\n                        if (string(node)) {\n                            // from is a selector string\n                            node = cy.filter(node);\n                        }\n                        return degrees[node.id()] / maxDegree;\n                    }\n                };\n            } else {\n                var indegrees = {};\n                var outdegrees = {};\n                var maxIndegree = 0;\n                var maxOutdegree = 0;\n                for(var _i = 0; _i < numNodes; _i++){\n                    var _node = nodes[_i];\n                    var id = _node.id(); // add current node to the current options object and call degreeCentrality\n                    options.root = _node;\n                    var _currDegree = this.degreeCentrality(options);\n                    if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n                    if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n                    indegrees[id] = _currDegree.indegree;\n                    outdegrees[id] = _currDegree.outdegree;\n                }\n                return {\n                    indegree: function indegree(node) {\n                        if (maxIndegree == 0) {\n                            return 0;\n                        }\n                        if (string(node)) {\n                            // from is a selector string\n                            node = cy.filter(node);\n                        }\n                        return indegrees[node.id()] / maxIndegree;\n                    },\n                    outdegree: function outdegree(node) {\n                        if (maxOutdegree === 0) {\n                            return 0;\n                        }\n                        if (string(node)) {\n                            // from is a selector string\n                            node = cy.filter(node);\n                        }\n                        return outdegrees[node.id()] / maxOutdegree;\n                    }\n                };\n            }\n        },\n        // degreeCentralityNormalized\n        // Implemented from the algorithm in Opsahl's paper\n        // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n        // check the heading 2 \"Degree\"\n        degreeCentrality: function degreeCentrality(options) {\n            options = defaults$f(options);\n            var cy = this.cy();\n            var callingEles = this;\n            var _options = options, root = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;\n            root = cy.collection(root)[0];\n            if (!directed) {\n                var connEdges = root.connectedEdges().intersection(callingEles);\n                var k = connEdges.length;\n                var s = 0; // Now, sum edge weights\n                for(var i = 0; i < connEdges.length; i++){\n                    s += weight(connEdges[i]);\n                }\n                return {\n                    degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n                };\n            } else {\n                var edges = root.connectedEdges();\n                var incoming = edges.filter(function(edge) {\n                    return edge.target().same(root) && callingEles.has(edge);\n                });\n                var outgoing = edges.filter(function(edge) {\n                    return edge.source().same(root) && callingEles.has(edge);\n                });\n                var k_in = incoming.length;\n                var k_out = outgoing.length;\n                var s_in = 0;\n                var s_out = 0; // Now, sum incoming edge weights\n                for(var _i2 = 0; _i2 < incoming.length; _i2++){\n                    s_in += weight(incoming[_i2]);\n                } // Now, sum outgoing edge weights\n                for(var _i3 = 0; _i3 < outgoing.length; _i3++){\n                    s_out += weight(outgoing[_i3]);\n                }\n                return {\n                    indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n                    outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n                };\n            }\n        } // degreeCentrality\n    }; // elesfn\n    // nice, short mathematical alias\n    elesfn$n.dc = elesfn$n.degreeCentrality;\n    elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\n    var defaults$e = defaults$g({\n        harmonic: true,\n        weight: function weight() {\n            return 1;\n        },\n        directed: false,\n        root: null\n    });\n    var elesfn$m = {\n        closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n            var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;\n            var cy = this.cy();\n            var closenesses = {};\n            var maxCloseness = 0;\n            var nodes = this.nodes();\n            var fw = this.floydWarshall({\n                weight: weight,\n                directed: directed\n            }); // Compute closeness for every node and find the maximum closeness\n            for(var i = 0; i < nodes.length; i++){\n                var currCloseness = 0;\n                var node_i = nodes[i];\n                for(var j = 0; j < nodes.length; j++){\n                    if (i !== j) {\n                        var d = fw.distance(node_i, nodes[j]);\n                        if (harmonic) {\n                            currCloseness += 1 / d;\n                        } else {\n                            currCloseness += d;\n                        }\n                    }\n                }\n                if (!harmonic) {\n                    currCloseness = 1 / currCloseness;\n                }\n                if (maxCloseness < currCloseness) {\n                    maxCloseness = currCloseness;\n                }\n                closenesses[node_i.id()] = currCloseness;\n            }\n            return {\n                closeness: function closeness(node) {\n                    if (maxCloseness == 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node)[0].id();\n                    } else {\n                        // from is a node\n                        node = node.id();\n                    }\n                    return closenesses[node] / maxCloseness;\n                }\n            };\n        },\n        // Implemented from pseudocode from wikipedia\n        closenessCentrality: function closenessCentrality(options) {\n            var _defaults2 = defaults$e(options), root = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;\n            root = this.filter(root)[0]; // we need distance from this node to every other node\n            var dijkstra = this.dijkstra({\n                root: root,\n                weight: weight,\n                directed: directed\n            });\n            var totalDistance = 0;\n            var nodes = this.nodes();\n            for(var i = 0; i < nodes.length; i++){\n                var n = nodes[i];\n                if (!n.same(root)) {\n                    var d = dijkstra.distanceTo(n);\n                    if (harmonic) {\n                        totalDistance += 1 / d;\n                    } else {\n                        totalDistance += d;\n                    }\n                }\n            }\n            return harmonic ? totalDistance : 1 / totalDistance;\n        } // closenessCentrality\n    }; // elesfn\n    // nice, short mathematical alias\n    elesfn$m.cc = elesfn$m.closenessCentrality;\n    elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\n    var defaults$d = defaults$g({\n        weight: null,\n        directed: false\n    });\n    var elesfn$l = {\n        // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n        betweennessCentrality: function betweennessCentrality(options) {\n            var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;\n            var weighted = weight != null;\n            var cy = this.cy(); // starting\n            var V = this.nodes();\n            var A = {};\n            var _C = {};\n            var max = 0;\n            var C = {\n                set: function set(key, val) {\n                    _C[key] = val;\n                    if (val > max) {\n                        max = val;\n                    }\n                },\n                get: function get(key) {\n                    return _C[key];\n                }\n            }; // A contains the neighborhoods of every node\n            for(var i = 0; i < V.length; i++){\n                var v = V[i];\n                var vid = v.id();\n                if (directed) {\n                    A[vid] = v.outgoers().nodes(); // get outgoers of every node\n                } else {\n                    A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n                }\n                C.set(vid, 0);\n            }\n            var _loop = function _loop(s) {\n                var sid = V[s].id();\n                var S = []; // stack\n                var P = {};\n                var g = {};\n                var d = {};\n                var Q = new heap(function(a, b) {\n                    return d[a] - d[b];\n                }); // queue\n                // init dictionaries\n                for(var _i = 0; _i < V.length; _i++){\n                    var _vid = V[_i].id();\n                    P[_vid] = [];\n                    g[_vid] = 0;\n                    d[_vid] = Infinity;\n                }\n                g[sid] = 1; // sigma\n                d[sid] = 0; // distance to s\n                Q.push(sid);\n                while(!Q.empty()){\n                    var _v = Q.pop();\n                    S.push(_v);\n                    if (weighted) {\n                        for(var j = 0; j < A[_v].length; j++){\n                            var w = A[_v][j];\n                            var vEle = cy.getElementById(_v);\n                            var edge = void 0;\n                            if (vEle.edgesTo(w).length > 0) {\n                                edge = vEle.edgesTo(w)[0];\n                            } else {\n                                edge = w.edgesTo(vEle)[0];\n                            }\n                            var edgeWeight = weight(edge);\n                            w = w.id();\n                            if (d[w] > d[_v] + edgeWeight) {\n                                d[w] = d[_v] + edgeWeight;\n                                if (Q.nodes.indexOf(w) < 0) {\n                                    //if w is not in Q\n                                    Q.push(w);\n                                } else {\n                                    // update position if w is in Q\n                                    Q.updateItem(w);\n                                }\n                                g[w] = 0;\n                                P[w] = [];\n                            }\n                            if (d[w] == d[_v] + edgeWeight) {\n                                g[w] = g[w] + g[_v];\n                                P[w].push(_v);\n                            }\n                        }\n                    } else {\n                        for(var _j = 0; _j < A[_v].length; _j++){\n                            var _w = A[_v][_j].id();\n                            if (d[_w] == Infinity) {\n                                Q.push(_w);\n                                d[_w] = d[_v] + 1;\n                            }\n                            if (d[_w] == d[_v] + 1) {\n                                g[_w] = g[_w] + g[_v];\n                                P[_w].push(_v);\n                            }\n                        }\n                    }\n                }\n                var e = {};\n                for(var _i2 = 0; _i2 < V.length; _i2++){\n                    e[V[_i2].id()] = 0;\n                }\n                while(S.length > 0){\n                    var _w2 = S.pop();\n                    for(var _j2 = 0; _j2 < P[_w2].length; _j2++){\n                        var _v2 = P[_w2][_j2];\n                        e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n                    }\n                    if (_w2 != V[s].id()) {\n                        C.set(_w2, C.get(_w2) + e[_w2]);\n                    }\n                }\n            };\n            for(var s = 0; s < V.length; s++){\n                _loop(s);\n            }\n            var ret = {\n                betweenness: function betweenness(node) {\n                    var id = cy.collection(node).id();\n                    return C.get(id);\n                },\n                betweennessNormalized: function betweennessNormalized(node) {\n                    if (max == 0) {\n                        return 0;\n                    }\n                    var id = cy.collection(node).id();\n                    return C.get(id) / max;\n                }\n            }; // alias\n            ret.betweennessNormalised = ret.betweennessNormalized;\n            return ret;\n        } // betweennessCentrality\n    }; // elesfn\n    // nice, short mathematical alias\n    elesfn$l.bc = elesfn$l.betweennessCentrality;\n    // Implemented by Zoe Xi @zoexi for GSOC 2016\n    /* eslint-disable no-unused-vars */ var defaults$c = defaults$g({\n        expandFactor: 2,\n        // affects time of computation and cluster granularity to some extent: M * M\n        inflateFactor: 2,\n        // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n        multFactor: 1,\n        // optional self loops for each node. Use a neutral value to improve cluster computations.\n        maxIterations: 20,\n        // maximum number of iterations of the MCL algorithm in a single run\n        attributes: [\n            function(edge) {\n                return 1;\n            }\n        ]\n    });\n    /* eslint-enable */ var setOptions$3 = function setOptions(options) {\n        return defaults$c(options);\n    };\n    /* eslint-enable */ var getSimilarity$1 = function getSimilarity(edge, attributes) {\n        var total = 0;\n        for(var i = 0; i < attributes.length; i++){\n            total += attributes[i](edge);\n        }\n        return total;\n    };\n    var addLoops = function addLoops(M, n, val) {\n        for(var i = 0; i < n; i++){\n            M[i * n + i] = val;\n        }\n    };\n    var normalize = function normalize(M, n) {\n        var sum;\n        for(var col = 0; col < n; col++){\n            sum = 0;\n            for(var row = 0; row < n; row++){\n                sum += M[row * n + col];\n            }\n            for(var _row = 0; _row < n; _row++){\n                M[_row * n + col] = M[_row * n + col] / sum;\n            }\n        }\n    }; // TODO: blocked matrix multiplication?\n    var mmult = function mmult(A, B, n) {\n        var C = new Array(n * n);\n        for(var i = 0; i < n; i++){\n            for(var j = 0; j < n; j++){\n                C[i * n + j] = 0;\n            }\n            for(var k = 0; k < n; k++){\n                for(var _j = 0; _j < n; _j++){\n                    C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n                }\n            }\n        }\n        return C;\n    };\n    var expand = function expand(M, n, expandFactor) {\n        var _M = M.slice(0);\n        for(var p = 1; p < expandFactor; p++){\n            M = mmult(M, _M, n);\n        }\n        return M;\n    };\n    var inflate = function inflate(M, n, inflateFactor) {\n        var _M = new Array(n * n); // M(i,j) ^ inflatePower\n        for(var i = 0; i < n * n; i++){\n            _M[i] = Math.pow(M[i], inflateFactor);\n        }\n        normalize(_M, n);\n        return _M;\n    };\n    var hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n        // Check that both matrices have the same elements (i,j)\n        for(var i = 0; i < n2; i++){\n            var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n            var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n            if (v1 !== v2) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var assign$2 = function assign(M, n, nodes, cy) {\n        var clusters = [];\n        for(var i = 0; i < n; i++){\n            var cluster = [];\n            for(var j = 0; j < n; j++){\n                // Row-wise attractors and elements that they attract belong in same cluster\n                if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n                    cluster.push(nodes[j]);\n                }\n            }\n            if (cluster.length !== 0) {\n                clusters.push(cy.collection(cluster));\n            }\n        }\n        return clusters;\n    };\n    var isDuplicate = function isDuplicate(c1, c2) {\n        for(var i = 0; i < c1.length; i++){\n            if (!c2[i] || c1[i].id() !== c2[i].id()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var removeDuplicates = function removeDuplicates(clusters) {\n        for(var i = 0; i < clusters.length; i++){\n            for(var j = 0; j < clusters.length; j++){\n                if (i != j && isDuplicate(clusters[i], clusters[j])) {\n                    clusters.splice(j, 1);\n                }\n            }\n        }\n        return clusters;\n    };\n    var markovClustering = function markovClustering(options) {\n        var nodes = this.nodes();\n        var edges = this.edges();\n        var cy = this.cy(); // Set parameters of algorithm:\n        var opts = setOptions$3(options); // Map each node to its position in node array\n        var id2position = {};\n        for(var i = 0; i < nodes.length; i++){\n            id2position[nodes[i].id()] = i;\n        } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n        var n = nodes.length, n2 = n * n;\n        var M = new Array(n2), _M;\n        for(var _i = 0; _i < n2; _i++){\n            M[_i] = 0;\n        }\n        for(var e = 0; e < edges.length; e++){\n            var edge = edges[e];\n            var _i2 = id2position[edge.source().id()];\n            var j = id2position[edge.target().id()];\n            var sim = getSimilarity$1(edge, opts.attributes);\n            M[_i2 * n + j] += sim; // G should be symmetric and undirected\n            M[j * n + _i2] += sim;\n        } // Begin Markov cluster algorithm\n        // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n        addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );\n        normalize(M, n);\n        var isStillMoving = true;\n        var iterations = 0;\n        while(isStillMoving && iterations < opts.maxIterations){\n            isStillMoving = false; // Step 3:\n            _M = expand(M, n, opts.expandFactor); // Step 4:\n            M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached\n            if (!hasConverged(M, _M, n2, 4)) {\n                isStillMoving = true;\n            }\n            iterations++;\n        } // Build clusters from matrix\n        var clusters = assign$2(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix\n        clusters = removeDuplicates(clusters);\n        return clusters;\n    };\n    var markovClustering$1 = {\n        markovClustering: markovClustering,\n        mcl: markovClustering\n    };\n    // Common distance metrics for clustering algorithms\n    var identity = function identity(x) {\n        return x;\n    };\n    var absDiff = function absDiff(p, q) {\n        return Math.abs(q - p);\n    };\n    var addAbsDiff = function addAbsDiff(total, p, q) {\n        return total + absDiff(p, q);\n    };\n    var addSquaredDiff = function addSquaredDiff(total, p, q) {\n        return total + Math.pow(q - p, 2);\n    };\n    var sqrt = function sqrt(x) {\n        return Math.sqrt(x);\n    };\n    var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n        return Math.max(currentMax, absDiff(p, q));\n    };\n    var getDistance = function getDistance(length, getP, getQ, init, visit) {\n        var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n        var ret = init;\n        var p, q;\n        for(var dim = 0; dim < length; dim++){\n            p = getP(dim);\n            q = getQ(dim);\n            ret = visit(ret, p, q);\n        }\n        return post(ret);\n    };\n    var distances = {\n        euclidean: function euclidean(length, getP, getQ) {\n            if (length >= 2) {\n                return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n            } else {\n                // for single attr case, more efficient to avoid sqrt\n                return getDistance(length, getP, getQ, 0, addAbsDiff);\n            }\n        },\n        squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n            return getDistance(length, getP, getQ, 0, addSquaredDiff);\n        },\n        manhattan: function manhattan(length, getP, getQ) {\n            return getDistance(length, getP, getQ, 0, addAbsDiff);\n        },\n        max: function max(length, getP, getQ) {\n            return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n        }\n    }; // in case the user accidentally doesn't use camel case\n    distances[\"squared-euclidean\"] = distances[\"squaredEuclidean\"];\n    distances[\"squaredeuclidean\"] = distances[\"squaredEuclidean\"];\n    function clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {\n        var impl;\n        if (fn$6(method)) {\n            impl = method;\n        } else {\n            impl = distances[method] || distances.euclidean;\n        }\n        if (length === 0 && fn$6(method)) {\n            return impl(nodeP, nodeQ);\n        } else {\n            return impl(length, getP, getQ, nodeP, nodeQ);\n        }\n    }\n    var defaults$b = defaults$g({\n        k: 2,\n        m: 2,\n        sensitivityThreshold: 0.0001,\n        distance: \"euclidean\",\n        maxIterations: 10,\n        attributes: [],\n        testMode: false,\n        testCentroids: null\n    });\n    var setOptions$2 = function setOptions(options) {\n        return defaults$b(options);\n    };\n    /* eslint-enable */ var getDist = function getDist(type, node, centroid, attributes, mode) {\n        var noNodeP = mode !== \"kMedoids\";\n        var getP = noNodeP ? function(i) {\n            return centroid[i];\n        } : function(i) {\n            return attributes[i](centroid);\n        };\n        var getQ = function getQ(i) {\n            return attributes[i](node);\n        };\n        var nodeP = centroid;\n        var nodeQ = node;\n        return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n    };\n    var randomCentroids = function randomCentroids(nodes, k, attributes) {\n        var ndim = attributes.length;\n        var min = new Array(ndim);\n        var max = new Array(ndim);\n        var centroids = new Array(k);\n        var centroid = null; // Find min, max values for each attribute dimension\n        for(var i = 0; i < ndim; i++){\n            min[i] = nodes.min(attributes[i]).value;\n            max[i] = nodes.max(attributes[i]).value;\n        } // Build k centroids, each represented as an n-dim feature vector\n        for(var c = 0; c < k; c++){\n            centroid = [];\n            for(var _i = 0; _i < ndim; _i++){\n                centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n            }\n            centroids[c] = centroid;\n        }\n        return centroids;\n    };\n    var classify = function classify(node, centroids, distance, attributes, type) {\n        var min = Infinity;\n        var index = 0;\n        for(var i = 0; i < centroids.length; i++){\n            var dist = getDist(distance, node, centroids[i], attributes, type);\n            if (dist < min) {\n                min = dist;\n                index = i;\n            }\n        }\n        return index;\n    };\n    var buildCluster = function buildCluster(centroid, nodes, assignment) {\n        var cluster = [];\n        var node = null;\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            if (assignment[node.id()] === centroid) {\n                //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n                cluster.push(node);\n            }\n        }\n        return cluster;\n    };\n    var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n        return Math.abs(v2 - v1) <= sensitivityThreshold;\n    };\n    var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n        for(var i = 0; i < v1.length; i++){\n            for(var j = 0; j < v1[i].length; j++){\n                var diff = Math.abs(v1[i][j] - v2[i][j]);\n                if (diff > sensitivityThreshold) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    var seenBefore = function seenBefore(node, medoids, n) {\n        for(var i = 0; i < n; i++){\n            if (node === medoids[i]) return true;\n        }\n        return false;\n    };\n    var randomMedoids = function randomMedoids(nodes, k) {\n        var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,\n        // so we need to check to see if we've already seen or chose this node before.\n        if (nodes.length < 50) {\n            // Randomly select k medoids from the n nodes\n            for(var i = 0; i < k; i++){\n                var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n                // Instead choose a different random node.\n                while(seenBefore(node, medoids, i)){\n                    node = nodes[Math.floor(Math.random() * nodes.length)];\n                }\n                medoids[i] = node;\n            }\n        } else {\n            // Relatively large data set, so pretty safe to not check and just select random nodes\n            for(var _i2 = 0; _i2 < k; _i2++){\n                medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n            }\n        }\n        return medoids;\n    };\n    var findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n        var cost = 0;\n        for(var n = 0; n < cluster.length; n++){\n            cost += getDist(\"manhattan\", cluster[n], potentialNewMedoid, attributes, \"kMedoids\");\n        }\n        return cost;\n    };\n    var kMeans = function kMeans(options) {\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.\n        var opts = setOptions$2(options); // Begin k-means algorithm\n        var clusters = new Array(opts.k);\n        var assignment = {};\n        var centroids; // Step 1: Initialize centroid positions\n        if (opts.testMode) {\n            if (typeof opts.testCentroids === \"number\") {\n                // TODO: implement a seeded random number generator.\n                opts.testCentroids;\n                centroids = randomCentroids(nodes, opts.k, opts.attributes);\n            } else if (_typeof(opts.testCentroids) === \"object\") {\n                centroids = opts.testCentroids;\n            } else {\n                centroids = randomCentroids(nodes, opts.k, opts.attributes);\n            }\n        } else {\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        }\n        var isStillMoving = true;\n        var iterations = 0;\n        while(isStillMoving && iterations < opts.maxIterations){\n            // Step 2: Assign nodes to the nearest centroid\n            for(var n = 0; n < nodes.length; n++){\n                node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n                assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, \"kMeans\");\n            } // Step 3: For each of the k clusters, update its centroid\n            isStillMoving = false;\n            for(var c = 0; c < opts.k; c++){\n                // Get all nodes that belong to this cluster\n                var cluster = buildCluster(c, nodes, assignment);\n                if (cluster.length === 0) {\n                    continue;\n                } // Update centroids by calculating avg of all nodes within the cluster.\n                var ndim = opts.attributes.length;\n                var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n                var newCentroid = new Array(ndim);\n                var sum = new Array(ndim);\n                for(var d = 0; d < ndim; d++){\n                    sum[d] = 0.0;\n                    for(var i = 0; i < cluster.length; i++){\n                        node = cluster[i];\n                        sum[d] += opts.attributes[d](node);\n                    }\n                    newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change\n                    if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n                        isStillMoving = true;\n                    }\n                }\n                centroids[c] = newCentroid;\n                clusters[c] = cy.collection(cluster);\n            }\n            iterations++;\n        }\n        return clusters;\n    };\n    var kMedoids = function kMedoids(options) {\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var node = null;\n        var opts = setOptions$2(options); // Begin k-medoids algorithm\n        var clusters = new Array(opts.k);\n        var medoids;\n        var assignment = {};\n        var curCost;\n        var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n        // Step 1: Initialize k medoids\n        if (opts.testMode) {\n            if (typeof opts.testCentroids === \"number\") ;\n            else if (_typeof(opts.testCentroids) === \"object\") {\n                medoids = opts.testCentroids;\n            } else {\n                medoids = randomMedoids(nodes, opts.k);\n            }\n        } else {\n            medoids = randomMedoids(nodes, opts.k);\n        }\n        var isStillMoving = true;\n        var iterations = 0;\n        while(isStillMoving && iterations < opts.maxIterations){\n            // Step 2: Assign nodes to the nearest medoid\n            for(var n = 0; n < nodes.length; n++){\n                node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n                assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, \"kMedoids\");\n            }\n            isStillMoving = false; // Step 3: For each medoid m, and for each node associated with mediod m,\n            // select the node with the lowest configuration cost as new medoid.\n            for(var m1 = 0; m1 < medoids.length; m1++){\n                // Get all nodes that belong to this medoid\n                var cluster = buildCluster(m1, nodes, assignment);\n                if (cluster.length === 0) {\n                    continue;\n                }\n                minCosts[m1] = findCost(medoids[m1], cluster, opts.attributes); // original cost\n                // Select different medoid if its configuration has the lowest cost\n                for(var _n = 0; _n < cluster.length; _n++){\n                    curCost = findCost(cluster[_n], cluster, opts.attributes);\n                    if (curCost < minCosts[m1]) {\n                        minCosts[m1] = curCost;\n                        medoids[m1] = cluster[_n];\n                        isStillMoving = true;\n                    }\n                }\n                clusters[m1] = cy.collection(cluster);\n            }\n            iterations++;\n        }\n        return clusters;\n    };\n    var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n        var numerator, denominator;\n        for(var n = 0; n < nodes.length; n++){\n            for(var c = 0; c < centroids.length; c++){\n                weight[n][c] = Math.pow(U[n][c], opts.m);\n            }\n        }\n        for(var _c = 0; _c < centroids.length; _c++){\n            for(var dim = 0; dim < opts.attributes.length; dim++){\n                numerator = 0;\n                denominator = 0;\n                for(var _n2 = 0; _n2 < nodes.length; _n2++){\n                    numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n                    denominator += weight[_n2][_c];\n                }\n                centroids[_c][dim] = numerator / denominator;\n            }\n        }\n    };\n    var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n        // Save previous step\n        for(var i = 0; i < U.length; i++){\n            _U[i] = U[i].slice();\n        }\n        var sum, numerator, denominator;\n        var pow = 2 / (opts.m - 1);\n        for(var c = 0; c < centroids.length; c++){\n            for(var n = 0; n < nodes.length; n++){\n                sum = 0;\n                for(var k = 0; k < centroids.length; k++){\n                    // against all other centroids\n                    numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, \"cmeans\");\n                    denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, \"cmeans\");\n                    sum += Math.pow(numerator / denominator, pow);\n                }\n                U[n][c] = 1 / sum;\n            }\n        }\n    };\n    var assign$1 = function assign(nodes, U, opts, cy) {\n        var clusters = new Array(opts.k);\n        for(var c = 0; c < clusters.length; c++){\n            clusters[c] = [];\n        }\n        var max;\n        var index;\n        for(var n = 0; n < U.length; n++){\n            // for each node (U is N x C matrix)\n            max = -Infinity;\n            index = -1; // Determine which cluster the node is most likely to belong in\n            for(var _c2 = 0; _c2 < U[0].length; _c2++){\n                if (U[n][_c2] > max) {\n                    max = U[n][_c2];\n                    index = _c2;\n                }\n            }\n            clusters[index].push(nodes[n]);\n        } // Turn every array into a collection of nodes\n        for(var _c3 = 0; _c3 < clusters.length; _c3++){\n            clusters[_c3] = cy.collection(clusters[_c3]);\n        }\n        return clusters;\n    };\n    var fuzzyCMeans = function fuzzyCMeans(options) {\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var opts = setOptions$2(options); // Begin fuzzy c-means algorithm\n        var clusters;\n        var centroids;\n        var U;\n        var _U;\n        var weight; // Step 1: Initialize letiables.\n        _U = new Array(nodes.length);\n        for(var i = 0; i < nodes.length; i++){\n            // N x C matrix\n            _U[i] = new Array(opts.k);\n        }\n        U = new Array(nodes.length);\n        for(var _i3 = 0; _i3 < nodes.length; _i3++){\n            // N x C matrix\n            U[_i3] = new Array(opts.k);\n        }\n        for(var _i4 = 0; _i4 < nodes.length; _i4++){\n            var total = 0;\n            for(var j = 0; j < opts.k; j++){\n                U[_i4][j] = Math.random();\n                total += U[_i4][j];\n            }\n            for(var _j = 0; _j < opts.k; _j++){\n                U[_i4][_j] = U[_i4][_j] / total;\n            }\n        }\n        centroids = new Array(opts.k);\n        for(var _i5 = 0; _i5 < opts.k; _i5++){\n            centroids[_i5] = new Array(opts.attributes.length);\n        }\n        weight = new Array(nodes.length);\n        for(var _i6 = 0; _i6 < nodes.length; _i6++){\n            // N x C matrix\n            weight[_i6] = new Array(opts.k);\n        } // end init FCM\n        var isStillMoving = true;\n        var iterations = 0;\n        while(isStillMoving && iterations < opts.maxIterations){\n            isStillMoving = false; // Step 2: Calculate the centroids for each step.\n            updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.\n            updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.\n            if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n                isStillMoving = true;\n            }\n            iterations++;\n        } // Assign nodes to clusters with highest probability.\n        clusters = assign$1(nodes, U, opts, cy);\n        return {\n            clusters: clusters,\n            degreeOfMembership: U\n        };\n    };\n    var kClustering = {\n        kMeans: kMeans,\n        kMedoids: kMedoids,\n        fuzzyCMeans: fuzzyCMeans,\n        fcm: fuzzyCMeans\n    };\n    // Implemented by Zoe Xi @zoexi for GSOC 2016\n    var defaults$a = defaults$g({\n        distance: \"euclidean\",\n        // distance metric to compare nodes\n        linkage: \"min\",\n        // linkage criterion : how to determine the distance between clusters of nodes\n        mode: \"threshold\",\n        // mode:'threshold' => clusters must be threshold distance apart\n        threshold: Infinity,\n        // the distance threshold\n        // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n        addDendrogram: false,\n        // whether to add the dendrogram to the graph for viz\n        dendrogramDepth: 0,\n        // depth at which dendrogram branches are merged into the returned clusters\n        attributes: [] // array of attr functions\n    });\n    var linkageAliases = {\n        \"single\": \"min\",\n        \"complete\": \"max\"\n    };\n    var setOptions$1 = function setOptions(options) {\n        var opts = defaults$a(options);\n        var preferredAlias = linkageAliases[opts.linkage];\n        if (preferredAlias != null) {\n            opts.linkage = preferredAlias;\n        }\n        return opts;\n    };\n    var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n        // Find two closest clusters from cached mins\n        var minKey = 0;\n        var min = Infinity;\n        var dist;\n        var attrs = opts.attributes;\n        var getDist = function getDist(n1, n2) {\n            return clusteringDistance(opts.distance, attrs.length, function(i) {\n                return attrs[i](n1);\n            }, function(i) {\n                return attrs[i](n2);\n            }, n1, n2);\n        };\n        for(var i = 0; i < clusters.length; i++){\n            var key = clusters[i].key;\n            var _dist = dists[key][mins[key]];\n            if (_dist < min) {\n                minKey = key;\n                min = _dist;\n            }\n        }\n        if (opts.mode === \"threshold\" && min >= opts.threshold || opts.mode === \"dendrogram\" && clusters.length === 1) {\n            return false;\n        }\n        var c1 = index[minKey];\n        var c2 = index[mins[minKey]];\n        var merged; // Merge two closest clusters\n        if (opts.mode === \"dendrogram\") {\n            merged = {\n                left: c1,\n                right: c2,\n                key: c1.key\n            };\n        } else {\n            merged = {\n                value: c1.value.concat(c2.value),\n                key: c1.key\n            };\n        }\n        clusters[c1.index] = merged;\n        clusters.splice(c2.index, 1);\n        index[c1.key] = merged; // Update distances with new merged cluster\n        for(var _i = 0; _i < clusters.length; _i++){\n            var cur = clusters[_i];\n            if (c1.key === cur.key) {\n                dist = Infinity;\n            } else if (opts.linkage === \"min\") {\n                dist = dists[c1.key][cur.key];\n                if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n                    dist = dists[c2.key][cur.key];\n                }\n            } else if (opts.linkage === \"max\") {\n                dist = dists[c1.key][cur.key];\n                if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n                    dist = dists[c2.key][cur.key];\n                }\n            } else if (opts.linkage === \"mean\") {\n                dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n            } else {\n                if (opts.mode === \"dendrogram\") dist = getDist(cur.value, c1.value);\n                else dist = getDist(cur.value[0], c1.value[0]);\n            }\n            dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n        } // Update cached mins\n        for(var _i2 = 0; _i2 < clusters.length; _i2++){\n            var key1 = clusters[_i2].key;\n            if (mins[key1] === c1.key || mins[key1] === c2.key) {\n                var _min = key1;\n                for(var j = 0; j < clusters.length; j++){\n                    var key2 = clusters[j].key;\n                    if (dists[key1][key2] < dists[key1][_min]) {\n                        _min = key2;\n                    }\n                }\n                mins[key1] = _min;\n            }\n            clusters[_i2].index = _i2;\n        } // Clean up meta data used for clustering\n        c1.key = c2.key = c1.index = c2.index = null;\n        return true;\n    };\n    var getAllChildren = function getAllChildren(root, arr, cy) {\n        if (!root) return;\n        if (root.value) {\n            arr.push(root.value);\n        } else {\n            if (root.left) getAllChildren(root.left, arr);\n            if (root.right) getAllChildren(root.right, arr);\n        }\n    };\n    var buildDendrogram = function buildDendrogram(root, cy) {\n        if (!root) return \"\";\n        if (root.left && root.right) {\n            var leftStr = buildDendrogram(root.left, cy);\n            var rightStr = buildDendrogram(root.right, cy);\n            var node = cy.add({\n                group: \"nodes\",\n                data: {\n                    id: leftStr + \",\" + rightStr\n                }\n            });\n            cy.add({\n                group: \"edges\",\n                data: {\n                    source: leftStr,\n                    target: node.id()\n                }\n            });\n            cy.add({\n                group: \"edges\",\n                data: {\n                    source: rightStr,\n                    target: node.id()\n                }\n            });\n            return node.id();\n        } else if (root.value) {\n            return root.value.id();\n        }\n    };\n    var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n        if (!root) return [];\n        var left = [], right = [], leaves = [];\n        if (k === 0) {\n            // don't cut tree, simply return all nodes as 1 single cluster\n            if (root.left) getAllChildren(root.left, left);\n            if (root.right) getAllChildren(root.right, right);\n            leaves = left.concat(right);\n            return [\n                cy.collection(leaves)\n            ];\n        } else if (k === 1) {\n            // cut at root\n            if (root.value) {\n                // leaf node\n                return [\n                    cy.collection(root.value)\n                ];\n            } else {\n                if (root.left) getAllChildren(root.left, left);\n                if (root.right) getAllChildren(root.right, right);\n                return [\n                    cy.collection(left),\n                    cy.collection(right)\n                ];\n            }\n        } else {\n            if (root.value) {\n                return [\n                    cy.collection(root.value)\n                ];\n            } else {\n                if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);\n                if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);\n                return left.concat(right);\n            }\n        }\n    };\n    /* eslint-enable */ var hierarchicalClustering = function hierarchicalClustering(options) {\n        var cy = this.cy();\n        var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.\n        var opts = setOptions$1(options);\n        var attrs = opts.attributes;\n        var getDist = function getDist(n1, n2) {\n            return clusteringDistance(opts.distance, attrs.length, function(i) {\n                return attrs[i](n1);\n            }, function(i) {\n                return attrs[i](n2);\n            }, n1, n2);\n        }; // Begin hierarchical algorithm\n        var clusters = [];\n        var dists = []; // distances between each pair of clusters\n        var mins = []; // closest cluster for each cluster\n        var index = []; // hash of all clusters by key\n        // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n        for(var n = 0; n < nodes.length; n++){\n            var cluster = {\n                value: opts.mode === \"dendrogram\" ? nodes[n] : [\n                    nodes[n]\n                ],\n                key: n,\n                index: n\n            };\n            clusters[n] = cluster;\n            index[n] = cluster;\n            dists[n] = [];\n            mins[n] = 0;\n        } // Calculate the distance between each pair of clusters\n        for(var i = 0; i < clusters.length; i++){\n            for(var j = 0; j <= i; j++){\n                var dist = void 0;\n                if (opts.mode === \"dendrogram\") {\n                    // modes store cluster values differently\n                    dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n                } else {\n                    dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n                }\n                dists[i][j] = dist;\n                dists[j][i] = dist;\n                if (dist < dists[i][mins[i]]) {\n                    mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n                }\n            }\n        } // Find the closest pair of clusters and merge them into a single cluster.\n        // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n        var merged = mergeClosest(clusters, index, dists, mins, opts);\n        while(merged){\n            merged = mergeClosest(clusters, index, dists, mins, opts);\n        }\n        var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n        // in addition to returning the clusters.\n        if (opts.mode === \"dendrogram\") {\n            retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n            if (opts.addDendrogram) buildDendrogram(clusters[0], cy);\n        } else {\n            // Regular mode simply returns the clusters\n            retClusters = new Array(clusters.length);\n            clusters.forEach(function(cluster, i) {\n                // Clean up meta data used for clustering\n                cluster.key = cluster.index = null;\n                retClusters[i] = cy.collection(cluster.value);\n            });\n        }\n        return retClusters;\n    };\n    var hierarchicalClustering$1 = {\n        hierarchicalClustering: hierarchicalClustering,\n        hca: hierarchicalClustering\n    };\n    // Implemented by Zoe Xi @zoexi for GSOC 2016\n    var defaults$9 = defaults$g({\n        distance: \"euclidean\",\n        // distance metric to compare attributes between two nodes\n        preference: \"median\",\n        // suitability of a data point to serve as an exemplar\n        damping: 0.8,\n        // damping factor between [0.5, 1)\n        maxIterations: 1000,\n        // max number of iterations to run\n        minIterations: 100,\n        // min number of iterations to run in order for clustering to stop\n        attributes: []\n    });\n    var setOptions = function setOptions(options) {\n        var dmp = options.damping;\n        var pref = options.preference;\n        if (!(0.5 <= dmp && dmp < 1)) {\n            error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n        }\n        var validPrefs = [\n            \"median\",\n            \"mean\",\n            \"min\",\n            \"max\"\n        ];\n        if (!(validPrefs.some(function(v) {\n            return v === pref;\n        }) || number$1(pref))) {\n            error(\"Preference must be one of [\".concat(validPrefs.map(function(p) {\n                return \"'\".concat(p, \"'\");\n            }).join(\", \"), \"] or a number.  Got: \").concat(pref));\n        }\n        return defaults$9(options);\n    };\n    /* eslint-enable */ var getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n        var attr = function attr(n, i) {\n            return attributes[i](n);\n        }; // nb negative because similarity should have an inverse relationship to distance\n        return -clusteringDistance(type, attributes.length, function(i) {\n            return attr(n1, i);\n        }, function(i) {\n            return attr(n2, i);\n        }, n1, n2);\n    };\n    var getPreference = function getPreference(S, preference) {\n        // larger preference = greater # of clusters\n        var p = null;\n        if (preference === \"median\") {\n            p = median(S);\n        } else if (preference === \"mean\") {\n            p = mean(S);\n        } else if (preference === \"min\") {\n            p = min(S);\n        } else if (preference === \"max\") {\n            p = max(S);\n        } else {\n            // Custom preference number, as set by user\n            p = preference;\n        }\n        return p;\n    };\n    var findExemplars = function findExemplars(n, R, A) {\n        var indices = [];\n        for(var i = 0; i < n; i++){\n            if (R[i * n + i] + A[i * n + i] > 0) {\n                indices.push(i);\n            }\n        }\n        return indices;\n    };\n    var assignClusters = function assignClusters(n, S, exemplars) {\n        var clusters = [];\n        for(var i = 0; i < n; i++){\n            var index = -1;\n            var max = -Infinity;\n            for(var ei = 0; ei < exemplars.length; ei++){\n                var e = exemplars[ei];\n                if (S[i * n + e] > max) {\n                    index = e;\n                    max = S[i * n + e];\n                }\n            }\n            if (index > 0) {\n                clusters.push(index);\n            }\n        }\n        for(var _ei = 0; _ei < exemplars.length; _ei++){\n            clusters[exemplars[_ei]] = exemplars[_ei];\n        }\n        return clusters;\n    };\n    var assign = function assign(n, S, exemplars) {\n        var clusters = assignClusters(n, S, exemplars);\n        for(var ei = 0; ei < exemplars.length; ei++){\n            var ii = [];\n            for(var c = 0; c < clusters.length; c++){\n                if (clusters[c] === exemplars[ei]) {\n                    ii.push(c);\n                }\n            }\n            var maxI = -1;\n            var maxSum = -Infinity;\n            for(var i = 0; i < ii.length; i++){\n                var sum = 0;\n                for(var j = 0; j < ii.length; j++){\n                    sum += S[ii[j] * n + ii[i]];\n                }\n                if (sum > maxSum) {\n                    maxI = i;\n                    maxSum = sum;\n                }\n            }\n            exemplars[ei] = ii[maxI];\n        }\n        clusters = assignClusters(n, S, exemplars);\n        return clusters;\n    };\n    var affinityPropagation = function affinityPropagation(options) {\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var opts = setOptions(options); // Map each node to its position in node array\n        var id2position = {};\n        for(var i = 0; i < nodes.length; i++){\n            id2position[nodes[i].id()] = i;\n        } // Begin affinity propagation algorithm\n        var n; // number of data points\n        var n2; // size of matrices\n        var S; // similarity matrix (1D array)\n        var p; // preference/suitability of a data point to serve as an exemplar\n        var R; // responsibility matrix (1D array)\n        var A; // availability matrix (1D array)\n        n = nodes.length;\n        n2 = n * n; // Initialize and build S similarity matrix\n        S = new Array(n2);\n        for(var _i = 0; _i < n2; _i++){\n            S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n        }\n        for(var _i2 = 0; _i2 < n; _i2++){\n            for(var j = 0; j < n; j++){\n                if (_i2 !== j) {\n                    S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n                }\n            }\n        } // Place preferences on the diagonal of S\n        p = getPreference(S, opts.preference);\n        for(var _i3 = 0; _i3 < n; _i3++){\n            S[_i3 * n + _i3] = p;\n        } // Initialize R responsibility matrix\n        R = new Array(n2);\n        for(var _i4 = 0; _i4 < n2; _i4++){\n            R[_i4] = 0.0;\n        } // Initialize A availability matrix\n        A = new Array(n2);\n        for(var _i5 = 0; _i5 < n2; _i5++){\n            A[_i5] = 0.0;\n        }\n        var old = new Array(n);\n        var Rp = new Array(n);\n        var se = new Array(n);\n        for(var _i6 = 0; _i6 < n; _i6++){\n            old[_i6] = 0.0;\n            Rp[_i6] = 0.0;\n            se[_i6] = 0;\n        }\n        var e = new Array(n * opts.minIterations);\n        for(var _i7 = 0; _i7 < e.length; _i7++){\n            e[_i7] = 0;\n        }\n        var iter;\n        for(iter = 0; iter < opts.maxIterations; iter++){\n            // main algorithmic loop\n            // Update R responsibility matrix\n            for(var _i8 = 0; _i8 < n; _i8++){\n                var max = -Infinity, max2 = -Infinity, maxI = -1, AS = 0.0;\n                for(var _j = 0; _j < n; _j++){\n                    old[_j] = R[_i8 * n + _j];\n                    AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n                    if (AS >= max) {\n                        max2 = max;\n                        max = AS;\n                        maxI = _j;\n                    } else if (AS > max2) {\n                        max2 = AS;\n                    }\n                }\n                for(var _j2 = 0; _j2 < n; _j2++){\n                    R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n                }\n                R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n            } // Update A availability matrix\n            for(var _i9 = 0; _i9 < n; _i9++){\n                var sum = 0;\n                for(var _j3 = 0; _j3 < n; _j3++){\n                    old[_j3] = A[_j3 * n + _i9];\n                    Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n                    sum += Rp[_j3];\n                }\n                sum -= Rp[_i9];\n                Rp[_i9] = R[_i9 * n + _i9];\n                sum += Rp[_i9];\n                for(var _j4 = 0; _j4 < n; _j4++){\n                    A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n                }\n                A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n            } // Check for convergence\n            var K = 0;\n            for(var _i10 = 0; _i10 < n; _i10++){\n                var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n                e[iter % opts.minIterations * n + _i10] = E;\n                K += E;\n            }\n            if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n                var _sum = 0;\n                for(var _i11 = 0; _i11 < n; _i11++){\n                    se[_i11] = 0;\n                    for(var _j5 = 0; _j5 < opts.minIterations; _j5++){\n                        se[_i11] += e[_j5 * n + _i11];\n                    }\n                    if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n                        _sum++;\n                    }\n                }\n                if (_sum === n) {\n                    break;\n                }\n            }\n        } // Identify exemplars (cluster centers)\n        var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters\n        var clusterIndices = assign(n, S, exemplarsIndices);\n        var clusters = {};\n        for(var c = 0; c < exemplarsIndices.length; c++){\n            clusters[exemplarsIndices[c]] = [];\n        }\n        for(var _i12 = 0; _i12 < nodes.length; _i12++){\n            var pos = id2position[nodes[_i12].id()];\n            var clusterIndex = clusterIndices[pos];\n            if (clusterIndex != null) {\n                // the node may have not been assigned a cluster if no valid attributes were specified\n                clusters[clusterIndex].push(nodes[_i12]);\n            }\n        }\n        var retClusters = new Array(exemplarsIndices.length);\n        for(var _c = 0; _c < exemplarsIndices.length; _c++){\n            retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n        }\n        return retClusters;\n    };\n    var affinityPropagation$1 = {\n        affinityPropagation: affinityPropagation,\n        ap: affinityPropagation\n    };\n    var hierholzerDefaults = defaults$g({\n        root: undefined,\n        directed: false\n    });\n    var elesfn$k = {\n        hierholzer: function hierholzer(options) {\n            if (!plainObject(options)) {\n                var args = arguments;\n                options = {\n                    root: args[0],\n                    directed: args[1]\n                };\n            }\n            var _hierholzerDefaults = hierholzerDefaults(options), root = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;\n            var eles = this;\n            var dflag = false;\n            var oddIn;\n            var oddOut;\n            var startVertex;\n            if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n            var nodes = {};\n            var edges = {};\n            if (directed) {\n                eles.forEach(function(ele) {\n                    var id = ele.id();\n                    if (ele.isNode()) {\n                        var ind = ele.indegree(true);\n                        var outd = ele.outdegree(true);\n                        var d1 = ind - outd;\n                        var d2 = outd - ind;\n                        if (d1 == 1) {\n                            if (oddIn) dflag = true;\n                            else oddIn = id;\n                        } else if (d2 == 1) {\n                            if (oddOut) dflag = true;\n                            else oddOut = id;\n                        } else if (d2 > 1 || d1 > 1) {\n                            dflag = true;\n                        }\n                        nodes[id] = [];\n                        ele.outgoers().forEach(function(e) {\n                            if (e.isEdge()) nodes[id].push(e.id());\n                        });\n                    } else {\n                        edges[id] = [\n                            undefined,\n                            ele.target().id()\n                        ];\n                    }\n                });\n            } else {\n                eles.forEach(function(ele) {\n                    var id = ele.id();\n                    if (ele.isNode()) {\n                        var d = ele.degree(true);\n                        if (d % 2) {\n                            if (!oddIn) oddIn = id;\n                            else if (!oddOut) oddOut = id;\n                            else dflag = true;\n                        }\n                        nodes[id] = [];\n                        ele.connectedEdges().forEach(function(e) {\n                            return nodes[id].push(e.id());\n                        });\n                    } else {\n                        edges[id] = [\n                            ele.source().id(),\n                            ele.target().id()\n                        ];\n                    }\n                });\n            }\n            var result = {\n                found: false,\n                trail: undefined\n            };\n            if (dflag) return result;\n            else if (oddOut && oddIn) {\n                if (directed) {\n                    if (startVertex && oddOut != startVertex) {\n                        return result;\n                    }\n                    startVertex = oddOut;\n                } else {\n                    if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n                        return result;\n                    } else if (!startVertex) {\n                        startVertex = oddOut;\n                    }\n                }\n            } else {\n                if (!startVertex) startVertex = eles[0].id();\n            }\n            var walk = function walk(v) {\n                var currentNode = v;\n                var subtour = [\n                    v\n                ];\n                var adj, adjTail, adjHead;\n                while(nodes[currentNode].length){\n                    adj = nodes[currentNode].shift();\n                    adjTail = edges[adj][0];\n                    adjHead = edges[adj][1];\n                    if (currentNode != adjHead) {\n                        nodes[adjHead] = nodes[adjHead].filter(function(e) {\n                            return e != adj;\n                        });\n                        currentNode = adjHead;\n                    } else if (!directed && currentNode != adjTail) {\n                        nodes[adjTail] = nodes[adjTail].filter(function(e) {\n                            return e != adj;\n                        });\n                        currentNode = adjTail;\n                    }\n                    subtour.unshift(adj);\n                    subtour.unshift(currentNode);\n                }\n                return subtour;\n            };\n            var trail = [];\n            var subtour = [];\n            subtour = walk(startVertex);\n            while(subtour.length != 1){\n                if (nodes[subtour[0]].length == 0) {\n                    trail.unshift(eles.getElementById(subtour.shift()));\n                    trail.unshift(eles.getElementById(subtour.shift()));\n                } else {\n                    subtour = walk(subtour.shift()).concat(subtour);\n                }\n            }\n            trail.unshift(eles.getElementById(subtour.shift())); // final node\n            for(var d in nodes){\n                if (nodes[d].length) {\n                    return result;\n                }\n            }\n            result.found = true;\n            result.trail = this.spawn(trail, true);\n            return result;\n        }\n    };\n    var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n        var eles = this;\n        var nodes = {};\n        var id = 0;\n        var edgeCount = 0;\n        var components = [];\n        var stack = [];\n        var visitedEdges = {};\n        var buildComponent = function buildComponent(x, y) {\n            var i = stack.length - 1;\n            var cutset = [];\n            var component = eles.spawn();\n            while(stack[i].x != x || stack[i].y != y){\n                cutset.push(stack.pop().edge);\n                i--;\n            }\n            cutset.push(stack.pop().edge);\n            cutset.forEach(function(edge) {\n                var connectedNodes = edge.connectedNodes().intersection(eles);\n                component.merge(edge);\n                connectedNodes.forEach(function(node) {\n                    var nodeId = node.id();\n                    var connectedEdges = node.connectedEdges().intersection(eles);\n                    component.merge(node);\n                    if (!nodes[nodeId].cutVertex) {\n                        component.merge(connectedEdges);\n                    } else {\n                        component.merge(connectedEdges.filter(function(edge) {\n                            return edge.isLoop();\n                        }));\n                    }\n                });\n            });\n            components.push(component);\n        };\n        var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n            if (root === parent) edgeCount += 1;\n            nodes[currentNode] = {\n                id: id,\n                low: id++,\n                cutVertex: false\n            };\n            var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n            if (edges.size() === 0) {\n                components.push(eles.spawn(eles.getElementById(currentNode)));\n            } else {\n                var sourceId, targetId, otherNodeId, edgeId;\n                edges.forEach(function(edge) {\n                    sourceId = edge.source().id();\n                    targetId = edge.target().id();\n                    otherNodeId = sourceId === currentNode ? targetId : sourceId;\n                    if (otherNodeId !== parent) {\n                        edgeId = edge.id();\n                        if (!visitedEdges[edgeId]) {\n                            visitedEdges[edgeId] = true;\n                            stack.push({\n                                x: currentNode,\n                                y: otherNodeId,\n                                edge: edge\n                            });\n                        }\n                        if (!(otherNodeId in nodes)) {\n                            biconnectedSearch(root, otherNodeId, currentNode);\n                            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n                            if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                                nodes[currentNode].cutVertex = true;\n                                buildComponent(currentNode, otherNodeId);\n                            }\n                        } else {\n                            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n                        }\n                    }\n                });\n            }\n        };\n        eles.forEach(function(ele) {\n            if (ele.isNode()) {\n                var nodeId = ele.id();\n                if (!(nodeId in nodes)) {\n                    edgeCount = 0;\n                    biconnectedSearch(nodeId, nodeId);\n                    nodes[nodeId].cutVertex = edgeCount > 1;\n                }\n            }\n        });\n        var cutVertices = Object.keys(nodes).filter(function(id) {\n            return nodes[id].cutVertex;\n        }).map(function(id) {\n            return eles.getElementById(id);\n        });\n        return {\n            cut: eles.spawn(cutVertices),\n            components: components\n        };\n    };\n    var hopcroftTarjanBiconnected$1 = {\n        hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n        htbc: hopcroftTarjanBiconnected,\n        htb: hopcroftTarjanBiconnected,\n        hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n    };\n    var tarjanStronglyConnected = function tarjanStronglyConnected() {\n        var eles = this;\n        var nodes = {};\n        var index = 0;\n        var components = [];\n        var stack = [];\n        var cut = eles.spawn(eles);\n        var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n            stack.push(sourceNodeId);\n            nodes[sourceNodeId] = {\n                index: index,\n                low: index++,\n                explored: false\n            };\n            var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n            connectedEdges.forEach(function(edge) {\n                var targetNodeId = edge.target().id();\n                if (targetNodeId !== sourceNodeId) {\n                    if (!(targetNodeId in nodes)) {\n                        stronglyConnectedSearch(targetNodeId);\n                    }\n                    if (!nodes[targetNodeId].explored) {\n                        nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n                    }\n                }\n            });\n            if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n                var componentNodes = eles.spawn();\n                for(;;){\n                    var nodeId = stack.pop();\n                    componentNodes.merge(eles.getElementById(nodeId));\n                    nodes[nodeId].low = nodes[sourceNodeId].index;\n                    nodes[nodeId].explored = true;\n                    if (nodeId === sourceNodeId) {\n                        break;\n                    }\n                }\n                var componentEdges = componentNodes.edgesWith(componentNodes);\n                var component = componentNodes.merge(componentEdges);\n                components.push(component);\n                cut = cut.difference(component);\n            }\n        };\n        eles.forEach(function(ele) {\n            if (ele.isNode()) {\n                var nodeId = ele.id();\n                if (!(nodeId in nodes)) {\n                    stronglyConnectedSearch(nodeId);\n                }\n            }\n        });\n        return {\n            cut: cut,\n            components: components\n        };\n    };\n    var tarjanStronglyConnected$1 = {\n        tarjanStronglyConnected: tarjanStronglyConnected,\n        tsc: tarjanStronglyConnected,\n        tscc: tarjanStronglyConnected,\n        tarjanStronglyConnectedComponents: tarjanStronglyConnected\n    };\n    var elesfn$j = {};\n    [\n        elesfn$v,\n        elesfn$u,\n        elesfn$t,\n        elesfn$s,\n        elesfn$r,\n        elesfn$q,\n        elesfn$p,\n        elesfn$o,\n        elesfn$n,\n        elesfn$m,\n        elesfn$l,\n        markovClustering$1,\n        kClustering,\n        hierarchicalClustering$1,\n        affinityPropagation$1,\n        elesfn$k,\n        hopcroftTarjanBiconnected$1,\n        tarjanStronglyConnected$1\n    ].forEach(function(props) {\n        extend(elesfn$j, props);\n    });\n    /*!\n  Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\n  Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\n  Licensed under The MIT License (http://opensource.org/licenses/MIT)\n  */ /*  promise states [Promises/A+ 2.1]  */ var STATE_PENDING = 0;\n    /*  [Promises/A+ 2.1.1]  */ var STATE_FULFILLED = 1;\n    /*  [Promises/A+ 2.1.2]  */ var STATE_REJECTED = 2;\n    /*  [Promises/A+ 2.1.3]  */ /*  promise object constructor  */ var api = function api(executor) {\n        /*  optionally support non-constructor/plain-function call  */ if (!(this instanceof api)) return new api(executor);\n        /*  initialize object  */ this.id = \"Thenable/1.0.7\";\n        this.state = STATE_PENDING;\n        /*  initial state  */ this.fulfillValue = undefined;\n        /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */ this.rejectReason = undefined;\n        /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */ this.onFulfilled = [];\n        /*  initial handlers  */ this.onRejected = [];\n        /*  initial handlers  */ /*  provide optional information-hiding proxy  */ this.proxy = {\n            then: this.then.bind(this)\n        };\n        /*  support optional executor function  */ if (typeof executor === \"function\") executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n    };\n    /*  promise API methods  */ api.prototype = {\n        /*  promise resolving methods  */ fulfill: function fulfill(value) {\n            return deliver(this, STATE_FULFILLED, \"fulfillValue\", value);\n        },\n        reject: function reject(value) {\n            return deliver(this, STATE_REJECTED, \"rejectReason\", value);\n        },\n        /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */ then: function then(onFulfilled, onRejected) {\n            var curr = this;\n            var next = new api();\n            /*  [Promises/A+ 2.2.7]  */ curr.onFulfilled.push(resolver(onFulfilled, next, \"fulfill\"));\n            /*  [Promises/A+ 2.2.2/2.2.6]  */ curr.onRejected.push(resolver(onRejected, next, \"reject\"));\n            /*  [Promises/A+ 2.2.3/2.2.6]  */ execute(curr);\n            return next.proxy;\n        /*  [Promises/A+ 2.2.7, 3.3]  */ }\n    };\n    /*  deliver an action  */ var deliver = function deliver(curr, state, name, value) {\n        if (curr.state === STATE_PENDING) {\n            curr.state = state;\n            /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */ curr[name] = value;\n            /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */ execute(curr);\n        }\n        return curr;\n    };\n    /*  execute all handlers  */ var execute = function execute(curr) {\n        if (curr.state === STATE_FULFILLED) execute_handlers(curr, \"onFulfilled\", curr.fulfillValue);\n        else if (curr.state === STATE_REJECTED) execute_handlers(curr, \"onRejected\", curr.rejectReason);\n    };\n    /*  execute particular set of handlers  */ var execute_handlers = function execute_handlers(curr, name, value) {\n        /* global setImmediate: true */ /* global setTimeout: true */ /*  short-circuit processing  */ if (curr[name].length === 0) return;\n        /*  iterate over all handlers, exactly once  */ var handlers = curr[name];\n        curr[name] = [];\n        /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */ var func = function func() {\n            for(var i = 0; i < handlers.length; i++){\n                handlers[i](value);\n            }\n        /*  [Promises/A+ 2.2.5]  */ };\n        /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */ if (typeof setImmediate === \"function\") setImmediate(func);\n        else setTimeout(func, 0);\n    };\n    /*  generate a resolver function  */ var resolver = function resolver(cb, next, method) {\n        return function(value) {\n            if (typeof cb !== \"function\") /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */ next[method].call(next, value);\n            else {\n                var result;\n                try {\n                    result = cb(value);\n                } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */ catch (e) {\n                    next.reject(e);\n                    /*  [Promises/A+ 2.2.7.2]  */ return;\n                }\n                resolve(next, result);\n            /*  [Promises/A+ 2.2.7.1]  */ }\n        };\n    };\n    /*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */ var resolve = function resolve(promise, x) {\n        /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */ if (promise === x || promise.proxy === x) {\n            promise.reject(new TypeError(\"cannot resolve promise with itself\"));\n            return;\n        }\n        /*  surgically check for a \"then\" method\n      (mainly to just call the \"getter\" of \"then\" only once)  */ var then;\n        if (_typeof(x) === \"object\" && x !== null || typeof x === \"function\") {\n            try {\n                then = x.then;\n            } /*  [Promises/A+ 2.3.3.1, 3.5]  */ catch (e) {\n                promise.reject(e);\n                /*  [Promises/A+ 2.3.3.2]  */ return;\n            }\n        }\n        /*  handle own Thenables    [Promises/A+ 2.3.2]\n      and similar \"thenables\" [Promises/A+ 2.3.3]  */ if (typeof then === \"function\") {\n            var resolved = false;\n            try {\n                /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */ then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */ function(y) {\n                    if (resolved) return;\n                    resolved = true;\n                    /*  [Promises/A+ 2.3.3.3.3]  */ if (y === x) /*  [Promises/A+ 3.6]  */ promise.reject(new TypeError(\"circular thenable chain\"));\n                    else resolve(promise, y);\n                }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */ function(r) {\n                    if (resolved) return;\n                    resolved = true;\n                    /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(r);\n                });\n            } catch (e) {\n                if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(e);\n            /*  [Promises/A+ 2.3.3.3.4]  */ }\n            return;\n        }\n        /*  handle other values  */ promise.fulfill(x);\n    /*  [Promises/A+ 2.3.4, 2.3.3.4]  */ }; // so we always have Promise.all()\n    api.all = function(ps) {\n        return new api(function(resolveAll, rejectAll) {\n            var vals = new Array(ps.length);\n            var doneCount = 0;\n            var fulfill = function fulfill(i, val) {\n                vals[i] = val;\n                doneCount++;\n                if (doneCount === ps.length) {\n                    resolveAll(vals);\n                }\n            };\n            for(var i = 0; i < ps.length; i++){\n                (function(i) {\n                    var p = ps[i];\n                    var isPromise = p != null && p.then != null;\n                    if (isPromise) {\n                        p.then(function(val) {\n                            fulfill(i, val);\n                        }, function(err) {\n                            rejectAll(err);\n                        });\n                    } else {\n                        var val = p;\n                        fulfill(i, val);\n                    }\n                })(i);\n            }\n        });\n    };\n    api.resolve = function(val) {\n        return new api(function(resolve, reject) {\n            resolve(val);\n        });\n    };\n    api.reject = function(val) {\n        return new api(function(resolve, reject) {\n            reject(val);\n        });\n    };\n    var Promise$1 = typeof Promise !== \"undefined\" ? Promise : api; // eslint-disable-line no-undef\n    var Animation = function Animation(target, opts, opts2) {\n        var isCore = core(target);\n        var isEle = !isCore;\n        var _p = this._private = extend({\n            duration: 1000\n        }, opts, opts2);\n        _p.target = target;\n        _p.style = _p.style || _p.css;\n        _p.started = false;\n        _p.playing = false;\n        _p.hooked = false;\n        _p.applying = false;\n        _p.progress = 0;\n        _p.completes = [];\n        _p.frames = [];\n        if (_p.complete && fn$6(_p.complete)) {\n            _p.completes.push(_p.complete);\n        }\n        if (isEle) {\n            var pos = target.position();\n            _p.startPosition = _p.startPosition || {\n                x: pos.x,\n                y: pos.y\n            };\n            _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n        }\n        if (isCore) {\n            var pan = target.pan();\n            _p.startPan = {\n                x: pan.x,\n                y: pan.y\n            };\n            _p.startZoom = target.zoom();\n        } // for future timeline/animations impl\n        this.length = 1;\n        this[0] = this;\n    };\n    var anifn = Animation.prototype;\n    extend(anifn, {\n        instanceString: function instanceString() {\n            return \"animation\";\n        },\n        hook: function hook() {\n            var _p = this._private;\n            if (!_p.hooked) {\n                // add to target's animation queue\n                var q;\n                var tAni = _p.target._private.animation;\n                if (_p.queue) {\n                    q = tAni.queue;\n                } else {\n                    q = tAni.current;\n                }\n                q.push(this); // add to the animation loop pool\n                if (elementOrCollection(_p.target)) {\n                    _p.target.cy().addToAnimationPool(_p.target);\n                }\n                _p.hooked = true;\n            }\n            return this;\n        },\n        play: function play() {\n            var _p = this._private; // autorewind\n            if (_p.progress === 1) {\n                _p.progress = 0;\n            }\n            _p.playing = true;\n            _p.started = false; // needs to be started by animation loop\n            _p.stopped = false;\n            this.hook(); // the animation loop will start the animation...\n            return this;\n        },\n        playing: function playing() {\n            return this._private.playing;\n        },\n        apply: function apply() {\n            var _p = this._private;\n            _p.applying = true;\n            _p.started = false; // needs to be started by animation loop\n            _p.stopped = false;\n            this.hook(); // the animation loop will apply the animation at this progress\n            return this;\n        },\n        applying: function applying() {\n            return this._private.applying;\n        },\n        pause: function pause() {\n            var _p = this._private;\n            _p.playing = false;\n            _p.started = false;\n            return this;\n        },\n        stop: function stop() {\n            var _p = this._private;\n            _p.playing = false;\n            _p.started = false;\n            _p.stopped = true; // to be removed from animation queues\n            return this;\n        },\n        rewind: function rewind() {\n            return this.progress(0);\n        },\n        fastforward: function fastforward() {\n            return this.progress(1);\n        },\n        time: function time(t) {\n            var _p = this._private;\n            if (t === undefined) {\n                return _p.progress * _p.duration;\n            } else {\n                return this.progress(t / _p.duration);\n            }\n        },\n        progress: function progress(p) {\n            var _p = this._private;\n            var wasPlaying = _p.playing;\n            if (p === undefined) {\n                return _p.progress;\n            } else {\n                if (wasPlaying) {\n                    this.pause();\n                }\n                _p.progress = p;\n                _p.started = false;\n                if (wasPlaying) {\n                    this.play();\n                }\n            }\n            return this;\n        },\n        completed: function completed() {\n            return this._private.progress === 1;\n        },\n        reverse: function reverse() {\n            var _p = this._private;\n            var wasPlaying = _p.playing;\n            if (wasPlaying) {\n                this.pause();\n            }\n            _p.progress = 1 - _p.progress;\n            _p.started = false;\n            var swap = function swap(a, b) {\n                var _pa = _p[a];\n                if (_pa == null) {\n                    return;\n                }\n                _p[a] = _p[b];\n                _p[b] = _pa;\n            };\n            swap(\"zoom\", \"startZoom\");\n            swap(\"pan\", \"startPan\");\n            swap(\"position\", \"startPosition\"); // swap styles\n            if (_p.style) {\n                for(var i = 0; i < _p.style.length; i++){\n                    var prop = _p.style[i];\n                    var name = prop.name;\n                    var startStyleProp = _p.startStyle[name];\n                    _p.startStyle[name] = prop;\n                    _p.style[i] = startStyleProp;\n                }\n            }\n            if (wasPlaying) {\n                this.play();\n            }\n            return this;\n        },\n        promise: function promise(type) {\n            var _p = this._private;\n            var arr;\n            switch(type){\n                case \"frame\":\n                    arr = _p.frames;\n                    break;\n                default:\n                case \"complete\":\n                case \"completed\":\n                    arr = _p.completes;\n            }\n            return new Promise$1(function(resolve, reject) {\n                arr.push(function() {\n                    resolve();\n                });\n            });\n        }\n    });\n    anifn.complete = anifn.completed;\n    anifn.run = anifn.play;\n    anifn.running = anifn.playing;\n    var define$3 = {\n        animated: function animated() {\n            return function animatedImpl() {\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return false;\n                }\n                var ele = all[0];\n                if (ele) {\n                    return ele._private.animation.current.length > 0;\n                }\n            };\n        },\n        // animated\n        clearQueue: function clearQueue() {\n            return function clearQueueImpl() {\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                for(var i = 0; i < all.length; i++){\n                    var ele = all[i];\n                    ele._private.animation.queue = [];\n                }\n                return this;\n            };\n        },\n        // clearQueue\n        delay: function delay() {\n            return function delayImpl(time, complete) {\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                return this.animate({\n                    delay: time,\n                    duration: time,\n                    complete: complete\n                });\n            };\n        },\n        // delay\n        delayAnimation: function delayAnimation() {\n            return function delayAnimationImpl(time, complete) {\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                return this.animation({\n                    delay: time,\n                    duration: time,\n                    complete: complete\n                });\n            };\n        },\n        // delay\n        animation: function animation() {\n            return function animationImpl(properties, params) {\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var cy = this._private.cy || this;\n                var isCore = !selfIsArrayLike;\n                var isEles = !isCore;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                var style = cy.style();\n                properties = extend({}, properties, params);\n                var propertiesEmpty = Object.keys(properties).length === 0;\n                if (propertiesEmpty) {\n                    return new Animation(all[0], properties); // nothing to animate\n                }\n                if (properties.duration === undefined) {\n                    properties.duration = 400;\n                }\n                switch(properties.duration){\n                    case \"slow\":\n                        properties.duration = 600;\n                        break;\n                    case \"fast\":\n                        properties.duration = 200;\n                        break;\n                }\n                if (isEles) {\n                    properties.style = style.getPropsList(properties.style || properties.css);\n                    properties.css = undefined;\n                }\n                if (isEles && properties.renderedPosition != null) {\n                    var rpos = properties.renderedPosition;\n                    var pan = cy.pan();\n                    var zoom = cy.zoom();\n                    properties.position = renderedToModelPosition(rpos, zoom, pan);\n                } // override pan w/ panBy if set\n                if (isCore && properties.panBy != null) {\n                    var panBy = properties.panBy;\n                    var cyPan = cy.pan();\n                    properties.pan = {\n                        x: cyPan.x + panBy.x,\n                        y: cyPan.y + panBy.y\n                    };\n                } // override pan w/ center if set\n                var center = properties.center || properties.centre;\n                if (isCore && center != null) {\n                    var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n                    if (centerPan != null) {\n                        properties.pan = centerPan;\n                    }\n                } // override pan & zoom w/ fit if set\n                if (isCore && properties.fit != null) {\n                    var fit = properties.fit;\n                    var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n                    if (fitVp != null) {\n                        properties.pan = fitVp.pan;\n                        properties.zoom = fitVp.zoom;\n                    }\n                } // override zoom (& potentially pan) w/ zoom obj if set\n                if (isCore && plainObject(properties.zoom)) {\n                    var vp = cy.getZoomedViewport(properties.zoom);\n                    if (vp != null) {\n                        if (vp.zoomed) {\n                            properties.zoom = vp.zoom;\n                        }\n                        if (vp.panned) {\n                            properties.pan = vp.pan;\n                        }\n                    } else {\n                        properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n                    }\n                }\n                return new Animation(all[0], properties);\n            };\n        },\n        // animate\n        animate: function animate() {\n            return function animateImpl(properties, params) {\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                if (params) {\n                    properties = extend({}, properties, params);\n                } // manually hook and run the animation\n                for(var i = 0; i < all.length; i++){\n                    var ele = all[i];\n                    var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n                    var ani = ele.animation(properties, queue ? {\n                        queue: true\n                    } : undefined);\n                    ani.play();\n                }\n                return this; // chaining\n            };\n        },\n        // animate\n        stop: function stop() {\n            return function stopImpl(clearQueue, jumpToEnd) {\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var cy = this._private.cy || this;\n                if (!cy.styleEnabled()) {\n                    return this;\n                }\n                for(var i = 0; i < all.length; i++){\n                    var ele = all[i];\n                    var _p = ele._private;\n                    var anis = _p.animation.current;\n                    for(var j = 0; j < anis.length; j++){\n                        var ani = anis[j];\n                        var ani_p = ani._private;\n                        if (jumpToEnd) {\n                            // next iteration of the animation loop, the animation\n                            // will go straight to the end and be removed\n                            ani_p.duration = 0;\n                        }\n                    } // clear the queue of future animations\n                    if (clearQueue) {\n                        _p.animation.queue = [];\n                    }\n                    if (!jumpToEnd) {\n                        _p.animation.current = [];\n                    }\n                } // we have to notify (the animation loop doesn't do it for us on `stop`)\n                cy.notify(\"draw\");\n                return this;\n            };\n        } // stop\n    }; // define\n    /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */ var isArray = Array.isArray;\n    var isArray_1 = isArray;\n    /** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n    /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */ function isKey(value, object) {\n        if (isArray_1(value)) {\n            return false;\n        }\n        var type = typeof value;\n        if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol_1(value)) {\n            return true;\n        }\n        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    var _isKey = isKey;\n    /** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n    /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */ function isFunction(value) {\n        if (!isObject_1(value)) {\n            return false;\n        }\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in Safari 9 which returns 'object' for typed arrays and other constructors.\n        var tag = _baseGetTag(value);\n        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    var isFunction_1 = isFunction;\n    /** Used to detect overreaching core-js shims. */ var coreJsData = _root[\"__core-js_shared__\"];\n    var _coreJsData = coreJsData;\n    /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n        var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || \"\");\n        return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */ function isMasked(func) {\n        return !!maskSrcKey && maskSrcKey in func;\n    }\n    var _isMasked = isMasked;\n    /** Used for built-in method references. */ var funcProto$1 = Function.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString$1 = funcProto$1.toString;\n    /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */ function toSource(func) {\n        if (func != null) {\n            try {\n                return funcToString$1.call(func);\n            } catch (e) {}\n            try {\n                return func + \"\";\n            } catch (e) {}\n        }\n        return \"\";\n    }\n    var _toSource = toSource;\n    /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto$3 = Object.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n    /** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty$3).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n    /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */ function baseIsNative(value) {\n        if (!isObject_1(value) || _isMasked(value)) {\n            return false;\n        }\n        var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n        return pattern.test(_toSource(value));\n    }\n    var _baseIsNative = baseIsNative;\n    /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */ function getValue$1(object, key) {\n        return object == null ? undefined : object[key];\n    }\n    var _getValue = getValue$1;\n    /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */ function getNative(object, key) {\n        var value = _getValue(object, key);\n        return _baseIsNative(value) ? value : undefined;\n    }\n    var _getNative = getNative;\n    /* Built-in method references that are verified to be native. */ var nativeCreate = _getNative(Object, \"create\");\n    var _nativeCreate = nativeCreate;\n    /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */ function hashClear() {\n        this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n        this.size = 0;\n    }\n    var _hashClear = hashClear;\n    /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */ function hashDelete(key) {\n        var result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    var _hashDelete = hashDelete;\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n    /** Used for built-in method references. */ var objectProto$2 = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n    /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */ function hashGet(key) {\n        var data = this.__data__;\n        if (_nativeCreate) {\n            var result = data[key];\n            return result === HASH_UNDEFINED$1 ? undefined : result;\n        }\n        return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n    }\n    var _hashGet = hashGet;\n    /** Used for built-in method references. */ var objectProto$1 = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n    /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */ function hashHas(key) {\n        var data = this.__data__;\n        return _nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);\n    }\n    var _hashHas = hashHas;\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */ function hashSet(key, value) {\n        var data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n    var _hashSet = hashSet;\n    /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */ function Hash(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `Hash`.\n    Hash.prototype.clear = _hashClear;\n    Hash.prototype[\"delete\"] = _hashDelete;\n    Hash.prototype.get = _hashGet;\n    Hash.prototype.has = _hashHas;\n    Hash.prototype.set = _hashSet;\n    var _Hash = Hash;\n    /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */ function listCacheClear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n    var _listCacheClear = listCacheClear;\n    /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */ function eq(value, other) {\n        return value === other || value !== value && other !== other;\n    }\n    var eq_1 = eq;\n    /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */ function assocIndexOf(array, key) {\n        var length = array.length;\n        while(length--){\n            if (eq_1(array[length][0], key)) {\n                return length;\n            }\n        }\n        return -1;\n    }\n    var _assocIndexOf = assocIndexOf;\n    /** Used for built-in method references. */ var arrayProto = Array.prototype;\n    /** Built-in value references. */ var splice = arrayProto.splice;\n    /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */ function listCacheDelete(key) {\n        var data = this.__data__, index = _assocIndexOf(data, key);\n        if (index < 0) {\n            return false;\n        }\n        var lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            splice.call(data, index, 1);\n        }\n        --this.size;\n        return true;\n    }\n    var _listCacheDelete = listCacheDelete;\n    /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */ function listCacheGet(key) {\n        var data = this.__data__, index = _assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n    var _listCacheGet = listCacheGet;\n    /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */ function listCacheHas(key) {\n        return _assocIndexOf(this.__data__, key) > -1;\n    }\n    var _listCacheHas = listCacheHas;\n    /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */ function listCacheSet(key, value) {\n        var data = this.__data__, index = _assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n    var _listCacheSet = listCacheSet;\n    /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */ function ListCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = _listCacheClear;\n    ListCache.prototype[\"delete\"] = _listCacheDelete;\n    ListCache.prototype.get = _listCacheGet;\n    ListCache.prototype.has = _listCacheHas;\n    ListCache.prototype.set = _listCacheSet;\n    var _ListCache = ListCache;\n    /* Built-in method references that are verified to be native. */ var Map$1 = _getNative(_root, \"Map\");\n    var _Map = Map$1;\n    /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */ function mapCacheClear() {\n        this.size = 0;\n        this.__data__ = {\n            \"hash\": new _Hash,\n            \"map\": new (_Map || _ListCache),\n            \"string\": new _Hash\n        };\n    }\n    var _mapCacheClear = mapCacheClear;\n    /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */ function isKeyable(value) {\n        var type = typeof value;\n        return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    var _isKeyable = isKeyable;\n    /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */ function getMapData(map, key) {\n        var data = map.__data__;\n        return _isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    var _getMapData = getMapData;\n    /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */ function mapCacheDelete(key) {\n        var result = _getMapData(this, key)[\"delete\"](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    var _mapCacheDelete = mapCacheDelete;\n    /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */ function mapCacheGet(key) {\n        return _getMapData(this, key).get(key);\n    }\n    var _mapCacheGet = mapCacheGet;\n    /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */ function mapCacheHas(key) {\n        return _getMapData(this, key).has(key);\n    }\n    var _mapCacheHas = mapCacheHas;\n    /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */ function mapCacheSet(key, value) {\n        var data = _getMapData(this, key), size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n    var _mapCacheSet = mapCacheSet;\n    /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */ function MapCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = _mapCacheClear;\n    MapCache.prototype[\"delete\"] = _mapCacheDelete;\n    MapCache.prototype.get = _mapCacheGet;\n    MapCache.prototype.has = _mapCacheHas;\n    MapCache.prototype.set = _mapCacheSet;\n    var _MapCache = MapCache;\n    /** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n    /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */ function memoize(func, resolver) {\n        if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        var memoized = function() {\n            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            var result = func.apply(this, args);\n            memoized.cache = cache.set(key, result) || cache;\n            return result;\n        };\n        memoized.cache = new (memoize.Cache || _MapCache);\n        return memoized;\n    }\n    // Expose `MapCache`.\n    memoize.Cache = _MapCache;\n    var memoize_1 = memoize;\n    /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n    /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */ function memoizeCapped(func) {\n        var result = memoize_1(func, function(key) {\n            if (cache.size === MAX_MEMOIZE_SIZE) {\n                cache.clear();\n            }\n            return key;\n        });\n        var cache = result.cache;\n        return result;\n    }\n    var _memoizeCapped = memoizeCapped;\n    /** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n    /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */ var stringToPath = _memoizeCapped(function(string) {\n        var result = [];\n        if (string.charCodeAt(0) === 46 /* . */ ) {\n            result.push(\"\");\n        }\n        string.replace(rePropName, function(match, number, quote, subString) {\n            result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n        });\n        return result;\n    });\n    var _stringToPath = stringToPath;\n    /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */ function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while(++index < length){\n            result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n    }\n    var _arrayMap = arrayMap;\n    /** Used as references for various `Number` constants. */ var INFINITY$1 = 1 / 0;\n    /** Used to convert symbols to primitives and strings. */ var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n    /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */ function baseToString(value) {\n        // Exit early for strings to avoid a performance hit in some environments.\n        if (typeof value == \"string\") {\n            return value;\n        }\n        if (isArray_1(value)) {\n            // Recursively convert values (susceptible to call stack limits).\n            return _arrayMap(value, baseToString) + \"\";\n        }\n        if (isSymbol_1(value)) {\n            return symbolToString ? symbolToString.call(value) : \"\";\n        }\n        var result = value + \"\";\n        return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n    }\n    var _baseToString = baseToString;\n    /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */ function toString$1(value) {\n        return value == null ? \"\" : _baseToString(value);\n    }\n    var toString_1 = toString$1;\n    /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */ function castPath(value, object) {\n        if (isArray_1(value)) {\n            return value;\n        }\n        return _isKey(value, object) ? [\n            value\n        ] : _stringToPath(toString_1(value));\n    }\n    var _castPath = castPath;\n    /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;\n    /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */ function toKey(value) {\n        if (typeof value == \"string\" || isSymbol_1(value)) {\n            return value;\n        }\n        var result = value + \"\";\n        return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n    }\n    var _toKey = toKey;\n    /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */ function baseGet(object, path) {\n        path = _castPath(path, object);\n        var index = 0, length = path.length;\n        while(object != null && index < length){\n            object = object[_toKey(path[index++])];\n        }\n        return index && index == length ? object : undefined;\n    }\n    var _baseGet = baseGet;\n    /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */ function get(object, path, defaultValue) {\n        var result = object == null ? undefined : _baseGet(object, path);\n        return result === undefined ? defaultValue : result;\n    }\n    var get_1 = get;\n    var defineProperty = function() {\n        try {\n            var func = _getNative(Object, \"defineProperty\");\n            func({}, \"\", {});\n            return func;\n        } catch (e) {}\n    }();\n    var _defineProperty = defineProperty;\n    /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */ function baseAssignValue(object, key, value) {\n        if (key == \"__proto__\" && _defineProperty) {\n            _defineProperty(object, key, {\n                \"configurable\": true,\n                \"enumerable\": true,\n                \"value\": value,\n                \"writable\": true\n            });\n        } else {\n            object[key] = value;\n        }\n    }\n    var _baseAssignValue = baseAssignValue;\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */ function assignValue(object, key, value) {\n        var objValue = object[key];\n        if (!(hasOwnProperty.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {\n            _baseAssignValue(object, key, value);\n        }\n    }\n    var _assignValue = assignValue;\n    /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n    /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */ function isIndex(value, length) {\n        var type = typeof value;\n        length = length == null ? MAX_SAFE_INTEGER : length;\n        return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    var _isIndex = isIndex;\n    /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */ function baseSet(object, path, value, customizer) {\n        if (!isObject_1(object)) {\n            return object;\n        }\n        path = _castPath(path, object);\n        var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n        while(nested != null && ++index < length){\n            var key = _toKey(path[index]), newValue = value;\n            if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n                return object;\n            }\n            if (index != lastIndex) {\n                var objValue = nested[key];\n                newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                if (newValue === undefined) {\n                    newValue = isObject_1(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};\n                }\n            }\n            _assignValue(nested, key, newValue);\n            nested = nested[key];\n        }\n        return object;\n    }\n    var _baseSet = baseSet;\n    /**\n   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n   * it's created. Arrays are created for missing index properties while objects\n   * are created for all other missing properties. Use `_.setWith` to customize\n   * `path` creation.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.set(object, 'a[0].b.c', 4);\n   * console.log(object.a[0].b.c);\n   * // => 4\n   *\n   * _.set(object, ['x', '0', 'y', 'z'], 5);\n   * console.log(object.x[0].y.z);\n   * // => 5\n   */ function set(object, path, value) {\n        return object == null ? object : _baseSet(object, path, value);\n    }\n    var set_1 = set;\n    /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */ function copyArray(source, array) {\n        var index = -1, length = source.length;\n        array || (array = Array(length));\n        while(++index < length){\n            array[index] = source[index];\n        }\n        return array;\n    }\n    var _copyArray = copyArray;\n    /**\n   * Converts `value` to a property path array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Util\n   * @param {*} value The value to convert.\n   * @returns {Array} Returns the new property path array.\n   * @example\n   *\n   * _.toPath('a.b.c');\n   * // => ['a', 'b', 'c']\n   *\n   * _.toPath('a[0].b.c');\n   * // => ['a', '0', 'b', 'c']\n   */ function toPath(value) {\n        if (isArray_1(value)) {\n            return _arrayMap(value, _toKey);\n        }\n        return isSymbol_1(value) ? [\n            value\n        ] : _copyArray(_stringToPath(toString_1(value)));\n    }\n    var toPath_1 = toPath;\n    var define$2 = {\n        // access data field\n        data: function data(params) {\n            var defaults = {\n                field: \"data\",\n                bindingEvent: \"data\",\n                allowBinding: false,\n                allowSetting: false,\n                allowGetting: false,\n                settingEvent: \"data\",\n                settingTriggersEvent: false,\n                triggerFnName: \"trigger\",\n                immutableKeys: {},\n                // key => true if immutable\n                updateStyle: false,\n                beforeGet: function beforeGet(self1) {},\n                beforeSet: function beforeSet(self1, obj) {},\n                onSet: function onSet(self1) {},\n                canSet: function canSet(self1) {\n                    return true;\n                }\n            };\n            params = extend({}, defaults, params);\n            return function dataImpl(name, value) {\n                var p = params;\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                var single = selfIsArrayLike ? self1[0] : self1; // .data('foo', ...)\n                if (string(name)) {\n                    // set or get property\n                    var isPathLike = name.indexOf(\".\") !== -1; // there might be a normal field with a dot \n                    var path = isPathLike && toPath_1(name); // .data('foo')\n                    if (p.allowGetting && value === undefined) {\n                        // get\n                        var ret;\n                        if (single) {\n                            p.beforeGet(single); // check if it's path and a field with the same name doesn't exist\n                            if (path && single._private[p.field][name] === undefined) {\n                                ret = get_1(single._private[p.field], path);\n                            } else {\n                                ret = single._private[p.field][name];\n                            }\n                        }\n                        return ret; // .data('foo', 'bar')\n                    } else if (p.allowSetting && value !== undefined) {\n                        // set\n                        var valid = !p.immutableKeys[name];\n                        if (valid) {\n                            var change = _defineProperty$1({}, name, value);\n                            p.beforeSet(self1, change);\n                            for(var i = 0, l = all.length; i < l; i++){\n                                var ele = all[i];\n                                if (p.canSet(ele)) {\n                                    if (path && single._private[p.field][name] === undefined) {\n                                        set_1(ele._private[p.field], path, value);\n                                    } else {\n                                        ele._private[p.field][name] = value;\n                                    }\n                                }\n                            } // update mappers if asked\n                            if (p.updateStyle) {\n                                self1.updateStyle();\n                            } // call onSet callback\n                            p.onSet(self1);\n                            if (p.settingTriggersEvent) {\n                                self1[p.triggerFnName](p.settingEvent);\n                            }\n                        }\n                    } // .data({ 'foo': 'bar' })\n                } else if (p.allowSetting && plainObject(name)) {\n                    // extend\n                    var obj = name;\n                    var k, v;\n                    var keys = Object.keys(obj);\n                    p.beforeSet(self1, obj);\n                    for(var _i = 0; _i < keys.length; _i++){\n                        k = keys[_i];\n                        v = obj[k];\n                        var _valid = !p.immutableKeys[k];\n                        if (_valid) {\n                            for(var j = 0; j < all.length; j++){\n                                var _ele = all[j];\n                                if (p.canSet(_ele)) {\n                                    _ele._private[p.field][k] = v;\n                                }\n                            }\n                        }\n                    } // update mappers if asked\n                    if (p.updateStyle) {\n                        self1.updateStyle();\n                    } // call onSet callback\n                    p.onSet(self1);\n                    if (p.settingTriggersEvent) {\n                        self1[p.triggerFnName](p.settingEvent);\n                    } // .data(function(){ ... })\n                } else if (p.allowBinding && fn$6(name)) {\n                    // bind to event\n                    var fn = name;\n                    self1.on(p.bindingEvent, fn); // .data()\n                } else if (p.allowGetting && name === undefined) {\n                    // get whole object\n                    var _ret;\n                    if (single) {\n                        p.beforeGet(single);\n                        _ret = single._private[p.field];\n                    }\n                    return _ret;\n                }\n                return self1; // maintain chainability\n            }; // function\n        },\n        // data\n        // remove data field\n        removeData: function removeData(params) {\n            var defaults = {\n                field: \"data\",\n                event: \"data\",\n                triggerFnName: \"trigger\",\n                triggerEvent: false,\n                immutableKeys: {} // key => true if immutable\n            };\n            params = extend({}, defaults, params);\n            return function removeDataImpl(names) {\n                var p = params;\n                var self1 = this;\n                var selfIsArrayLike = self1.length !== undefined;\n                var all = selfIsArrayLike ? self1 : [\n                    self1\n                ]; // put in array if not array-like\n                // .removeData('foo bar')\n                if (string(names)) {\n                    // then get the list of keys, and delete them\n                    var keys = names.split(/\\s+/);\n                    var l = keys.length;\n                    for(var i = 0; i < l; i++){\n                        // delete each non-empty key\n                        var key = keys[i];\n                        if (emptyString(key)) {\n                            continue;\n                        }\n                        var valid = !p.immutableKeys[key]; // not valid if immutable\n                        if (valid) {\n                            for(var i_a = 0, l_a = all.length; i_a < l_a; i_a++){\n                                all[i_a]._private[p.field][key] = undefined;\n                            }\n                        }\n                    }\n                    if (p.triggerEvent) {\n                        self1[p.triggerFnName](p.event);\n                    } // .removeData()\n                } else if (names === undefined) {\n                    // then delete all keys\n                    for(var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++){\n                        var _privateFields = all[_i_a]._private[p.field];\n                        var _keys = Object.keys(_privateFields);\n                        for(var _i2 = 0; _i2 < _keys.length; _i2++){\n                            var _key = _keys[_i2];\n                            var validKeyToDelete = !p.immutableKeys[_key];\n                            if (validKeyToDelete) {\n                                _privateFields[_key] = undefined;\n                            }\n                        }\n                    }\n                    if (p.triggerEvent) {\n                        self1[p.triggerFnName](p.event);\n                    }\n                }\n                return self1; // maintain chaining\n            }; // function\n        } // removeData\n    }; // define\n    var define$1 = {\n        eventAliasesOn: function eventAliasesOn(proto) {\n            var p = proto;\n            p.addListener = p.listen = p.bind = p.on;\n            p.unlisten = p.unbind = p.off = p.removeListener;\n            p.trigger = p.emit; // this is just a wrapper alias of .on()\n            p.pon = p.promiseOn = function(events, selector) {\n                var self1 = this;\n                var args = Array.prototype.slice.call(arguments, 0);\n                return new Promise$1(function(resolve, reject) {\n                    var callback = function callback(e) {\n                        self1.off.apply(self1, offArgs);\n                        resolve(e);\n                    };\n                    var onArgs = args.concat([\n                        callback\n                    ]);\n                    var offArgs = onArgs.concat([]);\n                    self1.on.apply(self1, onArgs);\n                });\n            };\n        }\n    }; // define\n    // use this module to cherry pick functions into your prototype\n    var define1 = {};\n    [\n        define$3,\n        define$2,\n        define$1\n    ].forEach(function(m1) {\n        extend(define1, m1);\n    });\n    var elesfn$i = {\n        animate: define1.animate(),\n        animation: define1.animation(),\n        animated: define1.animated(),\n        clearQueue: define1.clearQueue(),\n        delay: define1.delay(),\n        delayAnimation: define1.delayAnimation(),\n        stop: define1.stop()\n    };\n    var elesfn$h = {\n        classes: function classes(_classes) {\n            var self1 = this;\n            if (_classes === undefined) {\n                var ret = [];\n                self1[0]._private.classes.forEach(function(cls) {\n                    return ret.push(cls);\n                });\n                return ret;\n            } else if (!array(_classes)) {\n                // extract classes from string\n                _classes = (_classes || \"\").match(/\\S+/g) || [];\n            }\n            var changed = [];\n            var classesSet = new Set$1(_classes); // check and update each ele\n            for(var j = 0; j < self1.length; j++){\n                var ele = self1[j];\n                var _p = ele._private;\n                var eleClasses = _p.classes;\n                var changedEle = false; // check if ele has all of the passed classes\n                for(var i = 0; i < _classes.length; i++){\n                    var cls = _classes[i];\n                    var eleHasClass = eleClasses.has(cls);\n                    if (!eleHasClass) {\n                        changedEle = true;\n                        break;\n                    }\n                } // check if ele has classes outside of those passed\n                if (!changedEle) {\n                    changedEle = eleClasses.size !== _classes.length;\n                }\n                if (changedEle) {\n                    _p.classes = classesSet;\n                    changed.push(ele);\n                }\n            } // trigger update style on those eles that had class changes\n            if (changed.length > 0) {\n                this.spawn(changed).updateStyle().emit(\"class\");\n            }\n            return self1;\n        },\n        addClass: function addClass(classes) {\n            return this.toggleClass(classes, true);\n        },\n        hasClass: function hasClass(className) {\n            var ele = this[0];\n            return ele != null && ele._private.classes.has(className);\n        },\n        toggleClass: function toggleClass(classes, toggle) {\n            if (!array(classes)) {\n                // extract classes from string\n                classes = classes.match(/\\S+/g) || [];\n            }\n            var self1 = this;\n            var toggleUndefd = toggle === undefined;\n            var changed = []; // eles who had classes changed\n            for(var i = 0, il = self1.length; i < il; i++){\n                var ele = self1[i];\n                var eleClasses = ele._private.classes;\n                var changedEle = false;\n                for(var j = 0; j < classes.length; j++){\n                    var cls = classes[j];\n                    var hasClass = eleClasses.has(cls);\n                    var changedNow = false;\n                    if (toggle || toggleUndefd && !hasClass) {\n                        eleClasses.add(cls);\n                        changedNow = true;\n                    } else if (!toggle || toggleUndefd && hasClass) {\n                        eleClasses[\"delete\"](cls);\n                        changedNow = true;\n                    }\n                    if (!changedEle && changedNow) {\n                        changed.push(ele);\n                        changedEle = true;\n                    }\n                } // for j classes\n            } // for i eles\n            // trigger update style on those eles that had class changes\n            if (changed.length > 0) {\n                this.spawn(changed).updateStyle().emit(\"class\");\n            }\n            return self1;\n        },\n        removeClass: function removeClass(classes) {\n            return this.toggleClass(classes, false);\n        },\n        flashClass: function flashClass(classes, duration) {\n            var self1 = this;\n            if (duration == null) {\n                duration = 250;\n            } else if (duration === 0) {\n                return self1; // nothing to do really\n            }\n            self1.addClass(classes);\n            setTimeout(function() {\n                self1.removeClass(classes);\n            }, duration);\n            return self1;\n        }\n    };\n    elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n    var tokens = {\n        metaChar: \"[\\\\!\\\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]\",\n        // chars we need to escape in let names, etc\n        comparatorOp: \"=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=\",\n        // binary comparison op (used in data selectors)\n        boolOp: \"\\\\?|\\\\!|\\\\^\",\n        // boolean (unary) operators (used in data selectors)\n        string: '\"(?:\\\\\\\\\"|[^\"])*\"' + \"|\" + \"'(?:\\\\\\\\'|[^'])*'\",\n        // string literals (used in data selectors) -- doublequotes | singlequotes\n        number: number,\n        // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n        meta: \"degree|indegree|outdegree\",\n        // allowed metadata fields (i.e. allowed functions to use from Collection)\n        separator: \"\\\\s*,\\\\s*\",\n        // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n        descendant: \"\\\\s+\",\n        child: \"\\\\s+>\\\\s+\",\n        subject: \"\\\\$\",\n        group: \"node|edge|\\\\*\",\n        directedEdge: \"\\\\s+->\\\\s+\",\n        undirectedEdge: \"\\\\s+<->\\\\s+\"\n    };\n    tokens.variable = \"(?:[\\\\w-.]|(?:\\\\\\\\\" + tokens.metaChar + \"))+\"; // a variable name can have letters, numbers, dashes, and periods\n    tokens.className = \"(?:[\\\\w-]|(?:\\\\\\\\\" + tokens.metaChar + \"))+\"; // a class name has the same rules as a variable except it can't have a '.' in the name\n    tokens.value = tokens.string + \"|\" + tokens.number; // a value literal, either a string or number\n    tokens.id = tokens.variable; // an element id (follows variable conventions)\n    (function() {\n        var ops, op, i; // add @ variants to comparatorOp\n        ops = tokens.comparatorOp.split(\"|\");\n        for(i = 0; i < ops.length; i++){\n            op = ops[i];\n            tokens.comparatorOp += \"|@\" + op;\n        } // add ! variants to comparatorOp\n        ops = tokens.comparatorOp.split(\"|\");\n        for(i = 0; i < ops.length; i++){\n            op = ops[i];\n            if (op.indexOf(\"!\") >= 0) {\n                continue;\n            } // skip ops that explicitly contain !\n            if (op === \"=\") {\n                continue;\n            } // skip = b/c != is explicitly defined\n            tokens.comparatorOp += \"|\\\\!\" + op;\n        }\n    })();\n    /**\n   * Make a new query object\n   *\n   * @prop type {Type} The type enum (int) of the query\n   * @prop checks List of checks to make against an ele to test for a match\n   */ var newQuery = function newQuery() {\n        return {\n            checks: []\n        };\n    };\n    /**\n   * A check type enum-like object.  Uses integer values for fast match() lookup.\n   * The ordering does not matter as long as the ints are unique.\n   */ var Type = {\n        /** E.g. node */ GROUP: 0,\n        /** A collection of elements */ COLLECTION: 1,\n        /** A filter(ele) function */ FILTER: 2,\n        /** E.g. [foo > 1] */ DATA_COMPARE: 3,\n        /** E.g. [foo] */ DATA_EXIST: 4,\n        /** E.g. [?foo] */ DATA_BOOL: 5,\n        /** E.g. [[degree > 2]] */ META_COMPARE: 6,\n        /** E.g. :selected */ STATE: 7,\n        /** E.g. #foo */ ID: 8,\n        /** E.g. .foo */ CLASS: 9,\n        /** E.g. #foo <-> #bar */ UNDIRECTED_EDGE: 10,\n        /** E.g. #foo -> #bar */ DIRECTED_EDGE: 11,\n        /** E.g. $#foo -> #bar */ NODE_SOURCE: 12,\n        /** E.g. #foo -> $#bar */ NODE_TARGET: 13,\n        /** E.g. $#foo <-> #bar */ NODE_NEIGHBOR: 14,\n        /** E.g. #foo > #bar */ CHILD: 15,\n        /** E.g. #foo #bar */ DESCENDANT: 16,\n        /** E.g. $#foo > #bar */ PARENT: 17,\n        /** E.g. $#foo #bar */ ANCESTOR: 18,\n        /** E.g. #foo > $bar > #baz */ COMPOUND_SPLIT: 19,\n        /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */ TRUE: 20\n    };\n    var stateSelectors = [\n        {\n            selector: \":selected\",\n            matches: function matches(ele) {\n                return ele.selected();\n            }\n        },\n        {\n            selector: \":unselected\",\n            matches: function matches(ele) {\n                return !ele.selected();\n            }\n        },\n        {\n            selector: \":selectable\",\n            matches: function matches(ele) {\n                return ele.selectable();\n            }\n        },\n        {\n            selector: \":unselectable\",\n            matches: function matches(ele) {\n                return !ele.selectable();\n            }\n        },\n        {\n            selector: \":locked\",\n            matches: function matches(ele) {\n                return ele.locked();\n            }\n        },\n        {\n            selector: \":unlocked\",\n            matches: function matches(ele) {\n                return !ele.locked();\n            }\n        },\n        {\n            selector: \":visible\",\n            matches: function matches(ele) {\n                return ele.visible();\n            }\n        },\n        {\n            selector: \":hidden\",\n            matches: function matches(ele) {\n                return !ele.visible();\n            }\n        },\n        {\n            selector: \":transparent\",\n            matches: function matches(ele) {\n                return ele.transparent();\n            }\n        },\n        {\n            selector: \":grabbed\",\n            matches: function matches(ele) {\n                return ele.grabbed();\n            }\n        },\n        {\n            selector: \":free\",\n            matches: function matches(ele) {\n                return !ele.grabbed();\n            }\n        },\n        {\n            selector: \":removed\",\n            matches: function matches(ele) {\n                return ele.removed();\n            }\n        },\n        {\n            selector: \":inside\",\n            matches: function matches(ele) {\n                return !ele.removed();\n            }\n        },\n        {\n            selector: \":grabbable\",\n            matches: function matches(ele) {\n                return ele.grabbable();\n            }\n        },\n        {\n            selector: \":ungrabbable\",\n            matches: function matches(ele) {\n                return !ele.grabbable();\n            }\n        },\n        {\n            selector: \":animated\",\n            matches: function matches(ele) {\n                return ele.animated();\n            }\n        },\n        {\n            selector: \":unanimated\",\n            matches: function matches(ele) {\n                return !ele.animated();\n            }\n        },\n        {\n            selector: \":parent\",\n            matches: function matches(ele) {\n                return ele.isParent();\n            }\n        },\n        {\n            selector: \":childless\",\n            matches: function matches(ele) {\n                return ele.isChildless();\n            }\n        },\n        {\n            selector: \":child\",\n            matches: function matches(ele) {\n                return ele.isChild();\n            }\n        },\n        {\n            selector: \":orphan\",\n            matches: function matches(ele) {\n                return ele.isOrphan();\n            }\n        },\n        {\n            selector: \":nonorphan\",\n            matches: function matches(ele) {\n                return ele.isChild();\n            }\n        },\n        {\n            selector: \":compound\",\n            matches: function matches(ele) {\n                if (ele.isNode()) {\n                    return ele.isParent();\n                } else {\n                    return ele.source().isParent() || ele.target().isParent();\n                }\n            }\n        },\n        {\n            selector: \":loop\",\n            matches: function matches(ele) {\n                return ele.isLoop();\n            }\n        },\n        {\n            selector: \":simple\",\n            matches: function matches(ele) {\n                return ele.isSimple();\n            }\n        },\n        {\n            selector: \":active\",\n            matches: function matches(ele) {\n                return ele.active();\n            }\n        },\n        {\n            selector: \":inactive\",\n            matches: function matches(ele) {\n                return !ele.active();\n            }\n        },\n        {\n            selector: \":backgrounding\",\n            matches: function matches(ele) {\n                return ele.backgrounding();\n            }\n        },\n        {\n            selector: \":nonbackgrounding\",\n            matches: function matches(ele) {\n                return !ele.backgrounding();\n            }\n        }\n    ].sort(function(a, b) {\n        // n.b. selectors that are starting substrings of others must have the longer ones first\n        return descending(a.selector, b.selector);\n    });\n    var lookup = function() {\n        var selToFn = {};\n        var s;\n        for(var i = 0; i < stateSelectors.length; i++){\n            s = stateSelectors[i];\n            selToFn[s.selector] = s.matches;\n        }\n        return selToFn;\n    }();\n    var stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n        return lookup[sel](ele);\n    };\n    var stateSelectorRegex = \"(\" + stateSelectors.map(function(s) {\n        return s.selector;\n    }).join(\"|\") + \")\";\n    // so that values get compared properly in Selector.filter()\n    var cleanMetaChars = function cleanMetaChars(str) {\n        return str.replace(new RegExp(\"\\\\\\\\(\" + tokens.metaChar + \")\", \"g\"), function(match, $1) {\n            return $1;\n        });\n    };\n    var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n        selector[selector.length - 1] = replacementQuery;\n    }; // NOTE: add new expression syntax here to have it recognised by the parser;\n    // - a query contains all adjacent (i.e. no separator in between) expressions;\n    // - the current query is stored in selector[i]\n    // - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\n    var exprs = [\n        {\n            name: \"group\",\n            // just used for identifying when debugging\n            query: true,\n            regex: \"(\" + tokens.group + \")\",\n            populate: function populate(selector, query, _ref) {\n                var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];\n                query.checks.push({\n                    type: Type.GROUP,\n                    value: group === \"*\" ? group : group + \"s\"\n                });\n            }\n        },\n        {\n            name: \"state\",\n            query: true,\n            regex: stateSelectorRegex,\n            populate: function populate(selector, query, _ref3) {\n                var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];\n                query.checks.push({\n                    type: Type.STATE,\n                    value: state\n                });\n            }\n        },\n        {\n            name: \"id\",\n            query: true,\n            regex: \"\\\\#(\" + tokens.id + \")\",\n            populate: function populate(selector, query, _ref5) {\n                var _ref6 = _slicedToArray(_ref5, 1), id = _ref6[0];\n                query.checks.push({\n                    type: Type.ID,\n                    value: cleanMetaChars(id)\n                });\n            }\n        },\n        {\n            name: \"className\",\n            query: true,\n            regex: \"\\\\.(\" + tokens.className + \")\",\n            populate: function populate(selector, query, _ref7) {\n                var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];\n                query.checks.push({\n                    type: Type.CLASS,\n                    value: cleanMetaChars(className)\n                });\n            }\n        },\n        {\n            name: \"dataExists\",\n            query: true,\n            regex: \"\\\\[\\\\s*(\" + tokens.variable + \")\\\\s*\\\\]\",\n            populate: function populate(selector, query, _ref9) {\n                var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];\n                query.checks.push({\n                    type: Type.DATA_EXIST,\n                    field: cleanMetaChars(variable)\n                });\n            }\n        },\n        {\n            name: \"dataCompare\",\n            query: true,\n            regex: \"\\\\[\\\\s*(\" + tokens.variable + \")\\\\s*(\" + tokens.comparatorOp + \")\\\\s*(\" + tokens.value + \")\\\\s*\\\\]\",\n            populate: function populate(selector, query, _ref11) {\n                var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];\n                var valueIsString = new RegExp(\"^\" + tokens.string + \"$\").exec(value) != null;\n                if (valueIsString) {\n                    value = value.substring(1, value.length - 1);\n                } else {\n                    value = parseFloat(value);\n                }\n                query.checks.push({\n                    type: Type.DATA_COMPARE,\n                    field: cleanMetaChars(variable),\n                    operator: comparatorOp,\n                    value: value\n                });\n            }\n        },\n        {\n            name: \"dataBool\",\n            query: true,\n            regex: \"\\\\[\\\\s*(\" + tokens.boolOp + \")\\\\s*(\" + tokens.variable + \")\\\\s*\\\\]\",\n            populate: function populate(selector, query, _ref13) {\n                var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];\n                query.checks.push({\n                    type: Type.DATA_BOOL,\n                    field: cleanMetaChars(variable),\n                    operator: boolOp\n                });\n            }\n        },\n        {\n            name: \"metaCompare\",\n            query: true,\n            regex: \"\\\\[\\\\[\\\\s*(\" + tokens.meta + \")\\\\s*(\" + tokens.comparatorOp + \")\\\\s*(\" + tokens.number + \")\\\\s*\\\\]\\\\]\",\n            populate: function populate(selector, query, _ref15) {\n                var _ref16 = _slicedToArray(_ref15, 3), meta = _ref16[0], comparatorOp = _ref16[1], number = _ref16[2];\n                query.checks.push({\n                    type: Type.META_COMPARE,\n                    field: cleanMetaChars(meta),\n                    operator: comparatorOp,\n                    value: parseFloat(number)\n                });\n            }\n        },\n        {\n            name: \"nextQuery\",\n            separator: true,\n            regex: tokens.separator,\n            populate: function populate(selector, query) {\n                var currentSubject = selector.currentSubject;\n                var edgeCount = selector.edgeCount;\n                var compoundCount = selector.compoundCount;\n                var lastQ = selector[selector.length - 1];\n                if (currentSubject != null) {\n                    lastQ.subject = currentSubject;\n                    selector.currentSubject = null;\n                }\n                lastQ.edgeCount = edgeCount;\n                lastQ.compoundCount = compoundCount;\n                selector.edgeCount = 0;\n                selector.compoundCount = 0; // go on to next query\n                var nextQuery = selector[selector.length++] = newQuery();\n                return nextQuery; // this is the new query to be filled by the following exprs\n            }\n        },\n        {\n            name: \"directedEdge\",\n            separator: true,\n            regex: tokens.directedEdge,\n            populate: function populate(selector, query) {\n                if (selector.currentSubject == null) {\n                    // undirected edge\n                    var edgeQuery = newQuery();\n                    var source = query;\n                    var target = newQuery();\n                    edgeQuery.checks.push({\n                        type: Type.DIRECTED_EDGE,\n                        source: source,\n                        target: target\n                    }); // the query in the selector should be the edge rather than the source\n                    replaceLastQuery(selector, query, edgeQuery);\n                    selector.edgeCount++; // we're now populating the target query with expressions that follow\n                    return target;\n                } else {\n                    // source/target\n                    var srcTgtQ = newQuery();\n                    var _source = query;\n                    var _target = newQuery();\n                    srcTgtQ.checks.push({\n                        type: Type.NODE_SOURCE,\n                        source: _source,\n                        target: _target\n                    }); // the query in the selector should be the neighbourhood rather than the node\n                    replaceLastQuery(selector, query, srcTgtQ);\n                    selector.edgeCount++;\n                    return _target; // now populating the target with the following expressions\n                }\n            }\n        },\n        {\n            name: \"undirectedEdge\",\n            separator: true,\n            regex: tokens.undirectedEdge,\n            populate: function populate(selector, query) {\n                if (selector.currentSubject == null) {\n                    // undirected edge\n                    var edgeQuery = newQuery();\n                    var source = query;\n                    var target = newQuery();\n                    edgeQuery.checks.push({\n                        type: Type.UNDIRECTED_EDGE,\n                        nodes: [\n                            source,\n                            target\n                        ]\n                    }); // the query in the selector should be the edge rather than the source\n                    replaceLastQuery(selector, query, edgeQuery);\n                    selector.edgeCount++; // we're now populating the target query with expressions that follow\n                    return target;\n                } else {\n                    // neighbourhood\n                    var nhoodQ = newQuery();\n                    var node = query;\n                    var neighbor = newQuery();\n                    nhoodQ.checks.push({\n                        type: Type.NODE_NEIGHBOR,\n                        node: node,\n                        neighbor: neighbor\n                    }); // the query in the selector should be the neighbourhood rather than the node\n                    replaceLastQuery(selector, query, nhoodQ);\n                    return neighbor; // now populating the neighbor with following expressions\n                }\n            }\n        },\n        {\n            name: \"child\",\n            separator: true,\n            regex: tokens.child,\n            populate: function populate(selector, query) {\n                if (selector.currentSubject == null) {\n                    // default: child query\n                    var parentChildQuery = newQuery();\n                    var child = newQuery();\n                    var parent = selector[selector.length - 1];\n                    parentChildQuery.checks.push({\n                        type: Type.CHILD,\n                        parent: parent,\n                        child: child\n                    }); // the query in the selector should be the '>' itself\n                    replaceLastQuery(selector, query, parentChildQuery);\n                    selector.compoundCount++; // we're now populating the child query with expressions that follow\n                    return child;\n                } else if (selector.currentSubject === query) {\n                    // compound split query\n                    var compound = newQuery();\n                    var left = selector[selector.length - 1];\n                    var right = newQuery();\n                    var subject = newQuery();\n                    var _child = newQuery();\n                    var _parent = newQuery(); // set up the root compound q\n                    compound.checks.push({\n                        type: Type.COMPOUND_SPLIT,\n                        left: left,\n                        right: right,\n                        subject: subject\n                    }); // populate the subject and replace the q at the old spot (within left) with TRUE\n                    subject.checks = query.checks; // take the checks from the left\n                    query.checks = [\n                        {\n                            type: Type.TRUE\n                        }\n                    ]; // checks under left refs the subject implicitly\n                    // set up the right q\n                    _parent.checks.push({\n                        type: Type.TRUE\n                    }); // parent implicitly refs the subject\n                    right.checks.push({\n                        type: Type.PARENT,\n                        // type is swapped on right side queries\n                        parent: _parent,\n                        child: _child // empty for now\n                    });\n                    replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n                    selector.currentSubject = subject;\n                    selector.compoundCount++;\n                    return _child; // now populating the right side's child\n                } else {\n                    // parent query\n                    // info for parent query\n                    var _parent2 = newQuery();\n                    var _child2 = newQuery();\n                    var pcQChecks = [\n                        {\n                            type: Type.PARENT,\n                            parent: _parent2,\n                            child: _child2\n                        }\n                    ]; // the parent-child query takes the place of the query previously being populated\n                    _parent2.checks = query.checks; // the previous query contains the checks for the parent\n                    query.checks = pcQChecks; // pc query takes over\n                    selector.compoundCount++;\n                    return _child2; // we're now populating the child\n                }\n            }\n        },\n        {\n            name: \"descendant\",\n            separator: true,\n            regex: tokens.descendant,\n            populate: function populate(selector, query) {\n                if (selector.currentSubject == null) {\n                    // default: descendant query\n                    var ancChQuery = newQuery();\n                    var descendant = newQuery();\n                    var ancestor = selector[selector.length - 1];\n                    ancChQuery.checks.push({\n                        type: Type.DESCENDANT,\n                        ancestor: ancestor,\n                        descendant: descendant\n                    }); // the query in the selector should be the '>' itself\n                    replaceLastQuery(selector, query, ancChQuery);\n                    selector.compoundCount++; // we're now populating the descendant query with expressions that follow\n                    return descendant;\n                } else if (selector.currentSubject === query) {\n                    // compound split query\n                    var compound = newQuery();\n                    var left = selector[selector.length - 1];\n                    var right = newQuery();\n                    var subject = newQuery();\n                    var _descendant = newQuery();\n                    var _ancestor = newQuery(); // set up the root compound q\n                    compound.checks.push({\n                        type: Type.COMPOUND_SPLIT,\n                        left: left,\n                        right: right,\n                        subject: subject\n                    }); // populate the subject and replace the q at the old spot (within left) with TRUE\n                    subject.checks = query.checks; // take the checks from the left\n                    query.checks = [\n                        {\n                            type: Type.TRUE\n                        }\n                    ]; // checks under left refs the subject implicitly\n                    // set up the right q\n                    _ancestor.checks.push({\n                        type: Type.TRUE\n                    }); // ancestor implicitly refs the subject\n                    right.checks.push({\n                        type: Type.ANCESTOR,\n                        // type is swapped on right side queries\n                        ancestor: _ancestor,\n                        descendant: _descendant // empty for now\n                    });\n                    replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n                    selector.currentSubject = subject;\n                    selector.compoundCount++;\n                    return _descendant; // now populating the right side's descendant\n                } else {\n                    // ancestor query\n                    // info for parent query\n                    var _ancestor2 = newQuery();\n                    var _descendant2 = newQuery();\n                    var adQChecks = [\n                        {\n                            type: Type.ANCESTOR,\n                            ancestor: _ancestor2,\n                            descendant: _descendant2\n                        }\n                    ]; // the parent-child query takes the place of the query previously being populated\n                    _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n                    query.checks = adQChecks; // pc query takes over\n                    selector.compoundCount++;\n                    return _descendant2; // we're now populating the child\n                }\n            }\n        },\n        {\n            name: \"subject\",\n            modifier: true,\n            regex: tokens.subject,\n            populate: function populate(selector, query) {\n                if (selector.currentSubject != null && selector.currentSubject !== query) {\n                    warn(\"Redefinition of subject in selector `\" + selector.toString() + \"`\");\n                    return false;\n                }\n                selector.currentSubject = query;\n                var topQ = selector[selector.length - 1];\n                var topChk = topQ.checks[0];\n                var topType = topChk == null ? null : topChk.type;\n                if (topType === Type.DIRECTED_EDGE) {\n                    // directed edge with subject on the target\n                    // change to target node check\n                    topChk.type = Type.NODE_TARGET;\n                } else if (topType === Type.UNDIRECTED_EDGE) {\n                    // undirected edge with subject on the second node\n                    // change to neighbor check\n                    topChk.type = Type.NODE_NEIGHBOR;\n                    topChk.node = topChk.nodes[1]; // second node is subject\n                    topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type\n                    topChk.nodes = null;\n                }\n            }\n        }\n    ];\n    exprs.forEach(function(e) {\n        return e.regexObj = new RegExp(\"^\" + e.regex);\n    });\n    /**\n   * Of all the expressions, find the first match in the remaining text.\n   * @param {string} remaining The remaining text to parse\n   * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n   */ var consumeExpr = function consumeExpr(remaining) {\n        var expr;\n        var match;\n        var name;\n        for(var j = 0; j < exprs.length; j++){\n            var e = exprs[j];\n            var n = e.name;\n            var m1 = remaining.match(e.regexObj);\n            if (m1 != null) {\n                match = m1;\n                expr = e;\n                name = n;\n                var consumed = m1[0];\n                remaining = remaining.substring(consumed.length);\n                break; // we've consumed one expr, so we can return now\n            }\n        }\n        return {\n            expr: expr,\n            match: match,\n            name: name,\n            remaining: remaining\n        };\n    };\n    /**\n   * Consume all the leading whitespace\n   * @param {string} remaining The text to consume\n   * @returns The text with the leading whitespace removed\n   */ var consumeWhitespace = function consumeWhitespace(remaining) {\n        var match = remaining.match(/^\\s+/);\n        if (match) {\n            var consumed = match[0];\n            remaining = remaining.substring(consumed.length);\n        }\n        return remaining;\n    };\n    /**\n   * Parse the string and store the parsed representation in the Selector.\n   * @param {string} selector The selector string\n   * @returns `true` if the selector was successfully parsed, `false` otherwise\n   */ var parse = function parse(selector) {\n        var self1 = this;\n        var remaining = self1.inputText = selector;\n        var currentQuery = self1[0] = newQuery();\n        self1.length = 1;\n        remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n        for(;;){\n            var exprInfo = consumeExpr(remaining);\n            if (exprInfo.expr == null) {\n                warn(\"The selector `\" + selector + \"`is invalid\");\n                return false;\n            } else {\n                var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery\n                var ret = exprInfo.expr.populate(self1, currentQuery, args);\n                if (ret === false) {\n                    return false; // exit if population failed\n                } else if (ret != null) {\n                    currentQuery = ret; // change the current query to be filled if the expr specifies\n                }\n            }\n            remaining = exprInfo.remaining; // we're done when there's nothing left to parse\n            if (remaining.match(/^\\s*$/)) {\n                break;\n            }\n        }\n        var lastQ = self1[self1.length - 1];\n        if (self1.currentSubject != null) {\n            lastQ.subject = self1.currentSubject;\n        }\n        lastQ.edgeCount = self1.edgeCount;\n        lastQ.compoundCount = self1.compoundCount;\n        for(var i = 0; i < self1.length; i++){\n            var q = self1[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n            if (q.compoundCount > 0 && q.edgeCount > 0) {\n                warn(\"The selector `\" + selector + \"` is invalid because it uses both a compound selector and an edge selector\");\n                return false;\n            }\n            if (q.edgeCount > 1) {\n                warn(\"The selector `\" + selector + \"` is invalid because it uses multiple edge selectors\");\n                return false;\n            } else if (q.edgeCount === 1) {\n                warn(\"The selector `\" + selector + \"` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.\");\n            }\n        }\n        return true; // success\n    };\n    /**\n   * Get the selector represented as a string.  This value uses default formatting,\n   * so things like spacing may differ from the input text passed to the constructor.\n   * @returns {string} The selector string\n   */ var toString = function toString() {\n        if (this.toStringCache != null) {\n            return this.toStringCache;\n        }\n        var clean = function clean(obj) {\n            if (obj == null) {\n                return \"\";\n            } else {\n                return obj;\n            }\n        };\n        var cleanVal = function cleanVal(val) {\n            if (string(val)) {\n                return '\"' + val + '\"';\n            } else {\n                return clean(val);\n            }\n        };\n        var space = function space(val) {\n            return \" \" + val + \" \";\n        };\n        var checkToString = function checkToString(check, subject) {\n            var type = check.type, value = check.value;\n            switch(type){\n                case Type.GROUP:\n                    {\n                        var group = clean(value);\n                        return group.substring(0, group.length - 1);\n                    }\n                case Type.DATA_COMPARE:\n                    {\n                        var field = check.field, operator = check.operator;\n                        return \"[\" + field + space(clean(operator)) + cleanVal(value) + \"]\";\n                    }\n                case Type.DATA_BOOL:\n                    {\n                        var _operator = check.operator, _field = check.field;\n                        return \"[\" + clean(_operator) + _field + \"]\";\n                    }\n                case Type.DATA_EXIST:\n                    {\n                        var _field2 = check.field;\n                        return \"[\" + _field2 + \"]\";\n                    }\n                case Type.META_COMPARE:\n                    {\n                        var _operator2 = check.operator, _field3 = check.field;\n                        return \"[[\" + _field3 + space(clean(_operator2)) + cleanVal(value) + \"]]\";\n                    }\n                case Type.STATE:\n                    {\n                        return value;\n                    }\n                case Type.ID:\n                    {\n                        return \"#\" + value;\n                    }\n                case Type.CLASS:\n                    {\n                        return \".\" + value;\n                    }\n                case Type.PARENT:\n                case Type.CHILD:\n                    {\n                        return queryToString(check.parent, subject) + space(\">\") + queryToString(check.child, subject);\n                    }\n                case Type.ANCESTOR:\n                case Type.DESCENDANT:\n                    {\n                        return queryToString(check.ancestor, subject) + \" \" + queryToString(check.descendant, subject);\n                    }\n                case Type.COMPOUND_SPLIT:\n                    {\n                        var lhs = queryToString(check.left, subject);\n                        var sub = queryToString(check.subject, subject);\n                        var rhs = queryToString(check.right, subject);\n                        return lhs + (lhs.length > 0 ? \" \" : \"\") + sub + rhs;\n                    }\n                case Type.TRUE:\n                    {\n                        return \"\";\n                    }\n            }\n        };\n        var queryToString = function queryToString(query, subject) {\n            return query.checks.reduce(function(str, chk, i) {\n                return str + (subject === query && i === 0 ? \"$\" : \"\") + checkToString(chk, subject);\n            }, \"\");\n        };\n        var str = \"\";\n        for(var i = 0; i < this.length; i++){\n            var query = this[i];\n            str += queryToString(query, query.subject);\n            if (this.length > 1 && i < this.length - 1) {\n                str += \", \";\n            }\n        }\n        this.toStringCache = str;\n        return str;\n    };\n    var parse$1 = {\n        parse: parse,\n        toString: toString\n    };\n    var valCmp = function valCmp(fieldVal, operator, value) {\n        var matches;\n        var isFieldStr = string(fieldVal);\n        var isFieldNum = number$1(fieldVal);\n        var isValStr = string(value);\n        var fieldStr, valStr;\n        var caseInsensitive = false;\n        var notExpr = false;\n        var isIneqCmp = false;\n        if (operator.indexOf(\"!\") >= 0) {\n            operator = operator.replace(\"!\", \"\");\n            notExpr = true;\n        }\n        if (operator.indexOf(\"@\") >= 0) {\n            operator = operator.replace(\"@\", \"\");\n            caseInsensitive = true;\n        }\n        if (isFieldStr || isValStr || caseInsensitive) {\n            fieldStr = !isFieldStr && !isFieldNum ? \"\" : \"\" + fieldVal;\n            valStr = \"\" + value;\n        } // if we're doing a case insensitive comparison, then we're using a STRING comparison\n        // even if we're comparing numbers\n        if (caseInsensitive) {\n            fieldVal = fieldStr = fieldStr.toLowerCase();\n            value = valStr = valStr.toLowerCase();\n        }\n        switch(operator){\n            case \"*=\":\n                matches = fieldStr.indexOf(valStr) >= 0;\n                break;\n            case \"$=\":\n                matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n                break;\n            case \"^=\":\n                matches = fieldStr.indexOf(valStr) === 0;\n                break;\n            case \"=\":\n                matches = fieldVal === value;\n                break;\n            case \">\":\n                isIneqCmp = true;\n                matches = fieldVal > value;\n                break;\n            case \">=\":\n                isIneqCmp = true;\n                matches = fieldVal >= value;\n                break;\n            case \"<\":\n                isIneqCmp = true;\n                matches = fieldVal < value;\n                break;\n            case \"<=\":\n                isIneqCmp = true;\n                matches = fieldVal <= value;\n                break;\n            default:\n                matches = false;\n                break;\n        } // apply the not op, but null vals for inequalities should always stay non-matching\n        if (notExpr && (fieldVal != null || !isIneqCmp)) {\n            matches = !matches;\n        }\n        return matches;\n    };\n    var boolCmp = function boolCmp(fieldVal, operator) {\n        switch(operator){\n            case \"?\":\n                return fieldVal ? true : false;\n            case \"!\":\n                return fieldVal ? false : true;\n            case \"^\":\n                return fieldVal === undefined;\n        }\n    };\n    var existCmp = function existCmp(fieldVal) {\n        return fieldVal !== undefined;\n    };\n    var data$1 = function data(ele, field) {\n        return ele.data(field);\n    };\n    var meta = function meta(ele, field) {\n        return ele[field]();\n    };\n    /** A lookup of `match(check, ele)` functions by `Type` int */ var match = [];\n    /**\n   * Returns whether the query matches for the element\n   * @param query The `{ type, value, ... }` query object\n   * @param ele The element to compare against\n  */ var matches$1 = function matches(query, ele) {\n        return query.checks.every(function(chk) {\n            return match[chk.type](chk, ele);\n        });\n    };\n    match[Type.GROUP] = function(check, ele) {\n        var group = check.value;\n        return group === \"*\" || group === ele.group();\n    };\n    match[Type.STATE] = function(check, ele) {\n        var stateSelector = check.value;\n        return stateSelectorMatches(stateSelector, ele);\n    };\n    match[Type.ID] = function(check, ele) {\n        var id = check.value;\n        return ele.id() === id;\n    };\n    match[Type.CLASS] = function(check, ele) {\n        var cls = check.value;\n        return ele.hasClass(cls);\n    };\n    match[Type.META_COMPARE] = function(check, ele) {\n        var field = check.field, operator = check.operator, value = check.value;\n        return valCmp(meta(ele, field), operator, value);\n    };\n    match[Type.DATA_COMPARE] = function(check, ele) {\n        var field = check.field, operator = check.operator, value = check.value;\n        return valCmp(data$1(ele, field), operator, value);\n    };\n    match[Type.DATA_BOOL] = function(check, ele) {\n        var field = check.field, operator = check.operator;\n        return boolCmp(data$1(ele, field), operator);\n    };\n    match[Type.DATA_EXIST] = function(check, ele) {\n        var field = check.field;\n        check.operator;\n        return existCmp(data$1(ele, field));\n    };\n    match[Type.UNDIRECTED_EDGE] = function(check, ele) {\n        var qA = check.nodes[0];\n        var qB = check.nodes[1];\n        var src = ele.source();\n        var tgt = ele.target();\n        return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n    };\n    match[Type.NODE_NEIGHBOR] = function(check, ele) {\n        return matches$1(check.node, ele) && ele.neighborhood().some(function(n) {\n            return n.isNode() && matches$1(check.neighbor, n);\n        });\n    };\n    match[Type.DIRECTED_EDGE] = function(check, ele) {\n        return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n    };\n    match[Type.NODE_SOURCE] = function(check, ele) {\n        return matches$1(check.source, ele) && ele.outgoers().some(function(n) {\n            return n.isNode() && matches$1(check.target, n);\n        });\n    };\n    match[Type.NODE_TARGET] = function(check, ele) {\n        return matches$1(check.target, ele) && ele.incomers().some(function(n) {\n            return n.isNode() && matches$1(check.source, n);\n        });\n    };\n    match[Type.CHILD] = function(check, ele) {\n        return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n    };\n    match[Type.PARENT] = function(check, ele) {\n        return matches$1(check.parent, ele) && ele.children().some(function(c) {\n            return matches$1(check.child, c);\n        });\n    };\n    match[Type.DESCENDANT] = function(check, ele) {\n        return matches$1(check.descendant, ele) && ele.ancestors().some(function(a) {\n            return matches$1(check.ancestor, a);\n        });\n    };\n    match[Type.ANCESTOR] = function(check, ele) {\n        return matches$1(check.ancestor, ele) && ele.descendants().some(function(d) {\n            return matches$1(check.descendant, d);\n        });\n    };\n    match[Type.COMPOUND_SPLIT] = function(check, ele) {\n        return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n    };\n    match[Type.TRUE] = function() {\n        return true;\n    };\n    match[Type.COLLECTION] = function(check, ele) {\n        var collection = check.value;\n        return collection.has(ele);\n    };\n    match[Type.FILTER] = function(check, ele) {\n        var filter = check.value;\n        return filter(ele);\n    };\n    var filter = function filter(collection) {\n        var self1 = this; // for 1 id #foo queries, just get the element\n        if (self1.length === 1 && self1[0].checks.length === 1 && self1[0].checks[0].type === Type.ID) {\n            return collection.getElementById(self1[0].checks[0].value).collection();\n        }\n        var selectorFunction = function selectorFunction(element) {\n            for(var j = 0; j < self1.length; j++){\n                var query = self1[j];\n                if (matches$1(query, element)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (self1.text() == null) {\n            selectorFunction = function selectorFunction() {\n                return true;\n            };\n        }\n        return collection.filter(selectorFunction);\n    }; // filter\n    // does selector match a single element?\n    var matches = function matches(ele) {\n        var self1 = this;\n        for(var j = 0; j < self1.length; j++){\n            var query = self1[j];\n            if (matches$1(query, ele)) {\n                return true;\n            }\n        }\n        return false;\n    }; // matches\n    var matching = {\n        matches: matches,\n        filter: filter\n    };\n    var Selector = function Selector(selector) {\n        this.inputText = selector;\n        this.currentSubject = null;\n        this.compoundCount = 0;\n        this.edgeCount = 0;\n        this.length = 0;\n        if (selector == null || string(selector) && selector.match(/^\\s*$/)) ;\n        else if (elementOrCollection(selector)) {\n            this.addQuery({\n                checks: [\n                    {\n                        type: Type.COLLECTION,\n                        value: selector.collection()\n                    }\n                ]\n            });\n        } else if (fn$6(selector)) {\n            this.addQuery({\n                checks: [\n                    {\n                        type: Type.FILTER,\n                        value: selector\n                    }\n                ]\n            });\n        } else if (string(selector)) {\n            if (!this.parse(selector)) {\n                this.invalid = true;\n            }\n        } else {\n            error(\"A selector must be created from a string; found \");\n        }\n    };\n    var selfn = Selector.prototype;\n    [\n        parse$1,\n        matching\n    ].forEach(function(p) {\n        return extend(selfn, p);\n    });\n    selfn.text = function() {\n        return this.inputText;\n    };\n    selfn.size = function() {\n        return this.length;\n    };\n    selfn.eq = function(i) {\n        return this[i];\n    };\n    selfn.sameText = function(otherSel) {\n        return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n    };\n    selfn.addQuery = function(q) {\n        this[this.length++] = q;\n    };\n    selfn.selector = selfn.toString;\n    var elesfn$g = {\n        allAre: function allAre(selector) {\n            var selObj = new Selector(selector);\n            return this.every(function(ele) {\n                return selObj.matches(ele);\n            });\n        },\n        is: function is(selector) {\n            var selObj = new Selector(selector);\n            return this.some(function(ele) {\n                return selObj.matches(ele);\n            });\n        },\n        some: function some(fn, thisArg) {\n            for(var i = 0; i < this.length; i++){\n                var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                    this[i],\n                    i,\n                    this\n                ]);\n                if (ret) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        every: function every(fn, thisArg) {\n            for(var i = 0; i < this.length; i++){\n                var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                    this[i],\n                    i,\n                    this\n                ]);\n                if (!ret) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        same: function same(collection) {\n            // cheap collection ref check\n            if (this === collection) {\n                return true;\n            }\n            collection = this.cy().collection(collection);\n            var thisLength = this.length;\n            var collectionLength = collection.length; // cheap length check\n            if (thisLength !== collectionLength) {\n                return false;\n            } // cheap element ref check\n            if (thisLength === 1) {\n                return this[0] === collection[0];\n            }\n            return this.every(function(ele) {\n                return collection.hasElementWithId(ele.id());\n            });\n        },\n        anySame: function anySame(collection) {\n            collection = this.cy().collection(collection);\n            return this.some(function(ele) {\n                return collection.hasElementWithId(ele.id());\n            });\n        },\n        allAreNeighbors: function allAreNeighbors(collection) {\n            collection = this.cy().collection(collection);\n            var nhood = this.neighborhood();\n            return collection.every(function(ele) {\n                return nhood.hasElementWithId(ele.id());\n            });\n        },\n        contains: function contains(collection) {\n            collection = this.cy().collection(collection);\n            var self1 = this;\n            return collection.every(function(ele) {\n                return self1.hasElementWithId(ele.id());\n            });\n        }\n    };\n    elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\n    elesfn$g.has = elesfn$g.contains;\n    elesfn$g.equal = elesfn$g.equals = elesfn$g.same;\n    var cache = function cache(fn, name) {\n        return function traversalCache(arg1, arg2, arg3, arg4) {\n            var selectorOrEles = arg1;\n            var eles = this;\n            var key;\n            if (selectorOrEles == null) {\n                key = \"\";\n            } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n                key = selectorOrEles.id();\n            }\n            if (eles.length === 1 && key) {\n                var _p = eles[0]._private;\n                var tch = _p.traversalCache = _p.traversalCache || {};\n                var ch = tch[name] = tch[name] || [];\n                var hash = hashString(key);\n                var cacheHit = ch[hash];\n                if (cacheHit) {\n                    return cacheHit;\n                } else {\n                    return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n                }\n            } else {\n                return fn.call(eles, arg1, arg2, arg3, arg4);\n            }\n        };\n    };\n    var elesfn$f = {\n        parent: function parent(selector) {\n            var parents = []; // optimisation for single ele call\n            if (this.length === 1) {\n                var parent = this[0]._private.parent;\n                if (parent) {\n                    return parent;\n                }\n            }\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var _parent = ele._private.parent;\n                if (_parent) {\n                    parents.push(_parent);\n                }\n            }\n            return this.spawn(parents, true).filter(selector);\n        },\n        parents: function parents(selector) {\n            var parents = [];\n            var eles = this.parent();\n            while(eles.nonempty()){\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    parents.push(ele);\n                }\n                eles = eles.parent();\n            }\n            return this.spawn(parents, true).filter(selector);\n        },\n        commonAncestors: function commonAncestors(selector) {\n            var ancestors;\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var parents = ele.parents();\n                ancestors = ancestors || parents;\n                ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n            }\n            return ancestors.filter(selector);\n        },\n        orphans: function orphans(selector) {\n            return this.stdFilter(function(ele) {\n                return ele.isOrphan();\n            }).filter(selector);\n        },\n        nonorphans: function nonorphans(selector) {\n            return this.stdFilter(function(ele) {\n                return ele.isChild();\n            }).filter(selector);\n        },\n        children: cache(function(selector) {\n            var children = [];\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var eleChildren = ele._private.children;\n                for(var j = 0; j < eleChildren.length; j++){\n                    children.push(eleChildren[j]);\n                }\n            }\n            return this.spawn(children, true).filter(selector);\n        }, \"children\"),\n        siblings: function siblings(selector) {\n            return this.parent().children().not(this).filter(selector);\n        },\n        isParent: function isParent() {\n            var ele = this[0];\n            if (ele) {\n                return ele.isNode() && ele._private.children.length !== 0;\n            }\n        },\n        isChildless: function isChildless() {\n            var ele = this[0];\n            if (ele) {\n                return ele.isNode() && ele._private.children.length === 0;\n            }\n        },\n        isChild: function isChild() {\n            var ele = this[0];\n            if (ele) {\n                return ele.isNode() && ele._private.parent != null;\n            }\n        },\n        isOrphan: function isOrphan() {\n            var ele = this[0];\n            if (ele) {\n                return ele.isNode() && ele._private.parent == null;\n            }\n        },\n        descendants: function descendants(selector) {\n            var elements = [];\n            function add(eles) {\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    elements.push(ele);\n                    if (ele.children().nonempty()) {\n                        add(ele.children());\n                    }\n                }\n            }\n            add(this.children());\n            return this.spawn(elements, true).filter(selector);\n        }\n    };\n    function forEachCompound(eles, fn, includeSelf, recursiveStep) {\n        var q = [];\n        var did = new Set$1();\n        var cy = eles.cy();\n        var hasCompounds = cy.hasCompoundNodes();\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (includeSelf) {\n                q.push(ele);\n            } else if (hasCompounds) {\n                recursiveStep(q, did, ele);\n            }\n        }\n        while(q.length > 0){\n            var _ele = q.shift();\n            fn(_ele);\n            did.add(_ele.id());\n            if (hasCompounds) {\n                recursiveStep(q, did, _ele);\n            }\n        }\n        return eles;\n    }\n    function addChildren(q, did, ele) {\n        if (ele.isParent()) {\n            var children = ele._private.children;\n            for(var i = 0; i < children.length; i++){\n                var child = children[i];\n                if (!did.has(child.id())) {\n                    q.push(child);\n                }\n            }\n        }\n    } // very efficient version of eles.add( eles.descendants() ).forEach()\n    // for internal use\n    elesfn$f.forEachDown = function(fn) {\n        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return forEachCompound(this, fn, includeSelf, addChildren);\n    };\n    function addParent(q, did, ele) {\n        if (ele.isChild()) {\n            var parent = ele._private.parent;\n            if (!did.has(parent.id())) {\n                q.push(parent);\n            }\n        }\n    }\n    elesfn$f.forEachUp = function(fn) {\n        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return forEachCompound(this, fn, includeSelf, addParent);\n    };\n    function addParentAndChildren(q, did, ele) {\n        addParent(q, did, ele);\n        addChildren(q, did, ele);\n    }\n    elesfn$f.forEachUpAndDown = function(fn) {\n        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n    }; // aliases\n    elesfn$f.ancestors = elesfn$f.parents;\n    var fn$5, elesfn$e;\n    fn$5 = elesfn$e = {\n        data: define1.data({\n            field: \"data\",\n            bindingEvent: \"data\",\n            allowBinding: true,\n            allowSetting: true,\n            settingEvent: \"data\",\n            settingTriggersEvent: true,\n            triggerFnName: \"trigger\",\n            allowGetting: true,\n            immutableKeys: {\n                \"id\": true,\n                \"source\": true,\n                \"target\": true,\n                \"parent\": true\n            },\n            updateStyle: true\n        }),\n        removeData: define1.removeData({\n            field: \"data\",\n            event: \"data\",\n            triggerFnName: \"trigger\",\n            triggerEvent: true,\n            immutableKeys: {\n                \"id\": true,\n                \"source\": true,\n                \"target\": true,\n                \"parent\": true\n            },\n            updateStyle: true\n        }),\n        scratch: define1.data({\n            field: \"scratch\",\n            bindingEvent: \"scratch\",\n            allowBinding: true,\n            allowSetting: true,\n            settingEvent: \"scratch\",\n            settingTriggersEvent: true,\n            triggerFnName: \"trigger\",\n            allowGetting: true,\n            updateStyle: true\n        }),\n        removeScratch: define1.removeData({\n            field: \"scratch\",\n            event: \"scratch\",\n            triggerFnName: \"trigger\",\n            triggerEvent: true,\n            updateStyle: true\n        }),\n        rscratch: define1.data({\n            field: \"rscratch\",\n            allowBinding: false,\n            allowSetting: true,\n            settingTriggersEvent: false,\n            allowGetting: true\n        }),\n        removeRscratch: define1.removeData({\n            field: \"rscratch\",\n            triggerEvent: false\n        }),\n        id: function id() {\n            var ele = this[0];\n            if (ele) {\n                return ele._private.data.id;\n            }\n        }\n    }; // aliases\n    fn$5.attr = fn$5.data;\n    fn$5.removeAttr = fn$5.removeData;\n    var data = elesfn$e;\n    var elesfn$d = {};\n    function defineDegreeFunction(callback) {\n        return function(includeLoops) {\n            var self1 = this;\n            if (includeLoops === undefined) {\n                includeLoops = true;\n            }\n            if (self1.length === 0) {\n                return;\n            }\n            if (self1.isNode() && !self1.removed()) {\n                var degree = 0;\n                var node = self1[0];\n                var connectedEdges = node._private.edges;\n                for(var i = 0; i < connectedEdges.length; i++){\n                    var edge = connectedEdges[i];\n                    if (!includeLoops && edge.isLoop()) {\n                        continue;\n                    }\n                    degree += callback(node, edge);\n                }\n                return degree;\n            } else {\n                return;\n            }\n        };\n    }\n    extend(elesfn$d, {\n        degree: defineDegreeFunction(function(node, edge) {\n            if (edge.source().same(edge.target())) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }),\n        indegree: defineDegreeFunction(function(node, edge) {\n            if (edge.target().same(node)) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }),\n        outdegree: defineDegreeFunction(function(node, edge) {\n            if (edge.source().same(node)) {\n                return 1;\n            } else {\n                return 0;\n            }\n        })\n    });\n    function defineDegreeBoundsFunction(degreeFn, callback) {\n        return function(includeLoops) {\n            var ret;\n            var nodes = this.nodes();\n            for(var i = 0; i < nodes.length; i++){\n                var ele = nodes[i];\n                var degree = ele[degreeFn](includeLoops);\n                if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n                    ret = degree;\n                }\n            }\n            return ret;\n        };\n    }\n    extend(elesfn$d, {\n        minDegree: defineDegreeBoundsFunction(\"degree\", function(degree, min) {\n            return degree < min;\n        }),\n        maxDegree: defineDegreeBoundsFunction(\"degree\", function(degree, max) {\n            return degree > max;\n        }),\n        minIndegree: defineDegreeBoundsFunction(\"indegree\", function(degree, min) {\n            return degree < min;\n        }),\n        maxIndegree: defineDegreeBoundsFunction(\"indegree\", function(degree, max) {\n            return degree > max;\n        }),\n        minOutdegree: defineDegreeBoundsFunction(\"outdegree\", function(degree, min) {\n            return degree < min;\n        }),\n        maxOutdegree: defineDegreeBoundsFunction(\"outdegree\", function(degree, max) {\n            return degree > max;\n        })\n    });\n    extend(elesfn$d, {\n        totalDegree: function totalDegree(includeLoops) {\n            var total = 0;\n            var nodes = this.nodes();\n            for(var i = 0; i < nodes.length; i++){\n                total += nodes[i].degree(includeLoops);\n            }\n            return total;\n        }\n    });\n    var fn$4, elesfn$c;\n    var beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.locked()) {\n                var oldPos = ele._private.position;\n                var delta = {\n                    x: newPos.x != null ? newPos.x - oldPos.x : 0,\n                    y: newPos.y != null ? newPos.y - oldPos.y : 0\n                };\n                if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n                    ele.children().shift(delta, silent);\n                }\n                ele.dirtyBoundingBoxCache();\n            }\n        }\n    };\n    var positionDef = {\n        field: \"position\",\n        bindingEvent: \"position\",\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: \"position\",\n        settingTriggersEvent: true,\n        triggerFnName: \"emitAndNotify\",\n        allowGetting: true,\n        validKeys: [\n            \"x\",\n            \"y\"\n        ],\n        beforeGet: function beforeGet(ele) {\n            ele.updateCompoundBounds();\n        },\n        beforeSet: function beforeSet(eles, newPos) {\n            beforePositionSet(eles, newPos, false);\n        },\n        onSet: function onSet(eles) {\n            eles.dirtyCompoundBoundsCache();\n        },\n        canSet: function canSet(ele) {\n            return !ele.locked();\n        }\n    };\n    fn$4 = elesfn$c = {\n        position: define1.data(positionDef),\n        // position but no notification to renderer\n        silentPosition: define1.data(extend({}, positionDef, {\n            allowBinding: false,\n            allowSetting: true,\n            settingTriggersEvent: false,\n            allowGetting: false,\n            beforeSet: function beforeSet(eles, newPos) {\n                beforePositionSet(eles, newPos, true);\n            },\n            onSet: function onSet(eles) {\n                eles.dirtyCompoundBoundsCache();\n            }\n        })),\n        positions: function positions(pos, silent) {\n            if (plainObject(pos)) {\n                if (silent) {\n                    this.silentPosition(pos);\n                } else {\n                    this.position(pos);\n                }\n            } else if (fn$6(pos)) {\n                var _fn = pos;\n                var cy = this.cy();\n                cy.startBatch();\n                for(var i = 0; i < this.length; i++){\n                    var ele = this[i];\n                    var _pos = void 0;\n                    if (_pos = _fn(ele, i)) {\n                        if (silent) {\n                            ele.silentPosition(_pos);\n                        } else {\n                            ele.position(_pos);\n                        }\n                    }\n                }\n                cy.endBatch();\n            }\n            return this; // chaining\n        },\n        silentPositions: function silentPositions(pos) {\n            return this.positions(pos, true);\n        },\n        shift: function shift(dim, val, silent) {\n            var delta;\n            if (plainObject(dim)) {\n                delta = {\n                    x: number$1(dim.x) ? dim.x : 0,\n                    y: number$1(dim.y) ? dim.y : 0\n                };\n                silent = val;\n            } else if (string(dim) && number$1(val)) {\n                delta = {\n                    x: 0,\n                    y: 0\n                };\n                delta[dim] = val;\n            }\n            if (delta != null) {\n                var cy = this.cy();\n                cy.startBatch();\n                for(var i = 0; i < this.length; i++){\n                    var ele = this[i]; // exclude any node that is a descendant of the calling collection\n                    if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n                        continue;\n                    }\n                    var pos = ele.position();\n                    var newPos = {\n                        x: pos.x + delta.x,\n                        y: pos.y + delta.y\n                    };\n                    if (silent) {\n                        ele.silentPosition(newPos);\n                    } else {\n                        ele.position(newPos);\n                    }\n                }\n                cy.endBatch();\n            }\n            return this;\n        },\n        silentShift: function silentShift(dim, val) {\n            if (plainObject(dim)) {\n                this.shift(dim, true);\n            } else if (string(dim) && number$1(val)) {\n                this.shift(dim, val, true);\n            }\n            return this;\n        },\n        // get/set the rendered (i.e. on screen) positon of the element\n        renderedPosition: function renderedPosition(dim, val) {\n            var ele = this[0];\n            var cy = this.cy();\n            var zoom = cy.zoom();\n            var pan = cy.pan();\n            var rpos = plainObject(dim) ? dim : undefined;\n            var setting = rpos !== undefined || val !== undefined && string(dim);\n            if (ele && ele.isNode()) {\n                // must have an element and must be a node to return position\n                if (setting) {\n                    for(var i = 0; i < this.length; i++){\n                        var _ele = this[i];\n                        if (val !== undefined) {\n                            // set one dimension\n                            _ele.position(dim, (val - pan[dim]) / zoom);\n                        } else if (rpos !== undefined) {\n                            // set whole position\n                            _ele.position(renderedToModelPosition(rpos, zoom, pan));\n                        }\n                    }\n                } else {\n                    // getting\n                    var pos = ele.position();\n                    rpos = modelToRenderedPosition(pos, zoom, pan);\n                    if (dim === undefined) {\n                        // then return the whole rendered position\n                        return rpos;\n                    } else {\n                        // then return the specified dimension\n                        return rpos[dim];\n                    }\n                }\n            } else if (!setting) {\n                return undefined; // for empty collection case\n            }\n            return this; // chaining\n        },\n        // get/set the position relative to the parent\n        relativePosition: function relativePosition(dim, val) {\n            var ele = this[0];\n            var cy = this.cy();\n            var ppos = plainObject(dim) ? dim : undefined;\n            var setting = ppos !== undefined || val !== undefined && string(dim);\n            var hasCompoundNodes = cy.hasCompoundNodes();\n            if (ele && ele.isNode()) {\n                // must have an element and must be a node to return position\n                if (setting) {\n                    for(var i = 0; i < this.length; i++){\n                        var _ele2 = this[i];\n                        var parent = hasCompoundNodes ? _ele2.parent() : null;\n                        var hasParent = parent && parent.length > 0;\n                        var relativeToParent = hasParent;\n                        if (hasParent) {\n                            parent = parent[0];\n                        }\n                        var origin = relativeToParent ? parent.position() : {\n                            x: 0,\n                            y: 0\n                        };\n                        if (val !== undefined) {\n                            // set one dimension\n                            _ele2.position(dim, val + origin[dim]);\n                        } else if (ppos !== undefined) {\n                            // set whole position\n                            _ele2.position({\n                                x: ppos.x + origin.x,\n                                y: ppos.y + origin.y\n                            });\n                        }\n                    }\n                } else {\n                    // getting\n                    var pos = ele.position();\n                    var _parent = hasCompoundNodes ? ele.parent() : null;\n                    var _hasParent = _parent && _parent.length > 0;\n                    var _relativeToParent = _hasParent;\n                    if (_hasParent) {\n                        _parent = _parent[0];\n                    }\n                    var _origin = _relativeToParent ? _parent.position() : {\n                        x: 0,\n                        y: 0\n                    };\n                    ppos = {\n                        x: pos.x - _origin.x,\n                        y: pos.y - _origin.y\n                    };\n                    if (dim === undefined) {\n                        // then return the whole rendered position\n                        return ppos;\n                    } else {\n                        // then return the specified dimension\n                        return ppos[dim];\n                    }\n                }\n            } else if (!setting) {\n                return undefined; // for empty collection case\n            }\n            return this; // chaining\n        }\n    }; // aliases\n    fn$4.modelPosition = fn$4.point = fn$4.position;\n    fn$4.modelPositions = fn$4.points = fn$4.positions;\n    fn$4.renderedPoint = fn$4.renderedPosition;\n    fn$4.relativePoint = fn$4.relativePosition;\n    var position = elesfn$c;\n    var fn$3, elesfn$b;\n    fn$3 = elesfn$b = {};\n    elesfn$b.renderedBoundingBox = function(options) {\n        var bb = this.boundingBox(options);\n        var cy = this.cy();\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var x1 = bb.x1 * zoom + pan.x;\n        var x2 = bb.x2 * zoom + pan.x;\n        var y1 = bb.y1 * zoom + pan.y;\n        var y2 = bb.y2 * zoom + pan.y;\n        return {\n            x1: x1,\n            x2: x2,\n            y1: y1,\n            y2: y2,\n            w: x2 - x1,\n            h: y2 - y1\n        };\n    };\n    elesfn$b.dirtyCompoundBoundsCache = function() {\n        var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var cy = this.cy();\n        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n            return this;\n        }\n        this.forEachUp(function(ele) {\n            if (ele.isParent()) {\n                var _p = ele._private;\n                _p.compoundBoundsClean = false;\n                _p.bbCache = null;\n                if (!silent) {\n                    ele.emitAndNotify(\"bounds\");\n                }\n            }\n        });\n        return this;\n    };\n    elesfn$b.updateCompoundBounds = function() {\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled\n        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n            return this;\n        } // save cycles when batching -- but bounds will be stale (or not exist yet)\n        if (!force && cy.batching()) {\n            return this;\n        }\n        function update(parent) {\n            if (!parent.isParent()) {\n                return;\n            }\n            var _p = parent._private;\n            var children = parent.children();\n            var includeLabels = parent.pstyle(\"compound-sizing-wrt-labels\").value === \"include\";\n            var min = {\n                width: {\n                    val: parent.pstyle(\"min-width\").pfValue,\n                    left: parent.pstyle(\"min-width-bias-left\"),\n                    right: parent.pstyle(\"min-width-bias-right\")\n                },\n                height: {\n                    val: parent.pstyle(\"min-height\").pfValue,\n                    top: parent.pstyle(\"min-height-bias-top\"),\n                    bottom: parent.pstyle(\"min-height-bias-bottom\")\n                }\n            };\n            var bb = children.boundingBox({\n                includeLabels: includeLabels,\n                includeOverlays: false,\n                // updating the compound bounds happens outside of the regular\n                // cache cycle (i.e. before fired events)\n                useCache: false\n            });\n            var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h\n            if (bb.w === 0 || bb.h === 0) {\n                bb = {\n                    w: parent.pstyle(\"width\").pfValue,\n                    h: parent.pstyle(\"height\").pfValue\n                };\n                bb.x1 = pos.x - bb.w / 2;\n                bb.x2 = pos.x + bb.w / 2;\n                bb.y1 = pos.y - bb.h / 2;\n                bb.y2 = pos.y + bb.h / 2;\n            }\n            function computeBiasValues(propDiff, propBias, propBiasComplement) {\n                var biasDiff = 0;\n                var biasComplementDiff = 0;\n                var biasTotal = propBias + propBiasComplement;\n                if (propDiff > 0 && biasTotal > 0) {\n                    biasDiff = propBias / biasTotal * propDiff;\n                    biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n                }\n                return {\n                    biasDiff: biasDiff,\n                    biasComplementDiff: biasComplementDiff\n                };\n            }\n            function computePaddingValues(width, height, paddingObject, relativeTo) {\n                // Assuming percentage is number from 0 to 1\n                if (paddingObject.units === \"%\") {\n                    switch(relativeTo){\n                        case \"width\":\n                            return width > 0 ? paddingObject.pfValue * width : 0;\n                        case \"height\":\n                            return height > 0 ? paddingObject.pfValue * height : 0;\n                        case \"average\":\n                            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n                        case \"min\":\n                            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n                        case \"max\":\n                            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n                        default:\n                            return 0;\n                    }\n                } else if (paddingObject.units === \"px\") {\n                    return paddingObject.pfValue;\n                } else {\n                    return 0;\n                }\n            }\n            var leftVal = min.width.left.value;\n            if (min.width.left.units === \"px\" && min.width.val > 0) {\n                leftVal = leftVal * 100 / min.width.val;\n            }\n            var rightVal = min.width.right.value;\n            if (min.width.right.units === \"px\" && min.width.val > 0) {\n                rightVal = rightVal * 100 / min.width.val;\n            }\n            var topVal = min.height.top.value;\n            if (min.height.top.units === \"px\" && min.height.val > 0) {\n                topVal = topVal * 100 / min.height.val;\n            }\n            var bottomVal = min.height.bottom.value;\n            if (min.height.bottom.units === \"px\" && min.height.val > 0) {\n                bottomVal = bottomVal * 100 / min.height.val;\n            }\n            var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n            var diffLeft = widthBiasDiffs.biasDiff;\n            var diffRight = widthBiasDiffs.biasComplementDiff;\n            var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n            var diffTop = heightBiasDiffs.biasDiff;\n            var diffBottom = heightBiasDiffs.biasComplementDiff;\n            _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle(\"padding\"), parent.pstyle(\"padding-relative-to\").value);\n            _p.autoWidth = Math.max(bb.w, min.width.val);\n            pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n            _p.autoHeight = Math.max(bb.h, min.height.val);\n            pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _p = ele._private;\n            if (!_p.compoundBoundsClean || force) {\n                update(ele);\n                if (!cy.batching()) {\n                    _p.compoundBoundsClean = true;\n                }\n            }\n        }\n        return this;\n    };\n    var noninf = function noninf(x) {\n        if (x === Infinity || x === -Infinity) {\n            return 0;\n        }\n        return x;\n    };\n    var updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n        // don't update with zero area boxes\n        if (x2 - x1 === 0 || y2 - y1 === 0) {\n            return;\n        } // don't update with null dim\n        if (x1 == null || y1 == null || x2 == null || y2 == null) {\n            return;\n        }\n        b.x1 = x1 < b.x1 ? x1 : b.x1;\n        b.x2 = x2 > b.x2 ? x2 : b.x2;\n        b.y1 = y1 < b.y1 ? y1 : b.y1;\n        b.y2 = y2 > b.y2 ? y2 : b.y2;\n        b.w = b.x2 - b.x1;\n        b.h = b.y2 - b.y1;\n    };\n    var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n        if (b2 == null) {\n            return b;\n        }\n        return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n    };\n    var prefixedProperty = function prefixedProperty(obj, field, prefix) {\n        return getPrefixedProperty(obj, field, prefix);\n    };\n    var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n        if (ele.cy().headless()) {\n            return;\n        }\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        var halfArW = rstyle.arrowWidth / 2;\n        var arrowType = ele.pstyle(prefix + \"-arrow-shape\").value;\n        var x;\n        var y;\n        if (arrowType !== \"none\") {\n            if (prefix === \"source\") {\n                x = rstyle.srcX;\n                y = rstyle.srcY;\n            } else if (prefix === \"target\") {\n                x = rstyle.tgtX;\n                y = rstyle.tgtY;\n            } else {\n                x = rstyle.midX;\n                y = rstyle.midY;\n            } // always store the individual arrow bounds\n            var bbs = _p.arrowBounds = _p.arrowBounds || {};\n            var bb = bbs[prefix] = bbs[prefix] || {};\n            bb.x1 = x - halfArW;\n            bb.y1 = y - halfArW;\n            bb.x2 = x + halfArW;\n            bb.y2 = y + halfArW;\n            bb.w = bb.x2 - bb.x1;\n            bb.h = bb.y2 - bb.y1;\n            expandBoundingBox(bb, 1);\n            updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n        }\n    };\n    var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n        if (ele.cy().headless()) {\n            return;\n        }\n        var prefixDash;\n        if (prefix) {\n            prefixDash = prefix + \"-\";\n        } else {\n            prefixDash = \"\";\n        }\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        var label = ele.pstyle(prefixDash + \"label\").strValue;\n        if (label) {\n            var halign = ele.pstyle(\"text-halign\");\n            var valign = ele.pstyle(\"text-valign\");\n            var labelWidth = prefixedProperty(rstyle, \"labelWidth\", prefix);\n            var labelHeight = prefixedProperty(rstyle, \"labelHeight\", prefix);\n            var labelX = prefixedProperty(rstyle, \"labelX\", prefix);\n            var labelY = prefixedProperty(rstyle, \"labelY\", prefix);\n            var marginX = ele.pstyle(prefixDash + \"text-margin-x\").pfValue;\n            var marginY = ele.pstyle(prefixDash + \"text-margin-y\").pfValue;\n            var isEdge = ele.isEdge();\n            var rotation = ele.pstyle(prefixDash + \"text-rotation\");\n            var outlineWidth = ele.pstyle(\"text-outline-width\").pfValue;\n            var borderWidth = ele.pstyle(\"text-border-width\").pfValue;\n            var halfBorderWidth = borderWidth / 2;\n            var padding = ele.pstyle(\"text-background-padding\").pfValue;\n            var marginOfError = 2; // expand to work around browser dimension inaccuracies\n            var lh = labelHeight;\n            var lw = labelWidth;\n            var lw_2 = lw / 2;\n            var lh_2 = lh / 2;\n            var lx1, lx2, ly1, ly2;\n            if (isEdge) {\n                lx1 = labelX - lw_2;\n                lx2 = labelX + lw_2;\n                ly1 = labelY - lh_2;\n                ly2 = labelY + lh_2;\n            } else {\n                switch(halign.value){\n                    case \"left\":\n                        lx1 = labelX - lw;\n                        lx2 = labelX;\n                        break;\n                    case \"center\":\n                        lx1 = labelX - lw_2;\n                        lx2 = labelX + lw_2;\n                        break;\n                    case \"right\":\n                        lx1 = labelX;\n                        lx2 = labelX + lw;\n                        break;\n                }\n                switch(valign.value){\n                    case \"top\":\n                        ly1 = labelY - lh;\n                        ly2 = labelY;\n                        break;\n                    case \"center\":\n                        ly1 = labelY - lh_2;\n                        ly2 = labelY + lh_2;\n                        break;\n                    case \"bottom\":\n                        ly1 = labelY;\n                        ly2 = labelY + lh;\n                        break;\n                }\n            } // shift by margin and expand by outline and border\n            lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n            lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n            ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n            ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately\n            var bbPrefix = prefix || \"main\";\n            var bbs = _p.labelBounds;\n            var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n            bb.x1 = lx1;\n            bb.y1 = ly1;\n            bb.x2 = lx2;\n            bb.y2 = ly2;\n            bb.w = lx2 - lx1;\n            bb.h = ly2 - ly1;\n            var isAutorotate = isEdge && rotation.strValue === \"autorotate\";\n            var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n            if (isAutorotate || isPfValue) {\n                var theta = isAutorotate ? prefixedProperty(_p.rstyle, \"labelAngle\", prefix) : rotation.pfValue;\n                var cos = Math.cos(theta);\n                var sin = Math.sin(theta); // rotation point (default value for center-center)\n                var xo = (lx1 + lx2) / 2;\n                var yo = (ly1 + ly2) / 2;\n                if (!isEdge) {\n                    switch(halign.value){\n                        case \"left\":\n                            xo = lx2;\n                            break;\n                        case \"right\":\n                            xo = lx1;\n                            break;\n                    }\n                    switch(valign.value){\n                        case \"top\":\n                            yo = ly2;\n                            break;\n                        case \"bottom\":\n                            yo = ly1;\n                            break;\n                    }\n                }\n                var rotate = function rotate(x, y) {\n                    x = x - xo;\n                    y = y - yo;\n                    return {\n                        x: x * cos - y * sin + xo,\n                        y: x * sin + y * cos + yo\n                    };\n                };\n                var px1y1 = rotate(lx1, ly1);\n                var px1y2 = rotate(lx1, ly2);\n                var px2y1 = rotate(lx2, ly1);\n                var px2y2 = rotate(lx2, ly2);\n                lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n                lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n                ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n                ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n            }\n            var bbPrefixRot = bbPrefix + \"Rot\";\n            var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n            bbRot.x1 = lx1;\n            bbRot.y1 = ly1;\n            bbRot.x2 = lx2;\n            bbRot.y2 = ly2;\n            bbRot.w = lx2 - lx1;\n            bbRot.h = ly2 - ly1;\n            updateBounds(bounds, lx1, ly1, lx2, ly2);\n            updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n        }\n        return bounds;\n    }; // get the bounding box of the elements (in raw model position)\n    var boundingBoxImpl = function boundingBoxImpl(ele, options) {\n        var cy = ele._private.cy;\n        var styleEnabled = cy.styleEnabled();\n        var headless = cy.headless();\n        var bounds = makeBoundingBox();\n        var _p = ele._private;\n        var isNode = ele.isNode();\n        var isEdge = ele.isEdge();\n        var ex1, ex2, ey1, ey2; // extrema of body / lines\n        var x, y; // node pos\n        var rstyle = _p.rstyle;\n        var manualExpansion = isNode && styleEnabled ? ele.pstyle(\"bounds-expansion\").pfValue : [\n            0\n        ]; // must use `display` prop only, as reading `compound.width()` causes recursion\n        // (other factors like width values will be considered later in this function anyway)\n        var isDisplayed = function isDisplayed(ele) {\n            return ele.pstyle(\"display\").value !== \"none\";\n        };\n        var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node\n         && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n        if (displayed) {\n            // displayed suffices, since we will find zero area eles anyway\n            var overlayOpacity = 0;\n            var overlayPadding = 0;\n            if (styleEnabled && options.includeOverlays) {\n                overlayOpacity = ele.pstyle(\"overlay-opacity\").value;\n                if (overlayOpacity !== 0) {\n                    overlayPadding = ele.pstyle(\"overlay-padding\").value;\n                }\n            }\n            var underlayOpacity = 0;\n            var underlayPadding = 0;\n            if (styleEnabled && options.includeUnderlays) {\n                underlayOpacity = ele.pstyle(\"underlay-opacity\").value;\n                if (underlayOpacity !== 0) {\n                    underlayPadding = ele.pstyle(\"underlay-padding\").value;\n                }\n            }\n            var padding = Math.max(overlayPadding, underlayPadding);\n            var w = 0;\n            var wHalf = 0;\n            if (styleEnabled) {\n                w = ele.pstyle(\"width\").pfValue;\n                wHalf = w / 2;\n            }\n            if (isNode && options.includeNodes) {\n                var pos = ele.position();\n                x = pos.x;\n                y = pos.y;\n                var _w = ele.outerWidth();\n                var halfW = _w / 2;\n                var h = ele.outerHeight();\n                var halfH = h / 2; // handle node dimensions\n                /////////////////////////\n                ex1 = x - halfW;\n                ex2 = x + halfW;\n                ey1 = y - halfH;\n                ey2 = y + halfH;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n            } else if (isEdge && options.includeEdges) {\n                if (styleEnabled && !headless) {\n                    var curveStyle = ele.pstyle(\"curve-style\").strValue; // handle edge dimensions (rough box estimate)\n                    //////////////////////////////////////////////\n                    ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                    ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                    ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                    ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width\n                    ex1 -= wHalf;\n                    ex2 += wHalf;\n                    ey1 -= wHalf;\n                    ey2 += wHalf;\n                    updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges\n                    ////////////////\n                    if (curveStyle === \"haystack\") {\n                        var hpts = rstyle.haystackPts;\n                        if (hpts && hpts.length === 2) {\n                            ex1 = hpts[0].x;\n                            ey1 = hpts[0].y;\n                            ex2 = hpts[1].x;\n                            ey2 = hpts[1].y;\n                            if (ex1 > ex2) {\n                                var temp = ex1;\n                                ex1 = ex2;\n                                ex2 = temp;\n                            }\n                            if (ey1 > ey2) {\n                                var _temp = ey1;\n                                ey1 = ey2;\n                                ey2 = _temp;\n                            }\n                            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n                        }\n                    } else if (curveStyle === \"bezier\" || curveStyle === \"unbundled-bezier\" || curveStyle === \"segments\" || curveStyle === \"taxi\") {\n                        var pts;\n                        switch(curveStyle){\n                            case \"bezier\":\n                            case \"unbundled-bezier\":\n                                pts = rstyle.bezierPts;\n                                break;\n                            case \"segments\":\n                            case \"taxi\":\n                                pts = rstyle.linePts;\n                                break;\n                        }\n                        if (pts != null) {\n                            for(var j = 0; j < pts.length; j++){\n                                var pt = pts[j];\n                                ex1 = pt.x - wHalf;\n                                ex2 = pt.x + wHalf;\n                                ey1 = pt.y - wHalf;\n                                ey2 = pt.y + wHalf;\n                                updateBounds(bounds, ex1, ey1, ex2, ey2);\n                            }\n                        }\n                    } // bezier-like or segment-like edge\n                } else {\n                    // headless or style disabled\n                    // fallback on source and target positions\n                    //////////////////////////////////////////\n                    var n1 = ele.source();\n                    var n1pos = n1.position();\n                    var n2 = ele.target();\n                    var n2pos = n2.position();\n                    ex1 = n1pos.x;\n                    ex2 = n2pos.x;\n                    ey1 = n1pos.y;\n                    ey2 = n2pos.y;\n                    if (ex1 > ex2) {\n                        var _temp2 = ex1;\n                        ex1 = ex2;\n                        ex2 = _temp2;\n                    }\n                    if (ey1 > ey2) {\n                        var _temp3 = ey1;\n                        ey1 = ey2;\n                        ey2 = _temp3;\n                    } // take into account edge width\n                    ex1 -= wHalf;\n                    ex2 += wHalf;\n                    ey1 -= wHalf;\n                    ey2 += wHalf;\n                    updateBounds(bounds, ex1, ey1, ex2, ey2);\n                } // headless or style disabled\n            } // edges\n            // handle edge arrow size\n            /////////////////////////\n            if (styleEnabled && options.includeEdges && isEdge) {\n                updateBoundsFromArrow(bounds, ele, \"mid-source\");\n                updateBoundsFromArrow(bounds, ele, \"mid-target\");\n                updateBoundsFromArrow(bounds, ele, \"source\");\n                updateBoundsFromArrow(bounds, ele, \"target\");\n            } // ghost\n            ////////\n            if (styleEnabled) {\n                var ghost = ele.pstyle(\"ghost\").value === \"yes\";\n                if (ghost) {\n                    var gx = ele.pstyle(\"ghost-offset-x\").pfValue;\n                    var gy = ele.pstyle(\"ghost-offset-y\").pfValue;\n                    updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n                }\n            } // always store the body bounds separately from the labels\n            var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n            assignBoundingBox(bbBody, bounds);\n            expandBoundingBoxSides(bbBody, manualExpansion);\n            expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n            // overlay\n            //////////\n            if (styleEnabled) {\n                ex1 = bounds.x1;\n                ex2 = bounds.x2;\n                ey1 = bounds.y1;\n                ey2 = bounds.y2;\n                updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n            } // always store the body bounds separately from the labels\n            var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n            assignBoundingBox(bbOverlay, bounds);\n            expandBoundingBoxSides(bbOverlay, manualExpansion);\n            expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n            // handle label dimensions\n            //////////////////////////\n            var bbLabels = _p.labelBounds = _p.labelBounds || {};\n            if (bbLabels.all != null) {\n                clearBoundingBox(bbLabels.all);\n            } else {\n                bbLabels.all = makeBoundingBox();\n            }\n            if (styleEnabled && options.includeLabels) {\n                if (options.includeMainLabels) {\n                    updateBoundsFromLabel(bounds, ele, null);\n                }\n                if (isEdge) {\n                    if (options.includeSourceLabels) {\n                        updateBoundsFromLabel(bounds, ele, \"source\");\n                    }\n                    if (options.includeTargetLabels) {\n                        updateBoundsFromLabel(bounds, ele, \"target\");\n                    }\n                }\n            } // style enabled for labels\n        } // if displayed\n        bounds.x1 = noninf(bounds.x1);\n        bounds.y1 = noninf(bounds.y1);\n        bounds.x2 = noninf(bounds.x2);\n        bounds.y2 = noninf(bounds.y2);\n        bounds.w = noninf(bounds.x2 - bounds.x1);\n        bounds.h = noninf(bounds.y2 - bounds.y1);\n        if (bounds.w > 0 && bounds.h > 0 && displayed) {\n            expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n            expandBoundingBox(bounds, 1);\n        }\n        return bounds;\n    };\n    var getKey = function getKey(opts) {\n        var i = 0;\n        var tf = function tf(val) {\n            return (val ? 1 : 0) << i++;\n        };\n        var key = 0;\n        key += tf(opts.incudeNodes);\n        key += tf(opts.includeEdges);\n        key += tf(opts.includeLabels);\n        key += tf(opts.includeMainLabels);\n        key += tf(opts.includeSourceLabels);\n        key += tf(opts.includeTargetLabels);\n        key += tf(opts.includeOverlays);\n        return key;\n    };\n    var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n        if (ele.isEdge()) {\n            var p1 = ele.source().position();\n            var p2 = ele.target().position();\n            var r = function r(x) {\n                return Math.round(x);\n            };\n            return hashIntsArray([\n                r(p1.x),\n                r(p1.y),\n                r(p2.x),\n                r(p2.y)\n            ]);\n        } else {\n            return 0;\n        }\n    };\n    var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n        var _p = ele._private;\n        var bb;\n        var isEdge = ele.isEdge();\n        var key = opts == null ? defBbOptsKey : getKey(opts);\n        var usingDefOpts = key === defBbOptsKey;\n        var currPosKey = getBoundingBoxPosKey(ele);\n        var isPosKeySame = _p.bbCachePosKey === currPosKey;\n        var useCache = opts.useCache && isPosKeySame;\n        var isDirty = function isDirty(ele) {\n            return ele._private.bbCache == null || ele._private.styleDirty;\n        };\n        var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());\n        if (needRecalc) {\n            if (!isPosKeySame) {\n                ele.recalculateRenderedStyle(useCache);\n            }\n            bb = boundingBoxImpl(ele, defBbOpts);\n            _p.bbCache = bb;\n            _p.bbCachePosKey = currPosKey;\n        } else {\n            bb = _p.bbCache;\n        } // not using def opts => need to build up bb from combination of sub bbs\n        if (!usingDefOpts) {\n            var isNode = ele.isNode();\n            bb = makeBoundingBox();\n            if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n                if (opts.includeOverlays) {\n                    updateBoundsFromBox(bb, _p.overlayBounds);\n                } else {\n                    updateBoundsFromBox(bb, _p.bodyBounds);\n                }\n            }\n            if (opts.includeLabels) {\n                if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n                    updateBoundsFromBox(bb, _p.labelBounds.all);\n                } else {\n                    if (opts.includeMainLabels) {\n                        updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n                    }\n                    if (opts.includeSourceLabels) {\n                        updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n                    }\n                    if (opts.includeTargetLabels) {\n                        updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n                    }\n                }\n            }\n            bb.w = bb.x2 - bb.x1;\n            bb.h = bb.y2 - bb.y1;\n        }\n        return bb;\n    };\n    var defBbOpts = {\n        includeNodes: true,\n        includeEdges: true,\n        includeLabels: true,\n        includeMainLabels: true,\n        includeSourceLabels: true,\n        includeTargetLabels: true,\n        includeOverlays: true,\n        includeUnderlays: true,\n        useCache: true\n    };\n    var defBbOptsKey = getKey(defBbOpts);\n    var filledBbOpts = defaults$g(defBbOpts);\n    elesfn$b.boundingBox = function(options) {\n        var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options\n        // specified s.t. the cache is used, so check for this case to make it faster by\n        // avoiding the overhead of the rest of the function\n        if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n            if (options === undefined) {\n                options = defBbOpts;\n            } else {\n                options = filledBbOpts(options);\n            }\n            bounds = cachedBoundingBoxImpl(this[0], options);\n        } else {\n            bounds = makeBoundingBox();\n            options = options || defBbOpts;\n            var opts = filledBbOpts(options);\n            var eles = this;\n            var cy = eles.cy();\n            var styleEnabled = cy.styleEnabled();\n            if (styleEnabled) {\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _p = ele._private;\n                    var currPosKey = getBoundingBoxPosKey(ele);\n                    var isPosKeySame = _p.bbCachePosKey === currPosKey;\n                    var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;\n                    ele.recalculateRenderedStyle(useCache);\n                }\n            }\n            this.updateCompoundBounds(!options.useCache);\n            for(var _i = 0; _i < eles.length; _i++){\n                var _ele = eles[_i];\n                updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));\n            }\n        }\n        bounds.x1 = noninf(bounds.x1);\n        bounds.y1 = noninf(bounds.y1);\n        bounds.x2 = noninf(bounds.x2);\n        bounds.y2 = noninf(bounds.y2);\n        bounds.w = noninf(bounds.x2 - bounds.x1);\n        bounds.h = noninf(bounds.y2 - bounds.y1);\n        return bounds;\n    };\n    elesfn$b.dirtyBoundingBoxCache = function() {\n        for(var i = 0; i < this.length; i++){\n            var _p = this[i]._private;\n            _p.bbCache = null;\n            _p.bbCachePosKey = null;\n            _p.bodyBounds = null;\n            _p.overlayBounds = null;\n            _p.labelBounds.all = null;\n            _p.labelBounds.source = null;\n            _p.labelBounds.target = null;\n            _p.labelBounds.main = null;\n            _p.labelBounds.sourceRot = null;\n            _p.labelBounds.targetRot = null;\n            _p.labelBounds.mainRot = null;\n            _p.arrowBounds.source = null;\n            _p.arrowBounds.target = null;\n            _p.arrowBounds[\"mid-source\"] = null;\n            _p.arrowBounds[\"mid-target\"] = null;\n        }\n        this.emitAndNotify(\"bounds\");\n        return this;\n    }; // private helper to get bounding box for custom node positions\n    // - good for perf in certain cases but currently requires dirtying the rendered style\n    // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n    // - try to use for only things like discrete layouts where the node position would change anyway\n    elesfn$b.boundingBoxAt = function(fn) {\n        var nodes = this.nodes();\n        var cy = this.cy();\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        var parents = cy.collection();\n        if (hasCompoundNodes) {\n            parents = nodes.filter(function(node) {\n                return node.isParent();\n            });\n            nodes = nodes.not(parents);\n        }\n        if (plainObject(fn)) {\n            var obj = fn;\n            fn = function fn() {\n                return obj;\n            };\n        }\n        var storeOldPos = function storeOldPos(node, i) {\n            return node._private.bbAtOldPos = fn(node, i);\n        };\n        var getOldPos = function getOldPos(node) {\n            return node._private.bbAtOldPos;\n        };\n        cy.startBatch();\n        nodes.forEach(storeOldPos).silentPositions(fn);\n        if (hasCompoundNodes) {\n            parents.dirtyCompoundBoundsCache();\n            parents.dirtyBoundingBoxCache();\n            parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n        }\n        var bb = copyBoundingBox(this.boundingBox({\n            useCache: false\n        }));\n        nodes.silentPositions(getOldPos);\n        if (hasCompoundNodes) {\n            parents.dirtyCompoundBoundsCache();\n            parents.dirtyBoundingBoxCache();\n            parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n        }\n        cy.endBatch();\n        return bb;\n    };\n    fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\n    fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\n    var bounds = elesfn$b;\n    var fn$2, elesfn$a;\n    fn$2 = elesfn$a = {};\n    var defineDimFns = function defineDimFns(opts) {\n        opts.uppercaseName = capitalize(opts.name);\n        opts.autoName = \"auto\" + opts.uppercaseName;\n        opts.labelName = \"label\" + opts.uppercaseName;\n        opts.outerName = \"outer\" + opts.uppercaseName;\n        opts.uppercaseOuterName = capitalize(opts.outerName);\n        fn$2[opts.name] = function dimImpl() {\n            var ele = this[0];\n            var _p = ele._private;\n            var cy = _p.cy;\n            var styleEnabled = cy._private.styleEnabled;\n            if (ele) {\n                if (styleEnabled) {\n                    if (ele.isParent()) {\n                        ele.updateCompoundBounds();\n                        return _p[opts.autoName] || 0;\n                    }\n                    var d = ele.pstyle(opts.name);\n                    switch(d.strValue){\n                        case \"label\":\n                            ele.recalculateRenderedStyle();\n                            return _p.rstyle[opts.labelName] || 0;\n                        default:\n                            return d.pfValue;\n                    }\n                } else {\n                    return 1;\n                }\n            }\n        };\n        fn$2[\"outer\" + opts.uppercaseName] = function outerDimImpl() {\n            var ele = this[0];\n            var _p = ele._private;\n            var cy = _p.cy;\n            var styleEnabled = cy._private.styleEnabled;\n            if (ele) {\n                if (styleEnabled) {\n                    var dim = ele[opts.name]();\n                    var border = ele.pstyle(\"border-width\").pfValue; // n.b. 1/2 each side\n                    var padding = 2 * ele.padding();\n                    return dim + border + padding;\n                } else {\n                    return 1;\n                }\n            }\n        };\n        fn$2[\"rendered\" + opts.uppercaseName] = function renderedDimImpl() {\n            var ele = this[0];\n            if (ele) {\n                var d = ele[opts.name]();\n                return d * this.cy().zoom();\n            }\n        };\n        fn$2[\"rendered\" + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n            var ele = this[0];\n            if (ele) {\n                var od = ele[opts.outerName]();\n                return od * this.cy().zoom();\n            }\n        };\n    };\n    defineDimFns({\n        name: \"width\"\n    });\n    defineDimFns({\n        name: \"height\"\n    });\n    elesfn$a.padding = function() {\n        var ele = this[0];\n        var _p = ele._private;\n        if (ele.isParent()) {\n            ele.updateCompoundBounds();\n            if (_p.autoPadding !== undefined) {\n                return _p.autoPadding;\n            } else {\n                return ele.pstyle(\"padding\").pfValue;\n            }\n        } else {\n            return ele.pstyle(\"padding\").pfValue;\n        }\n    };\n    elesfn$a.paddedHeight = function() {\n        var ele = this[0];\n        return ele.height() + 2 * ele.padding();\n    };\n    elesfn$a.paddedWidth = function() {\n        var ele = this[0];\n        return ele.width() + 2 * ele.padding();\n    };\n    var widthHeight = elesfn$a;\n    var ifEdge = function ifEdge(ele, getValue) {\n        if (ele.isEdge()) {\n            return getValue(ele);\n        }\n    };\n    var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n        if (ele.isEdge()) {\n            var cy = ele.cy();\n            return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());\n        }\n    };\n    var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n        if (ele.isEdge()) {\n            var cy = ele.cy();\n            var pan = cy.pan();\n            var zoom = cy.zoom();\n            return getPoints(ele).map(function(p) {\n                return modelToRenderedPosition(p, zoom, pan);\n            });\n        }\n    };\n    var controlPoints = function controlPoints(ele) {\n        return ele.renderer().getControlPoints(ele);\n    };\n    var segmentPoints = function segmentPoints(ele) {\n        return ele.renderer().getSegmentPoints(ele);\n    };\n    var sourceEndpoint = function sourceEndpoint(ele) {\n        return ele.renderer().getSourceEndpoint(ele);\n    };\n    var targetEndpoint = function targetEndpoint(ele) {\n        return ele.renderer().getTargetEndpoint(ele);\n    };\n    var midpoint = function midpoint(ele) {\n        return ele.renderer().getEdgeMidpoint(ele);\n    };\n    var pts = {\n        controlPoints: {\n            get: controlPoints,\n            mult: true\n        },\n        segmentPoints: {\n            get: segmentPoints,\n            mult: true\n        },\n        sourceEndpoint: {\n            get: sourceEndpoint\n        },\n        targetEndpoint: {\n            get: targetEndpoint\n        },\n        midpoint: {\n            get: midpoint\n        }\n    };\n    var renderedName = function renderedName(name) {\n        return \"rendered\" + name[0].toUpperCase() + name.substr(1);\n    };\n    var edgePoints = Object.keys(pts).reduce(function(obj, name) {\n        var spec = pts[name];\n        var rName = renderedName(name);\n        obj[name] = function() {\n            return ifEdge(this, spec.get);\n        };\n        if (spec.mult) {\n            obj[rName] = function() {\n                return ifEdgeRenderedPositions(this, spec.get);\n            };\n        } else {\n            obj[rName] = function() {\n                return ifEdgeRenderedPosition(this, spec.get);\n            };\n        }\n        return obj;\n    }, {});\n    var dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n    /*!\n  Event object based on jQuery events, MIT license\n\n  https://jquery.org/license/\n  https://tldrlegal.com/license/mit-license\n  https://github.com/jquery/jquery/blob/master/src/event.js\n  */ var Event = function Event(src, props) {\n        this.recycle(src, props);\n    };\n    function returnFalse() {\n        return false;\n    }\n    function returnTrue() {\n        return true;\n    } // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    Event.prototype = {\n        instanceString: function instanceString() {\n            return \"event\";\n        },\n        recycle: function recycle(src, props) {\n            this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n            if (src != null && src.preventDefault) {\n                // Browser Event object\n                this.type = src.type; // Events bubbling up the document may have been marked as prevented\n                // by a handler lower down the tree; reflect the correct value.\n                this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n            } else if (src != null && src.type) {\n                // Plain object containing all event details\n                props = src;\n            } else {\n                // Event string\n                this.type = src;\n            } // Put explicitly provided properties onto the event object\n            if (props != null) {\n                // more efficient to manually copy fields we use\n                this.originalEvent = props.originalEvent;\n                this.type = props.type != null ? props.type : this.type;\n                this.cy = props.cy;\n                this.target = props.target;\n                this.position = props.position;\n                this.renderedPosition = props.renderedPosition;\n                this.namespace = props.namespace;\n                this.layout = props.layout;\n            }\n            if (this.cy != null && this.position != null && this.renderedPosition == null) {\n                // create a rendered position based on the passed position\n                var pos = this.position;\n                var zoom = this.cy.zoom();\n                var pan = this.cy.pan();\n                this.renderedPosition = {\n                    x: pos.x * zoom + pan.x,\n                    y: pos.y * zoom + pan.y\n                };\n            } // Create a timestamp if incoming event doesn't have one\n            this.timeStamp = src && src.timeStamp || Date.now();\n        },\n        preventDefault: function preventDefault() {\n            this.isDefaultPrevented = returnTrue;\n            var e = this.originalEvent;\n            if (!e) {\n                return;\n            } // if preventDefault exists run it on the original event\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n        },\n        stopPropagation: function stopPropagation() {\n            this.isPropagationStopped = returnTrue;\n            var e = this.originalEvent;\n            if (!e) {\n                return;\n            } // if stopPropagation exists run it on the original event\n            if (e.stopPropagation) {\n                e.stopPropagation();\n            }\n        },\n        stopImmediatePropagation: function stopImmediatePropagation() {\n            this.isImmediatePropagationStopped = returnTrue;\n            this.stopPropagation();\n        },\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse\n    };\n    var eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\n    var universalNamespace = \".*\"; // matches as if no namespace specified and prevents users from unbinding accidentally\n    var defaults$8 = {\n        qualifierCompare: function qualifierCompare(q1, q2) {\n            return q1 === q2;\n        },\n        eventMatches: function /*context, listener, eventObj*/ eventMatches() {\n            return true;\n        },\n        addEventFields: function /*context, evt*/ addEventFields() {},\n        callbackContext: function callbackContext(context) {\n            return context;\n        },\n        beforeEmit: function /* context, listener, eventObj */ beforeEmit() {},\n        afterEmit: function /* context, listener, eventObj */ afterEmit() {},\n        bubble: function /*context*/ bubble() {\n            return false;\n        },\n        parent: function /*context*/ parent() {\n            return null;\n        },\n        context: null\n    };\n    var defaultsKeys = Object.keys(defaults$8);\n    var emptyOpts = {};\n    function Emitter() {\n        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n        var context = arguments.length > 1 ? arguments[1] : undefined;\n        // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n        for(var i = 0; i < defaultsKeys.length; i++){\n            var key = defaultsKeys[i];\n            this[key] = opts[key] || defaults$8[key];\n        }\n        this.context = context || this.context;\n        this.listeners = [];\n        this.emitting = 0;\n    }\n    var p = Emitter.prototype;\n    var forEachEvent = function forEachEvent(self1, handler, events, qualifier, callback, conf, confOverrides) {\n        if (fn$6(qualifier)) {\n            callback = qualifier;\n            qualifier = null;\n        }\n        if (confOverrides) {\n            if (conf == null) {\n                conf = confOverrides;\n            } else {\n                conf = extend({}, conf, confOverrides);\n            }\n        }\n        var eventList = array(events) ? events : events.split(/\\s+/);\n        for(var i = 0; i < eventList.length; i++){\n            var evt = eventList[i];\n            if (emptyString(evt)) {\n                continue;\n            }\n            var match = evt.match(eventRegex); // type[.namespace]\n            if (match) {\n                var type = match[1];\n                var namespace = match[2] ? match[2] : null;\n                var ret = handler(self1, evt, type, namespace, qualifier, callback, conf);\n                if (ret === false) {\n                    break;\n                } // allow exiting early\n            }\n        }\n    };\n    var makeEventObj = function makeEventObj(self1, obj) {\n        self1.addEventFields(self1.context, obj);\n        return new Event(obj.type, obj);\n    };\n    var forEachEventObj = function forEachEventObj(self1, handler, events) {\n        if (event(events)) {\n            handler(self1, events);\n            return;\n        } else if (plainObject(events)) {\n            handler(self1, makeEventObj(self1, events));\n            return;\n        }\n        var eventList = array(events) ? events : events.split(/\\s+/);\n        for(var i = 0; i < eventList.length; i++){\n            var evt = eventList[i];\n            if (emptyString(evt)) {\n                continue;\n            }\n            var match = evt.match(eventRegex); // type[.namespace]\n            if (match) {\n                var type = match[1];\n                var namespace = match[2] ? match[2] : null;\n                var eventObj = makeEventObj(self1, {\n                    type: type,\n                    namespace: namespace,\n                    target: self1.context\n                });\n                handler(self1, eventObj);\n            }\n        }\n    };\n    p.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {\n        forEachEvent(this, function(self1, event, type, namespace, qualifier, callback, conf) {\n            if (fn$6(callback)) {\n                self1.listeners.push({\n                    event: event,\n                    // full event string\n                    callback: callback,\n                    // callback to run\n                    type: type,\n                    // the event type (e.g. 'click')\n                    namespace: namespace,\n                    // the event namespace (e.g. \".foo\")\n                    qualifier: qualifier,\n                    // a restriction on whether to match this emitter\n                    conf: conf // additional configuration\n                });\n            }\n        }, events, qualifier, callback, conf, confOverrides);\n        return this;\n    };\n    p.one = function(events, qualifier, callback, conf) {\n        return this.on(events, qualifier, callback, conf, {\n            one: true\n        });\n    };\n    p.removeListener = p.off = function(events, qualifier, callback, conf) {\n        var _this = this;\n        if (this.emitting !== 0) {\n            this.listeners = copyArray$1(this.listeners);\n        }\n        var listeners = this.listeners;\n        var _loop = function _loop(i) {\n            var listener = listeners[i];\n            forEachEvent(_this, function(self1, event, type, namespace, qualifier, callback) {\n                if ((listener.type === type || events === \"*\") && (!namespace && listener.namespace !== \".*\" || listener.namespace === namespace) && (!qualifier || self1.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n                    listeners.splice(i, 1);\n                    return false;\n                }\n            }, events, qualifier, callback, conf);\n        };\n        for(var i = listeners.length - 1; i >= 0; i--){\n            _loop(i);\n        }\n        return this;\n    };\n    p.removeAllListeners = function() {\n        return this.removeListener(\"*\");\n    };\n    p.emit = p.trigger = function(events, extraParams, manualCallback) {\n        var listeners = this.listeners;\n        var numListenersBeforeEmit = listeners.length;\n        this.emitting++;\n        if (!array(extraParams)) {\n            extraParams = [\n                extraParams\n            ];\n        }\n        forEachEventObj(this, function(self1, eventObj) {\n            if (manualCallback != null) {\n                listeners = [\n                    {\n                        event: eventObj.event,\n                        type: eventObj.type,\n                        namespace: eventObj.namespace,\n                        callback: manualCallback\n                    }\n                ];\n                numListenersBeforeEmit = listeners.length;\n            }\n            var _loop2 = function _loop2(i) {\n                var listener = listeners[i];\n                if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self1.eventMatches(self1.context, listener, eventObj)) {\n                    var args = [\n                        eventObj\n                    ];\n                    if (extraParams != null) {\n                        push(args, extraParams);\n                    }\n                    self1.beforeEmit(self1.context, listener, eventObj);\n                    if (listener.conf && listener.conf.one) {\n                        self1.listeners = self1.listeners.filter(function(l) {\n                            return l !== listener;\n                        });\n                    }\n                    var context = self1.callbackContext(self1.context, listener, eventObj);\n                    var ret = listener.callback.apply(context, args);\n                    self1.afterEmit(self1.context, listener, eventObj);\n                    if (ret === false) {\n                        eventObj.stopPropagation();\n                        eventObj.preventDefault();\n                    }\n                } // if listener matches\n            };\n            for(var i = 0; i < numListenersBeforeEmit; i++){\n                _loop2(i);\n            } // for listener\n            if (self1.bubble(self1.context) && !eventObj.isPropagationStopped()) {\n                self1.parent(self1.context).emit(eventObj, extraParams);\n            }\n        }, events);\n        this.emitting--;\n        return this;\n    };\n    var emitterOptions$1 = {\n        qualifierCompare: function qualifierCompare(selector1, selector2) {\n            if (selector1 == null || selector2 == null) {\n                return selector1 == null && selector2 == null;\n            } else {\n                return selector1.sameText(selector2);\n            }\n        },\n        eventMatches: function eventMatches(ele, listener, eventObj) {\n            var selector = listener.qualifier;\n            if (selector != null) {\n                return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n            }\n            return true;\n        },\n        addEventFields: function addEventFields(ele, evt) {\n            evt.cy = ele.cy();\n            evt.target = ele;\n        },\n        callbackContext: function callbackContext(ele, listener, eventObj) {\n            return listener.qualifier != null ? eventObj.target : ele;\n        },\n        beforeEmit: function beforeEmit(context, listener) {\n            if (listener.conf && listener.conf.once) {\n                listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n            }\n        },\n        bubble: function bubble() {\n            return true;\n        },\n        parent: function parent(ele) {\n            return ele.isChild() ? ele.parent() : ele.cy();\n        }\n    };\n    var argSelector$1 = function argSelector(arg) {\n        if (string(arg)) {\n            return new Selector(arg);\n        } else {\n            return arg;\n        }\n    };\n    var elesfn$9 = {\n        createEmitter: function createEmitter() {\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var _p = ele._private;\n                if (!_p.emitter) {\n                    _p.emitter = new Emitter(emitterOptions$1, ele);\n                }\n            }\n            return this;\n        },\n        emitter: function emitter() {\n            return this._private.emitter;\n        },\n        on: function on(events, selector, callback) {\n            var argSel = argSelector$1(selector);\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().on(events, argSel, callback);\n            }\n            return this;\n        },\n        removeListener: function removeListener(events, selector, callback) {\n            var argSel = argSelector$1(selector);\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().removeListener(events, argSel, callback);\n            }\n            return this;\n        },\n        removeAllListeners: function removeAllListeners() {\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().removeAllListeners();\n            }\n            return this;\n        },\n        one: function one(events, selector, callback) {\n            var argSel = argSelector$1(selector);\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().one(events, argSel, callback);\n            }\n            return this;\n        },\n        once: function once(events, selector, callback) {\n            var argSel = argSelector$1(selector);\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().on(events, argSel, callback, {\n                    once: true,\n                    onceCollection: this\n                });\n            }\n        },\n        emit: function emit(events, extraParams) {\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                ele.emitter().emit(events, extraParams);\n            }\n            return this;\n        },\n        emitAndNotify: function emitAndNotify(event, extraParams) {\n            // for internal use only\n            if (this.length === 0) {\n                return;\n            } // empty collections don't need to notify anything\n            // notify renderer\n            this.cy().notify(event, this);\n            this.emit(event, extraParams);\n            return this;\n        }\n    };\n    define1.eventAliasesOn(elesfn$9);\n    var elesfn$8 = {\n        nodes: function nodes(selector) {\n            return this.filter(function(ele) {\n                return ele.isNode();\n            }).filter(selector);\n        },\n        edges: function edges(selector) {\n            return this.filter(function(ele) {\n                return ele.isEdge();\n            }).filter(selector);\n        },\n        // internal helper to get nodes and edges as separate collections with single iteration over elements\n        byGroup: function byGroup() {\n            var nodes = this.spawn();\n            var edges = this.spawn();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                if (ele.isNode()) {\n                    nodes.push(ele);\n                } else {\n                    edges.push(ele);\n                }\n            }\n            return {\n                nodes: nodes,\n                edges: edges\n            };\n        },\n        filter: function filter(_filter, thisArg) {\n            if (_filter === undefined) {\n                // check this first b/c it's the most common/performant case\n                return this;\n            } else if (string(_filter) || elementOrCollection(_filter)) {\n                return new Selector(_filter).filter(this);\n            } else if (fn$6(_filter)) {\n                var filterEles = this.spawn();\n                var eles = this;\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var include = thisArg ? _filter.apply(thisArg, [\n                        ele,\n                        i,\n                        eles\n                    ]) : _filter(ele, i, eles);\n                    if (include) {\n                        filterEles.push(ele);\n                    }\n                }\n                return filterEles;\n            }\n            return this.spawn(); // if not handled by above, give 'em an empty collection\n        },\n        not: function not(toRemove) {\n            if (!toRemove) {\n                return this;\n            } else {\n                if (string(toRemove)) {\n                    toRemove = this.filter(toRemove);\n                }\n                var elements = this.spawn();\n                for(var i = 0; i < this.length; i++){\n                    var element = this[i];\n                    var remove = toRemove.has(element);\n                    if (!remove) {\n                        elements.push(element);\n                    }\n                }\n                return elements;\n            }\n        },\n        absoluteComplement: function absoluteComplement() {\n            var cy = this.cy();\n            return cy.mutableElements().not(this);\n        },\n        intersect: function intersect(other) {\n            // if a selector is specified, then filter by it instead\n            if (string(other)) {\n                var selector = other;\n                return this.filter(selector);\n            }\n            var elements = this.spawn();\n            var col1 = this;\n            var col2 = other;\n            var col1Smaller = this.length < other.length;\n            var colS = col1Smaller ? col1 : col2;\n            var colL = col1Smaller ? col2 : col1;\n            for(var i = 0; i < colS.length; i++){\n                var ele = colS[i];\n                if (colL.has(ele)) {\n                    elements.push(ele);\n                }\n            }\n            return elements;\n        },\n        xor: function xor(other) {\n            var cy = this._private.cy;\n            if (string(other)) {\n                other = cy.$(other);\n            }\n            var elements = this.spawn();\n            var col1 = this;\n            var col2 = other;\n            var add = function add(col, other) {\n                for(var i = 0; i < col.length; i++){\n                    var ele = col[i];\n                    var id = ele._private.data.id;\n                    var inOther = other.hasElementWithId(id);\n                    if (!inOther) {\n                        elements.push(ele);\n                    }\n                }\n            };\n            add(col1, col2);\n            add(col2, col1);\n            return elements;\n        },\n        diff: function diff(other) {\n            var cy = this._private.cy;\n            if (string(other)) {\n                other = cy.$(other);\n            }\n            var left = this.spawn();\n            var right = this.spawn();\n            var both = this.spawn();\n            var col1 = this;\n            var col2 = other;\n            var add = function add(col, other, retEles) {\n                for(var i = 0; i < col.length; i++){\n                    var ele = col[i];\n                    var id = ele._private.data.id;\n                    var inOther = other.hasElementWithId(id);\n                    if (inOther) {\n                        both.merge(ele);\n                    } else {\n                        retEles.push(ele);\n                    }\n                }\n            };\n            add(col1, col2, left);\n            add(col2, col1, right);\n            return {\n                left: left,\n                right: right,\n                both: both\n            };\n        },\n        add: function add(toAdd) {\n            var cy = this._private.cy;\n            if (!toAdd) {\n                return this;\n            }\n            if (string(toAdd)) {\n                var selector = toAdd;\n                toAdd = cy.mutableElements().filter(selector);\n            }\n            var elements = this.spawnSelf();\n            for(var i = 0; i < toAdd.length; i++){\n                var ele = toAdd[i];\n                var add = !this.has(ele);\n                if (add) {\n                    elements.push(ele);\n                }\n            }\n            return elements;\n        },\n        // in place merge on calling collection\n        merge: function merge(toAdd) {\n            var _p = this._private;\n            var cy = _p.cy;\n            if (!toAdd) {\n                return this;\n            }\n            if (toAdd && string(toAdd)) {\n                var selector = toAdd;\n                toAdd = cy.mutableElements().filter(selector);\n            }\n            var map = _p.map;\n            for(var i = 0; i < toAdd.length; i++){\n                var toAddEle = toAdd[i];\n                var id = toAddEle._private.data.id;\n                var add = !map.has(id);\n                if (add) {\n                    var index = this.length++;\n                    this[index] = toAddEle;\n                    map.set(id, {\n                        ele: toAddEle,\n                        index: index\n                    });\n                }\n            }\n            return this; // chaining\n        },\n        unmergeAt: function unmergeAt(i) {\n            var ele = this[i];\n            var id = ele.id();\n            var _p = this._private;\n            var map = _p.map; // remove ele\n            this[i] = undefined;\n            map[\"delete\"](id);\n            var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection\n            if (this.length > 1 && !unmergedLastEle) {\n                var lastEleI = this.length - 1;\n                var lastEle = this[lastEleI];\n                var lastEleId = lastEle._private.data.id;\n                this[lastEleI] = undefined;\n                this[i] = lastEle;\n                map.set(lastEleId, {\n                    ele: lastEle,\n                    index: i\n                });\n            } // the collection is now 1 ele smaller\n            this.length--;\n            return this;\n        },\n        // remove single ele in place in calling collection\n        unmergeOne: function unmergeOne(ele) {\n            ele = ele[0];\n            var _p = this._private;\n            var id = ele._private.data.id;\n            var map = _p.map;\n            var entry = map.get(id);\n            if (!entry) {\n                return this; // no need to remove\n            }\n            var i = entry.index;\n            this.unmergeAt(i);\n            return this;\n        },\n        // remove eles in place on calling collection\n        unmerge: function unmerge(toRemove) {\n            var cy = this._private.cy;\n            if (!toRemove) {\n                return this;\n            }\n            if (toRemove && string(toRemove)) {\n                var selector = toRemove;\n                toRemove = cy.mutableElements().filter(selector);\n            }\n            for(var i = 0; i < toRemove.length; i++){\n                this.unmergeOne(toRemove[i]);\n            }\n            return this; // chaining\n        },\n        unmergeBy: function unmergeBy(toRmFn) {\n            for(var i = this.length - 1; i >= 0; i--){\n                var ele = this[i];\n                if (toRmFn(ele)) {\n                    this.unmergeAt(i);\n                }\n            }\n            return this;\n        },\n        map: function map(mapFn, thisArg) {\n            var arr = [];\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var ret = thisArg ? mapFn.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : mapFn(ele, i, eles);\n                arr.push(ret);\n            }\n            return arr;\n        },\n        reduce: function reduce(fn, initialValue) {\n            var val = initialValue;\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                val = fn(val, eles[i], i, eles);\n            }\n            return val;\n        },\n        max: function max(valFn, thisArg) {\n            var max = -Infinity;\n            var maxEle;\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var val = thisArg ? valFn.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : valFn(ele, i, eles);\n                if (val > max) {\n                    max = val;\n                    maxEle = ele;\n                }\n            }\n            return {\n                value: max,\n                ele: maxEle\n            };\n        },\n        min: function min(valFn, thisArg) {\n            var min = Infinity;\n            var minEle;\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var val = thisArg ? valFn.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : valFn(ele, i, eles);\n                if (val < min) {\n                    min = val;\n                    minEle = ele;\n                }\n            }\n            return {\n                value: min,\n                ele: minEle\n            };\n        }\n    }; // aliases\n    var fn$1 = elesfn$8;\n    fn$1[\"u\"] = fn$1[\"|\"] = fn$1[\"+\"] = fn$1.union = fn$1.or = fn$1.add;\n    fn$1[\"\\\\\"] = fn$1[\"!\"] = fn$1[\"-\"] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\n    fn$1[\"n\"] = fn$1[\"&\"] = fn$1[\".\"] = fn$1.and = fn$1.intersection = fn$1.intersect;\n    fn$1[\"^\"] = fn$1[\"(+)\"] = fn$1[\"(-)\"] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\n    fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\n    fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\n    var elesfn$7 = {\n        isNode: function isNode() {\n            return this.group() === \"nodes\";\n        },\n        isEdge: function isEdge() {\n            return this.group() === \"edges\";\n        },\n        isLoop: function isLoop() {\n            return this.isEdge() && this.source()[0] === this.target()[0];\n        },\n        isSimple: function isSimple() {\n            return this.isEdge() && this.source()[0] !== this.target()[0];\n        },\n        group: function group() {\n            var ele = this[0];\n            if (ele) {\n                return ele._private.group;\n            }\n        }\n    };\n    /**\n   *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n   *  and z-index (low to high).  These styles affect how this applies:\n   *\n   *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n   *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n   *      root to leaves of the compound graph.  The last drawn is `top`.\n   *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n   *      `manual` ignores this convention and draws based on the `z-index` value setting.\n   *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n   *      `z-index` will be drawn on top of an element with a lower `z-index`.\n   */ var zIndexSort = function zIndexSort(a, b) {\n        var cy = a.cy();\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        function getDepth(ele) {\n            var style = ele.pstyle(\"z-compound-depth\");\n            if (style.value === \"auto\") {\n                return hasCompoundNodes ? ele.zDepth() : 0;\n            } else if (style.value === \"bottom\") {\n                return -1;\n            } else if (style.value === \"top\") {\n                return MAX_INT$1;\n            } // 'orphan'\n            return 0;\n        }\n        var depthDiff = getDepth(a) - getDepth(b);\n        if (depthDiff !== 0) {\n            return depthDiff;\n        }\n        function getEleDepth(ele) {\n            var style = ele.pstyle(\"z-index-compare\");\n            if (style.value === \"auto\") {\n                return ele.isNode() ? 1 : 0;\n            } // 'manual'\n            return 0;\n        }\n        var eleDiff = getEleDepth(a) - getEleDepth(b);\n        if (eleDiff !== 0) {\n            return eleDiff;\n        }\n        var zDiff = a.pstyle(\"z-index\").value - b.pstyle(\"z-index\").value;\n        if (zDiff !== 0) {\n            return zDiff;\n        } // compare indices in the core (order added to graph w/ last on top)\n        return a.poolIndex() - b.poolIndex();\n    };\n    var elesfn$6 = {\n        forEach: function forEach(fn, thisArg) {\n            if (fn$6(fn)) {\n                var N = this.length;\n                for(var i = 0; i < N; i++){\n                    var ele = this[i];\n                    var ret = thisArg ? fn.apply(thisArg, [\n                        ele,\n                        i,\n                        this\n                    ]) : fn(ele, i, this);\n                    if (ret === false) {\n                        break;\n                    } // exit each early on return false\n                }\n            }\n            return this;\n        },\n        toArray: function toArray() {\n            var array = [];\n            for(var i = 0; i < this.length; i++){\n                array.push(this[i]);\n            }\n            return array;\n        },\n        slice: function slice(start, end) {\n            var array = [];\n            var thisSize = this.length;\n            if (end == null) {\n                end = thisSize;\n            }\n            if (start == null) {\n                start = 0;\n            }\n            if (start < 0) {\n                start = thisSize + start;\n            }\n            if (end < 0) {\n                end = thisSize + end;\n            }\n            for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n                array.push(this[i]);\n            }\n            return this.spawn(array);\n        },\n        size: function size() {\n            return this.length;\n        },\n        eq: function eq(i) {\n            return this[i] || this.spawn();\n        },\n        first: function first() {\n            return this[0] || this.spawn();\n        },\n        last: function last() {\n            return this[this.length - 1] || this.spawn();\n        },\n        empty: function empty() {\n            return this.length === 0;\n        },\n        nonempty: function nonempty() {\n            return !this.empty();\n        },\n        sort: function sort(sortFn) {\n            if (!fn$6(sortFn)) {\n                return this;\n            }\n            var sorted = this.toArray().sort(sortFn);\n            return this.spawn(sorted);\n        },\n        sortByZIndex: function sortByZIndex() {\n            return this.sort(zIndexSort);\n        },\n        zDepth: function zDepth() {\n            var ele = this[0];\n            if (!ele) {\n                return undefined;\n            } // let cy = ele.cy();\n            var _p = ele._private;\n            var group = _p.group;\n            if (group === \"nodes\") {\n                var depth = _p.data.parent ? ele.parents().size() : 0;\n                if (!ele.isParent()) {\n                    return MAX_INT$1 - 1; // childless nodes always on top\n                }\n                return depth;\n            } else {\n                var src = _p.source;\n                var tgt = _p.target;\n                var srcDepth = src.zDepth();\n                var tgtDepth = tgt.zDepth();\n                return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n            }\n        }\n    };\n    elesfn$6.each = elesfn$6.forEach;\n    var defineSymbolIterator = function defineSymbolIterator() {\n        var typeofUndef = \"undefined\";\n        var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n        if (isIteratorSupported) {\n            elesfn$6[Symbol.iterator] = function() {\n                var _this = this;\n                // eslint-disable-line no-undef\n                var entry = {\n                    value: undefined,\n                    done: false\n                };\n                var i = 0;\n                var length = this.length;\n                return _defineProperty$1({\n                    next: function next() {\n                        if (i < length) {\n                            entry.value = _this[i++];\n                        } else {\n                            entry.value = undefined;\n                            entry.done = true;\n                        }\n                        return entry;\n                    }\n                }, Symbol.iterator, function() {\n                    // eslint-disable-line no-undef\n                    return this;\n                });\n            };\n        }\n    };\n    defineSymbolIterator();\n    var getLayoutDimensionOptions = defaults$g({\n        nodeDimensionsIncludeLabels: false\n    });\n    var elesfn$5 = {\n        // Calculates and returns node dimensions { x, y } based on options given\n        layoutDimensions: function layoutDimensions(options) {\n            options = getLayoutDimensionOptions(options);\n            var dims;\n            if (!this.takesUpSpace()) {\n                dims = {\n                    w: 0,\n                    h: 0\n                };\n            } else if (options.nodeDimensionsIncludeLabels) {\n                var bbDim = this.boundingBox();\n                dims = {\n                    w: bbDim.w,\n                    h: bbDim.h\n                };\n            } else {\n                dims = {\n                    w: this.outerWidth(),\n                    h: this.outerHeight()\n                };\n            } // sanitise the dimensions for external layouts (avoid division by zero)\n            if (dims.w === 0 || dims.h === 0) {\n                dims.w = dims.h = 1;\n            }\n            return dims;\n        },\n        // using standard layout options, apply position function (w/ or w/o animation)\n        layoutPositions: function layoutPositions(layout, options, fn) {\n            var nodes = this.nodes().filter(function(n) {\n                return !n.isParent();\n            });\n            var cy = this.cy();\n            var layoutEles = options.eles; // nodes & edges\n            var getMemoizeKey = function getMemoizeKey(node) {\n                return node.id();\n            };\n            var fnMem = memoize$1(fn, getMemoizeKey); // memoized version of position function\n            layout.emit({\n                type: \"layoutstart\",\n                layout: layout\n            });\n            layout.animations = [];\n            var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n                var center = {\n                    x: nodesBb.x1 + nodesBb.w / 2,\n                    y: nodesBb.y1 + nodesBb.h / 2\n                };\n                var spacingVector = {\n                    // scale from center of bounding box (not necessarily 0,0)\n                    x: (pos.x - center.x) * spacing,\n                    y: (pos.y - center.y) * spacing\n                };\n                return {\n                    x: center.x + spacingVector.x,\n                    y: center.y + spacingVector.y\n                };\n            };\n            var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n            var spacingBb = function spacingBb() {\n                if (!useSpacingFactor) {\n                    return null;\n                }\n                var bb = makeBoundingBox();\n                for(var i = 0; i < nodes.length; i++){\n                    var node = nodes[i];\n                    var pos = fnMem(node, i);\n                    expandBoundingBoxByPoint(bb, pos.x, pos.y);\n                }\n                return bb;\n            };\n            var bb = spacingBb();\n            var getFinalPos = memoize$1(function(node, i) {\n                var newPos = fnMem(node, i);\n                if (useSpacingFactor) {\n                    var spacing = Math.abs(options.spacingFactor);\n                    newPos = calculateSpacing(spacing, bb, newPos);\n                }\n                if (options.transform != null) {\n                    newPos = options.transform(node, newPos);\n                }\n                return newPos;\n            }, getMemoizeKey);\n            if (options.animate) {\n                for(var i = 0; i < nodes.length; i++){\n                    var node = nodes[i];\n                    var newPos = getFinalPos(node, i);\n                    var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n                    if (animateNode) {\n                        var ani = node.animation({\n                            position: newPos,\n                            duration: options.animationDuration,\n                            easing: options.animationEasing\n                        });\n                        layout.animations.push(ani);\n                    } else {\n                        node.position(newPos);\n                    }\n                }\n                if (options.fit) {\n                    var fitAni = cy.animation({\n                        fit: {\n                            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n                            padding: options.padding\n                        },\n                        duration: options.animationDuration,\n                        easing: options.animationEasing\n                    });\n                    layout.animations.push(fitAni);\n                } else if (options.zoom !== undefined && options.pan !== undefined) {\n                    var zoomPanAni = cy.animation({\n                        zoom: options.zoom,\n                        pan: options.pan,\n                        duration: options.animationDuration,\n                        easing: options.animationEasing\n                    });\n                    layout.animations.push(zoomPanAni);\n                }\n                layout.animations.forEach(function(ani) {\n                    return ani.play();\n                });\n                layout.one(\"layoutready\", options.ready);\n                layout.emit({\n                    type: \"layoutready\",\n                    layout: layout\n                });\n                Promise$1.all(layout.animations.map(function(ani) {\n                    return ani.promise();\n                })).then(function() {\n                    layout.one(\"layoutstop\", options.stop);\n                    layout.emit({\n                        type: \"layoutstop\",\n                        layout: layout\n                    });\n                });\n            } else {\n                nodes.positions(getFinalPos);\n                if (options.fit) {\n                    cy.fit(options.eles, options.padding);\n                }\n                if (options.zoom != null) {\n                    cy.zoom(options.zoom);\n                }\n                if (options.pan) {\n                    cy.pan(options.pan);\n                }\n                layout.one(\"layoutready\", options.ready);\n                layout.emit({\n                    type: \"layoutready\",\n                    layout: layout\n                });\n                layout.one(\"layoutstop\", options.stop);\n                layout.emit({\n                    type: \"layoutstop\",\n                    layout: layout\n                });\n            }\n            return this; // chaining\n        },\n        layout: function layout(options) {\n            var cy = this.cy();\n            return cy.makeLayout(extend({}, options, {\n                eles: this\n            }));\n        }\n    }; // aliases:\n    elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\n    function styleCache(key, fn, ele) {\n        var _p = ele._private;\n        var cache = _p.styleCache = _p.styleCache || [];\n        var val;\n        if ((val = cache[key]) != null) {\n            return val;\n        } else {\n            val = cache[key] = fn(ele);\n            return val;\n        }\n    }\n    function cacheStyleFunction(key, fn) {\n        key = hashString(key);\n        return function cachedStyleFunction(ele) {\n            return styleCache(key, fn, ele);\n        };\n    }\n    function cachePrototypeStyleFunction(key, fn) {\n        key = hashString(key);\n        var selfFn = function selfFn(ele) {\n            return fn.call(ele);\n        };\n        return function cachedPrototypeStyleFunction() {\n            var ele = this[0];\n            if (ele) {\n                return styleCache(key, selfFn, ele);\n            }\n        };\n    }\n    var elesfn$4 = {\n        recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n            var cy = this.cy();\n            var renderer = cy.renderer();\n            var styleEnabled = cy.styleEnabled();\n            if (renderer && styleEnabled) {\n                renderer.recalculateRenderedStyle(this, useCache);\n            }\n            return this;\n        },\n        dirtyStyleCache: function dirtyStyleCache() {\n            var cy = this.cy();\n            var dirty = function dirty(ele) {\n                return ele._private.styleCache = null;\n            };\n            if (cy.hasCompoundNodes()) {\n                var eles;\n                eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n                eles.merge(eles.connectedEdges());\n                eles.forEach(dirty);\n            } else {\n                this.forEach(function(ele) {\n                    dirty(ele);\n                    ele.connectedEdges().forEach(dirty);\n                });\n            }\n            return this;\n        },\n        // fully updates (recalculates) the style for the elements\n        updateStyle: function updateStyle(notifyRenderer) {\n            var cy = this._private.cy;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            if (cy.batching()) {\n                var bEles = cy._private.batchStyleEles;\n                bEles.merge(this);\n                return this; // chaining and exit early when batching\n            }\n            var hasCompounds = cy.hasCompoundNodes();\n            var updatedEles = this;\n            notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n            if (hasCompounds) {\n                // then add everything up and down for compound selector checks\n                updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n            } // let changedEles = style.apply( updatedEles );\n            var changedEles = updatedEles;\n            if (notifyRenderer) {\n                changedEles.emitAndNotify(\"style\"); // let renderer know we changed style\n            } else {\n                changedEles.emit(\"style\"); // just fire the event\n            }\n            updatedEles.forEach(function(ele) {\n                return ele._private.styleDirty = true;\n            });\n            return this; // chaining\n        },\n        // private: clears dirty flag and recalculates style\n        cleanStyle: function cleanStyle() {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return;\n            }\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                if (ele._private.styleDirty) {\n                    // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                    ele._private.styleDirty = false;\n                    cy.style().apply(ele);\n                }\n            }\n        },\n        // get the internal parsed style object for the specified property\n        parsedStyle: function parsedStyle(property) {\n            var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var ele = this[0];\n            var cy = ele.cy();\n            if (!cy.styleEnabled()) {\n                return;\n            }\n            if (ele) {\n                this.cleanStyle();\n                var overriddenStyle = ele._private.style[property];\n                if (overriddenStyle != null) {\n                    return overriddenStyle;\n                } else if (includeNonDefault) {\n                    return cy.style().getDefaultProperty(property);\n                } else {\n                    return null;\n                }\n            }\n        },\n        numericStyle: function numericStyle(property) {\n            var ele = this[0];\n            if (!ele.cy().styleEnabled()) {\n                return;\n            }\n            if (ele) {\n                var pstyle = ele.pstyle(property);\n                return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n            }\n        },\n        numericStyleUnits: function numericStyleUnits(property) {\n            var ele = this[0];\n            if (!ele.cy().styleEnabled()) {\n                return;\n            }\n            if (ele) {\n                return ele.pstyle(property).units;\n            }\n        },\n        // get the specified css property as a rendered value (i.e. on-screen value)\n        // or get the whole rendered style if no property specified (NB doesn't allow setting)\n        renderedStyle: function renderedStyle(property) {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var ele = this[0];\n            if (ele) {\n                return cy.style().getRenderedStyle(ele, property);\n            }\n        },\n        // read the calculated css style of the element or override the style (via a bypass)\n        style: function style(name, value) {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var updateTransitions = false;\n            var style = cy.style();\n            if (plainObject(name)) {\n                // then extend the bypass\n                var props = name;\n                style.applyBypass(this, props, updateTransitions);\n                this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n            } else if (string(name)) {\n                if (value === undefined) {\n                    // then get the property from the style\n                    var ele = this[0];\n                    if (ele) {\n                        return style.getStylePropertyValue(ele, name);\n                    } else {\n                        // empty collection => can't get any value\n                        return;\n                    }\n                } else {\n                    // then set the bypass with the property value\n                    style.applyBypass(this, name, value, updateTransitions);\n                    this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n                }\n            } else if (name === undefined) {\n                var _ele = this[0];\n                if (_ele) {\n                    return style.getRawStyle(_ele);\n                } else {\n                    // empty collection => can't get any value\n                    return;\n                }\n            }\n            return this; // chaining\n        },\n        removeStyle: function removeStyle(names) {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var updateTransitions = false;\n            var style = cy.style();\n            var eles = this;\n            if (names === undefined) {\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    style.removeAllBypasses(ele, updateTransitions);\n                }\n            } else {\n                names = names.split(/\\s+/);\n                for(var _i = 0; _i < eles.length; _i++){\n                    var _ele2 = eles[_i];\n                    style.removeBypasses(_ele2, names, updateTransitions);\n                }\n            }\n            this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n            return this; // chaining\n        },\n        show: function show() {\n            this.css(\"display\", \"element\");\n            return this; // chaining\n        },\n        hide: function hide() {\n            this.css(\"display\", \"none\");\n            return this; // chaining\n        },\n        effectiveOpacity: function effectiveOpacity() {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return 1;\n            }\n            var hasCompoundNodes = cy.hasCompoundNodes();\n            var ele = this[0];\n            if (ele) {\n                var _p = ele._private;\n                var parentOpacity = ele.pstyle(\"opacity\").value;\n                if (!hasCompoundNodes) {\n                    return parentOpacity;\n                }\n                var parents = !_p.data.parent ? null : ele.parents();\n                if (parents) {\n                    for(var i = 0; i < parents.length; i++){\n                        var parent = parents[i];\n                        var opacity = parent.pstyle(\"opacity\").value;\n                        parentOpacity = opacity * parentOpacity;\n                    }\n                }\n                return parentOpacity;\n            }\n        },\n        transparent: function transparent() {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return false;\n            }\n            var ele = this[0];\n            var hasCompoundNodes = ele.cy().hasCompoundNodes();\n            if (ele) {\n                if (!hasCompoundNodes) {\n                    return ele.pstyle(\"opacity\").value === 0;\n                } else {\n                    return ele.effectiveOpacity() === 0;\n                }\n            }\n        },\n        backgrounding: function backgrounding() {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return false;\n            }\n            var ele = this[0];\n            return ele._private.backgrounding ? true : false;\n        }\n    };\n    function checkCompound(ele, parentOk) {\n        var _p = ele._private;\n        var parents = _p.data.parent ? ele.parents() : null;\n        if (parents) {\n            for(var i = 0; i < parents.length; i++){\n                var parent = parents[i];\n                if (!parentOk(parent)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function defineDerivedStateFunction(specs) {\n        var ok = specs.ok;\n        var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n        var parentOk = specs.parentOk || specs.ok;\n        return function() {\n            var cy = this.cy();\n            if (!cy.styleEnabled()) {\n                return true;\n            }\n            var ele = this[0];\n            var hasCompoundNodes = cy.hasCompoundNodes();\n            if (ele) {\n                var _p = ele._private;\n                if (!ok(ele)) {\n                    return false;\n                }\n                if (ele.isNode()) {\n                    return !hasCompoundNodes || checkCompound(ele, parentOk);\n                } else {\n                    var src = _p.source;\n                    var tgt = _p.target;\n                    return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n                }\n            }\n        };\n    }\n    var eleTakesUpSpace = cacheStyleFunction(\"eleTakesUpSpace\", function(ele) {\n        return ele.pstyle(\"display\").value === \"element\" && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n    });\n    elesfn$4.takesUpSpace = cachePrototypeStyleFunction(\"takesUpSpace\", defineDerivedStateFunction({\n        ok: eleTakesUpSpace\n    }));\n    var eleInteractive = cacheStyleFunction(\"eleInteractive\", function(ele) {\n        return ele.pstyle(\"events\").value === \"yes\" && ele.pstyle(\"visibility\").value === \"visible\" && eleTakesUpSpace(ele);\n    });\n    var parentInteractive = cacheStyleFunction(\"parentInteractive\", function(parent) {\n        return parent.pstyle(\"visibility\").value === \"visible\" && eleTakesUpSpace(parent);\n    });\n    elesfn$4.interactive = cachePrototypeStyleFunction(\"interactive\", defineDerivedStateFunction({\n        ok: eleInteractive,\n        parentOk: parentInteractive,\n        edgeOkViaNode: eleTakesUpSpace\n    }));\n    elesfn$4.noninteractive = function() {\n        var ele = this[0];\n        if (ele) {\n            return !ele.interactive();\n        }\n    };\n    var eleVisible = cacheStyleFunction(\"eleVisible\", function(ele) {\n        return ele.pstyle(\"visibility\").value === \"visible\" && ele.pstyle(\"opacity\").pfValue !== 0 && eleTakesUpSpace(ele);\n    });\n    var edgeVisibleViaNode = eleTakesUpSpace;\n    elesfn$4.visible = cachePrototypeStyleFunction(\"visible\", defineDerivedStateFunction({\n        ok: eleVisible,\n        edgeOkViaNode: edgeVisibleViaNode\n    }));\n    elesfn$4.hidden = function() {\n        var ele = this[0];\n        if (ele) {\n            return !ele.visible();\n        }\n    };\n    elesfn$4.isBundledBezier = cachePrototypeStyleFunction(\"isBundledBezier\", function() {\n        if (!this.cy().styleEnabled()) {\n            return false;\n        }\n        return !this.removed() && this.pstyle(\"curve-style\").value === \"bezier\" && this.takesUpSpace();\n    });\n    elesfn$4.bypass = elesfn$4.css = elesfn$4.style;\n    elesfn$4.renderedCss = elesfn$4.renderedStyle;\n    elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\n    elesfn$4.pstyle = elesfn$4.parsedStyle;\n    var elesfn$3 = {};\n    function defineSwitchFunction(params) {\n        return function() {\n            var args = arguments;\n            var changedEles = []; // e.g. cy.nodes().select( data, handler )\n            if (args.length === 2) {\n                var data = args[0];\n                var handler = args[1];\n                this.on(params.event, data, handler);\n            } else if (args.length === 1 && fn$6(args[0])) {\n                var _handler = args[0];\n                this.on(params.event, _handler);\n            } else if (args.length === 0 || args.length === 1 && array(args[0])) {\n                var addlEvents = args.length === 1 ? args[0] : null;\n                for(var i = 0; i < this.length; i++){\n                    var ele = this[i];\n                    var able = !params.ableField || ele._private[params.ableField];\n                    var changed = ele._private[params.field] != params.value;\n                    if (params.overrideAble) {\n                        var overrideAble = params.overrideAble(ele);\n                        if (overrideAble !== undefined) {\n                            able = overrideAble;\n                            if (!overrideAble) {\n                                return this;\n                            } // to save cycles assume not able for all on override\n                        }\n                    }\n                    if (able) {\n                        ele._private[params.field] = params.value;\n                        if (changed) {\n                            changedEles.push(ele);\n                        }\n                    }\n                }\n                var changedColl = this.spawn(changedEles);\n                changedColl.updateStyle(); // change of state => possible change of style\n                changedColl.emit(params.event);\n                if (addlEvents) {\n                    changedColl.emit(addlEvents);\n                }\n            }\n            return this;\n        };\n    }\n    function defineSwitchSet(params) {\n        elesfn$3[params.field] = function() {\n            var ele = this[0];\n            if (ele) {\n                if (params.overrideField) {\n                    var val = params.overrideField(ele);\n                    if (val !== undefined) {\n                        return val;\n                    }\n                }\n                return ele._private[params.field];\n            }\n        };\n        elesfn$3[params.on] = defineSwitchFunction({\n            event: params.on,\n            field: params.field,\n            ableField: params.ableField,\n            overrideAble: params.overrideAble,\n            value: true\n        });\n        elesfn$3[params.off] = defineSwitchFunction({\n            event: params.off,\n            field: params.field,\n            ableField: params.ableField,\n            overrideAble: params.overrideAble,\n            value: false\n        });\n    }\n    defineSwitchSet({\n        field: \"locked\",\n        overrideField: function overrideField(ele) {\n            return ele.cy().autolock() ? true : undefined;\n        },\n        on: \"lock\",\n        off: \"unlock\"\n    });\n    defineSwitchSet({\n        field: \"grabbable\",\n        overrideField: function overrideField(ele) {\n            return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n        },\n        on: \"grabify\",\n        off: \"ungrabify\"\n    });\n    defineSwitchSet({\n        field: \"selected\",\n        ableField: \"selectable\",\n        overrideAble: function overrideAble(ele) {\n            return ele.cy().autounselectify() ? false : undefined;\n        },\n        on: \"select\",\n        off: \"unselect\"\n    });\n    defineSwitchSet({\n        field: \"selectable\",\n        overrideField: function overrideField(ele) {\n            return ele.cy().autounselectify() ? false : undefined;\n        },\n        on: \"selectify\",\n        off: \"unselectify\"\n    });\n    elesfn$3.deselect = elesfn$3.unselect;\n    elesfn$3.grabbed = function() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.grabbed;\n        }\n    };\n    defineSwitchSet({\n        field: \"active\",\n        on: \"activate\",\n        off: \"unactivate\"\n    });\n    defineSwitchSet({\n        field: \"pannable\",\n        on: \"panify\",\n        off: \"unpanify\"\n    });\n    elesfn$3.inactive = function() {\n        var ele = this[0];\n        if (ele) {\n            return !ele._private.active;\n        }\n    };\n    var elesfn$2 = {}; // DAG functions\n    ////////////////\n    var defineDagExtremity = function defineDagExtremity(params) {\n        return function dagExtremityImpl(selector) {\n            var eles = this;\n            var ret = [];\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                if (!ele.isNode()) {\n                    continue;\n                }\n                var disqualified = false;\n                var edges = ele.connectedEdges();\n                for(var j = 0; j < edges.length; j++){\n                    var edge = edges[j];\n                    var src = edge.source();\n                    var tgt = edge.target();\n                    if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n                        disqualified = true;\n                        break;\n                    }\n                }\n                if (!disqualified) {\n                    ret.push(ele);\n                }\n            }\n            return this.spawn(ret, true).filter(selector);\n        };\n    };\n    var defineDagOneHop = function defineDagOneHop(params) {\n        return function(selector) {\n            var eles = this;\n            var oEles = [];\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                if (!ele.isNode()) {\n                    continue;\n                }\n                var edges = ele.connectedEdges();\n                for(var j = 0; j < edges.length; j++){\n                    var edge = edges[j];\n                    var src = edge.source();\n                    var tgt = edge.target();\n                    if (params.outgoing && src === ele) {\n                        oEles.push(edge);\n                        oEles.push(tgt);\n                    } else if (params.incoming && tgt === ele) {\n                        oEles.push(edge);\n                        oEles.push(src);\n                    }\n                }\n            }\n            return this.spawn(oEles, true).filter(selector);\n        };\n    };\n    var defineDagAllHops = function defineDagAllHops(params) {\n        return function(selector) {\n            var eles = this;\n            var sEles = [];\n            var sElesIds = {};\n            for(;;){\n                var next = params.outgoing ? eles.outgoers() : eles.incomers();\n                if (next.length === 0) {\n                    break;\n                } // done if none left\n                var newNext = false;\n                for(var i = 0; i < next.length; i++){\n                    var n = next[i];\n                    var nid = n.id();\n                    if (!sElesIds[nid]) {\n                        sElesIds[nid] = true;\n                        sEles.push(n);\n                        newNext = true;\n                    }\n                }\n                if (!newNext) {\n                    break;\n                } // done if touched all outgoers already\n                eles = next;\n            }\n            return this.spawn(sEles, true).filter(selector);\n        };\n    };\n    elesfn$2.clearTraversalCache = function() {\n        for(var i = 0; i < this.length; i++){\n            this[i]._private.traversalCache = null;\n        }\n    };\n    extend(elesfn$2, {\n        // get the root nodes in the DAG\n        roots: defineDagExtremity({\n            noIncomingEdges: true\n        }),\n        // get the leaf nodes in the DAG\n        leaves: defineDagExtremity({\n            noOutgoingEdges: true\n        }),\n        // normally called children in graph theory\n        // these nodes =edges=> outgoing nodes\n        outgoers: cache(defineDagOneHop({\n            outgoing: true\n        }), \"outgoers\"),\n        // aka DAG descendants\n        successors: defineDagAllHops({\n            outgoing: true\n        }),\n        // normally called parents in graph theory\n        // these nodes <=edges= incoming nodes\n        incomers: cache(defineDagOneHop({\n            incoming: true\n        }), \"incomers\"),\n        // aka DAG ancestors\n        predecessors: defineDagAllHops({\n            incoming: true\n        })\n    }); // Neighbourhood functions\n    //////////////////////////\n    extend(elesfn$2, {\n        neighborhood: cache(function(selector) {\n            var elements = [];\n            var nodes = this.nodes();\n            for(var i = 0; i < nodes.length; i++){\n                // for all nodes\n                var node = nodes[i];\n                var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node\n                for(var j = 0; j < connectedEdges.length; j++){\n                    var edge = connectedEdges[j];\n                    var src = edge.source();\n                    var tgt = edge.target();\n                    var otherNode = node === src ? tgt : src; // need check in case of loop\n                    if (otherNode.length > 0) {\n                        elements.push(otherNode[0]); // add node 1 hop away\n                    } // add connected edge\n                    elements.push(edge[0]);\n                }\n            }\n            return this.spawn(elements, true).filter(selector);\n        }, \"neighborhood\"),\n        closedNeighborhood: function closedNeighborhood(selector) {\n            return this.neighborhood().add(this).filter(selector);\n        },\n        openNeighborhood: function openNeighborhood(selector) {\n            return this.neighborhood(selector);\n        }\n    }); // aliases\n    elesfn$2.neighbourhood = elesfn$2.neighborhood;\n    elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\n    elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood; // Edge functions\n    /////////////////\n    extend(elesfn$2, {\n        source: cache(function sourceImpl(selector) {\n            var ele = this[0];\n            var src;\n            if (ele) {\n                src = ele._private.source || ele.cy().collection();\n            }\n            return src && selector ? src.filter(selector) : src;\n        }, \"source\"),\n        target: cache(function targetImpl(selector) {\n            var ele = this[0];\n            var tgt;\n            if (ele) {\n                tgt = ele._private.target || ele.cy().collection();\n            }\n            return tgt && selector ? tgt.filter(selector) : tgt;\n        }, \"target\"),\n        sources: defineSourceFunction({\n            attr: \"source\"\n        }),\n        targets: defineSourceFunction({\n            attr: \"target\"\n        })\n    });\n    function defineSourceFunction(params) {\n        return function sourceImpl(selector) {\n            var sources = [];\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var src = ele._private[params.attr];\n                if (src) {\n                    sources.push(src);\n                }\n            }\n            return this.spawn(sources, true).filter(selector);\n        };\n    }\n    extend(elesfn$2, {\n        edgesWith: cache(defineEdgesWithFunction(), \"edgesWith\"),\n        edgesTo: cache(defineEdgesWithFunction({\n            thisIsSrc: true\n        }), \"edgesTo\")\n    });\n    function defineEdgesWithFunction(params) {\n        return function edgesWithImpl(otherNodes) {\n            var elements = [];\n            var cy = this._private.cy;\n            var p = params || {}; // get elements if a selector is specified\n            if (string(otherNodes)) {\n                otherNodes = cy.$(otherNodes);\n            }\n            for(var h = 0; h < otherNodes.length; h++){\n                var edges = otherNodes[h]._private.edges;\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    var edgeData = edge._private.data;\n                    var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n                    var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n                    var edgeConnectsThisAndOther = thisToOther || otherToThis;\n                    if (!edgeConnectsThisAndOther) {\n                        continue;\n                    }\n                    if (p.thisIsSrc || p.thisIsTgt) {\n                        if (p.thisIsSrc && !thisToOther) {\n                            continue;\n                        }\n                        if (p.thisIsTgt && !otherToThis) {\n                            continue;\n                        }\n                    }\n                    elements.push(edge);\n                }\n            }\n            return this.spawn(elements, true);\n        };\n    }\n    extend(elesfn$2, {\n        connectedEdges: cache(function(selector) {\n            var retEles = [];\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var node = eles[i];\n                if (!node.isNode()) {\n                    continue;\n                }\n                var edges = node._private.edges;\n                for(var j = 0; j < edges.length; j++){\n                    var edge = edges[j];\n                    retEles.push(edge);\n                }\n            }\n            return this.spawn(retEles, true).filter(selector);\n        }, \"connectedEdges\"),\n        connectedNodes: cache(function(selector) {\n            var retEles = [];\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var edge = eles[i];\n                if (!edge.isEdge()) {\n                    continue;\n                }\n                retEles.push(edge.source()[0]);\n                retEles.push(edge.target()[0]);\n            }\n            return this.spawn(retEles, true).filter(selector);\n        }, \"connectedNodes\"),\n        parallelEdges: cache(defineParallelEdgesFunction(), \"parallelEdges\"),\n        codirectedEdges: cache(defineParallelEdgesFunction({\n            codirected: true\n        }), \"codirectedEdges\")\n    });\n    function defineParallelEdgesFunction(params) {\n        var defaults = {\n            codirected: false\n        };\n        params = extend({}, defaults, params);\n        return function parallelEdgesImpl(selector) {\n            // micro-optimised for renderer\n            var elements = [];\n            var edges = this.edges();\n            var p = params; // look at all the edges in the collection\n            for(var i = 0; i < edges.length; i++){\n                var edge1 = edges[i];\n                var edge1_p = edge1._private;\n                var src1 = edge1_p.source;\n                var srcid1 = src1._private.data.id;\n                var tgtid1 = edge1_p.data.target;\n                var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge\n                for(var j = 0; j < srcEdges1.length; j++){\n                    var edge2 = srcEdges1[j];\n                    var edge2data = edge2._private.data;\n                    var tgtid2 = edge2data.target;\n                    var srcid2 = edge2data.source;\n                    var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n                    var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n                    if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n                        elements.push(edge2);\n                    }\n                }\n            }\n            return this.spawn(elements, true).filter(selector);\n        };\n    } // Misc functions\n    /////////////////\n    extend(elesfn$2, {\n        components: function components(root) {\n            var self1 = this;\n            var cy = self1.cy();\n            var visited = cy.collection();\n            var unvisited = root == null ? self1.nodes() : root.nodes();\n            var components = [];\n            if (root != null && unvisited.empty()) {\n                // root may contain only edges\n                unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n            }\n            var visitInComponent = function visitInComponent(node, component) {\n                visited.merge(node);\n                unvisited.unmerge(node);\n                component.merge(node);\n            };\n            if (unvisited.empty()) {\n                return self1.spawn();\n            }\n            var _loop = function _loop() {\n                // each iteration yields a component\n                var cmpt = cy.collection();\n                components.push(cmpt);\n                var root = unvisited[0];\n                visitInComponent(root, cmpt);\n                self1.bfs({\n                    directed: false,\n                    roots: root,\n                    visit: function visit(v) {\n                        return visitInComponent(v, cmpt);\n                    }\n                });\n                cmpt.forEach(function(node) {\n                    node.connectedEdges().forEach(function(e) {\n                        // connectedEdges() usually cached\n                        if (self1.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n                            // has() is cheap\n                            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n                        }\n                    });\n                });\n            };\n            do {\n                _loop();\n            }while (unvisited.length > 0);\n            return components;\n        },\n        component: function component() {\n            var ele = this[0];\n            return ele.cy().mutableElements().components(ele)[0];\n        }\n    });\n    elesfn$2.componentsOf = elesfn$2.components;\n    var Collection = function Collection(cy, elements) {\n        var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        if (cy === undefined) {\n            error(\"A collection must have a reference to the core\");\n            return;\n        }\n        var map = new Map$2();\n        var createdElements = false;\n        if (!elements) {\n            elements = [];\n        } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n            createdElements = true; // make elements from json and restore all at once later\n            var eles = [];\n            var elesIds = new Set$1();\n            for(var i = 0, l = elements.length; i < l; i++){\n                var json = elements[i];\n                if (json.data == null) {\n                    json.data = {};\n                }\n                var _data = json.data; // make sure newly created elements have valid ids\n                if (_data.id == null) {\n                    _data.id = uuid();\n                } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n                    continue; // can't create element if prior id already exists\n                }\n                var ele = new Element(cy, json, false);\n                eles.push(ele);\n                elesIds.add(_data.id);\n            }\n            elements = eles;\n        }\n        this.length = 0;\n        for(var _i = 0, _l = elements.length; _i < _l; _i++){\n            var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n            if (element$1 == null) {\n                continue;\n            }\n            var id = element$1._private.data.id;\n            if (!unique || !map.has(id)) {\n                if (unique) {\n                    map.set(id, {\n                        index: this.length,\n                        ele: element$1\n                    });\n                }\n                this[this.length] = element$1;\n                this.length++;\n            }\n        }\n        this._private = {\n            eles: this,\n            cy: cy,\n            get map () {\n                if (this.lazyMap == null) {\n                    this.rebuildMap();\n                }\n                return this.lazyMap;\n            },\n            set map (m){\n                this.lazyMap = m;\n            },\n            rebuildMap: function rebuildMap() {\n                var m1 = this.lazyMap = new Map$2();\n                var eles = this.eles;\n                for(var _i2 = 0; _i2 < eles.length; _i2++){\n                    var _ele = eles[_i2];\n                    m1.set(_ele.id(), {\n                        index: _i2,\n                        ele: _ele\n                    });\n                }\n            }\n        };\n        if (unique) {\n            this._private.map = map;\n        } // restore the elements if we created them from json\n        if (createdElements && !removed) {\n            this.restore();\n        }\n    }; // Functions\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // keep the prototypes in sync (an element has the same functions as a collection)\n    // and use elefn and elesfn as shorthands to the prototypes\n    var elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\n    elesfn$1.instanceString = function() {\n        return \"collection\";\n    };\n    elesfn$1.spawn = function(eles, unique) {\n        return new Collection(this.cy(), eles, unique);\n    };\n    elesfn$1.spawnSelf = function() {\n        return this.spawn(this);\n    };\n    elesfn$1.cy = function() {\n        return this._private.cy;\n    };\n    elesfn$1.renderer = function() {\n        return this._private.cy.renderer();\n    };\n    elesfn$1.element = function() {\n        return this[0];\n    };\n    elesfn$1.collection = function() {\n        if (collection(this)) {\n            return this;\n        } else {\n            // an element\n            return new Collection(this._private.cy, [\n                this\n            ]);\n        }\n    };\n    elesfn$1.unique = function() {\n        return new Collection(this._private.cy, this, true);\n    };\n    elesfn$1.hasElementWithId = function(id) {\n        id = \"\" + id; // id must be string\n        return this._private.map.has(id);\n    };\n    elesfn$1.getElementById = function(id) {\n        id = \"\" + id; // id must be string\n        var cy = this._private.cy;\n        var entry = this._private.map.get(id);\n        return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n    };\n    elesfn$1.$id = elesfn$1.getElementById;\n    elesfn$1.poolIndex = function() {\n        var cy = this._private.cy;\n        var eles = cy._private.elements;\n        var id = this[0]._private.data.id;\n        return eles._private.map.get(id).index;\n    };\n    elesfn$1.indexOf = function(ele) {\n        var id = ele[0]._private.data.id;\n        return this._private.map.get(id).index;\n    };\n    elesfn$1.indexOfId = function(id) {\n        id = \"\" + id; // id must be string\n        return this._private.map.get(id).index;\n    };\n    elesfn$1.json = function(obj) {\n        var ele = this.element();\n        var cy = this.cy();\n        if (ele == null && obj) {\n            return this;\n        } // can't set to no eles\n        if (ele == null) {\n            return undefined;\n        } // can't get from no eles\n        var p = ele._private;\n        if (plainObject(obj)) {\n            // set\n            cy.startBatch();\n            if (obj.data) {\n                ele.data(obj.data);\n                var _data2 = p.data;\n                if (ele.isEdge()) {\n                    // source and target are immutable via data()\n                    var move = false;\n                    var spec = {};\n                    var src = obj.data.source;\n                    var tgt = obj.data.target;\n                    if (src != null && src != _data2.source) {\n                        spec.source = \"\" + src; // id must be string\n                        move = true;\n                    }\n                    if (tgt != null && tgt != _data2.target) {\n                        spec.target = \"\" + tgt; // id must be string\n                        move = true;\n                    }\n                    if (move) {\n                        ele = ele.move(spec);\n                    }\n                } else {\n                    // parent is immutable via data()\n                    var newParentValSpecd = \"parent\" in obj.data;\n                    var parent = obj.data.parent;\n                    if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n                        if (parent === undefined) {\n                            // can't set undefined imperatively, so use null\n                            parent = null;\n                        }\n                        if (parent != null) {\n                            parent = \"\" + parent; // id must be string\n                        }\n                        ele = ele.move({\n                            parent: parent\n                        });\n                    }\n                }\n            }\n            if (obj.position) {\n                ele.position(obj.position);\n            } // ignore group -- immutable\n            var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n                var obj_k = obj[k];\n                if (obj_k != null && obj_k !== p[k]) {\n                    if (obj_k) {\n                        ele[trueFnName]();\n                    } else {\n                        ele[falseFnName]();\n                    }\n                }\n            };\n            checkSwitch(\"removed\", \"remove\", \"restore\");\n            checkSwitch(\"selected\", \"select\", \"unselect\");\n            checkSwitch(\"selectable\", \"selectify\", \"unselectify\");\n            checkSwitch(\"locked\", \"lock\", \"unlock\");\n            checkSwitch(\"grabbable\", \"grabify\", \"ungrabify\");\n            checkSwitch(\"pannable\", \"panify\", \"unpanify\");\n            if (obj.classes != null) {\n                ele.classes(obj.classes);\n            }\n            cy.endBatch();\n            return this;\n        } else if (obj === undefined) {\n            // get\n            var json = {\n                data: copy(p.data),\n                position: copy(p.position),\n                group: p.group,\n                removed: p.removed,\n                selected: p.selected,\n                selectable: p.selectable,\n                locked: p.locked,\n                grabbable: p.grabbable,\n                pannable: p.pannable,\n                classes: null\n            };\n            json.classes = \"\";\n            var i = 0;\n            p.classes.forEach(function(cls) {\n                return json.classes += i++ === 0 ? cls : \" \" + cls;\n            });\n            return json;\n        }\n    };\n    elesfn$1.jsons = function() {\n        var jsons = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var json = ele.json();\n            jsons.push(json);\n        }\n        return jsons;\n    };\n    elesfn$1.clone = function() {\n        var cy = this.cy();\n        var elesArr = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var json = ele.json();\n            var clone = new Element(cy, json, false); // NB no restore\n            elesArr.push(clone);\n        }\n        return new Collection(cy, elesArr);\n    };\n    elesfn$1.copy = elesfn$1.clone;\n    elesfn$1.restore = function() {\n        var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var self1 = this;\n        var cy = self1.cy();\n        var cy_p = cy._private; // create arrays of nodes and edges, since we need to\n        // restore the nodes first\n        var nodes = [];\n        var edges = [];\n        var elements;\n        for(var _i3 = 0, l = self1.length; _i3 < l; _i3++){\n            var ele = self1[_i3];\n            if (addToPool && !ele.removed()) {\n                continue;\n            } // keep nodes first in the array and edges after\n            if (ele.isNode()) {\n                // put to front of array if node\n                nodes.push(ele);\n            } else {\n                // put to end of array if edge\n                edges.push(ele);\n            }\n        }\n        elements = nodes.concat(edges);\n        var i;\n        var removeFromElements = function removeFromElements() {\n            elements.splice(i, 1);\n            i--;\n        }; // now, restore each element\n        for(i = 0; i < elements.length; i++){\n            var _ele2 = elements[i];\n            var _private = _ele2._private;\n            var _data3 = _private.data; // the traversal cache should start fresh when ele is added\n            _ele2.clearTraversalCache(); // set id and validate\n            if (!addToPool && !_private.removed) ;\n            else if (_data3.id === undefined) {\n                _data3.id = uuid();\n            } else if (number$1(_data3.id)) {\n                _data3.id = \"\" + _data3.id; // now it's a string\n            } else if (emptyString(_data3.id) || !string(_data3.id)) {\n                error(\"Can not create element with invalid string ID `\" + _data3.id + \"`\"); // can't create element if it has empty string as id or non-string id\n                removeFromElements();\n                continue;\n            } else if (cy.hasElementWithId(_data3.id)) {\n                error(\"Can not create second element with ID `\" + _data3.id + \"`\"); // can't create element if one already has that id\n                removeFromElements();\n                continue;\n            }\n            var id = _data3.id; // id is finalised, now let's keep a ref\n            if (_ele2.isNode()) {\n                // extra checks for nodes\n                var pos = _private.position; // make sure the nodes have a defined position\n                if (pos.x == null) {\n                    pos.x = 0;\n                }\n                if (pos.y == null) {\n                    pos.y = 0;\n                }\n            }\n            if (_ele2.isEdge()) {\n                // extra checks for edges\n                var edge = _ele2;\n                var fields = [\n                    \"source\",\n                    \"target\"\n                ];\n                var fieldsLength = fields.length;\n                var badSourceOrTarget = false;\n                for(var j = 0; j < fieldsLength; j++){\n                    var field = fields[j];\n                    var val = _data3[field];\n                    if (number$1(val)) {\n                        val = _data3[field] = \"\" + _data3[field]; // now string\n                    }\n                    if (val == null || val === \"\") {\n                        // can't create if source or target is not defined properly\n                        error(\"Can not create edge `\" + id + \"` with unspecified \" + field);\n                        badSourceOrTarget = true;\n                    } else if (!cy.hasElementWithId(val)) {\n                        // can't create edge if one of its nodes doesn't exist\n                        error(\"Can not create edge `\" + id + \"` with nonexistant \" + field + \" `\" + val + \"`\");\n                        badSourceOrTarget = true;\n                    }\n                }\n                if (badSourceOrTarget) {\n                    removeFromElements();\n                    continue;\n                } // can't create this\n                var src = cy.getElementById(_data3.source);\n                var tgt = cy.getElementById(_data3.target); // only one edge in node if loop\n                if (src.same(tgt)) {\n                    src._private.edges.push(edge);\n                } else {\n                    src._private.edges.push(edge);\n                    tgt._private.edges.push(edge);\n                }\n                edge._private.source = src;\n                edge._private.target = tgt;\n            } // if is edge\n            // create mock ids / indexes maps for element so it can be used like collections\n            _private.map = new Map$2();\n            _private.map.set(id, {\n                ele: _ele2,\n                index: 0\n            });\n            _private.removed = false;\n            if (addToPool) {\n                cy.addToPool(_ele2);\n            }\n        } // for each element\n        // do compound node sanity checks\n        for(var _i4 = 0; _i4 < nodes.length; _i4++){\n            // each node\n            var node = nodes[_i4];\n            var _data4 = node._private.data;\n            if (number$1(_data4.parent)) {\n                // then automake string\n                _data4.parent = \"\" + _data4.parent;\n            }\n            var parentId = _data4.parent;\n            var specifiedParent = parentId != null;\n            if (specifiedParent || node._private.parent) {\n                var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n                if (parent.empty()) {\n                    // non-existant parent; just remove it\n                    _data4.parent = undefined;\n                } else if (parent[0].removed()) {\n                    warn(\"Node added with missing parent, reference to parent removed\");\n                    _data4.parent = undefined;\n                    node._private.parent = null;\n                } else {\n                    var selfAsParent = false;\n                    var ancestor = parent;\n                    while(!ancestor.empty()){\n                        if (node.same(ancestor)) {\n                            // mark self as parent and remove from data\n                            selfAsParent = true;\n                            _data4.parent = undefined; // remove parent reference\n                            break;\n                        }\n                        ancestor = ancestor.parent();\n                    }\n                    if (!selfAsParent) {\n                        // connect with children\n                        parent[0]._private.children.push(node);\n                        node._private.parent = parent[0]; // let the core know we have a compound graph\n                        cy_p.hasCompoundNodes = true;\n                    }\n                } // else\n            } // if specified parent\n        } // for each node\n        if (elements.length > 0) {\n            var restored = elements.length === self1.length ? self1 : new Collection(cy, elements);\n            for(var _i5 = 0; _i5 < restored.length; _i5++){\n                var _ele3 = restored[_i5];\n                if (_ele3.isNode()) {\n                    continue;\n                } // adding an edge invalidates the traversal caches for the parallel edges\n                _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes\n                _ele3.source().clearTraversalCache();\n                _ele3.target().clearTraversalCache();\n            }\n            var toUpdateStyle;\n            if (cy_p.hasCompoundNodes) {\n                toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n            } else {\n                toUpdateStyle = restored;\n            }\n            toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n            if (notifyRenderer) {\n                restored.emitAndNotify(\"add\");\n            } else if (addToPool) {\n                restored.emit(\"add\");\n            }\n        }\n        return self1; // chainability\n    };\n    elesfn$1.removed = function() {\n        var ele = this[0];\n        return ele && ele._private.removed;\n    };\n    elesfn$1.inside = function() {\n        var ele = this[0];\n        return ele && !ele._private.removed;\n    };\n    elesfn$1.remove = function() {\n        var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var self1 = this;\n        var elesToRemove = [];\n        var elesToRemoveIds = {};\n        var cy = self1._private.cy; // add connected edges\n        function addConnectedEdges(node) {\n            var edges = node._private.edges;\n            for(var i = 0; i < edges.length; i++){\n                add(edges[i]);\n            }\n        } // add descendant nodes\n        function addChildren(node) {\n            var children = node._private.children;\n            for(var i = 0; i < children.length; i++){\n                add(children[i]);\n            }\n        }\n        function add(ele) {\n            var alreadyAdded = elesToRemoveIds[ele.id()];\n            if (removeFromPool && ele.removed() || alreadyAdded) {\n                return;\n            } else {\n                elesToRemoveIds[ele.id()] = true;\n            }\n            if (ele.isNode()) {\n                elesToRemove.push(ele); // nodes are removed last\n                addConnectedEdges(ele);\n                addChildren(ele);\n            } else {\n                elesToRemove.unshift(ele); // edges are removed first\n            }\n        } // make the list of elements to remove\n        // (may be removing more than specified due to connected edges etc)\n        for(var i = 0, l = self1.length; i < l; i++){\n            var ele = self1[i];\n            add(ele);\n        }\n        function removeEdgeRef(node, edge) {\n            var connectedEdges = node._private.edges;\n            removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes\n            node.clearTraversalCache();\n        }\n        function removeParallelRef(pllEdge) {\n            // removing an edge invalidates the traversal caches for the parallel edges\n            pllEdge.clearTraversalCache();\n        }\n        var alteredParents = [];\n        alteredParents.ids = {};\n        function removeChildRef(parent, ele) {\n            ele = ele[0];\n            parent = parent[0];\n            var children = parent._private.children;\n            var pid = parent.id();\n            removeFromArray(children, ele); // remove parent => child ref\n            ele._private.parent = null; // remove child => parent ref\n            if (!alteredParents.ids[pid]) {\n                alteredParents.ids[pid] = true;\n                alteredParents.push(parent);\n            }\n        }\n        self1.dirtyCompoundBoundsCache();\n        if (removeFromPool) {\n            cy.removeFromPool(elesToRemove); // remove from core pool\n        }\n        for(var _i6 = 0; _i6 < elesToRemove.length; _i6++){\n            var _ele4 = elesToRemove[_i6];\n            if (_ele4.isEdge()) {\n                // remove references to this edge in its connected nodes\n                var src = _ele4.source()[0];\n                var tgt = _ele4.target()[0];\n                removeEdgeRef(src, _ele4);\n                removeEdgeRef(tgt, _ele4);\n                var pllEdges = _ele4.parallelEdges();\n                for(var j = 0; j < pllEdges.length; j++){\n                    var pllEdge = pllEdges[j];\n                    removeParallelRef(pllEdge);\n                    if (pllEdge.isBundledBezier()) {\n                        pllEdge.dirtyBoundingBoxCache();\n                    }\n                }\n            } else {\n                // remove reference to parent\n                var parent = _ele4.parent();\n                if (parent.length !== 0) {\n                    removeChildRef(parent, _ele4);\n                }\n            }\n            if (removeFromPool) {\n                // mark as removed\n                _ele4._private.removed = true;\n            }\n        } // check to see if we have a compound graph or not\n        var elesStillInside = cy._private.elements;\n        cy._private.hasCompoundNodes = false;\n        for(var _i7 = 0; _i7 < elesStillInside.length; _i7++){\n            var _ele5 = elesStillInside[_i7];\n            if (_ele5.isParent()) {\n                cy._private.hasCompoundNodes = true;\n                break;\n            }\n        }\n        var removedElements = new Collection(this.cy(), elesToRemove);\n        if (removedElements.size() > 0) {\n            // must manually notify since trigger won't do this automatically once removed\n            if (notifyRenderer) {\n                removedElements.emitAndNotify(\"remove\");\n            } else if (removeFromPool) {\n                removedElements.emit(\"remove\");\n            }\n        } // the parents who were modified by the removal need their style updated\n        for(var _i8 = 0; _i8 < alteredParents.length; _i8++){\n            var _ele6 = alteredParents[_i8];\n            if (!removeFromPool || !_ele6.removed()) {\n                _ele6.updateStyle();\n            }\n        }\n        return removedElements;\n    };\n    elesfn$1.move = function(struct) {\n        var cy = this._private.cy;\n        var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring\n        // (our calls to remove/restore do not remove from the graph or make events)\n        var notifyRenderer = false;\n        var modifyPool = false;\n        var toString = function toString(id) {\n            return id == null ? id : \"\" + id;\n        }; // id must be string\n        if (struct.source !== undefined || struct.target !== undefined) {\n            var srcId = toString(struct.source);\n            var tgtId = toString(struct.target);\n            var srcExists = srcId != null && cy.hasElementWithId(srcId);\n            var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n            if (srcExists || tgtExists) {\n                cy.batch(function() {\n                    // avoid duplicate style updates\n                    eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                    eles.emitAndNotify(\"moveout\");\n                    for(var i = 0; i < eles.length; i++){\n                        var ele = eles[i];\n                        var _data5 = ele._private.data;\n                        if (ele.isEdge()) {\n                            if (srcExists) {\n                                _data5.source = srcId;\n                            }\n                            if (tgtExists) {\n                                _data5.target = tgtId;\n                            }\n                        }\n                    }\n                    eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n                });\n                eles.emitAndNotify(\"move\");\n            }\n        } else if (struct.parent !== undefined) {\n            // move node to new parent\n            var parentId = toString(struct.parent);\n            var parentExists = parentId === null || cy.hasElementWithId(parentId);\n            if (parentExists) {\n                var pidToAssign = parentId === null ? undefined : parentId;\n                cy.batch(function() {\n                    // avoid duplicate style updates\n                    var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                    updated.emitAndNotify(\"moveout\");\n                    for(var i = 0; i < eles.length; i++){\n                        var ele = eles[i];\n                        var _data6 = ele._private.data;\n                        if (ele.isNode()) {\n                            _data6.parent = pidToAssign;\n                        }\n                    }\n                    updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n                });\n                eles.emitAndNotify(\"move\");\n            }\n        }\n        return this;\n    };\n    [\n        elesfn$j,\n        elesfn$i,\n        elesfn$h,\n        elesfn$g,\n        elesfn$f,\n        data,\n        elesfn$d,\n        dimensions,\n        elesfn$9,\n        elesfn$8,\n        elesfn$7,\n        elesfn$6,\n        elesfn$5,\n        elesfn$4,\n        elesfn$3,\n        elesfn$2\n    ].forEach(function(props) {\n        extend(elesfn$1, props);\n    });\n    var corefn$9 = {\n        add: function add(opts) {\n            var elements;\n            var cy = this; // add the elements\n            if (elementOrCollection(opts)) {\n                var eles = opts;\n                if (eles._private.cy === cy) {\n                    // same instance => just restore\n                    elements = eles.restore();\n                } else {\n                    // otherwise, copy from json\n                    var jsons = [];\n                    for(var i = 0; i < eles.length; i++){\n                        var ele = eles[i];\n                        jsons.push(ele.json());\n                    }\n                    elements = new Collection(cy, jsons);\n                }\n            } else if (array(opts)) {\n                var _jsons = opts;\n                elements = new Collection(cy, _jsons);\n            } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n                var elesByGroup = opts;\n                var _jsons2 = [];\n                var grs = [\n                    \"nodes\",\n                    \"edges\"\n                ];\n                for(var _i = 0, il = grs.length; _i < il; _i++){\n                    var group = grs[_i];\n                    var elesArray = elesByGroup[group];\n                    if (array(elesArray)) {\n                        for(var j = 0, jl = elesArray.length; j < jl; j++){\n                            var json = extend({\n                                group: group\n                            }, elesArray[j]);\n                            _jsons2.push(json);\n                        }\n                    }\n                }\n                elements = new Collection(cy, _jsons2);\n            } else {\n                var _json = opts;\n                elements = new Element(cy, _json).collection();\n            }\n            return elements;\n        },\n        remove: function remove(collection) {\n            if (elementOrCollection(collection)) ;\n            else if (string(collection)) {\n                var selector = collection;\n                collection = this.$(selector);\n            }\n            return collection.remove();\n        }\n    };\n    /* global Float32Array */ /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */ function generateCubicBezier(mX1, mY1, mX2, mY2) {\n        var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0), float32ArraySupported = typeof Float32Array !== \"undefined\";\n        /* Must contain four arguments. */ if (arguments.length !== 4) {\n            return false;\n        }\n        /* Arguments must be numbers. */ for(var i = 0; i < 4; ++i){\n            if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n                return false;\n            }\n        }\n        /* X values must be in the [0, 1] range. */ mX1 = Math.min(mX1, 1);\n        mX2 = Math.min(mX2, 1);\n        mX1 = Math.max(mX1, 0);\n        mX2 = Math.max(mX2, 0);\n        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n        function A(aA1, aA2) {\n            return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n        }\n        function B(aA1, aA2) {\n            return 3.0 * aA2 - 6.0 * aA1;\n        }\n        function C(aA1) {\n            return 3.0 * aA1;\n        }\n        function calcBezier(aT, aA1, aA2) {\n            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n        }\n        function getSlope(aT, aA1, aA2) {\n            return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n        }\n        function newtonRaphsonIterate(aX, aGuessT) {\n            for(var _i = 0; _i < NEWTON_ITERATIONS; ++_i){\n                var currentSlope = getSlope(aGuessT, mX1, mX2);\n                if (currentSlope === 0.0) {\n                    return aGuessT;\n                }\n                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n                aGuessT -= currentX / currentSlope;\n            }\n            return aGuessT;\n        }\n        function calcSampleValues() {\n            for(var _i2 = 0; _i2 < kSplineTableSize; ++_i2){\n                mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n            }\n        }\n        function binarySubdivide(aX, aA, aB) {\n            var currentX, currentT, i = 0;\n            do {\n                currentT = aA + (aB - aA) / 2.0;\n                currentX = calcBezier(currentT, mX1, mX2) - aX;\n                if (currentX > 0.0) {\n                    aB = currentT;\n                } else {\n                    aA = currentT;\n                }\n            }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n            return currentT;\n        }\n        function getTForX(aX) {\n            var intervalStart = 0.0, currentSample = 1, lastSample = kSplineTableSize - 1;\n            for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n                intervalStart += kSampleStepSize;\n            }\n            --currentSample;\n            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);\n            if (initialSlope >= NEWTON_MIN_SLOPE) {\n                return newtonRaphsonIterate(aX, guessForT);\n            } else if (initialSlope === 0.0) {\n                return guessForT;\n            } else {\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n            }\n        }\n        var _precomputed = false;\n        function precompute() {\n            _precomputed = true;\n            if (mX1 !== mY1 || mX2 !== mY2) {\n                calcSampleValues();\n            }\n        }\n        var f = function f(aX) {\n            if (!_precomputed) {\n                precompute();\n            }\n            if (mX1 === mY1 && mX2 === mY2) {\n                return aX;\n            }\n            if (aX === 0) {\n                return 0;\n            }\n            if (aX === 1) {\n                return 1;\n            }\n            return calcBezier(getTForX(aX), mY1, mY2);\n        };\n        f.getControlPoints = function() {\n            return [\n                {\n                    x: mX1,\n                    y: mY1\n                },\n                {\n                    x: mX2,\n                    y: mY2\n                }\n            ];\n        };\n        var str = \"generateBezier(\" + [\n            mX1,\n            mY1,\n            mX2,\n            mY2\n        ] + \")\";\n        f.toString = function() {\n            return str;\n        };\n        return f;\n    }\n    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */ /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n     then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */ var generateSpringRK4 = function() {\n        function springAccelerationForState(state) {\n            return -state.tension * state.x - state.friction * state.v;\n        }\n        function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n            var state = {\n                x: initialState.x + derivative.dx * dt,\n                v: initialState.v + derivative.dv * dt,\n                tension: initialState.tension,\n                friction: initialState.friction\n            };\n            return {\n                dx: state.v,\n                dv: springAccelerationForState(state)\n            };\n        }\n        function springIntegrateState(state, dt) {\n            var a = {\n                dx: state.v,\n                dv: springAccelerationForState(state)\n            }, b = springEvaluateStateWithDerivative(state, dt * 0.5, a), c = springEvaluateStateWithDerivative(state, dt * 0.5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx), dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n            state.x = state.x + dxdt * dt;\n            state.v = state.v + dvdt * dt;\n            return state;\n        }\n        return function springRK4Factory(tension, friction, duration) {\n            var initState = {\n                x: -1,\n                v: 0,\n                tension: null,\n                friction: null\n            }, path = [\n                0\n            ], time_lapsed = 0, tolerance = 1 / 10000, DT = 16 / 1000, have_duration, dt, last_state;\n            tension = parseFloat(tension) || 500;\n            friction = parseFloat(friction) || 20;\n            duration = duration || null;\n            initState.tension = tension;\n            initState.friction = friction;\n            have_duration = duration !== null;\n            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */ if (have_duration) {\n                /* Run the simulation without a duration. */ time_lapsed = springRK4Factory(tension, friction);\n                /* Compute the adjusted time delta. */ dt = time_lapsed / duration * DT;\n            } else {\n                dt = DT;\n            }\n            for(;;){\n                /* Next/step function .*/ last_state = springIntegrateState(last_state || initState, dt);\n                /* Store the position. */ path.push(1 + last_state.x);\n                time_lapsed += 16;\n                /* If the change threshold is reached, break. */ if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n                    break;\n                }\n            }\n            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n         computed path and returns a snapshot of the position according to a given percentComplete. */ return !have_duration ? time_lapsed : function(percentComplete) {\n                return path[percentComplete * (path.length - 1) | 0];\n            };\n        };\n    }();\n    var cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n        var bezier = generateCubicBezier(t1, p1, t2, p2);\n        return function(start, end, percent) {\n            return start + (end - start) * bezier(percent);\n        };\n    };\n    var easings = {\n        \"linear\": function linear(start, end, percent) {\n            return start + (end - start) * percent;\n        },\n        // default easings\n        \"ease\": cubicBezier(0.25, 0.1, 0.25, 1),\n        \"ease-in\": cubicBezier(0.42, 0, 1, 1),\n        \"ease-out\": cubicBezier(0, 0, 0.58, 1),\n        \"ease-in-out\": cubicBezier(0.42, 0, 0.58, 1),\n        // sine\n        \"ease-in-sine\": cubicBezier(0.47, 0, 0.745, 0.715),\n        \"ease-out-sine\": cubicBezier(0.39, 0.575, 0.565, 1),\n        \"ease-in-out-sine\": cubicBezier(0.445, 0.05, 0.55, 0.95),\n        // quad\n        \"ease-in-quad\": cubicBezier(0.55, 0.085, 0.68, 0.53),\n        \"ease-out-quad\": cubicBezier(0.25, 0.46, 0.45, 0.94),\n        \"ease-in-out-quad\": cubicBezier(0.455, 0.03, 0.515, 0.955),\n        // cubic\n        \"ease-in-cubic\": cubicBezier(0.55, 0.055, 0.675, 0.19),\n        \"ease-out-cubic\": cubicBezier(0.215, 0.61, 0.355, 1),\n        \"ease-in-out-cubic\": cubicBezier(0.645, 0.045, 0.355, 1),\n        // quart\n        \"ease-in-quart\": cubicBezier(0.895, 0.03, 0.685, 0.22),\n        \"ease-out-quart\": cubicBezier(0.165, 0.84, 0.44, 1),\n        \"ease-in-out-quart\": cubicBezier(0.77, 0, 0.175, 1),\n        // quint\n        \"ease-in-quint\": cubicBezier(0.755, 0.05, 0.855, 0.06),\n        \"ease-out-quint\": cubicBezier(0.23, 1, 0.32, 1),\n        \"ease-in-out-quint\": cubicBezier(0.86, 0, 0.07, 1),\n        // expo\n        \"ease-in-expo\": cubicBezier(0.95, 0.05, 0.795, 0.035),\n        \"ease-out-expo\": cubicBezier(0.19, 1, 0.22, 1),\n        \"ease-in-out-expo\": cubicBezier(1, 0, 0, 1),\n        // circ\n        \"ease-in-circ\": cubicBezier(0.6, 0.04, 0.98, 0.335),\n        \"ease-out-circ\": cubicBezier(0.075, 0.82, 0.165, 1),\n        \"ease-in-out-circ\": cubicBezier(0.785, 0.135, 0.15, 0.86),\n        // user param easings...\n        \"spring\": function spring(tension, friction, duration) {\n            if (duration === 0) {\n                // can't get a spring w/ duration 0\n                return easings.linear; // duration 0 => jump to end so impl doesn't matter\n            }\n            var spring = generateSpringRK4(tension, friction, duration);\n            return function(start, end, percent) {\n                return start + (end - start) * spring(percent);\n            };\n        },\n        \"cubic-bezier\": cubicBezier\n    };\n    function getEasedValue(type, start, end, percent, easingFn) {\n        if (percent === 1) {\n            return end;\n        }\n        if (start === end) {\n            return end;\n        }\n        var val = easingFn(start, end, percent);\n        if (type == null) {\n            return val;\n        }\n        if (type.roundValue || type.color) {\n            val = Math.round(val);\n        }\n        if (type.min !== undefined) {\n            val = Math.max(val, type.min);\n        }\n        if (type.max !== undefined) {\n            val = Math.min(val, type.max);\n        }\n        return val;\n    }\n    function getValue(prop, spec) {\n        if (prop.pfValue != null || prop.value != null) {\n            if (prop.pfValue != null && (spec == null || spec.type.units !== \"%\")) {\n                return prop.pfValue;\n            } else {\n                return prop.value;\n            }\n        } else {\n            return prop;\n        }\n    }\n    function ease(startProp, endProp, percent, easingFn, propSpec) {\n        var type = propSpec != null ? propSpec.type : null;\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 1) {\n            percent = 1;\n        }\n        var start = getValue(startProp, propSpec);\n        var end = getValue(endProp, propSpec);\n        if (number$1(start) && number$1(end)) {\n            return getEasedValue(type, start, end, percent, easingFn);\n        } else if (array(start) && array(end)) {\n            var easedArr = [];\n            for(var i = 0; i < end.length; i++){\n                var si = start[i];\n                var ei = end[i];\n                if (si != null && ei != null) {\n                    var val = getEasedValue(type, si, ei, percent, easingFn);\n                    easedArr.push(val);\n                } else {\n                    easedArr.push(ei);\n                }\n            }\n            return easedArr;\n        }\n        return undefined;\n    }\n    function step$1(self1, ani, now, isCore) {\n        var isEles = !isCore;\n        var _p = self1._private;\n        var ani_p = ani._private;\n        var pEasing = ani_p.easing;\n        var startTime = ani_p.startTime;\n        var cy = isCore ? self1 : self1.cy();\n        var style = cy.style();\n        if (!ani_p.easingImpl) {\n            if (pEasing == null) {\n                // use default\n                ani_p.easingImpl = easings[\"linear\"];\n            } else {\n                // then define w/ name\n                var easingVals;\n                if (string(pEasing)) {\n                    var easingProp = style.parse(\"transition-timing-function\", pEasing);\n                    easingVals = easingProp.value;\n                } else {\n                    // then assume preparsed array\n                    easingVals = pEasing;\n                }\n                var name, args;\n                if (string(easingVals)) {\n                    name = easingVals;\n                    args = [];\n                } else {\n                    name = easingVals[1];\n                    args = easingVals.slice(2).map(function(n) {\n                        return +n;\n                    });\n                }\n                if (args.length > 0) {\n                    // create with args\n                    if (name === \"spring\") {\n                        args.push(ani_p.duration); // need duration to generate spring\n                    }\n                    ani_p.easingImpl = easings[name].apply(null, args);\n                } else {\n                    // static impl by name\n                    ani_p.easingImpl = easings[name];\n                }\n            }\n        }\n        var easing = ani_p.easingImpl;\n        var percent;\n        if (ani_p.duration === 0) {\n            percent = 1;\n        } else {\n            percent = (now - startTime) / ani_p.duration;\n        }\n        if (ani_p.applying) {\n            percent = ani_p.progress;\n        }\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 1) {\n            percent = 1;\n        }\n        if (ani_p.delay == null) {\n            // then update\n            var startPos = ani_p.startPosition;\n            var endPos = ani_p.position;\n            if (endPos && isEles && !self1.locked()) {\n                var newPos = {};\n                if (valid(startPos.x, endPos.x)) {\n                    newPos.x = ease(startPos.x, endPos.x, percent, easing);\n                }\n                if (valid(startPos.y, endPos.y)) {\n                    newPos.y = ease(startPos.y, endPos.y, percent, easing);\n                }\n                self1.position(newPos);\n            }\n            var startPan = ani_p.startPan;\n            var endPan = ani_p.pan;\n            var pan = _p.pan;\n            var animatingPan = endPan != null && isCore;\n            if (animatingPan) {\n                if (valid(startPan.x, endPan.x)) {\n                    pan.x = ease(startPan.x, endPan.x, percent, easing);\n                }\n                if (valid(startPan.y, endPan.y)) {\n                    pan.y = ease(startPan.y, endPan.y, percent, easing);\n                }\n                self1.emit(\"pan\");\n            }\n            var startZoom = ani_p.startZoom;\n            var endZoom = ani_p.zoom;\n            var animatingZoom = endZoom != null && isCore;\n            if (animatingZoom) {\n                if (valid(startZoom, endZoom)) {\n                    _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n                }\n                self1.emit(\"zoom\");\n            }\n            if (animatingPan || animatingZoom) {\n                self1.emit(\"viewport\");\n            }\n            var props = ani_p.style;\n            if (props && props.length > 0 && isEles) {\n                for(var i = 0; i < props.length; i++){\n                    var prop = props[i];\n                    var _name = prop.name;\n                    var end = prop;\n                    var start = ani_p.startStyle[_name];\n                    var propSpec = style.properties[start.name];\n                    var easedVal = ease(start, end, percent, easing, propSpec);\n                    style.overrideBypass(self1, _name, easedVal);\n                } // for props\n                self1.emit(\"style\");\n            } // if\n        }\n        ani_p.progress = percent;\n        return percent;\n    }\n    function valid(start, end) {\n        if (start == null || end == null) {\n            return false;\n        }\n        if (number$1(start) && number$1(end)) {\n            return true;\n        } else if (start && end) {\n            return true;\n        }\n        return false;\n    }\n    function startAnimation(self1, ani, now, isCore) {\n        var ani_p = ani._private;\n        ani_p.started = true;\n        ani_p.startTime = now - ani_p.progress * ani_p.duration;\n    }\n    function stepAll(now, cy) {\n        var eles = cy._private.aniEles;\n        var doneEles = [];\n        function stepOne(ele, isCore) {\n            var _p = ele._private;\n            var current = _p.animation.current;\n            var queue = _p.animation.queue;\n            var ranAnis = false; // if nothing currently animating, get something from the queue\n            if (current.length === 0) {\n                var next = queue.shift();\n                if (next) {\n                    current.push(next);\n                }\n            }\n            var callbacks = function callbacks(_callbacks) {\n                for(var j = _callbacks.length - 1; j >= 0; j--){\n                    var cb = _callbacks[j];\n                    cb();\n                }\n                _callbacks.splice(0, _callbacks.length);\n            }; // step and remove if done\n            for(var i = current.length - 1; i >= 0; i--){\n                var ani = current[i];\n                var ani_p = ani._private;\n                if (ani_p.stopped) {\n                    current.splice(i, 1);\n                    ani_p.hooked = false;\n                    ani_p.playing = false;\n                    ani_p.started = false;\n                    callbacks(ani_p.frames);\n                    continue;\n                }\n                if (!ani_p.playing && !ani_p.applying) {\n                    continue;\n                } // an apply() while playing shouldn't do anything\n                if (ani_p.playing && ani_p.applying) {\n                    ani_p.applying = false;\n                }\n                if (!ani_p.started) {\n                    startAnimation(ele, ani, now);\n                }\n                step$1(ele, ani, now, isCore);\n                if (ani_p.applying) {\n                    ani_p.applying = false;\n                }\n                callbacks(ani_p.frames);\n                if (ani_p.step != null) {\n                    ani_p.step(now);\n                }\n                if (ani.completed()) {\n                    current.splice(i, 1);\n                    ani_p.hooked = false;\n                    ani_p.playing = false;\n                    ani_p.started = false;\n                    callbacks(ani_p.completes);\n                }\n                ranAnis = true;\n            }\n            if (!isCore && current.length === 0 && queue.length === 0) {\n                doneEles.push(ele);\n            }\n            return ranAnis;\n        } // stepElement\n        // handle all eles\n        var ranEleAni = false;\n        for(var e = 0; e < eles.length; e++){\n            var ele = eles[e];\n            var handledThisEle = stepOne(ele);\n            ranEleAni = ranEleAni || handledThisEle;\n        } // each element\n        var ranCoreAni = stepOne(cy, true); // notify renderer\n        if (ranEleAni || ranCoreAni) {\n            if (eles.length > 0) {\n                cy.notify(\"draw\", eles);\n            } else {\n                cy.notify(\"draw\");\n            }\n        } // remove elements from list of currently animating if its queues are empty\n        eles.unmerge(doneEles);\n        cy.emit(\"step\");\n    } // stepAll\n    var corefn$8 = {\n        // pull in animation functions\n        animate: define1.animate(),\n        animation: define1.animation(),\n        animated: define1.animated(),\n        clearQueue: define1.clearQueue(),\n        delay: define1.delay(),\n        delayAnimation: define1.delayAnimation(),\n        stop: define1.stop(),\n        addToAnimationPool: function addToAnimationPool(eles) {\n            var cy = this;\n            if (!cy.styleEnabled()) {\n                return;\n            } // save cycles when no style used\n            cy._private.aniEles.merge(eles);\n        },\n        stopAnimationLoop: function stopAnimationLoop() {\n            this._private.animationsRunning = false;\n        },\n        startAnimationLoop: function startAnimationLoop() {\n            var cy = this;\n            cy._private.animationsRunning = true;\n            if (!cy.styleEnabled()) {\n                return;\n            } // save cycles when no style used\n            // NB the animation loop will exec in headless environments if style enabled\n            // and explicit cy.destroy() is necessary to stop the loop\n            function headlessStep() {\n                if (!cy._private.animationsRunning) {\n                    return;\n                }\n                requestAnimationFrame(function animationStep(now) {\n                    stepAll(now, cy);\n                    headlessStep();\n                });\n            }\n            var renderer = cy.renderer();\n            if (renderer && renderer.beforeRender) {\n                // let the renderer schedule animations\n                renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n                    stepAll(now, cy);\n                }, renderer.beforeRenderPriorities.animations);\n            } else {\n                // manage the animation loop ourselves\n                headlessStep(); // first call\n            }\n        }\n    };\n    var emitterOptions = {\n        qualifierCompare: function qualifierCompare(selector1, selector2) {\n            if (selector1 == null || selector2 == null) {\n                return selector1 == null && selector2 == null;\n            } else {\n                return selector1.sameText(selector2);\n            }\n        },\n        eventMatches: function eventMatches(cy, listener, eventObj) {\n            var selector = listener.qualifier;\n            if (selector != null) {\n                return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n            }\n            return true;\n        },\n        addEventFields: function addEventFields(cy, evt) {\n            evt.cy = cy;\n            evt.target = cy;\n        },\n        callbackContext: function callbackContext(cy, listener, eventObj) {\n            return listener.qualifier != null ? eventObj.target : cy;\n        }\n    };\n    var argSelector = function argSelector(arg) {\n        if (string(arg)) {\n            return new Selector(arg);\n        } else {\n            return arg;\n        }\n    };\n    var elesfn = {\n        createEmitter: function createEmitter() {\n            var _p = this._private;\n            if (!_p.emitter) {\n                _p.emitter = new Emitter(emitterOptions, this);\n            }\n            return this;\n        },\n        emitter: function emitter() {\n            return this._private.emitter;\n        },\n        on: function on(events, selector, callback) {\n            this.emitter().on(events, argSelector(selector), callback);\n            return this;\n        },\n        removeListener: function removeListener(events, selector, callback) {\n            this.emitter().removeListener(events, argSelector(selector), callback);\n            return this;\n        },\n        removeAllListeners: function removeAllListeners() {\n            this.emitter().removeAllListeners();\n            return this;\n        },\n        one: function one(events, selector, callback) {\n            this.emitter().one(events, argSelector(selector), callback);\n            return this;\n        },\n        once: function once(events, selector, callback) {\n            this.emitter().one(events, argSelector(selector), callback);\n            return this;\n        },\n        emit: function emit(events, extraParams) {\n            this.emitter().emit(events, extraParams);\n            return this;\n        },\n        emitAndNotify: function emitAndNotify(event, eles) {\n            this.emit(event);\n            this.notify(event, eles);\n            return this;\n        }\n    };\n    define1.eventAliasesOn(elesfn);\n    var corefn$7 = {\n        png: function png(options) {\n            var renderer = this._private.renderer;\n            options = options || {};\n            return renderer.png(options);\n        },\n        jpg: function jpg(options) {\n            var renderer = this._private.renderer;\n            options = options || {};\n            options.bg = options.bg || \"#fff\";\n            return renderer.jpg(options);\n        }\n    };\n    corefn$7.jpeg = corefn$7.jpg;\n    var corefn$6 = {\n        layout: function layout(options) {\n            var cy = this;\n            if (options == null) {\n                error(\"Layout options must be specified to make a layout\");\n                return;\n            }\n            if (options.name == null) {\n                error(\"A `name` must be specified to make a layout\");\n                return;\n            }\n            var name = options.name;\n            var Layout = cy.extension(\"layout\", name);\n            if (Layout == null) {\n                error(\"No such layout `\" + name + \"` found.  Did you forget to import it and `cytoscape.use()` it?\");\n                return;\n            }\n            var eles;\n            if (string(options.eles)) {\n                eles = cy.$(options.eles);\n            } else {\n                eles = options.eles != null ? options.eles : cy.$();\n            }\n            var layout = new Layout(extend({}, options, {\n                cy: cy,\n                eles: eles\n            }));\n            return layout;\n        }\n    };\n    corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\n    var corefn$5 = {\n        notify: function notify(eventName, eventEles) {\n            var _p = this._private;\n            if (this.batching()) {\n                _p.batchNotifications = _p.batchNotifications || {};\n                var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n                if (eventEles != null) {\n                    eles.merge(eventEles);\n                }\n                return; // notifications are disabled during batching\n            }\n            if (!_p.notificationsEnabled) {\n                return;\n            } // exit on disabled\n            var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528\n            if (this.destroyed() || !renderer) {\n                return;\n            }\n            renderer.notify(eventName, eventEles);\n        },\n        notifications: function notifications(bool) {\n            var p = this._private;\n            if (bool === undefined) {\n                return p.notificationsEnabled;\n            } else {\n                p.notificationsEnabled = bool ? true : false;\n            }\n            return this;\n        },\n        noNotifications: function noNotifications(callback) {\n            this.notifications(false);\n            callback();\n            this.notifications(true);\n        },\n        batching: function batching() {\n            return this._private.batchCount > 0;\n        },\n        startBatch: function startBatch() {\n            var _p = this._private;\n            if (_p.batchCount == null) {\n                _p.batchCount = 0;\n            }\n            if (_p.batchCount === 0) {\n                _p.batchStyleEles = this.collection();\n                _p.batchNotifications = {};\n            }\n            _p.batchCount++;\n            return this;\n        },\n        endBatch: function endBatch() {\n            var _p = this._private;\n            if (_p.batchCount === 0) {\n                return this;\n            }\n            _p.batchCount--;\n            if (_p.batchCount === 0) {\n                // update style for dirty eles\n                _p.batchStyleEles.updateStyle();\n                var renderer = this.renderer(); // notify the renderer of queued eles and event types\n                Object.keys(_p.batchNotifications).forEach(function(eventName) {\n                    var eles = _p.batchNotifications[eventName];\n                    if (eles.empty()) {\n                        renderer.notify(eventName);\n                    } else {\n                        renderer.notify(eventName, eles);\n                    }\n                });\n            }\n            return this;\n        },\n        batch: function batch(callback) {\n            this.startBatch();\n            callback();\n            this.endBatch();\n            return this;\n        },\n        // for backwards compatibility\n        batchData: function batchData(map) {\n            var cy = this;\n            return this.batch(function() {\n                var ids = Object.keys(map);\n                for(var i = 0; i < ids.length; i++){\n                    var id = ids[i];\n                    var data = map[id];\n                    var ele = cy.getElementById(id);\n                    ele.data(data);\n                }\n            });\n        }\n    };\n    var rendererDefaults = defaults$g({\n        hideEdgesOnViewport: false,\n        textureOnViewport: false,\n        motionBlur: false,\n        motionBlurOpacity: 0.05,\n        pixelRatio: undefined,\n        desktopTapThreshold: 4,\n        touchTapThreshold: 8,\n        wheelSensitivity: 1,\n        debug: false,\n        showFps: false\n    });\n    var corefn$4 = {\n        renderTo: function renderTo(context, zoom, pan, pxRatio) {\n            var r = this._private.renderer;\n            r.renderTo(context, zoom, pan, pxRatio);\n            return this;\n        },\n        renderer: function renderer() {\n            return this._private.renderer;\n        },\n        forceRender: function forceRender() {\n            this.notify(\"draw\");\n            return this;\n        },\n        resize: function resize() {\n            this.invalidateSize();\n            this.emitAndNotify(\"resize\");\n            return this;\n        },\n        initRenderer: function initRenderer(options) {\n            var cy = this;\n            var RendererProto = cy.extension(\"renderer\", options.name);\n            if (RendererProto == null) {\n                error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n                return;\n            }\n            if (options.wheelSensitivity !== undefined) {\n                warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n            }\n            var rOpts = rendererDefaults(options);\n            rOpts.cy = cy;\n            cy._private.renderer = new RendererProto(rOpts);\n            this.notify(\"init\");\n        },\n        destroyRenderer: function destroyRenderer() {\n            var cy = this;\n            cy.notify(\"destroy\"); // destroy the renderer\n            var domEle = cy.container();\n            if (domEle) {\n                domEle._cyreg = null;\n                while(domEle.childNodes.length > 0){\n                    domEle.removeChild(domEle.childNodes[0]);\n                }\n            }\n            cy._private.renderer = null; // to be extra safe, remove the ref\n            cy.mutableElements().forEach(function(ele) {\n                var _p = ele._private;\n                _p.rscratch = {};\n                _p.rstyle = {};\n                _p.animation.current = [];\n                _p.animation.queue = [];\n            });\n        },\n        onRender: function onRender(fn) {\n            return this.on(\"render\", fn);\n        },\n        offRender: function offRender(fn) {\n            return this.off(\"render\", fn);\n        }\n    };\n    corefn$4.invalidateDimensions = corefn$4.resize;\n    var corefn$3 = {\n        // get a collection\n        // - empty collection on no args\n        // - collection of elements in the graph on selector arg\n        // - guarantee a returned collection when elements or collection specified\n        collection: function collection(eles, opts) {\n            if (string(eles)) {\n                return this.$(eles);\n            } else if (elementOrCollection(eles)) {\n                return eles.collection();\n            } else if (array(eles)) {\n                if (!opts) {\n                    opts = {};\n                }\n                return new Collection(this, eles, opts.unique, opts.removed);\n            }\n            return new Collection(this);\n        },\n        nodes: function nodes(selector) {\n            var nodes = this.$(function(ele) {\n                return ele.isNode();\n            });\n            if (selector) {\n                return nodes.filter(selector);\n            }\n            return nodes;\n        },\n        edges: function edges(selector) {\n            var edges = this.$(function(ele) {\n                return ele.isEdge();\n            });\n            if (selector) {\n                return edges.filter(selector);\n            }\n            return edges;\n        },\n        // search the graph like jQuery\n        $: function $(selector) {\n            var eles = this._private.elements;\n            if (selector) {\n                return eles.filter(selector);\n            } else {\n                return eles.spawnSelf();\n            }\n        },\n        mutableElements: function mutableElements() {\n            return this._private.elements;\n        }\n    }; // aliases\n    corefn$3.elements = corefn$3.filter = corefn$3.$;\n    var styfn$8 = {}; // keys for style blocks, e.g. ttfftt\n    var TRUE = \"t\";\n    var FALSE = \"f\"; // (potentially expensive calculation)\n    // apply the style to the element based on\n    // - its bypass\n    // - what selectors match it\n    styfn$8.apply = function(eles) {\n        var self1 = this;\n        var _p = self1._private;\n        var cy = _p.cy;\n        var updatedEles = cy.collection();\n        for(var ie = 0; ie < eles.length; ie++){\n            var ele = eles[ie];\n            var cxtMeta = self1.getContextMeta(ele);\n            if (cxtMeta.empty) {\n                continue;\n            }\n            var cxtStyle = self1.getContextStyle(cxtMeta);\n            var app = self1.applyContextStyle(cxtMeta, cxtStyle, ele);\n            if (ele._private.appliedInitStyle) {\n                self1.updateTransitions(ele, app.diffProps);\n            } else {\n                ele._private.appliedInitStyle = true;\n            }\n            var hintsDiff = self1.updateStyleHints(ele);\n            if (hintsDiff) {\n                updatedEles.push(ele);\n            }\n        } // for elements\n        return updatedEles;\n    };\n    styfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {\n        var self1 = this;\n        var cache = self1._private.propDiffs = self1._private.propDiffs || {};\n        var dualCxtKey = oldCxtKey + \"-\" + newCxtKey;\n        var cachedVal = cache[dualCxtKey];\n        if (cachedVal) {\n            return cachedVal;\n        }\n        var diffProps = [];\n        var addedProp = {};\n        for(var i = 0; i < self1.length; i++){\n            var cxt = self1[i];\n            var oldHasCxt = oldCxtKey[i] === TRUE;\n            var newHasCxt = newCxtKey[i] === TRUE;\n            var cxtHasDiffed = oldHasCxt !== newHasCxt;\n            var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n            if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n                var props = void 0;\n                if (cxtHasDiffed && cxtHasMappedProps) {\n                    props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n                } else if (cxtHasDiffed) {\n                    props = cxt.properties; // need to check them all\n                } else if (cxtHasMappedProps) {\n                    props = cxt.mappedProperties; // only need to check mapped\n                }\n                for(var j = 0; j < props.length; j++){\n                    var prop = props[j];\n                    var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n                    // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n                    // is cached)\n                    var laterCxtOverrides = false;\n                    for(var k = i + 1; k < self1.length; k++){\n                        var laterCxt = self1[k];\n                        var hasLaterCxt = newCxtKey[k] === TRUE;\n                        if (!hasLaterCxt) {\n                            continue;\n                        } // can't override unless the context is active\n                        laterCxtOverrides = laterCxt.properties[prop.name] != null;\n                        if (laterCxtOverrides) {\n                            break;\n                        } // exit early as long as one later context overrides\n                    }\n                    if (!addedProp[name] && !laterCxtOverrides) {\n                        addedProp[name] = true;\n                        diffProps.push(name);\n                    }\n                } // for props\n            } // if\n        } // for contexts\n        cache[dualCxtKey] = diffProps;\n        return diffProps;\n    };\n    styfn$8.getContextMeta = function(ele) {\n        var self1 = this;\n        var cxtKey = \"\";\n        var diffProps;\n        var prevKey = ele._private.styleCxtKey || \"\"; // get the cxt key\n        for(var i = 0; i < self1.length; i++){\n            var context = self1[i];\n            var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n            if (contextSelectorMatches) {\n                cxtKey += TRUE;\n            } else {\n                cxtKey += FALSE;\n            }\n        } // for context\n        diffProps = self1.getPropertiesDiff(prevKey, cxtKey);\n        ele._private.styleCxtKey = cxtKey;\n        return {\n            key: cxtKey,\n            diffPropNames: diffProps,\n            empty: diffProps.length === 0\n        };\n    }; // gets a computed ele style object based on matched contexts\n    styfn$8.getContextStyle = function(cxtMeta) {\n        var cxtKey = cxtMeta.key;\n        var self1 = this;\n        var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy\n        if (cxtStyles[cxtKey]) {\n            return cxtStyles[cxtKey];\n        }\n        var style = {\n            _private: {\n                key: cxtKey\n            }\n        };\n        for(var i = 0; i < self1.length; i++){\n            var cxt = self1[i];\n            var hasCxt = cxtKey[i] === TRUE;\n            if (!hasCxt) {\n                continue;\n            }\n            for(var j = 0; j < cxt.properties.length; j++){\n                var prop = cxt.properties[j];\n                style[prop.name] = prop;\n            }\n        }\n        cxtStyles[cxtKey] = style;\n        return style;\n    };\n    styfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {\n        var self1 = this;\n        var diffProps = cxtMeta.diffPropNames;\n        var retDiffProps = {};\n        var types = self1.types;\n        for(var i = 0; i < diffProps.length; i++){\n            var diffPropName = diffProps[i];\n            var cxtProp = cxtStyle[diffPropName];\n            var eleProp = ele.pstyle(diffPropName);\n            if (!cxtProp) {\n                // no context prop means delete\n                if (!eleProp) {\n                    continue; // no existing prop means nothing needs to be removed\n                // nb affects initial application on mapped values like control-point-distances\n                } else if (eleProp.bypass) {\n                    cxtProp = {\n                        name: diffPropName,\n                        deleteBypassed: true\n                    };\n                } else {\n                    cxtProp = {\n                        name: diffPropName,\n                        \"delete\": true\n                    };\n                }\n            } // save cycles when the context prop doesn't need to be applied\n            if (eleProp === cxtProp) {\n                continue;\n            } // save cycles when a mapped context prop doesn't need to be applied\n            if (cxtProp.mapped === types.fn // context prop is function mapper\n             && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n             && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n             && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n            ) {\n                // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n                var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n                var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n                if (fnValue === mapping.prevFnValue) {\n                    continue;\n                }\n            }\n            var retDiffProp = retDiffProps[diffPropName] = {\n                prev: eleProp\n            };\n            self1.applyParsedProperty(ele, cxtProp);\n            retDiffProp.next = ele.pstyle(diffPropName);\n            if (retDiffProp.next && retDiffProp.next.bypass) {\n                retDiffProp.next = retDiffProp.next.bypassed;\n            }\n        }\n        return {\n            diffProps: retDiffProps\n        };\n    };\n    styfn$8.updateStyleHints = function(ele) {\n        var _p = ele._private;\n        var self1 = this;\n        var propNames = self1.propertyGroupNames;\n        var propGrKeys = self1.propertyGroupKeys;\n        var propHash = function propHash(ele, propNames, seedKey) {\n            return self1.getPropertiesHash(ele, propNames, seedKey);\n        };\n        var oldStyleKey = _p.styleKey;\n        if (ele.removed()) {\n            return false;\n        }\n        var isNode = _p.group === \"nodes\"; // get the style key hashes per prop group\n        // but lazily -- only use non-default prop values to reduce the number of hashes\n        //\n        var overriddenStyles = ele._private.style;\n        propNames = Object.keys(overriddenStyles);\n        for(var i = 0; i < propGrKeys.length; i++){\n            var grKey = propGrKeys[i];\n            _p.styleKeys[grKey] = [\n                DEFAULT_HASH_SEED,\n                DEFAULT_HASH_SEED_ALT\n            ];\n        }\n        var updateGrKey1 = function updateGrKey1(val, grKey) {\n            return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n        };\n        var updateGrKey2 = function updateGrKey2(val, grKey) {\n            return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n        };\n        var updateGrKey = function updateGrKey(val, grKey) {\n            updateGrKey1(val, grKey);\n            updateGrKey2(val, grKey);\n        };\n        var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n            for(var j = 0; j < strVal.length; j++){\n                var ch = strVal.charCodeAt(j);\n                updateGrKey1(ch, grKey);\n                updateGrKey2(ch, grKey);\n            }\n        }; // - hashing works on 32 bit ints b/c we use bitwise ops\n        // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n        // - raise up small numbers so more significant digits are seen by hashing\n        // - make small numbers larger than a normal value to avoid collisions\n        // - works in practice and it's relatively cheap\n        var N = 2000000000;\n        var cleanNum = function cleanNum(val) {\n            return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n        };\n        for(var _i = 0; _i < propNames.length; _i++){\n            var name = propNames[_i];\n            var parsedProp = overriddenStyles[name];\n            if (parsedProp == null) {\n                continue;\n            }\n            var propInfo = this.properties[name];\n            var type = propInfo.type;\n            var _grKey = propInfo.groupKey;\n            var normalizedNumberVal = void 0;\n            if (propInfo.hashOverride != null) {\n                normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n            } else if (parsedProp.pfValue != null) {\n                normalizedNumberVal = parsedProp.pfValue;\n            } // might not be a number if it allows enums\n            var numberVal = propInfo.enums == null ? parsedProp.value : null;\n            var haveNormNum = normalizedNumberVal != null;\n            var haveUnitedNum = numberVal != null;\n            var haveNum = haveNormNum || haveUnitedNum;\n            var units = parsedProp.units; // numbers are cheaper to hash than strings\n            // 1 hash op vs n hash ops (for length n string)\n            if (type.number && haveNum && !type.multiple) {\n                var v = haveNormNum ? normalizedNumberVal : numberVal;\n                updateGrKey(cleanNum(v), _grKey);\n                if (!haveNormNum && units != null) {\n                    updateGrKeyWStr(units, _grKey);\n                }\n            } else {\n                updateGrKeyWStr(parsedProp.strValue, _grKey);\n            }\n        } // overall style key\n        //\n        var hash = [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ];\n        for(var _i2 = 0; _i2 < propGrKeys.length; _i2++){\n            var _grKey2 = propGrKeys[_i2];\n            var grHash = _p.styleKeys[_grKey2];\n            hash[0] = hashInt(grHash[0], hash[0]);\n            hash[1] = hashIntAlt(grHash[1], hash[1]);\n        }\n        _p.styleKey = combineHashes(hash[0], hash[1]); // label dims\n        //\n        var sk = _p.styleKeys;\n        _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n        var labelKeys = propHash(ele, [\n            \"label\"\n        ], sk.labelDimensions);\n        _p.labelKey = combineHashesArray(labelKeys);\n        _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n        if (!isNode) {\n            var sourceLabelKeys = propHash(ele, [\n                \"source-label\"\n            ], sk.labelDimensions);\n            _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n            _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n            var targetLabelKeys = propHash(ele, [\n                \"target-label\"\n            ], sk.labelDimensions);\n            _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n            _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n        } // node\n        //\n        if (isNode) {\n            var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie;\n            var nodeKeys = [\n                nodeBody,\n                nodeBorder,\n                backgroundImage,\n                compound,\n                pie\n            ].filter(function(k) {\n                return k != null;\n            }).reduce(hashArrays, [\n                DEFAULT_HASH_SEED,\n                DEFAULT_HASH_SEED_ALT\n            ]);\n            _p.nodeKey = combineHashesArray(nodeKeys);\n            _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n        }\n        return oldStyleKey !== _p.styleKey;\n    };\n    styfn$8.clearStyleHints = function(ele) {\n        var _p = ele._private;\n        _p.styleCxtKey = \"\";\n        _p.styleKeys = {};\n        _p.styleKey = null;\n        _p.labelKey = null;\n        _p.labelStyleKey = null;\n        _p.sourceLabelKey = null;\n        _p.sourceLabelStyleKey = null;\n        _p.targetLabelKey = null;\n        _p.targetLabelStyleKey = null;\n        _p.nodeKey = null;\n        _p.hasPie = null;\n    }; // apply a property to the style (for internal use)\n    // returns whether application was successful\n    //\n    // now, this function flattens the property, and here's how:\n    //\n    // for parsedProp:{ bypass: true, deleteBypass: true }\n    // no property is generated, instead the bypass property in the\n    // element's style is replaced by what's pointed to by the `bypassed`\n    // field in the bypass property (i.e. restoring the property the\n    // bypass was overriding)\n    //\n    // for parsedProp:{ mapped: truthy }\n    // the generated flattenedProp:{ mapping: prop }\n    //\n    // for parsedProp:{ bypass: true }\n    // the generated flattenedProp:{ bypassed: parsedProp }\n    styfn$8.applyParsedProperty = function(ele, parsedProp) {\n        var self1 = this;\n        var prop = parsedProp;\n        var style = ele._private.style;\n        var flatProp;\n        var types = self1.types;\n        var type = self1.properties[prop.name].type;\n        var propIsBypass = prop.bypass;\n        var origProp = style[prop.name];\n        var origPropIsBypass = origProp && origProp.bypass;\n        var _p = ele._private;\n        var flatPropMapping = \"mapping\";\n        var getVal = function getVal(p) {\n            if (p == null) {\n                return null;\n            } else if (p.pfValue != null) {\n                return p.pfValue;\n            } else {\n                return p.value;\n            }\n        };\n        var checkTriggers = function checkTriggers() {\n            var fromVal = getVal(origProp);\n            var toVal = getVal(prop);\n            self1.checkTriggers(ele, prop.name, fromVal, toVal);\n        };\n        if (prop && prop.name.substr(0, 3) === \"pie\") {\n            warn(\"The pie style properties are deprecated.  Create charts using background images instead.\");\n        } // edge sanity checks to prevent the client from making serious mistakes\n        if (parsedProp.name === \"curve-style\" && ele.isEdge() && (parsedProp.value !== \"bezier\" && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n        parsedProp.value === \"haystack\" && (ele.source().isParent() || ele.target().isParent()))) {\n            prop = parsedProp = this.parse(parsedProp.name, \"bezier\", propIsBypass);\n        }\n        if (prop[\"delete\"]) {\n            // delete the property and use the default value on falsey value\n            style[prop.name] = undefined;\n            checkTriggers();\n            return true;\n        }\n        if (prop.deleteBypassed) {\n            // delete the property that the\n            if (!origProp) {\n                checkTriggers();\n                return true; // can't delete if no prop\n            } else if (origProp.bypass) {\n                // delete bypassed\n                origProp.bypassed = undefined;\n                checkTriggers();\n                return true;\n            } else {\n                return false; // we're unsuccessful deleting the bypassed\n            }\n        } // check if we need to delete the current bypass\n        if (prop.deleteBypass) {\n            // then this property is just here to indicate we need to delete\n            if (!origProp) {\n                checkTriggers();\n                return true; // property is already not defined\n            } else if (origProp.bypass) {\n                // then replace the bypass property with the original\n                // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n                style[prop.name] = origProp.bypassed;\n                checkTriggers();\n                return true;\n            } else {\n                return false; // we're unsuccessful deleting the bypass\n            }\n        }\n        var printMappingErr = function printMappingErr() {\n            warn(\"Do not assign mappings to elements without corresponding data (i.e. ele `\" + ele.id() + \"` has no mapping for property `\" + prop.name + \"` with data field `\" + prop.field + \"`); try a `[\" + prop.field + \"]` selector to limit scope to elements with `\" + prop.field + \"` defined\");\n        }; // put the property in the style objects\n        switch(prop.mapped){\n            // flatten the property if mapped\n            case types.mapData:\n                {\n                    // flatten the field (e.g. data.foo.bar)\n                    var fields = prop.field.split(\".\");\n                    var fieldVal = _p.data;\n                    for(var i = 0; i < fields.length && fieldVal; i++){\n                        var field = fields[i];\n                        fieldVal = fieldVal[field];\n                    }\n                    if (fieldVal == null) {\n                        printMappingErr();\n                        return false;\n                    }\n                    var percent;\n                    if (!number$1(fieldVal)) {\n                        // then don't apply and fall back on the existing style\n                        warn(\"Do not use continuous mappers without specifying numeric data (i.e. `\" + prop.field + \": \" + fieldVal + \"` for `\" + ele.id() + \"` is non-numeric)\");\n                        return false;\n                    } else {\n                        var fieldWidth = prop.fieldMax - prop.fieldMin;\n                        if (fieldWidth === 0) {\n                            // safety check -- not strictly necessary as no props of zero range should be passed here\n                            percent = 0;\n                        } else {\n                            percent = (fieldVal - prop.fieldMin) / fieldWidth;\n                        }\n                    } // make sure to bound percent value\n                    if (percent < 0) {\n                        percent = 0;\n                    } else if (percent > 1) {\n                        percent = 1;\n                    }\n                    if (type.color) {\n                        var r1 = prop.valueMin[0];\n                        var r2 = prop.valueMax[0];\n                        var g1 = prop.valueMin[1];\n                        var g2 = prop.valueMax[1];\n                        var b1 = prop.valueMin[2];\n                        var b2 = prop.valueMax[2];\n                        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n                        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n                        var clr = [\n                            Math.round(r1 + (r2 - r1) * percent),\n                            Math.round(g1 + (g2 - g1) * percent),\n                            Math.round(b1 + (b2 - b1) * percent),\n                            Math.round(a1 + (a2 - a1) * percent)\n                        ];\n                        flatProp = {\n                            // colours are simple, so just create the flat property instead of expensive string parsing\n                            bypass: prop.bypass,\n                            // we're a bypass if the mapping property is a bypass\n                            name: prop.name,\n                            value: clr,\n                            strValue: \"rgb(\" + clr[0] + \", \" + clr[1] + \", \" + clr[2] + \")\"\n                        };\n                    } else if (type.number) {\n                        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n                        flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n                    } else {\n                        return false; // can only map to colours and numbers\n                    }\n                    if (!flatProp) {\n                        // if we can't flatten the property, then don't apply the property and fall back on the existing style\n                        printMappingErr();\n                        return false;\n                    }\n                    flatProp.mapping = prop; // keep a reference to the mapping\n                    prop = flatProp; // the flattened (mapped) property is the one we want\n                    break;\n                }\n            // direct mapping\n            case types.data:\n                {\n                    // flatten the field (e.g. data.foo.bar)\n                    var _fields = prop.field.split(\".\");\n                    var _fieldVal = _p.data;\n                    for(var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++){\n                        var _field = _fields[_i3];\n                        _fieldVal = _fieldVal[_field];\n                    }\n                    if (_fieldVal != null) {\n                        flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n                    }\n                    if (!flatProp) {\n                        // if we can't flatten the property, then don't apply and fall back on the existing style\n                        printMappingErr();\n                        return false;\n                    }\n                    flatProp.mapping = prop; // keep a reference to the mapping\n                    prop = flatProp; // the flattened (mapped) property is the one we want\n                    break;\n                }\n            case types.fn:\n                {\n                    var fn = prop.value;\n                    var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n                    prop.prevFnValue = fnRetVal;\n                    if (fnRetVal == null) {\n                        warn(\"Custom function mappers may not return null (i.e. `\" + prop.name + \"` for ele `\" + ele.id() + \"` is null)\");\n                        return false;\n                    }\n                    flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n                    if (!flatProp) {\n                        warn(\"Custom function mappers may not return invalid values for the property type (i.e. `\" + prop.name + \"` for ele `\" + ele.id() + \"` is invalid)\");\n                        return false;\n                    }\n                    flatProp.mapping = copy(prop); // keep a reference to the mapping\n                    prop = flatProp; // the flattened (mapped) property is the one we want\n                    break;\n                }\n            case undefined:\n                break;\n            // just set the property\n            default:\n                return false;\n        } // if the property is a bypass property, then link the resultant property to the original one\n        if (propIsBypass) {\n            if (origPropIsBypass) {\n                // then this bypass overrides the existing one\n                prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n            } else {\n                // then link the orig prop to the new bypass\n                prop.bypassed = origProp;\n            }\n            style[prop.name] = prop; // and set\n        } else {\n            // prop is not bypass\n            if (origPropIsBypass) {\n                // then keep the orig prop (since it's a bypass) and link to the new prop\n                origProp.bypassed = prop;\n            } else {\n                // then just replace the old prop with the new one\n                style[prop.name] = prop;\n            }\n        }\n        checkTriggers();\n        return true;\n    };\n    styfn$8.cleanElements = function(eles, keepBypasses) {\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            this.clearStyleHints(ele);\n            ele.dirtyCompoundBoundsCache();\n            ele.dirtyBoundingBoxCache();\n            if (!keepBypasses) {\n                ele._private.style = {};\n            } else {\n                var style = ele._private.style;\n                var propNames = Object.keys(style);\n                for(var j = 0; j < propNames.length; j++){\n                    var propName = propNames[j];\n                    var eleProp = style[propName];\n                    if (eleProp != null) {\n                        if (eleProp.bypass) {\n                            eleProp.bypassed = null;\n                        } else {\n                            style[propName] = null;\n                        }\n                    }\n                }\n            }\n        }\n    }; // updates the visual style for all elements (useful for manual style modification after init)\n    styfn$8.update = function() {\n        var cy = this._private.cy;\n        var eles = cy.mutableElements();\n        eles.updateStyle();\n    }; // diffProps : { name => { prev, next } }\n    styfn$8.updateTransitions = function(ele, diffProps) {\n        var self1 = this;\n        var _p = ele._private;\n        var props = ele.pstyle(\"transition-property\").value;\n        var duration = ele.pstyle(\"transition-duration\").pfValue;\n        var delay = ele.pstyle(\"transition-delay\").pfValue;\n        if (props.length > 0 && duration > 0) {\n            var style = {}; // build up the style to animate towards\n            var anyPrev = false;\n            for(var i = 0; i < props.length; i++){\n                var prop = props[i];\n                var styProp = ele.pstyle(prop);\n                var diffProp = diffProps[prop];\n                if (!diffProp) {\n                    continue;\n                }\n                var prevProp = diffProp.prev;\n                var fromProp = prevProp;\n                var toProp = diffProp.next != null ? diffProp.next : styProp;\n                var diff = false;\n                var initVal = void 0;\n                var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n                if (!fromProp) {\n                    continue;\n                } // consider px values\n                if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n                    diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n                    initVal = fromProp.pfValue + initDt * diff; // consider numerical values\n                } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n                    diff = toProp.value - fromProp.value; // nonzero is truthy\n                    initVal = fromProp.value + initDt * diff; // consider colour values\n                } else if (array(fromProp.value) && array(toProp.value)) {\n                    diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n                    initVal = fromProp.strValue;\n                } // the previous value is good for an animation only if it's different\n                if (diff) {\n                    style[prop] = toProp.strValue; // to val\n                    this.applyBypass(ele, prop, initVal); // from val\n                    anyPrev = true;\n                }\n            } // end if props allow ani\n            // can't transition if there's nothing previous to transition from\n            if (!anyPrev) {\n                return;\n            }\n            _p.transitioning = true;\n            new Promise$1(function(resolve) {\n                if (delay > 0) {\n                    ele.delayAnimation(delay).play().promise().then(resolve);\n                } else {\n                    resolve();\n                }\n            }).then(function() {\n                return ele.animation({\n                    style: style,\n                    duration: duration,\n                    easing: ele.pstyle(\"transition-timing-function\").value,\n                    queue: false\n                }).play().promise();\n            }).then(function() {\n                // if( !isBypass ){\n                self1.removeBypasses(ele, props);\n                ele.emitAndNotify(\"style\"); // }\n                _p.transitioning = false;\n            });\n        } else if (_p.transitioning) {\n            this.removeBypasses(ele, props);\n            ele.emitAndNotify(\"style\");\n            _p.transitioning = false;\n        }\n    };\n    styfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {\n        var prop = this.properties[name];\n        var triggerCheck = getTrigger(prop);\n        if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n            onTrigger(prop);\n        }\n    };\n    styfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {\n        var _this = this;\n        this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n            return prop.triggersZOrder;\n        }, function() {\n            _this._private.cy.notify(\"zorder\", ele);\n        });\n    };\n    styfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {\n        this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n            return prop.triggersBounds;\n        }, function(prop) {\n            ele.dirtyCompoundBoundsCache();\n            ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,\n            // then dirty the pll edge bb cache as well\n            if (prop.triggersBoundsOfParallelBeziers && (name === \"curve-style\" && (fromValue === \"bezier\" || toValue === \"bezier\") || name === \"display\" && (fromValue === \"none\" || toValue === \"none\"))) {\n                ele.parallelEdges().forEach(function(pllEdge) {\n                    if (pllEdge.isBundledBezier()) {\n                        pllEdge.dirtyBoundingBoxCache();\n                    }\n                });\n            }\n        });\n    };\n    styfn$8.checkTriggers = function(ele, name, fromValue, toValue) {\n        ele.dirtyStyleCache();\n        this.checkZOrderTrigger(ele, name, fromValue, toValue);\n        this.checkBoundsTrigger(ele, name, fromValue, toValue);\n    };\n    var styfn$7 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily\n    // returns true iff application was successful for at least 1 specified property\n    styfn$7.applyBypass = function(eles, name, value, updateTransitions) {\n        var self1 = this;\n        var props = [];\n        var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them\n        if (name === \"*\" || name === \"**\") {\n            // apply to all property names\n            if (value !== undefined) {\n                for(var i = 0; i < self1.properties.length; i++){\n                    var prop = self1.properties[i];\n                    var _name = prop.name;\n                    var parsedProp = this.parse(_name, value, true);\n                    if (parsedProp) {\n                        props.push(parsedProp);\n                    }\n                }\n            }\n        } else if (string(name)) {\n            // then parse the single property\n            var _parsedProp = this.parse(name, value, true);\n            if (_parsedProp) {\n                props.push(_parsedProp);\n            }\n        } else if (plainObject(name)) {\n            // then parse each property\n            var specifiedProps = name;\n            updateTransitions = value;\n            var names = Object.keys(specifiedProps);\n            for(var _i = 0; _i < names.length; _i++){\n                var _name2 = names[_i];\n                var _value = specifiedProps[_name2];\n                if (_value === undefined) {\n                    // try camel case name too\n                    _value = specifiedProps[dash2camel(_name2)];\n                }\n                if (_value !== undefined) {\n                    var _parsedProp2 = this.parse(_name2, _value, true);\n                    if (_parsedProp2) {\n                        props.push(_parsedProp2);\n                    }\n                }\n            }\n        } else {\n            // can't do anything without well defined properties\n            return false;\n        } // we've failed if there are no valid properties\n        if (props.length === 0) {\n            return false;\n        } // now, apply the bypass properties on the elements\n        var ret = false; // return true if at least one succesful bypass applied\n        for(var _i2 = 0; _i2 < eles.length; _i2++){\n            // for each ele\n            var ele = eles[_i2];\n            var diffProps = {};\n            var diffProp = void 0;\n            for(var j = 0; j < props.length; j++){\n                // for each prop\n                var _prop = props[j];\n                if (updateTransitions) {\n                    var prevProp = ele.pstyle(_prop.name);\n                    diffProp = diffProps[_prop.name] = {\n                        prev: prevProp\n                    };\n                }\n                ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n                if (updateTransitions) {\n                    diffProp.next = ele.pstyle(_prop.name);\n                }\n            } // for props\n            if (ret) {\n                this.updateStyleHints(ele);\n            }\n            if (updateTransitions) {\n                this.updateTransitions(ele, diffProps, isBypass);\n            }\n        } // for eles\n        return ret;\n    }; // only useful in specific cases like animation\n    styfn$7.overrideBypass = function(eles, name, value) {\n        name = camel2dash(name);\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var prop = ele._private.style[name];\n            var type = this.properties[name].type;\n            var isColor = type.color;\n            var isMulti = type.mutiple;\n            var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n            if (!prop || !prop.bypass) {\n                // need a bypass if one doesn't exist\n                this.applyBypass(ele, name, value);\n            } else {\n                prop.value = value;\n                if (prop.pfValue != null) {\n                    prop.pfValue = value;\n                }\n                if (isColor) {\n                    prop.strValue = \"rgb(\" + value.join(\",\") + \")\";\n                } else if (isMulti) {\n                    prop.strValue = value.join(\" \");\n                } else {\n                    prop.strValue = \"\" + value;\n                }\n                this.updateStyleHints(ele);\n            }\n            this.checkTriggers(ele, name, oldValue, value);\n        }\n    };\n    styfn$7.removeAllBypasses = function(eles, updateTransitions) {\n        return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n    };\n    styfn$7.removeBypasses = function(eles, props, updateTransitions) {\n        var isBypass = true;\n        for(var j = 0; j < eles.length; j++){\n            var ele = eles[j];\n            var diffProps = {};\n            for(var i = 0; i < props.length; i++){\n                var name = props[i];\n                var prop = this.properties[name];\n                var prevProp = ele.pstyle(prop.name);\n                if (!prevProp || !prevProp.bypass) {\n                    continue;\n                }\n                var value = \"\"; // empty => remove bypass\n                var parsedProp = this.parse(name, value, true);\n                var diffProp = diffProps[prop.name] = {\n                    prev: prevProp\n                };\n                this.applyParsedProperty(ele, parsedProp);\n                diffProp.next = ele.pstyle(prop.name);\n            } // for props\n            this.updateStyleHints(ele);\n            if (updateTransitions) {\n                this.updateTransitions(ele, diffProps, isBypass);\n            }\n        } // for eles\n    };\n    var styfn$6 = {}; // gets what an em size corresponds to in pixels relative to a dom element\n    styfn$6.getEmSizeInPixels = function() {\n        var px = this.containerCss(\"font-size\");\n        if (px != null) {\n            return parseFloat(px);\n        } else {\n            return 1; // for headless\n        }\n    }; // gets css property from the core container\n    styfn$6.containerCss = function(propName) {\n        var cy = this._private.cy;\n        var domElement = cy.container();\n        if (window$1 && domElement && window$1.getComputedStyle) {\n            return window$1.getComputedStyle(domElement).getPropertyValue(propName);\n        }\n    };\n    var styfn$5 = {}; // gets the rendered style for an element\n    styfn$5.getRenderedStyle = function(ele, prop) {\n        if (prop) {\n            return this.getStylePropertyValue(ele, prop, true);\n        } else {\n            return this.getRawStyle(ele, true);\n        }\n    }; // gets the raw style for an element\n    styfn$5.getRawStyle = function(ele, isRenderedVal) {\n        var self1 = this;\n        ele = ele[0]; // insure it's an element\n        if (ele) {\n            var rstyle = {};\n            for(var i = 0; i < self1.properties.length; i++){\n                var prop = self1.properties[i];\n                var val = self1.getStylePropertyValue(ele, prop.name, isRenderedVal);\n                if (val != null) {\n                    rstyle[prop.name] = val;\n                    rstyle[dash2camel(prop.name)] = val;\n                }\n            }\n            return rstyle;\n        }\n    };\n    styfn$5.getIndexedStyle = function(ele, property, subproperty, index) {\n        var pstyle = ele.pstyle(property)[subproperty][index];\n        return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n    };\n    styfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {\n        var self1 = this;\n        ele = ele[0]; // insure it's an element\n        if (ele) {\n            var prop = self1.properties[propName];\n            if (prop.alias) {\n                prop = prop.pointsTo;\n            }\n            var type = prop.type;\n            var styleProp = ele.pstyle(prop.name);\n            if (styleProp) {\n                var value = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;\n                if (isRenderedVal && type.number && value != null && number$1(value)) {\n                    var zoom = ele.cy().zoom();\n                    var getRenderedValue = function getRenderedValue(val) {\n                        return val * zoom;\n                    };\n                    var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n                        return getRenderedValue(val) + units;\n                    };\n                    var isArrayValue = array(value);\n                    var haveUnits = isArrayValue ? units.every(function(u) {\n                        return u != null;\n                    }) : units != null;\n                    if (haveUnits) {\n                        if (isArrayValue) {\n                            return value.map(function(v, i) {\n                                return getValueStringWithUnits(v, units[i]);\n                            }).join(\" \");\n                        } else {\n                            return getValueStringWithUnits(value, units);\n                        }\n                    } else {\n                        if (isArrayValue) {\n                            return value.map(function(v) {\n                                return string(v) ? v : \"\" + getRenderedValue(v);\n                            }).join(\" \");\n                        } else {\n                            return \"\" + getRenderedValue(value);\n                        }\n                    }\n                } else if (strValue != null) {\n                    return strValue;\n                }\n            }\n            return null;\n        }\n    };\n    styfn$5.getAnimationStartStyle = function(ele, aniProps) {\n        var rstyle = {};\n        for(var i = 0; i < aniProps.length; i++){\n            var aniProp = aniProps[i];\n            var name = aniProp.name;\n            var styleProp = ele.pstyle(name);\n            if (styleProp !== undefined) {\n                // then make a prop of it\n                if (plainObject(styleProp)) {\n                    styleProp = this.parse(name, styleProp.strValue);\n                } else {\n                    styleProp = this.parse(name, styleProp);\n                }\n            }\n            if (styleProp) {\n                rstyle[name] = styleProp;\n            }\n        }\n        return rstyle;\n    };\n    styfn$5.getPropsList = function(propsObj) {\n        var self1 = this;\n        var rstyle = [];\n        var style = propsObj;\n        var props = self1.properties;\n        if (style) {\n            var names = Object.keys(style);\n            for(var i = 0; i < names.length; i++){\n                var name = names[i];\n                var val = style[name];\n                var prop = props[name] || props[camel2dash(name)];\n                var styleProp = this.parse(prop.name, val);\n                if (styleProp) {\n                    rstyle.push(styleProp);\n                }\n            }\n        }\n        return rstyle;\n    };\n    styfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {\n        var hash = seed.slice();\n        var name, val, strVal, chVal;\n        var i, j;\n        for(i = 0; i < propNames.length; i++){\n            name = propNames[i];\n            val = ele.pstyle(name, false);\n            if (val == null) {\n                continue;\n            } else if (val.pfValue != null) {\n                hash[0] = hashInt(chVal, hash[0]);\n                hash[1] = hashIntAlt(chVal, hash[1]);\n            } else {\n                strVal = val.strValue;\n                for(j = 0; j < strVal.length; j++){\n                    chVal = strVal.charCodeAt(j);\n                    hash[0] = hashInt(chVal, hash[0]);\n                    hash[1] = hashIntAlt(chVal, hash[1]);\n                }\n            }\n        }\n        return hash;\n    };\n    styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\n    var styfn$4 = {};\n    styfn$4.appendFromJson = function(json) {\n        var style = this;\n        for(var i = 0; i < json.length; i++){\n            var context = json[i];\n            var selector = context.selector;\n            var props = context.style || context.css;\n            var names = Object.keys(props);\n            style.selector(selector); // apply selector\n            for(var j = 0; j < names.length; j++){\n                var name = names[j];\n                var value = props[name];\n                style.css(name, value); // apply property\n            }\n        }\n        return style;\n    }; // accessible cy.style() function\n    styfn$4.fromJson = function(json) {\n        var style = this;\n        style.resetToDefault();\n        style.appendFromJson(json);\n        return style;\n    }; // get json from cy.style() api\n    styfn$4.json = function() {\n        var json = [];\n        for(var i = this.defaultLength; i < this.length; i++){\n            var cxt = this[i];\n            var selector = cxt.selector;\n            var props = cxt.properties;\n            var css = {};\n            for(var j = 0; j < props.length; j++){\n                var prop = props[j];\n                css[prop.name] = prop.strValue;\n            }\n            json.push({\n                selector: !selector ? \"core\" : selector.toString(),\n                style: css\n            });\n        }\n        return json;\n    };\n    var styfn$3 = {};\n    styfn$3.appendFromString = function(string) {\n        var self1 = this;\n        var style = this;\n        var remaining = \"\" + string;\n        var selAndBlockStr;\n        var blockRem;\n        var propAndValStr; // remove comments from the style string\n        remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, \"\");\n        function removeSelAndBlockFromRemaining() {\n            // remove the parsed selector and block from the remaining text to parse\n            if (remaining.length > selAndBlockStr.length) {\n                remaining = remaining.substr(selAndBlockStr.length);\n            } else {\n                remaining = \"\";\n            }\n        }\n        function removePropAndValFromRem() {\n            // remove the parsed property and value from the remaining block text to parse\n            if (blockRem.length > propAndValStr.length) {\n                blockRem = blockRem.substr(propAndValStr.length);\n            } else {\n                blockRem = \"\";\n            }\n        }\n        for(;;){\n            var nothingLeftToParse = remaining.match(/^\\s*$/);\n            if (nothingLeftToParse) {\n                break;\n            }\n            var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n            if (!selAndBlock) {\n                warn(\"Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: \" + remaining);\n                break;\n            }\n            selAndBlockStr = selAndBlock[0]; // parse the selector\n            var selectorStr = selAndBlock[1];\n            if (selectorStr !== \"core\") {\n                var selector = new Selector(selectorStr);\n                if (selector.invalid) {\n                    warn(\"Skipping parsing of block: Invalid selector found in string stylesheet: \" + selectorStr); // skip this selector and block\n                    removeSelAndBlockFromRemaining();\n                    continue;\n                }\n            } // parse the block of properties and values\n            var blockStr = selAndBlock[2];\n            var invalidBlock = false;\n            blockRem = blockStr;\n            var props = [];\n            for(;;){\n                var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n                if (_nothingLeftToParse) {\n                    break;\n                }\n                var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n                if (!propAndVal) {\n                    warn(\"Skipping parsing of block: Invalid formatting of style property and value definitions found in:\" + blockStr);\n                    invalidBlock = true;\n                    break;\n                }\n                propAndValStr = propAndVal[0];\n                var propStr = propAndVal[1];\n                var valStr = propAndVal[2];\n                var prop = self1.properties[propStr];\n                if (!prop) {\n                    warn(\"Skipping property: Invalid property name in: \" + propAndValStr); // skip this property in the block\n                    removePropAndValFromRem();\n                    continue;\n                }\n                var parsedProp = style.parse(propStr, valStr);\n                if (!parsedProp) {\n                    warn(\"Skipping property: Invalid property definition in: \" + propAndValStr); // skip this property in the block\n                    removePropAndValFromRem();\n                    continue;\n                }\n                props.push({\n                    name: propStr,\n                    val: valStr\n                });\n                removePropAndValFromRem();\n            }\n            if (invalidBlock) {\n                removeSelAndBlockFromRemaining();\n                break;\n            } // put the parsed block in the style\n            style.selector(selectorStr);\n            for(var i = 0; i < props.length; i++){\n                var _prop = props[i];\n                style.css(_prop.name, _prop.val);\n            }\n            removeSelAndBlockFromRemaining();\n        }\n        return style;\n    };\n    styfn$3.fromString = function(string) {\n        var style = this;\n        style.resetToDefault();\n        style.appendFromString(string);\n        return style;\n    };\n    var styfn$2 = {};\n    (function() {\n        var number$1 = number;\n        var rgba = rgbaNoBackRefs;\n        var hsla = hslaNoBackRefs;\n        var hex3$1 = hex3;\n        var hex6$1 = hex6;\n        var data = function data(prefix) {\n            return \"^\" + prefix + \"\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$\";\n        };\n        var mapData = function mapData(prefix) {\n            var mapArg = number$1 + \"|\\\\w+|\" + rgba + \"|\" + hsla + \"|\" + hex3$1 + \"|\" + hex6$1;\n            return \"^\" + prefix + \"\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(\" + number$1 + \")\\\\s*\\\\,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + mapArg + \")\\\\s*\\\\,\\\\s*(\" + mapArg + \")\\\\)$\";\n        };\n        var urlRegexes = [\n            \"^url\\\\s*\\\\(\\\\s*['\\\"]?(.+?)['\\\"]?\\\\s*\\\\)$\",\n            \"^(none)$\",\n            \"^(.+)$\"\n        ]; // each visual style property has a type and needs to be validated according to it\n        styfn$2.types = {\n            time: {\n                number: true,\n                min: 0,\n                units: \"s|ms\",\n                implicitUnits: \"ms\"\n            },\n            percent: {\n                number: true,\n                min: 0,\n                max: 100,\n                units: \"%\",\n                implicitUnits: \"%\"\n            },\n            percentages: {\n                number: true,\n                min: 0,\n                max: 100,\n                units: \"%\",\n                implicitUnits: \"%\",\n                multiple: true\n            },\n            zeroOneNumber: {\n                number: true,\n                min: 0,\n                max: 1,\n                unitless: true\n            },\n            zeroOneNumbers: {\n                number: true,\n                min: 0,\n                max: 1,\n                unitless: true,\n                multiple: true\n            },\n            nOneOneNumber: {\n                number: true,\n                min: -1,\n                max: 1,\n                unitless: true\n            },\n            nonNegativeInt: {\n                number: true,\n                min: 0,\n                integer: true,\n                unitless: true\n            },\n            position: {\n                enums: [\n                    \"parent\",\n                    \"origin\"\n                ]\n            },\n            nodeSize: {\n                number: true,\n                min: 0,\n                enums: [\n                    \"label\"\n                ]\n            },\n            number: {\n                number: true,\n                unitless: true\n            },\n            numbers: {\n                number: true,\n                unitless: true,\n                multiple: true\n            },\n            positiveNumber: {\n                number: true,\n                unitless: true,\n                min: 0,\n                strictMin: true\n            },\n            size: {\n                number: true,\n                min: 0\n            },\n            bidirectionalSize: {\n                number: true\n            },\n            // allows negative\n            bidirectionalSizeMaybePercent: {\n                number: true,\n                allowPercent: true\n            },\n            // allows negative\n            bidirectionalSizes: {\n                number: true,\n                multiple: true\n            },\n            // allows negative\n            sizeMaybePercent: {\n                number: true,\n                min: 0,\n                allowPercent: true\n            },\n            axisDirection: {\n                enums: [\n                    \"horizontal\",\n                    \"leftward\",\n                    \"rightward\",\n                    \"vertical\",\n                    \"upward\",\n                    \"downward\",\n                    \"auto\"\n                ]\n            },\n            paddingRelativeTo: {\n                enums: [\n                    \"width\",\n                    \"height\",\n                    \"average\",\n                    \"min\",\n                    \"max\"\n                ]\n            },\n            bgWH: {\n                number: true,\n                min: 0,\n                allowPercent: true,\n                enums: [\n                    \"auto\"\n                ],\n                multiple: true\n            },\n            bgPos: {\n                number: true,\n                allowPercent: true,\n                multiple: true\n            },\n            bgRelativeTo: {\n                enums: [\n                    \"inner\",\n                    \"include-padding\"\n                ],\n                multiple: true\n            },\n            bgRepeat: {\n                enums: [\n                    \"repeat\",\n                    \"repeat-x\",\n                    \"repeat-y\",\n                    \"no-repeat\"\n                ],\n                multiple: true\n            },\n            bgFit: {\n                enums: [\n                    \"none\",\n                    \"contain\",\n                    \"cover\"\n                ],\n                multiple: true\n            },\n            bgCrossOrigin: {\n                enums: [\n                    \"anonymous\",\n                    \"use-credentials\",\n                    \"null\"\n                ],\n                multiple: true\n            },\n            bgClip: {\n                enums: [\n                    \"none\",\n                    \"node\"\n                ],\n                multiple: true\n            },\n            bgContainment: {\n                enums: [\n                    \"inside\",\n                    \"over\"\n                ],\n                multiple: true\n            },\n            color: {\n                color: true\n            },\n            colors: {\n                color: true,\n                multiple: true\n            },\n            fill: {\n                enums: [\n                    \"solid\",\n                    \"linear-gradient\",\n                    \"radial-gradient\"\n                ]\n            },\n            bool: {\n                enums: [\n                    \"yes\",\n                    \"no\"\n                ]\n            },\n            bools: {\n                enums: [\n                    \"yes\",\n                    \"no\"\n                ],\n                multiple: true\n            },\n            lineStyle: {\n                enums: [\n                    \"solid\",\n                    \"dotted\",\n                    \"dashed\"\n                ]\n            },\n            lineCap: {\n                enums: [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ]\n            },\n            borderStyle: {\n                enums: [\n                    \"solid\",\n                    \"dotted\",\n                    \"dashed\",\n                    \"double\"\n                ]\n            },\n            curveStyle: {\n                enums: [\n                    \"bezier\",\n                    \"unbundled-bezier\",\n                    \"haystack\",\n                    \"segments\",\n                    \"straight\",\n                    \"straight-triangle\",\n                    \"taxi\"\n                ]\n            },\n            fontFamily: {\n                regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n            },\n            fontStyle: {\n                enums: [\n                    \"italic\",\n                    \"normal\",\n                    \"oblique\"\n                ]\n            },\n            fontWeight: {\n                enums: [\n                    \"normal\",\n                    \"bold\",\n                    \"bolder\",\n                    \"lighter\",\n                    \"100\",\n                    \"200\",\n                    \"300\",\n                    \"400\",\n                    \"500\",\n                    \"600\",\n                    \"800\",\n                    \"900\",\n                    100,\n                    200,\n                    300,\n                    400,\n                    500,\n                    600,\n                    700,\n                    800,\n                    900\n                ]\n            },\n            textDecoration: {\n                enums: [\n                    \"none\",\n                    \"underline\",\n                    \"overline\",\n                    \"line-through\"\n                ]\n            },\n            textTransform: {\n                enums: [\n                    \"none\",\n                    \"uppercase\",\n                    \"lowercase\"\n                ]\n            },\n            textWrap: {\n                enums: [\n                    \"none\",\n                    \"wrap\",\n                    \"ellipsis\"\n                ]\n            },\n            textOverflowWrap: {\n                enums: [\n                    \"whitespace\",\n                    \"anywhere\"\n                ]\n            },\n            textBackgroundShape: {\n                enums: [\n                    \"rectangle\",\n                    \"roundrectangle\",\n                    \"round-rectangle\"\n                ]\n            },\n            nodeShape: {\n                enums: [\n                    \"rectangle\",\n                    \"roundrectangle\",\n                    \"round-rectangle\",\n                    \"cutrectangle\",\n                    \"cut-rectangle\",\n                    \"bottomroundrectangle\",\n                    \"bottom-round-rectangle\",\n                    \"barrel\",\n                    \"ellipse\",\n                    \"triangle\",\n                    \"round-triangle\",\n                    \"square\",\n                    \"pentagon\",\n                    \"round-pentagon\",\n                    \"hexagon\",\n                    \"round-hexagon\",\n                    \"concavehexagon\",\n                    \"concave-hexagon\",\n                    \"heptagon\",\n                    \"round-heptagon\",\n                    \"octagon\",\n                    \"round-octagon\",\n                    \"tag\",\n                    \"round-tag\",\n                    \"star\",\n                    \"diamond\",\n                    \"round-diamond\",\n                    \"vee\",\n                    \"rhomboid\",\n                    \"polygon\"\n                ]\n            },\n            overlayShape: {\n                enums: [\n                    \"roundrectangle\",\n                    \"round-rectangle\",\n                    \"ellipse\"\n                ]\n            },\n            compoundIncludeLabels: {\n                enums: [\n                    \"include\",\n                    \"exclude\"\n                ]\n            },\n            arrowShape: {\n                enums: [\n                    \"tee\",\n                    \"triangle\",\n                    \"triangle-tee\",\n                    \"circle-triangle\",\n                    \"triangle-cross\",\n                    \"triangle-backcurve\",\n                    \"vee\",\n                    \"square\",\n                    \"circle\",\n                    \"diamond\",\n                    \"chevron\",\n                    \"none\"\n                ]\n            },\n            arrowFill: {\n                enums: [\n                    \"filled\",\n                    \"hollow\"\n                ]\n            },\n            display: {\n                enums: [\n                    \"element\",\n                    \"none\"\n                ]\n            },\n            visibility: {\n                enums: [\n                    \"hidden\",\n                    \"visible\"\n                ]\n            },\n            zCompoundDepth: {\n                enums: [\n                    \"bottom\",\n                    \"orphan\",\n                    \"auto\",\n                    \"top\"\n                ]\n            },\n            zIndexCompare: {\n                enums: [\n                    \"auto\",\n                    \"manual\"\n                ]\n            },\n            valign: {\n                enums: [\n                    \"top\",\n                    \"center\",\n                    \"bottom\"\n                ]\n            },\n            halign: {\n                enums: [\n                    \"left\",\n                    \"center\",\n                    \"right\"\n                ]\n            },\n            justification: {\n                enums: [\n                    \"left\",\n                    \"center\",\n                    \"right\",\n                    \"auto\"\n                ]\n            },\n            text: {\n                string: true\n            },\n            data: {\n                mapping: true,\n                regex: data(\"data\")\n            },\n            layoutData: {\n                mapping: true,\n                regex: data(\"layoutData\")\n            },\n            scratch: {\n                mapping: true,\n                regex: data(\"scratch\")\n            },\n            mapData: {\n                mapping: true,\n                regex: mapData(\"mapData\")\n            },\n            mapLayoutData: {\n                mapping: true,\n                regex: mapData(\"mapLayoutData\")\n            },\n            mapScratch: {\n                mapping: true,\n                regex: mapData(\"mapScratch\")\n            },\n            fn: {\n                mapping: true,\n                fn: true\n            },\n            url: {\n                regexes: urlRegexes,\n                singleRegexMatchValue: true\n            },\n            urls: {\n                regexes: urlRegexes,\n                singleRegexMatchValue: true,\n                multiple: true\n            },\n            propList: {\n                propList: true\n            },\n            angle: {\n                number: true,\n                units: \"deg|rad\",\n                implicitUnits: \"rad\"\n            },\n            textRotation: {\n                number: true,\n                units: \"deg|rad\",\n                implicitUnits: \"rad\",\n                enums: [\n                    \"none\",\n                    \"autorotate\"\n                ]\n            },\n            polygonPointList: {\n                number: true,\n                multiple: true,\n                evenMultiple: true,\n                min: -1,\n                max: 1,\n                unitless: true\n            },\n            edgeDistances: {\n                enums: [\n                    \"intersection\",\n                    \"node-position\"\n                ]\n            },\n            edgeEndpoint: {\n                number: true,\n                multiple: true,\n                units: \"%|px|em|deg|rad\",\n                implicitUnits: \"px\",\n                enums: [\n                    \"inside-to-node\",\n                    \"outside-to-node\",\n                    \"outside-to-node-or-label\",\n                    \"outside-to-line\",\n                    \"outside-to-line-or-label\"\n                ],\n                singleEnum: true,\n                validate: function validate(valArr, unitsArr) {\n                    switch(valArr.length){\n                        case 2:\n                            // can be % or px only\n                            return unitsArr[0] !== \"deg\" && unitsArr[0] !== \"rad\" && unitsArr[1] !== \"deg\" && unitsArr[1] !== \"rad\";\n                        case 1:\n                            // can be enum, deg, or rad only\n                            return string(valArr[0]) || unitsArr[0] === \"deg\" || unitsArr[0] === \"rad\";\n                        default:\n                            return false;\n                    }\n                }\n            },\n            easing: {\n                regexes: [\n                    \"^(spring)\\\\s*\\\\(\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*\\\\)$\",\n                    \"^(cubic-bezier)\\\\s*\\\\(\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*\\\\)$\"\n                ],\n                enums: [\n                    \"linear\",\n                    \"ease\",\n                    \"ease-in\",\n                    \"ease-out\",\n                    \"ease-in-out\",\n                    \"ease-in-sine\",\n                    \"ease-out-sine\",\n                    \"ease-in-out-sine\",\n                    \"ease-in-quad\",\n                    \"ease-out-quad\",\n                    \"ease-in-out-quad\",\n                    \"ease-in-cubic\",\n                    \"ease-out-cubic\",\n                    \"ease-in-out-cubic\",\n                    \"ease-in-quart\",\n                    \"ease-out-quart\",\n                    \"ease-in-out-quart\",\n                    \"ease-in-quint\",\n                    \"ease-out-quint\",\n                    \"ease-in-out-quint\",\n                    \"ease-in-expo\",\n                    \"ease-out-expo\",\n                    \"ease-in-out-expo\",\n                    \"ease-in-circ\",\n                    \"ease-out-circ\",\n                    \"ease-in-out-circ\"\n                ]\n            },\n            gradientDirection: {\n                enums: [\n                    \"to-bottom\",\n                    \"to-top\",\n                    \"to-left\",\n                    \"to-right\",\n                    \"to-bottom-right\",\n                    \"to-bottom-left\",\n                    \"to-top-right\",\n                    \"to-top-left\",\n                    \"to-right-bottom\",\n                    \"to-left-bottom\",\n                    \"to-right-top\",\n                    \"to-left-top\" // different order\n                ]\n            },\n            boundsExpansion: {\n                number: true,\n                multiple: true,\n                min: 0,\n                validate: function validate(valArr) {\n                    var length = valArr.length;\n                    return length === 1 || length === 2 || length === 4;\n                }\n            }\n        };\n        var diff = {\n            zeroNonZero: function zeroNonZero(val1, val2) {\n                if ((val1 == null || val2 == null) && val1 !== val2) {\n                    return true; // null cases could represent any value\n                }\n                if (val1 == 0 && val2 != 0) {\n                    return true;\n                } else if (val1 != 0 && val2 == 0) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            any: function any(val1, val2) {\n                return val1 != val2;\n            },\n            emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n                var empty1 = emptyString(str1);\n                var empty2 = emptyString(str2);\n                return empty1 && !empty2 || !empty1 && empty2;\n            }\n        }; // define visual style properties\n        //\n        // - n.b. adding a new group of props may require updates to updateStyleHints()\n        // - adding new props to an existing group gets handled automatically\n        var t = styfn$2.types;\n        var mainLabel = [\n            {\n                name: \"label\",\n                type: t.text,\n                triggersBounds: diff.any,\n                triggersZOrder: diff.emptyNonEmpty\n            },\n            {\n                name: \"text-rotation\",\n                type: t.textRotation,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-margin-x\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-margin-y\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            }\n        ];\n        var sourceLabel = [\n            {\n                name: \"source-label\",\n                type: t.text,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-text-rotation\",\n                type: t.textRotation,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-text-margin-x\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-text-margin-y\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-text-offset\",\n                type: t.size,\n                triggersBounds: diff.any\n            }\n        ];\n        var targetLabel = [\n            {\n                name: \"target-label\",\n                type: t.text,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-text-rotation\",\n                type: t.textRotation,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-text-margin-x\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-text-margin-y\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-text-offset\",\n                type: t.size,\n                triggersBounds: diff.any\n            }\n        ];\n        var labelDimensions = [\n            {\n                name: \"font-family\",\n                type: t.fontFamily,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"font-style\",\n                type: t.fontStyle,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"font-weight\",\n                type: t.fontWeight,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"font-size\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-transform\",\n                type: t.textTransform,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-wrap\",\n                type: t.textWrap,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-overflow-wrap\",\n                type: t.textOverflowWrap,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-max-width\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-outline-width\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"line-height\",\n                type: t.positiveNumber,\n                triggersBounds: diff.any\n            }\n        ];\n        var commonLabel = [\n            {\n                name: \"text-valign\",\n                type: t.valign,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-halign\",\n                type: t.halign,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"color\",\n                type: t.color\n            },\n            {\n                name: \"text-outline-color\",\n                type: t.color\n            },\n            {\n                name: \"text-outline-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"text-background-color\",\n                type: t.color\n            },\n            {\n                name: \"text-background-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"text-background-padding\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-border-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"text-border-color\",\n                type: t.color\n            },\n            {\n                name: \"text-border-width\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-border-style\",\n                type: t.borderStyle,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-background-shape\",\n                type: t.textBackgroundShape,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"text-justification\",\n                type: t.justification\n            }\n        ];\n        var behavior = [\n            {\n                name: \"events\",\n                type: t.bool\n            },\n            {\n                name: \"text-events\",\n                type: t.bool\n            }\n        ];\n        var visibility = [\n            {\n                name: \"display\",\n                type: t.display,\n                triggersZOrder: diff.any,\n                triggersBounds: diff.any,\n                triggersBoundsOfParallelBeziers: true\n            },\n            {\n                name: \"visibility\",\n                type: t.visibility,\n                triggersZOrder: diff.any\n            },\n            {\n                name: \"opacity\",\n                type: t.zeroOneNumber,\n                triggersZOrder: diff.zeroNonZero\n            },\n            {\n                name: \"text-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"min-zoomed-font-size\",\n                type: t.size\n            },\n            {\n                name: \"z-compound-depth\",\n                type: t.zCompoundDepth,\n                triggersZOrder: diff.any\n            },\n            {\n                name: \"z-index-compare\",\n                type: t.zIndexCompare,\n                triggersZOrder: diff.any\n            },\n            {\n                name: \"z-index\",\n                type: t.nonNegativeInt,\n                triggersZOrder: diff.any\n            }\n        ];\n        var overlay = [\n            {\n                name: \"overlay-padding\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"overlay-color\",\n                type: t.color\n            },\n            {\n                name: \"overlay-opacity\",\n                type: t.zeroOneNumber,\n                triggersBounds: diff.zeroNonZero\n            },\n            {\n                name: \"overlay-shape\",\n                type: t.overlayShape,\n                triggersBounds: diff.any\n            }\n        ];\n        var underlay = [\n            {\n                name: \"underlay-padding\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"underlay-color\",\n                type: t.color\n            },\n            {\n                name: \"underlay-opacity\",\n                type: t.zeroOneNumber,\n                triggersBounds: diff.zeroNonZero\n            },\n            {\n                name: \"underlay-shape\",\n                type: t.overlayShape,\n                triggersBounds: diff.any\n            }\n        ];\n        var transition = [\n            {\n                name: \"transition-property\",\n                type: t.propList\n            },\n            {\n                name: \"transition-duration\",\n                type: t.time\n            },\n            {\n                name: \"transition-delay\",\n                type: t.time\n            },\n            {\n                name: \"transition-timing-function\",\n                type: t.easing\n            }\n        ];\n        var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n            if (parsedProp.value === \"label\") {\n                return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n            } else {\n                return parsedProp.pfValue;\n            }\n        };\n        var nodeBody = [\n            {\n                name: \"height\",\n                type: t.nodeSize,\n                triggersBounds: diff.any,\n                hashOverride: nodeSizeHashOverride\n            },\n            {\n                name: \"width\",\n                type: t.nodeSize,\n                triggersBounds: diff.any,\n                hashOverride: nodeSizeHashOverride\n            },\n            {\n                name: \"shape\",\n                type: t.nodeShape,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"shape-polygon-points\",\n                type: t.polygonPointList,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"background-color\",\n                type: t.color\n            },\n            {\n                name: \"background-fill\",\n                type: t.fill\n            },\n            {\n                name: \"background-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"background-blacken\",\n                type: t.nOneOneNumber\n            },\n            {\n                name: \"background-gradient-stop-colors\",\n                type: t.colors\n            },\n            {\n                name: \"background-gradient-stop-positions\",\n                type: t.percentages\n            },\n            {\n                name: \"background-gradient-direction\",\n                type: t.gradientDirection\n            },\n            {\n                name: \"padding\",\n                type: t.sizeMaybePercent,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"padding-relative-to\",\n                type: t.paddingRelativeTo,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"bounds-expansion\",\n                type: t.boundsExpansion,\n                triggersBounds: diff.any\n            }\n        ];\n        var nodeBorder = [\n            {\n                name: \"border-color\",\n                type: t.color\n            },\n            {\n                name: \"border-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"border-width\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"border-style\",\n                type: t.borderStyle\n            }\n        ];\n        var backgroundImage = [\n            {\n                name: \"background-image\",\n                type: t.urls\n            },\n            {\n                name: \"background-image-crossorigin\",\n                type: t.bgCrossOrigin\n            },\n            {\n                name: \"background-image-opacity\",\n                type: t.zeroOneNumbers\n            },\n            {\n                name: \"background-image-containment\",\n                type: t.bgContainment\n            },\n            {\n                name: \"background-image-smoothing\",\n                type: t.bools\n            },\n            {\n                name: \"background-position-x\",\n                type: t.bgPos\n            },\n            {\n                name: \"background-position-y\",\n                type: t.bgPos\n            },\n            {\n                name: \"background-width-relative-to\",\n                type: t.bgRelativeTo\n            },\n            {\n                name: \"background-height-relative-to\",\n                type: t.bgRelativeTo\n            },\n            {\n                name: \"background-repeat\",\n                type: t.bgRepeat\n            },\n            {\n                name: \"background-fit\",\n                type: t.bgFit\n            },\n            {\n                name: \"background-clip\",\n                type: t.bgClip\n            },\n            {\n                name: \"background-width\",\n                type: t.bgWH\n            },\n            {\n                name: \"background-height\",\n                type: t.bgWH\n            },\n            {\n                name: \"background-offset-x\",\n                type: t.bgPos\n            },\n            {\n                name: \"background-offset-y\",\n                type: t.bgPos\n            }\n        ];\n        var compound = [\n            {\n                name: \"position\",\n                type: t.position,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"compound-sizing-wrt-labels\",\n                type: t.compoundIncludeLabels,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-width\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-width-bias-left\",\n                type: t.sizeMaybePercent,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-width-bias-right\",\n                type: t.sizeMaybePercent,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-height\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-height-bias-top\",\n                type: t.sizeMaybePercent,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"min-height-bias-bottom\",\n                type: t.sizeMaybePercent,\n                triggersBounds: diff.any\n            }\n        ];\n        var edgeLine = [\n            {\n                name: \"line-style\",\n                type: t.lineStyle\n            },\n            {\n                name: \"line-color\",\n                type: t.color\n            },\n            {\n                name: \"line-fill\",\n                type: t.fill\n            },\n            {\n                name: \"line-cap\",\n                type: t.lineCap\n            },\n            {\n                name: \"line-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"line-dash-pattern\",\n                type: t.numbers\n            },\n            {\n                name: \"line-dash-offset\",\n                type: t.number\n            },\n            {\n                name: \"line-gradient-stop-colors\",\n                type: t.colors\n            },\n            {\n                name: \"line-gradient-stop-positions\",\n                type: t.percentages\n            },\n            {\n                name: \"curve-style\",\n                type: t.curveStyle,\n                triggersBounds: diff.any,\n                triggersBoundsOfParallelBeziers: true\n            },\n            {\n                name: \"haystack-radius\",\n                type: t.zeroOneNumber,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-endpoint\",\n                type: t.edgeEndpoint,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-endpoint\",\n                type: t.edgeEndpoint,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"control-point-step-size\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"control-point-distances\",\n                type: t.bidirectionalSizes,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"control-point-weights\",\n                type: t.numbers,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"segment-distances\",\n                type: t.bidirectionalSizes,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"segment-weights\",\n                type: t.numbers,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"taxi-turn\",\n                type: t.bidirectionalSizeMaybePercent,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"taxi-turn-min-distance\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"taxi-direction\",\n                type: t.axisDirection,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"edge-distances\",\n                type: t.edgeDistances,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"arrow-scale\",\n                type: t.positiveNumber,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"loop-direction\",\n                type: t.angle,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"loop-sweep\",\n                type: t.angle,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"source-distance-from-node\",\n                type: t.size,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"target-distance-from-node\",\n                type: t.size,\n                triggersBounds: diff.any\n            }\n        ];\n        var ghost = [\n            {\n                name: \"ghost\",\n                type: t.bool,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"ghost-offset-x\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"ghost-offset-y\",\n                type: t.bidirectionalSize,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"ghost-opacity\",\n                type: t.zeroOneNumber\n            }\n        ];\n        var core = [\n            {\n                name: \"selection-box-color\",\n                type: t.color\n            },\n            {\n                name: \"selection-box-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"selection-box-border-color\",\n                type: t.color\n            },\n            {\n                name: \"selection-box-border-width\",\n                type: t.size\n            },\n            {\n                name: \"active-bg-color\",\n                type: t.color\n            },\n            {\n                name: \"active-bg-opacity\",\n                type: t.zeroOneNumber\n            },\n            {\n                name: \"active-bg-size\",\n                type: t.size\n            },\n            {\n                name: \"outside-texture-bg-color\",\n                type: t.color\n            },\n            {\n                name: \"outside-texture-bg-opacity\",\n                type: t.zeroOneNumber\n            }\n        ]; // pie backgrounds for nodes\n        var pie = [];\n        styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n        pie.push({\n            name: \"pie-size\",\n            type: t.sizeMaybePercent\n        });\n        for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n            pie.push({\n                name: \"pie-\" + i + \"-background-color\",\n                type: t.color\n            });\n            pie.push({\n                name: \"pie-\" + i + \"-background-size\",\n                type: t.percent\n            });\n            pie.push({\n                name: \"pie-\" + i + \"-background-opacity\",\n                type: t.zeroOneNumber\n            });\n        } // edge arrows\n        var edgeArrow = [];\n        var arrowPrefixes = styfn$2.arrowPrefixes = [\n            \"source\",\n            \"mid-source\",\n            \"target\",\n            \"mid-target\"\n        ];\n        [\n            {\n                name: \"arrow-shape\",\n                type: t.arrowShape,\n                triggersBounds: diff.any\n            },\n            {\n                name: \"arrow-color\",\n                type: t.color\n            },\n            {\n                name: \"arrow-fill\",\n                type: t.arrowFill\n            }\n        ].forEach(function(prop) {\n            arrowPrefixes.forEach(function(prefix) {\n                var name = prefix + \"-\" + prop.name;\n                var type = prop.type, triggersBounds = prop.triggersBounds;\n                edgeArrow.push({\n                    name: name,\n                    type: type,\n                    triggersBounds: triggersBounds\n                });\n            });\n        }, {});\n        var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n        var propGroups = styfn$2.propertyGroups = {\n            // common to all eles\n            behavior: behavior,\n            transition: transition,\n            visibility: visibility,\n            overlay: overlay,\n            underlay: underlay,\n            ghost: ghost,\n            // labels\n            commonLabel: commonLabel,\n            labelDimensions: labelDimensions,\n            mainLabel: mainLabel,\n            sourceLabel: sourceLabel,\n            targetLabel: targetLabel,\n            // node props\n            nodeBody: nodeBody,\n            nodeBorder: nodeBorder,\n            backgroundImage: backgroundImage,\n            pie: pie,\n            compound: compound,\n            // edge props\n            edgeLine: edgeLine,\n            edgeArrow: edgeArrow,\n            core: core\n        };\n        var propGroupNames = styfn$2.propertyGroupNames = {};\n        var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n        propGroupKeys.forEach(function(key) {\n            propGroupNames[key] = propGroups[key].map(function(prop) {\n                return prop.name;\n            });\n            propGroups[key].forEach(function(prop) {\n                return prop.groupKey = key;\n            });\n        }); // define aliases\n        var aliases = styfn$2.aliases = [\n            {\n                name: \"content\",\n                pointsTo: \"label\"\n            },\n            {\n                name: \"control-point-distance\",\n                pointsTo: \"control-point-distances\"\n            },\n            {\n                name: \"control-point-weight\",\n                pointsTo: \"control-point-weights\"\n            },\n            {\n                name: \"edge-text-rotation\",\n                pointsTo: \"text-rotation\"\n            },\n            {\n                name: \"padding-left\",\n                pointsTo: \"padding\"\n            },\n            {\n                name: \"padding-right\",\n                pointsTo: \"padding\"\n            },\n            {\n                name: \"padding-top\",\n                pointsTo: \"padding\"\n            },\n            {\n                name: \"padding-bottom\",\n                pointsTo: \"padding\"\n            }\n        ]; // list of property names\n        styfn$2.propertyNames = props.map(function(p) {\n            return p.name;\n        }); // allow access of properties by name ( e.g. style.properties.height )\n        for(var _i = 0; _i < props.length; _i++){\n            var prop = props[_i];\n            props[prop.name] = prop; // allow lookup by name\n        } // map aliases\n        for(var _i2 = 0; _i2 < aliases.length; _i2++){\n            var alias = aliases[_i2];\n            var pointsToProp = props[alias.pointsTo];\n            var aliasProp = {\n                name: alias.name,\n                alias: true,\n                pointsTo: pointsToProp\n            }; // add alias prop for parsing\n            props.push(aliasProp);\n            props[alias.name] = aliasProp; // allow lookup by name\n        }\n    })();\n    styfn$2.getDefaultProperty = function(name) {\n        return this.getDefaultProperties()[name];\n    };\n    styfn$2.getDefaultProperties = function() {\n        var _p = this._private;\n        if (_p.defaultProperties != null) {\n            return _p.defaultProperties;\n        }\n        var rawProps = extend({\n            // core props\n            \"selection-box-color\": \"#ddd\",\n            \"selection-box-opacity\": 0.65,\n            \"selection-box-border-color\": \"#aaa\",\n            \"selection-box-border-width\": 1,\n            \"active-bg-color\": \"black\",\n            \"active-bg-opacity\": 0.15,\n            \"active-bg-size\": 30,\n            \"outside-texture-bg-color\": \"#000\",\n            \"outside-texture-bg-opacity\": 0.125,\n            // common node/edge props\n            \"events\": \"yes\",\n            \"text-events\": \"no\",\n            \"text-valign\": \"top\",\n            \"text-halign\": \"center\",\n            \"text-justification\": \"auto\",\n            \"line-height\": 1,\n            \"color\": \"#000\",\n            \"text-outline-color\": \"#000\",\n            \"text-outline-width\": 0,\n            \"text-outline-opacity\": 1,\n            \"text-opacity\": 1,\n            \"text-decoration\": \"none\",\n            \"text-transform\": \"none\",\n            \"text-wrap\": \"none\",\n            \"text-overflow-wrap\": \"whitespace\",\n            \"text-max-width\": 9999,\n            \"text-background-color\": \"#000\",\n            \"text-background-opacity\": 0,\n            \"text-background-shape\": \"rectangle\",\n            \"text-background-padding\": 0,\n            \"text-border-opacity\": 0,\n            \"text-border-width\": 0,\n            \"text-border-style\": \"solid\",\n            \"text-border-color\": \"#000\",\n            \"font-family\": \"Helvetica Neue, Helvetica, sans-serif\",\n            \"font-style\": \"normal\",\n            \"font-weight\": \"normal\",\n            \"font-size\": 16,\n            \"min-zoomed-font-size\": 0,\n            \"text-rotation\": \"none\",\n            \"source-text-rotation\": \"none\",\n            \"target-text-rotation\": \"none\",\n            \"visibility\": \"visible\",\n            \"display\": \"element\",\n            \"opacity\": 1,\n            \"z-compound-depth\": \"auto\",\n            \"z-index-compare\": \"auto\",\n            \"z-index\": 0,\n            \"label\": \"\",\n            \"text-margin-x\": 0,\n            \"text-margin-y\": 0,\n            \"source-label\": \"\",\n            \"source-text-offset\": 0,\n            \"source-text-margin-x\": 0,\n            \"source-text-margin-y\": 0,\n            \"target-label\": \"\",\n            \"target-text-offset\": 0,\n            \"target-text-margin-x\": 0,\n            \"target-text-margin-y\": 0,\n            \"overlay-opacity\": 0,\n            \"overlay-color\": \"#000\",\n            \"overlay-padding\": 10,\n            \"overlay-shape\": \"round-rectangle\",\n            \"underlay-opacity\": 0,\n            \"underlay-color\": \"#000\",\n            \"underlay-padding\": 10,\n            \"underlay-shape\": \"round-rectangle\",\n            \"transition-property\": \"none\",\n            \"transition-duration\": 0,\n            \"transition-delay\": 0,\n            \"transition-timing-function\": \"linear\",\n            // node props\n            \"background-blacken\": 0,\n            \"background-color\": \"#999\",\n            \"background-fill\": \"solid\",\n            \"background-opacity\": 1,\n            \"background-image\": \"none\",\n            \"background-image-crossorigin\": \"anonymous\",\n            \"background-image-opacity\": 1,\n            \"background-image-containment\": \"inside\",\n            \"background-image-smoothing\": \"yes\",\n            \"background-position-x\": \"50%\",\n            \"background-position-y\": \"50%\",\n            \"background-offset-x\": 0,\n            \"background-offset-y\": 0,\n            \"background-width-relative-to\": \"include-padding\",\n            \"background-height-relative-to\": \"include-padding\",\n            \"background-repeat\": \"no-repeat\",\n            \"background-fit\": \"none\",\n            \"background-clip\": \"node\",\n            \"background-width\": \"auto\",\n            \"background-height\": \"auto\",\n            \"border-color\": \"#000\",\n            \"border-opacity\": 1,\n            \"border-width\": 0,\n            \"border-style\": \"solid\",\n            \"height\": 30,\n            \"width\": 30,\n            \"shape\": \"ellipse\",\n            \"shape-polygon-points\": \"-1, -1,   1, -1,   1, 1,   -1, 1\",\n            \"bounds-expansion\": 0,\n            // node gradient\n            \"background-gradient-direction\": \"to-bottom\",\n            \"background-gradient-stop-colors\": \"#999\",\n            \"background-gradient-stop-positions\": \"0%\",\n            // ghost props\n            \"ghost\": \"no\",\n            \"ghost-offset-y\": 0,\n            \"ghost-offset-x\": 0,\n            \"ghost-opacity\": 0,\n            // compound props\n            \"padding\": 0,\n            \"padding-relative-to\": \"width\",\n            \"position\": \"origin\",\n            \"compound-sizing-wrt-labels\": \"include\",\n            \"min-width\": 0,\n            \"min-width-bias-left\": 0,\n            \"min-width-bias-right\": 0,\n            \"min-height\": 0,\n            \"min-height-bias-top\": 0,\n            \"min-height-bias-bottom\": 0\n        }, {\n            // node pie bg\n            \"pie-size\": \"100%\"\n        }, [\n            {\n                name: \"pie-{{i}}-background-color\",\n                value: \"black\"\n            },\n            {\n                name: \"pie-{{i}}-background-size\",\n                value: \"0%\"\n            },\n            {\n                name: \"pie-{{i}}-background-opacity\",\n                value: 1\n            }\n        ].reduce(function(css, prop) {\n            for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n                var name = prop.name.replace(\"{{i}}\", i);\n                var val = prop.value;\n                css[name] = val;\n            }\n            return css;\n        }, {}), {\n            // edge props\n            \"line-style\": \"solid\",\n            \"line-color\": \"#999\",\n            \"line-fill\": \"solid\",\n            \"line-cap\": \"butt\",\n            \"line-opacity\": 1,\n            \"line-gradient-stop-colors\": \"#999\",\n            \"line-gradient-stop-positions\": \"0%\",\n            \"control-point-step-size\": 40,\n            \"control-point-weights\": 0.5,\n            \"segment-weights\": 0.5,\n            \"segment-distances\": 20,\n            \"taxi-turn\": \"50%\",\n            \"taxi-turn-min-distance\": 10,\n            \"taxi-direction\": \"auto\",\n            \"edge-distances\": \"intersection\",\n            \"curve-style\": \"haystack\",\n            \"haystack-radius\": 0,\n            \"arrow-scale\": 1,\n            \"loop-direction\": \"-45deg\",\n            \"loop-sweep\": \"-90deg\",\n            \"source-distance-from-node\": 0,\n            \"target-distance-from-node\": 0,\n            \"source-endpoint\": \"outside-to-node\",\n            \"target-endpoint\": \"outside-to-node\",\n            \"line-dash-pattern\": [\n                6,\n                3\n            ],\n            \"line-dash-offset\": 0\n        }, [\n            {\n                name: \"arrow-shape\",\n                value: \"none\"\n            },\n            {\n                name: \"arrow-color\",\n                value: \"#999\"\n            },\n            {\n                name: \"arrow-fill\",\n                value: \"filled\"\n            }\n        ].reduce(function(css, prop) {\n            styfn$2.arrowPrefixes.forEach(function(prefix) {\n                var name = prefix + \"-\" + prop.name;\n                var val = prop.value;\n                css[name] = val;\n            });\n            return css;\n        }, {}));\n        var parsedProps = {};\n        for(var i = 0; i < this.properties.length; i++){\n            var prop = this.properties[i];\n            if (prop.pointsTo) {\n                continue;\n            }\n            var name = prop.name;\n            var val = rawProps[name];\n            var parsedProp = this.parse(name, val);\n            parsedProps[name] = parsedProp;\n        }\n        _p.defaultProperties = parsedProps;\n        return _p.defaultProperties;\n    };\n    styfn$2.addDefaultStylesheet = function() {\n        this.selector(\":parent\").css({\n            \"shape\": \"rectangle\",\n            \"padding\": 10,\n            \"background-color\": \"#eee\",\n            \"border-color\": \"#ccc\",\n            \"border-width\": 1\n        }).selector(\"edge\").css({\n            \"width\": 3\n        }).selector(\":loop\").css({\n            \"curve-style\": \"bezier\"\n        }).selector(\"edge:compound\").css({\n            \"curve-style\": \"bezier\",\n            \"source-endpoint\": \"outside-to-line\",\n            \"target-endpoint\": \"outside-to-line\"\n        }).selector(\":selected\").css({\n            \"background-color\": \"#0169D9\",\n            \"line-color\": \"#0169D9\",\n            \"source-arrow-color\": \"#0169D9\",\n            \"target-arrow-color\": \"#0169D9\",\n            \"mid-source-arrow-color\": \"#0169D9\",\n            \"mid-target-arrow-color\": \"#0169D9\"\n        }).selector(\":parent:selected\").css({\n            \"background-color\": \"#CCE1F9\",\n            \"border-color\": \"#aec8e5\"\n        }).selector(\":active\").css({\n            \"overlay-color\": \"black\",\n            \"overlay-padding\": 10,\n            \"overlay-opacity\": 0.25\n        });\n        this.defaultLength = this.length;\n    };\n    var styfn$1 = {}; // a caching layer for property parsing\n    styfn$1.parse = function(name, value, propIsBypass, propIsFlat) {\n        var self1 = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n        if (fn$6(value)) {\n            return self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n        }\n        var flatKey = propIsFlat === \"mapping\" || propIsFlat === true || propIsFlat === false || propIsFlat == null ? \"dontcare\" : propIsFlat;\n        var bypassKey = propIsBypass ? \"t\" : \"f\";\n        var valueKey = \"\" + value;\n        var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n        var propCache = self1.propCache = self1.propCache || [];\n        var ret;\n        if (!(ret = propCache[argHash])) {\n            ret = propCache[argHash] = self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n        } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n        // - mappings can't be shared b/c mappings are per-element\n        if (propIsBypass || propIsFlat === \"mapping\") {\n            // need a copy since props are mutated later in their lifecycles\n            ret = copy(ret);\n            if (ret) {\n                ret.value = copy(ret.value); // because it could be an array, e.g. colour\n            }\n        }\n        return ret;\n    };\n    styfn$1.parseImplWarn = function(name, value, propIsBypass, propIsFlat) {\n        var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n        if (!prop && value != null) {\n            warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n        }\n        if (prop && (prop.name === \"width\" || prop.name === \"height\") && value === \"label\") {\n            warn(\"The style value of `label` is deprecated for `\" + prop.name + \"`\");\n        }\n        return prop;\n    }; // parse a property; return null on invalid; return parsed property otherwise\n    // fields :\n    // - name : the name of the property\n    // - value : the parsed, native-typed value of the property\n    // - strValue : a string value that represents the property value in valid css\n    // - bypass : true iff the property is a bypass property\n    styfn$1.parseImpl = function(name, value, propIsBypass, propIsFlat) {\n        var self1 = this;\n        name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n        var property = self1.properties[name];\n        var passedValue = value;\n        var types = self1.types;\n        if (!property) {\n            return null;\n        } // return null on property of unknown name\n        if (value === undefined) {\n            return null;\n        } // can't assign undefined\n        // the property may be an alias\n        if (property.alias) {\n            property = property.pointsTo;\n            name = property.name;\n        }\n        var valueIsString = string(value);\n        if (valueIsString) {\n            // trim the value to make parsing easier\n            value = value.trim();\n        }\n        var type = property.type;\n        if (!type) {\n            return null;\n        } // no type, no luck\n        // check if bypass is null or empty string (i.e. indication to delete bypass property)\n        if (propIsBypass && (value === \"\" || value === null)) {\n            return {\n                name: name,\n                value: value,\n                bypass: true,\n                deleteBypass: true\n            };\n        } // check if value is a function used as a mapper\n        if (fn$6(value)) {\n            return {\n                name: name,\n                value: value,\n                strValue: \"fn\",\n                mapped: types.fn,\n                bypass: propIsBypass\n            };\n        } // check if value is mapped\n        var data, mapData;\n        if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== \"a\") ;\n        else if (value.length >= 7 && value[0] === \"d\" && (data = new RegExp(types.data.regex).exec(value))) {\n            if (propIsBypass) {\n                return false;\n            } // mappers not allowed in bypass\n            var mapped = types.data;\n            return {\n                name: name,\n                value: data,\n                strValue: \"\" + value,\n                mapped: mapped,\n                field: data[1],\n                bypass: propIsBypass\n            };\n        } else if (value.length >= 10 && value[0] === \"m\" && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n            if (propIsBypass) {\n                return false;\n            } // mappers not allowed in bypass\n            if (type.multiple) {\n                return false;\n            } // impossible to map to num\n            var _mapped = types.mapData; // we can map only if the type is a colour or a number\n            if (!(type.color || type.number)) {\n                return false;\n            }\n            var valueMin = this.parse(name, mapData[4]); // parse to validate\n            if (!valueMin || valueMin.mapped) {\n                return false;\n            } // can't be invalid or mapped\n            var valueMax = this.parse(name, mapData[5]); // parse to validate\n            if (!valueMax || valueMax.mapped) {\n                return false;\n            } // can't be invalid or mapped\n            // check if valueMin and valueMax are the same\n            if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n                warn(\"`\" + name + \": \" + value + \"` is not a valid mapper because the output range is zero; converting to `\" + name + \": \" + valueMin.strValue + \"`\");\n                return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n            } else if (type.color) {\n                var c1 = valueMin.value;\n                var c2 = valueMax.value;\n                var same = c1[0] === c2[0] // red\n                 && c1[1] === c2[1] // green\n                 && c1[2] === c2[2] // blue\n                 && (c1[3] === c2[3] // same alpha outright\n                 || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n                ) && (c2[3] == null || c2[3] === 1 // full opacity for colour 2?\n                ));\n                if (same) {\n                    return false;\n                } // can't make a mapper without a range\n            }\n            return {\n                name: name,\n                value: mapData,\n                strValue: \"\" + value,\n                mapped: _mapped,\n                field: mapData[1],\n                fieldMin: parseFloat(mapData[2]),\n                // min & max are numeric\n                fieldMax: parseFloat(mapData[3]),\n                valueMin: valueMin.value,\n                valueMax: valueMax.value,\n                bypass: propIsBypass\n            };\n        }\n        if (type.multiple && propIsFlat !== \"multiple\") {\n            var vals;\n            if (valueIsString) {\n                vals = value.split(/\\s+/);\n            } else if (array(value)) {\n                vals = value;\n            } else {\n                vals = [\n                    value\n                ];\n            }\n            if (type.evenMultiple && vals.length % 2 !== 0) {\n                return null;\n            }\n            var valArr = [];\n            var unitsArr = [];\n            var pfValArr = [];\n            var strVal = \"\";\n            var hasEnum = false;\n            for(var i = 0; i < vals.length; i++){\n                var p = self1.parse(name, vals[i], propIsBypass, \"multiple\");\n                hasEnum = hasEnum || string(p.value);\n                valArr.push(p.value);\n                pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n                unitsArr.push(p.units);\n                strVal += (i > 0 ? \" \" : \"\") + p.strValue;\n            }\n            if (type.validate && !type.validate(valArr, unitsArr)) {\n                return null;\n            }\n            if (type.singleEnum && hasEnum) {\n                if (valArr.length === 1 && string(valArr[0])) {\n                    return {\n                        name: name,\n                        value: valArr[0],\n                        strValue: valArr[0],\n                        bypass: propIsBypass\n                    };\n                } else {\n                    return null;\n                }\n            }\n            return {\n                name: name,\n                value: valArr,\n                pfValue: pfValArr,\n                strValue: strVal,\n                bypass: propIsBypass,\n                units: unitsArr\n            };\n        } // several types also allow enums\n        var checkEnums = function checkEnums() {\n            for(var _i = 0; _i < type.enums.length; _i++){\n                var en = type.enums[_i];\n                if (en === value) {\n                    return {\n                        name: name,\n                        value: value,\n                        strValue: \"\" + value,\n                        bypass: propIsBypass\n                    };\n                }\n            }\n            return null;\n        }; // check the type and return the appropriate object\n        if (type.number) {\n            var units;\n            var implicitUnits = \"px\"; // not set => px\n            if (type.units) {\n                // use specified units if set\n                units = type.units;\n            }\n            if (type.implicitUnits) {\n                implicitUnits = type.implicitUnits;\n            }\n            if (!type.unitless) {\n                if (valueIsString) {\n                    var unitsRegex = \"px|em\" + (type.allowPercent ? \"|\\\\%\" : \"\");\n                    if (units) {\n                        unitsRegex = units;\n                    } // only allow explicit units if so set\n                    var match = value.match(\"^(\" + number + \")(\" + unitsRegex + \")?\" + \"$\");\n                    if (match) {\n                        value = match[1];\n                        units = match[2] || implicitUnits;\n                    }\n                } else if (!units || type.implicitUnits) {\n                    units = implicitUnits; // implicitly px if unspecified\n                }\n            }\n            value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid\n            if (isNaN(value) && type.enums === undefined) {\n                return null;\n            } // check if this number type also accepts special keywords in place of numbers\n            // (i.e. `left`, `auto`, etc)\n            if (isNaN(value) && type.enums !== undefined) {\n                value = passedValue;\n                return checkEnums();\n            } // check if value must be an integer\n            if (type.integer && !integer(value)) {\n                return null;\n            } // check value is within range\n            if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n                return null;\n            }\n            var ret = {\n                name: name,\n                value: value,\n                strValue: \"\" + value + (units ? units : \"\"),\n                units: units,\n                bypass: propIsBypass\n            }; // normalise value in pixels\n            if (type.unitless || units !== \"px\" && units !== \"em\") {\n                ret.pfValue = value;\n            } else {\n                ret.pfValue = units === \"px\" || !units ? value : this.getEmSizeInPixels() * value;\n            } // normalise value in ms\n            if (units === \"ms\" || units === \"s\") {\n                ret.pfValue = units === \"ms\" ? value : 1000 * value;\n            } // normalise value in rad\n            if (units === \"deg\" || units === \"rad\") {\n                ret.pfValue = units === \"rad\" ? value : deg2rad(value);\n            } // normalize value in %\n            if (units === \"%\") {\n                ret.pfValue = value / 100;\n            }\n            return ret;\n        } else if (type.propList) {\n            var props = [];\n            var propsStr = \"\" + value;\n            if (propsStr === \"none\") ;\n            else {\n                // go over each prop\n                var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n                for(var _i2 = 0; _i2 < propsSplit.length; _i2++){\n                    var propName = propsSplit[_i2].trim();\n                    if (self1.properties[propName]) {\n                        props.push(propName);\n                    } else {\n                        warn(\"`\" + propName + \"` is not a valid property name\");\n                    }\n                }\n                if (props.length === 0) {\n                    return null;\n                }\n            }\n            return {\n                name: name,\n                value: props,\n                strValue: props.length === 0 ? \"none\" : props.join(\" \"),\n                bypass: propIsBypass\n            };\n        } else if (type.color) {\n            var tuple = color2tuple(value);\n            if (!tuple) {\n                return null;\n            }\n            return {\n                name: name,\n                value: tuple,\n                pfValue: tuple,\n                strValue: \"rgb(\" + tuple[0] + \",\" + tuple[1] + \",\" + tuple[2] + \")\",\n                // n.b. no spaces b/c of multiple support\n                bypass: propIsBypass\n            };\n        } else if (type.regex || type.regexes) {\n            // first check enums\n            if (type.enums) {\n                var enumProp = checkEnums();\n                if (enumProp) {\n                    return enumProp;\n                }\n            }\n            var regexes = type.regexes ? type.regexes : [\n                type.regex\n            ];\n            for(var _i3 = 0; _i3 < regexes.length; _i3++){\n                var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n                var m1 = regex.exec(value);\n                if (m1) {\n                    // regex matches\n                    return {\n                        name: name,\n                        value: type.singleRegexMatchValue ? m1[1] : m1,\n                        strValue: \"\" + value,\n                        bypass: propIsBypass\n                    };\n                }\n            }\n            return null; // didn't match any\n        } else if (type.string) {\n            // just return\n            return {\n                name: name,\n                value: \"\" + value,\n                strValue: \"\" + value,\n                bypass: propIsBypass\n            };\n        } else if (type.enums) {\n            // check enums last because it's a combo type in others\n            return checkEnums();\n        } else {\n            return null; // not a type we can handle\n        }\n    };\n    var Style = function Style(cy) {\n        if (!(this instanceof Style)) {\n            return new Style(cy);\n        }\n        if (!core(cy)) {\n            error(\"A style must have a core reference\");\n            return;\n        }\n        this._private = {\n            cy: cy,\n            coreStyle: {}\n        };\n        this.length = 0;\n        this.resetToDefault();\n    };\n    var styfn = Style.prototype;\n    styfn.instanceString = function() {\n        return \"style\";\n    }; // remove all contexts\n    styfn.clear = function() {\n        var _p = this._private;\n        var cy = _p.cy;\n        var eles = cy.elements();\n        for(var i = 0; i < this.length; i++){\n            this[i] = undefined;\n        }\n        this.length = 0;\n        _p.contextStyles = {};\n        _p.propDiffs = {};\n        this.cleanElements(eles, true);\n        eles.forEach(function(ele) {\n            var ele_p = ele[0]._private;\n            ele_p.styleDirty = true;\n            ele_p.appliedInitStyle = false;\n        });\n        return this; // chaining\n    };\n    styfn.resetToDefault = function() {\n        this.clear();\n        this.addDefaultStylesheet();\n        return this;\n    }; // builds a style object for the 'core' selector\n    styfn.core = function(propName) {\n        return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n    }; // create a new context from the specified selector string and switch to that context\n    styfn.selector = function(selectorStr) {\n        // 'core' is a special case and does not need a selector\n        var selector = selectorStr === \"core\" ? null : new Selector(selectorStr);\n        var i = this.length++; // new context means new index\n        this[i] = {\n            selector: selector,\n            properties: [],\n            mappedProperties: [],\n            index: i\n        };\n        return this; // chaining\n    }; // add one or many css rules to the current context\n    styfn.css = function() {\n        var self1 = this;\n        var args = arguments;\n        if (args.length === 1) {\n            var map = args[0];\n            for(var i = 0; i < self1.properties.length; i++){\n                var prop = self1.properties[i];\n                var mapVal = map[prop.name];\n                if (mapVal === undefined) {\n                    mapVal = map[dash2camel(prop.name)];\n                }\n                if (mapVal !== undefined) {\n                    this.cssRule(prop.name, mapVal);\n                }\n            }\n        } else if (args.length === 2) {\n            this.cssRule(args[0], args[1]);\n        } // do nothing if args are invalid\n        return this; // chaining\n    };\n    styfn.style = styfn.css; // add a single css rule to the current context\n    styfn.cssRule = function(name, value) {\n        // name-value pair\n        var property = this.parse(name, value); // add property to current context if valid\n        if (property) {\n            var i = this.length - 1;\n            this[i].properties.push(property);\n            this[i].properties[property.name] = property; // allow access by name as well\n            if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n                this._private.hasPie = true;\n            }\n            if (property.mapped) {\n                this[i].mappedProperties.push(property);\n            } // add to core style if necessary\n            var currentSelectorIsCore = !this[i].selector;\n            if (currentSelectorIsCore) {\n                this._private.coreStyle[property.name] = property;\n            }\n        }\n        return this; // chaining\n    };\n    styfn.append = function(style) {\n        if (stylesheet(style)) {\n            style.appendToStyle(this);\n        } else if (array(style)) {\n            this.appendFromJson(style);\n        } else if (string(style)) {\n            this.appendFromString(style);\n        } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n        return this;\n    }; // static function\n    Style.fromJson = function(cy, json) {\n        var style = new Style(cy);\n        style.fromJson(json);\n        return style;\n    };\n    Style.fromString = function(cy, string) {\n        return new Style(cy).fromString(string);\n    };\n    [\n        styfn$8,\n        styfn$7,\n        styfn$6,\n        styfn$5,\n        styfn$4,\n        styfn$3,\n        styfn$2,\n        styfn$1\n    ].forEach(function(props) {\n        extend(styfn, props);\n    });\n    Style.types = styfn.types;\n    Style.properties = styfn.properties;\n    Style.propertyGroups = styfn.propertyGroups;\n    Style.propertyGroupNames = styfn.propertyGroupNames;\n    Style.propertyGroupKeys = styfn.propertyGroupKeys;\n    var corefn$2 = {\n        style: function style(newStyle) {\n            if (newStyle) {\n                var s = this.setStyle(newStyle);\n                s.update();\n            }\n            return this._private.style;\n        },\n        setStyle: function setStyle(style) {\n            var _p = this._private;\n            if (stylesheet(style)) {\n                _p.style = style.generateStyle(this);\n            } else if (array(style)) {\n                _p.style = Style.fromJson(this, style);\n            } else if (string(style)) {\n                _p.style = Style.fromString(this, style);\n            } else {\n                _p.style = Style(this);\n            }\n            return _p.style;\n        },\n        // e.g. cy.data() changed => recalc ele mappers\n        updateStyle: function updateStyle() {\n            this.mutableElements().updateStyle(); // just send to all eles\n        }\n    };\n    var defaultSelectionType = \"single\";\n    var corefn$1 = {\n        autolock: function autolock(bool) {\n            if (bool !== undefined) {\n                this._private.autolock = bool ? true : false;\n            } else {\n                return this._private.autolock;\n            }\n            return this; // chaining\n        },\n        autoungrabify: function autoungrabify(bool) {\n            if (bool !== undefined) {\n                this._private.autoungrabify = bool ? true : false;\n            } else {\n                return this._private.autoungrabify;\n            }\n            return this; // chaining\n        },\n        autounselectify: function autounselectify(bool) {\n            if (bool !== undefined) {\n                this._private.autounselectify = bool ? true : false;\n            } else {\n                return this._private.autounselectify;\n            }\n            return this; // chaining\n        },\n        selectionType: function selectionType(selType) {\n            var _p = this._private;\n            if (_p.selectionType == null) {\n                _p.selectionType = defaultSelectionType;\n            }\n            if (selType !== undefined) {\n                if (selType === \"additive\" || selType === \"single\") {\n                    _p.selectionType = selType;\n                }\n            } else {\n                return _p.selectionType;\n            }\n            return this;\n        },\n        panningEnabled: function panningEnabled(bool) {\n            if (bool !== undefined) {\n                this._private.panningEnabled = bool ? true : false;\n            } else {\n                return this._private.panningEnabled;\n            }\n            return this; // chaining\n        },\n        userPanningEnabled: function userPanningEnabled(bool) {\n            if (bool !== undefined) {\n                this._private.userPanningEnabled = bool ? true : false;\n            } else {\n                return this._private.userPanningEnabled;\n            }\n            return this; // chaining\n        },\n        zoomingEnabled: function zoomingEnabled(bool) {\n            if (bool !== undefined) {\n                this._private.zoomingEnabled = bool ? true : false;\n            } else {\n                return this._private.zoomingEnabled;\n            }\n            return this; // chaining\n        },\n        userZoomingEnabled: function userZoomingEnabled(bool) {\n            if (bool !== undefined) {\n                this._private.userZoomingEnabled = bool ? true : false;\n            } else {\n                return this._private.userZoomingEnabled;\n            }\n            return this; // chaining\n        },\n        boxSelectionEnabled: function boxSelectionEnabled(bool) {\n            if (bool !== undefined) {\n                this._private.boxSelectionEnabled = bool ? true : false;\n            } else {\n                return this._private.boxSelectionEnabled;\n            }\n            return this; // chaining\n        },\n        pan: function pan() {\n            var args = arguments;\n            var pan = this._private.pan;\n            var dim, val, dims, x, y;\n            switch(args.length){\n                case 0:\n                    // .pan()\n                    return pan;\n                case 1:\n                    if (string(args[0])) {\n                        // .pan('x')\n                        dim = args[0];\n                        return pan[dim];\n                    } else if (plainObject(args[0])) {\n                        // .pan({ x: 0, y: 100 })\n                        if (!this._private.panningEnabled) {\n                            return this;\n                        }\n                        dims = args[0];\n                        x = dims.x;\n                        y = dims.y;\n                        if (number$1(x)) {\n                            pan.x = x;\n                        }\n                        if (number$1(y)) {\n                            pan.y = y;\n                        }\n                        this.emit(\"pan viewport\");\n                    }\n                    break;\n                case 2:\n                    // .pan('x', 100)\n                    if (!this._private.panningEnabled) {\n                        return this;\n                    }\n                    dim = args[0];\n                    val = args[1];\n                    if ((dim === \"x\" || dim === \"y\") && number$1(val)) {\n                        pan[dim] = val;\n                    }\n                    this.emit(\"pan viewport\");\n                    break;\n            }\n            this.notify(\"viewport\");\n            return this; // chaining\n        },\n        panBy: function panBy(arg0, arg1) {\n            var args = arguments;\n            var pan = this._private.pan;\n            var dim, val, dims, x, y;\n            if (!this._private.panningEnabled) {\n                return this;\n            }\n            switch(args.length){\n                case 1:\n                    if (plainObject(arg0)) {\n                        // .panBy({ x: 0, y: 100 })\n                        dims = args[0];\n                        x = dims.x;\n                        y = dims.y;\n                        if (number$1(x)) {\n                            pan.x += x;\n                        }\n                        if (number$1(y)) {\n                            pan.y += y;\n                        }\n                        this.emit(\"pan viewport\");\n                    }\n                    break;\n                case 2:\n                    // .panBy('x', 100)\n                    dim = arg0;\n                    val = arg1;\n                    if ((dim === \"x\" || dim === \"y\") && number$1(val)) {\n                        pan[dim] += val;\n                    }\n                    this.emit(\"pan viewport\");\n                    break;\n            }\n            this.notify(\"viewport\");\n            return this; // chaining\n        },\n        fit: function fit(elements, padding) {\n            var viewportState = this.getFitViewport(elements, padding);\n            if (viewportState) {\n                var _p = this._private;\n                _p.zoom = viewportState.zoom;\n                _p.pan = viewportState.pan;\n                this.emit(\"pan zoom viewport\");\n                this.notify(\"viewport\");\n            }\n            return this; // chaining\n        },\n        getFitViewport: function getFitViewport(elements, padding) {\n            if (number$1(elements) && padding === undefined) {\n                // elements is optional\n                padding = elements;\n                elements = undefined;\n            }\n            if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n                return;\n            }\n            var bb;\n            if (string(elements)) {\n                var sel = elements;\n                elements = this.$(sel);\n            } else if (boundingBox(elements)) {\n                // assume bb\n                var bbe = elements;\n                bb = {\n                    x1: bbe.x1,\n                    y1: bbe.y1,\n                    x2: bbe.x2,\n                    y2: bbe.y2\n                };\n                bb.w = bb.x2 - bb.x1;\n                bb.h = bb.y2 - bb.y1;\n            } else if (!elementOrCollection(elements)) {\n                elements = this.mutableElements();\n            }\n            if (elementOrCollection(elements) && elements.empty()) {\n                return;\n            } // can't fit to nothing\n            bb = bb || elements.boundingBox();\n            var w = this.width();\n            var h = this.height();\n            var zoom;\n            padding = number$1(padding) ? padding : 0;\n            if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n                zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom\n                zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n                zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n                var pan = {\n                    // now pan to middle\n                    x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n                    y: (h - zoom * (bb.y1 + bb.y2)) / 2\n                };\n                return {\n                    zoom: zoom,\n                    pan: pan\n                };\n            }\n            return;\n        },\n        zoomRange: function zoomRange(min, max) {\n            var _p = this._private;\n            if (max == null) {\n                var opts = min;\n                min = opts.min;\n                max = opts.max;\n            }\n            if (number$1(min) && number$1(max) && min <= max) {\n                _p.minZoom = min;\n                _p.maxZoom = max;\n            } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n                _p.minZoom = min;\n            } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n                _p.maxZoom = max;\n            }\n            return this;\n        },\n        minZoom: function minZoom(zoom) {\n            if (zoom === undefined) {\n                return this._private.minZoom;\n            } else {\n                return this.zoomRange({\n                    min: zoom\n                });\n            }\n        },\n        maxZoom: function maxZoom(zoom) {\n            if (zoom === undefined) {\n                return this._private.maxZoom;\n            } else {\n                return this.zoomRange({\n                    max: zoom\n                });\n            }\n        },\n        getZoomedViewport: function getZoomedViewport(params) {\n            var _p = this._private;\n            var currentPan = _p.pan;\n            var currentZoom = _p.zoom;\n            var pos; // in rendered px\n            var zoom;\n            var bail = false;\n            if (!_p.zoomingEnabled) {\n                // zooming disabled\n                bail = true;\n            }\n            if (number$1(params)) {\n                // then set the zoom\n                zoom = params;\n            } else if (plainObject(params)) {\n                // then zoom about a point\n                zoom = params.level;\n                if (params.position != null) {\n                    pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n                } else if (params.renderedPosition != null) {\n                    pos = params.renderedPosition;\n                }\n                if (pos != null && !_p.panningEnabled) {\n                    // panning disabled\n                    bail = true;\n                }\n            } // crop zoom\n            zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n            zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params\n            if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n                return null;\n            }\n            if (pos != null) {\n                // set zoom about position\n                var pan1 = currentPan;\n                var zoom1 = currentZoom;\n                var zoom2 = zoom;\n                var pan2 = {\n                    x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n                    y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n                };\n                return {\n                    zoomed: true,\n                    panned: true,\n                    zoom: zoom2,\n                    pan: pan2\n                };\n            } else {\n                // just set the zoom\n                return {\n                    zoomed: true,\n                    panned: false,\n                    zoom: zoom,\n                    pan: currentPan\n                };\n            }\n        },\n        zoom: function zoom(params) {\n            if (params === undefined) {\n                // get\n                return this._private.zoom;\n            } else {\n                // set\n                var vp = this.getZoomedViewport(params);\n                var _p = this._private;\n                if (vp == null || !vp.zoomed) {\n                    return this;\n                }\n                _p.zoom = vp.zoom;\n                if (vp.panned) {\n                    _p.pan.x = vp.pan.x;\n                    _p.pan.y = vp.pan.y;\n                }\n                this.emit(\"zoom\" + (vp.panned ? \" pan\" : \"\") + \" viewport\");\n                this.notify(\"viewport\");\n                return this; // chaining\n            }\n        },\n        viewport: function viewport(opts) {\n            var _p = this._private;\n            var zoomDefd = true;\n            var panDefd = true;\n            var events = []; // to trigger\n            var zoomFailed = false;\n            var panFailed = false;\n            if (!opts) {\n                return this;\n            }\n            if (!number$1(opts.zoom)) {\n                zoomDefd = false;\n            }\n            if (!plainObject(opts.pan)) {\n                panDefd = false;\n            }\n            if (!zoomDefd && !panDefd) {\n                return this;\n            }\n            if (zoomDefd) {\n                var z = opts.zoom;\n                if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n                    zoomFailed = true;\n                } else {\n                    _p.zoom = z;\n                    events.push(\"zoom\");\n                }\n            }\n            if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n                var p = opts.pan;\n                if (number$1(p.x)) {\n                    _p.pan.x = p.x;\n                    panFailed = false;\n                }\n                if (number$1(p.y)) {\n                    _p.pan.y = p.y;\n                    panFailed = false;\n                }\n                if (!panFailed) {\n                    events.push(\"pan\");\n                }\n            }\n            if (events.length > 0) {\n                events.push(\"viewport\");\n                this.emit(events.join(\" \"));\n                this.notify(\"viewport\");\n            }\n            return this; // chaining\n        },\n        center: function center(elements) {\n            var pan = this.getCenterPan(elements);\n            if (pan) {\n                this._private.pan = pan;\n                this.emit(\"pan viewport\");\n                this.notify(\"viewport\");\n            }\n            return this; // chaining\n        },\n        getCenterPan: function getCenterPan(elements, zoom) {\n            if (!this._private.panningEnabled) {\n                return;\n            }\n            if (string(elements)) {\n                var selector = elements;\n                elements = this.mutableElements().filter(selector);\n            } else if (!elementOrCollection(elements)) {\n                elements = this.mutableElements();\n            }\n            if (elements.length === 0) {\n                return;\n            } // can't centre pan to nothing\n            var bb = elements.boundingBox();\n            var w = this.width();\n            var h = this.height();\n            zoom = zoom === undefined ? this._private.zoom : zoom;\n            var pan = {\n                // middle\n                x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n                y: (h - zoom * (bb.y1 + bb.y2)) / 2\n            };\n            return pan;\n        },\n        reset: function reset() {\n            if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n                return this;\n            }\n            this.viewport({\n                pan: {\n                    x: 0,\n                    y: 0\n                },\n                zoom: 1\n            });\n            return this; // chaining\n        },\n        invalidateSize: function invalidateSize() {\n            this._private.sizeCache = null;\n        },\n        size: function size() {\n            var _p = this._private;\n            var container = _p.container;\n            return _p.sizeCache = _p.sizeCache || (container ? function() {\n                var style = window$1.getComputedStyle(container);\n                var val = function val(name) {\n                    return parseFloat(style.getPropertyValue(name));\n                };\n                return {\n                    width: container.clientWidth - val(\"padding-left\") - val(\"padding-right\"),\n                    height: container.clientHeight - val(\"padding-top\") - val(\"padding-bottom\")\n                };\n            }() : {\n                // fallback if no container (not 0 b/c can be used for dividing etc)\n                width: 1,\n                height: 1\n            });\n        },\n        width: function width() {\n            return this.size().width;\n        },\n        height: function height() {\n            return this.size().height;\n        },\n        extent: function extent() {\n            var pan = this._private.pan;\n            var zoom = this._private.zoom;\n            var rb = this.renderedExtent();\n            var b = {\n                x1: (rb.x1 - pan.x) / zoom,\n                x2: (rb.x2 - pan.x) / zoom,\n                y1: (rb.y1 - pan.y) / zoom,\n                y2: (rb.y2 - pan.y) / zoom\n            };\n            b.w = b.x2 - b.x1;\n            b.h = b.y2 - b.y1;\n            return b;\n        },\n        renderedExtent: function renderedExtent() {\n            var width = this.width();\n            var height = this.height();\n            return {\n                x1: 0,\n                y1: 0,\n                x2: width,\n                y2: height,\n                w: width,\n                h: height\n            };\n        },\n        multiClickDebounceTime: function multiClickDebounceTime(_int) {\n            if (_int) this._private.multiClickDebounceTime = _int;\n            else return this._private.multiClickDebounceTime;\n            return this; // chaining\n        }\n    }; // aliases\n    corefn$1.centre = corefn$1.center; // backwards compatibility\n    corefn$1.autolockNodes = corefn$1.autolock;\n    corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\n    var fn = {\n        data: define1.data({\n            field: \"data\",\n            bindingEvent: \"data\",\n            allowBinding: true,\n            allowSetting: true,\n            settingEvent: \"data\",\n            settingTriggersEvent: true,\n            triggerFnName: \"trigger\",\n            allowGetting: true,\n            updateStyle: true\n        }),\n        removeData: define1.removeData({\n            field: \"data\",\n            event: \"data\",\n            triggerFnName: \"trigger\",\n            triggerEvent: true,\n            updateStyle: true\n        }),\n        scratch: define1.data({\n            field: \"scratch\",\n            bindingEvent: \"scratch\",\n            allowBinding: true,\n            allowSetting: true,\n            settingEvent: \"scratch\",\n            settingTriggersEvent: true,\n            triggerFnName: \"trigger\",\n            allowGetting: true,\n            updateStyle: true\n        }),\n        removeScratch: define1.removeData({\n            field: \"scratch\",\n            event: \"scratch\",\n            triggerFnName: \"trigger\",\n            triggerEvent: true,\n            updateStyle: true\n        })\n    }; // aliases\n    fn.attr = fn.data;\n    fn.removeAttr = fn.removeData;\n    var Core = function Core(opts) {\n        var cy = this;\n        opts = extend({}, opts);\n        var container = opts.container; // allow for passing a wrapped jquery object\n        // e.g. cytoscape({ container: $('#cy') })\n        if (container && !htmlElement(container) && htmlElement(container[0])) {\n            container = container[0];\n        }\n        var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n        reg = reg || {};\n        if (reg && reg.cy) {\n            reg.cy.destroy();\n            reg = {}; // old instance => replace reg completely\n        }\n        var readies = reg.readies = reg.readies || [];\n        if (container) {\n            container._cyreg = reg;\n        } // make sure container assoc'd reg points to this cy\n        reg.cy = cy;\n        var head = window$1 !== undefined && container !== undefined && !opts.headless;\n        var options = opts;\n        options.layout = extend({\n            name: head ? \"grid\" : \"null\"\n        }, options.layout);\n        options.renderer = extend({\n            name: head ? \"canvas\" : \"null\"\n        }, options.renderer);\n        var defVal = function defVal(def, val, altVal) {\n            if (val !== undefined) {\n                return val;\n            } else if (altVal !== undefined) {\n                return altVal;\n            } else {\n                return def;\n            }\n        };\n        var _p = this._private = {\n            container: container,\n            // html dom ele container\n            ready: false,\n            // whether ready has been triggered\n            options: options,\n            // cached options\n            elements: new Collection(this),\n            // elements in the graph\n            listeners: [],\n            // list of listeners\n            aniEles: new Collection(this),\n            // elements being animated\n            data: options.data || {},\n            // data for the core\n            scratch: {},\n            // scratch object for core\n            layout: null,\n            renderer: null,\n            destroyed: false,\n            // whether destroy was called\n            notificationsEnabled: true,\n            // whether notifications are sent to the renderer\n            minZoom: 1e-50,\n            maxZoom: 1e50,\n            zoomingEnabled: defVal(true, options.zoomingEnabled),\n            userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n            panningEnabled: defVal(true, options.panningEnabled),\n            userPanningEnabled: defVal(true, options.userPanningEnabled),\n            boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n            autolock: defVal(false, options.autolock, options.autolockNodes),\n            autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n            autounselectify: defVal(false, options.autounselectify),\n            styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n            zoom: number$1(options.zoom) ? options.zoom : 1,\n            pan: {\n                x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n                y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n            },\n            animation: {\n                // object for currently-running animations\n                current: [],\n                queue: []\n            },\n            hasCompoundNodes: false,\n            multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n        };\n        this.createEmitter(); // set selection type\n        this.selectionType(options.selectionType); // init zoom bounds\n        this.zoomRange({\n            min: options.minZoom,\n            max: options.maxZoom\n        });\n        var loadExtData = function loadExtData(extData, next) {\n            var anyIsPromise = extData.some(promise);\n            if (anyIsPromise) {\n                return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n            } else {\n                next(extData); // exec synchronously for convenience\n            }\n        }; // start with the default stylesheet so we have something before loading an external stylesheet\n        if (_p.styleEnabled) {\n            cy.setStyle([]);\n        } // create the renderer\n        var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n        cy.initRenderer(rendererOptions);\n        var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n            cy.notifications(false); // remove old elements\n            var oldEles = cy.mutableElements();\n            if (oldEles.length > 0) {\n                oldEles.remove();\n            }\n            if (elements != null) {\n                if (plainObject(elements) || array(elements)) {\n                    cy.add(elements);\n                }\n            }\n            cy.one(\"layoutready\", function(e) {\n                cy.notifications(true);\n                cy.emit(e); // we missed this event by turning notifications off, so pass it on\n                cy.one(\"load\", onload);\n                cy.emitAndNotify(\"load\");\n            }).one(\"layoutstop\", function() {\n                cy.one(\"done\", ondone);\n                cy.emit(\"done\");\n            });\n            var layoutOpts = extend({}, cy._private.options.layout);\n            layoutOpts.eles = cy.elements();\n            cy.layout(layoutOpts).run();\n        };\n        loadExtData([\n            options.style,\n            options.elements\n        ], function(thens) {\n            var initStyle = thens[0];\n            var initEles = thens[1]; // init style\n            if (_p.styleEnabled) {\n                cy.style().append(initStyle);\n            } // initial load\n            setElesAndLayout(initEles, function() {\n                // onready\n                cy.startAnimationLoop();\n                _p.ready = true; // if a ready callback is specified as an option, the bind it\n                if (fn$6(options.ready)) {\n                    cy.on(\"ready\", options.ready);\n                } // bind all the ready handlers registered before creating this instance\n                for(var i = 0; i < readies.length; i++){\n                    var fn = readies[i];\n                    cy.on(\"ready\", fn);\n                }\n                if (reg) {\n                    reg.readies = [];\n                } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n                cy.emit(\"ready\");\n            }, options.done);\n        });\n    };\n    var corefn = Core.prototype; // short alias\n    extend(corefn, {\n        instanceString: function instanceString() {\n            return \"core\";\n        },\n        isReady: function isReady() {\n            return this._private.ready;\n        },\n        destroyed: function destroyed() {\n            return this._private.destroyed;\n        },\n        ready: function ready(fn) {\n            if (this.isReady()) {\n                this.emitter().emit(\"ready\", [], fn); // just calls fn as though triggered via ready event\n            } else {\n                this.on(\"ready\", fn);\n            }\n            return this;\n        },\n        destroy: function destroy() {\n            var cy = this;\n            if (cy.destroyed()) return;\n            cy.stopAnimationLoop();\n            cy.destroyRenderer();\n            this.emit(\"destroy\");\n            cy._private.destroyed = true;\n            return cy;\n        },\n        hasElementWithId: function hasElementWithId(id) {\n            return this._private.elements.hasElementWithId(id);\n        },\n        getElementById: function getElementById(id) {\n            return this._private.elements.getElementById(id);\n        },\n        hasCompoundNodes: function hasCompoundNodes() {\n            return this._private.hasCompoundNodes;\n        },\n        headless: function headless() {\n            return this._private.renderer.isHeadless();\n        },\n        styleEnabled: function styleEnabled() {\n            return this._private.styleEnabled;\n        },\n        addToPool: function addToPool(eles) {\n            this._private.elements.merge(eles);\n            return this; // chaining\n        },\n        removeFromPool: function removeFromPool(eles) {\n            this._private.elements.unmerge(eles);\n            return this;\n        },\n        container: function container() {\n            return this._private.container || null;\n        },\n        mount: function mount(container) {\n            if (container == null) {\n                return;\n            }\n            var cy = this;\n            var _p = cy._private;\n            var options = _p.options;\n            if (!htmlElement(container) && htmlElement(container[0])) {\n                container = container[0];\n            }\n            cy.stopAnimationLoop();\n            cy.destroyRenderer();\n            _p.container = container;\n            _p.styleEnabled = true;\n            cy.invalidateSize();\n            cy.initRenderer(extend({}, options, options.renderer, {\n                // allow custom renderer name to be re-used, otherwise use canvas\n                name: options.renderer.name === \"null\" ? \"canvas\" : options.renderer.name\n            }));\n            cy.startAnimationLoop();\n            cy.style(options.style);\n            cy.emit(\"mount\");\n            return cy;\n        },\n        unmount: function unmount() {\n            var cy = this;\n            cy.stopAnimationLoop();\n            cy.destroyRenderer();\n            cy.initRenderer({\n                name: \"null\"\n            });\n            cy.emit(\"unmount\");\n            return cy;\n        },\n        options: function options() {\n            return copy(this._private.options);\n        },\n        json: function json(obj) {\n            var cy = this;\n            var _p = cy._private;\n            var eles = cy.mutableElements();\n            var getFreshRef = function getFreshRef(ele) {\n                return cy.getElementById(ele.id());\n            };\n            if (plainObject(obj)) {\n                // set\n                cy.startBatch();\n                if (obj.elements) {\n                    var idInJson = {};\n                    var updateEles = function updateEles(jsons, gr) {\n                        var toAdd = [];\n                        var toMod = [];\n                        for(var i = 0; i < jsons.length; i++){\n                            var json = jsons[i];\n                            if (!json.data.id) {\n                                warn(\"cy.json() cannot handle elements without an ID attribute\");\n                                continue;\n                            }\n                            var id = \"\" + json.data.id; // id must be string\n                            var ele = cy.getElementById(id);\n                            idInJson[id] = true;\n                            if (ele.length !== 0) {\n                                // existing element should be updated\n                                toMod.push({\n                                    ele: ele,\n                                    json: json\n                                });\n                            } else {\n                                // otherwise should be added\n                                if (gr) {\n                                    json.group = gr;\n                                    toAdd.push(json);\n                                } else {\n                                    toAdd.push(json);\n                                }\n                            }\n                        }\n                        cy.add(toAdd);\n                        for(var _i = 0; _i < toMod.length; _i++){\n                            var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;\n                            _ele.json(_json);\n                        }\n                    };\n                    if (array(obj.elements)) {\n                        // elements: []\n                        updateEles(obj.elements);\n                    } else {\n                        // elements: { nodes: [], edges: [] }\n                        var grs = [\n                            \"nodes\",\n                            \"edges\"\n                        ];\n                        for(var i = 0; i < grs.length; i++){\n                            var gr = grs[i];\n                            var elements = obj.elements[gr];\n                            if (array(elements)) {\n                                updateEles(elements, gr);\n                            }\n                        }\n                    }\n                    var parentsToRemove = cy.collection();\n                    eles.filter(function(ele) {\n                        return !idInJson[ele.id()];\n                    }).forEach(function(ele) {\n                        if (ele.isParent()) {\n                            parentsToRemove.merge(ele);\n                        } else {\n                            ele.remove();\n                        }\n                    }); // so that children are not removed w/parent\n                    parentsToRemove.forEach(function(ele) {\n                        return ele.children().move({\n                            parent: null\n                        });\n                    }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n                    parentsToRemove.forEach(function(ele) {\n                        return getFreshRef(ele).remove();\n                    });\n                }\n                if (obj.style) {\n                    cy.style(obj.style);\n                }\n                if (obj.zoom != null && obj.zoom !== _p.zoom) {\n                    cy.zoom(obj.zoom);\n                }\n                if (obj.pan) {\n                    if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n                        cy.pan(obj.pan);\n                    }\n                }\n                if (obj.data) {\n                    cy.data(obj.data);\n                }\n                var fields = [\n                    \"minZoom\",\n                    \"maxZoom\",\n                    \"zoomingEnabled\",\n                    \"userZoomingEnabled\",\n                    \"panningEnabled\",\n                    \"userPanningEnabled\",\n                    \"boxSelectionEnabled\",\n                    \"autolock\",\n                    \"autoungrabify\",\n                    \"autounselectify\",\n                    \"multiClickDebounceTime\"\n                ];\n                for(var _i2 = 0; _i2 < fields.length; _i2++){\n                    var f = fields[_i2];\n                    if (obj[f] != null) {\n                        cy[f](obj[f]);\n                    }\n                }\n                cy.endBatch();\n                return this; // chaining\n            } else {\n                // get\n                var flat = !!obj;\n                var json = {};\n                if (flat) {\n                    json.elements = this.elements().map(function(ele) {\n                        return ele.json();\n                    });\n                } else {\n                    json.elements = {};\n                    eles.forEach(function(ele) {\n                        var group = ele.group();\n                        if (!json.elements[group]) {\n                            json.elements[group] = [];\n                        }\n                        json.elements[group].push(ele.json());\n                    });\n                }\n                if (this._private.styleEnabled) {\n                    json.style = cy.style().json();\n                }\n                json.data = copy(cy.data());\n                var options = _p.options;\n                json.zoomingEnabled = _p.zoomingEnabled;\n                json.userZoomingEnabled = _p.userZoomingEnabled;\n                json.zoom = _p.zoom;\n                json.minZoom = _p.minZoom;\n                json.maxZoom = _p.maxZoom;\n                json.panningEnabled = _p.panningEnabled;\n                json.userPanningEnabled = _p.userPanningEnabled;\n                json.pan = copy(_p.pan);\n                json.boxSelectionEnabled = _p.boxSelectionEnabled;\n                json.renderer = copy(options.renderer);\n                json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n                json.textureOnViewport = options.textureOnViewport;\n                json.wheelSensitivity = options.wheelSensitivity;\n                json.motionBlur = options.motionBlur;\n                json.multiClickDebounceTime = options.multiClickDebounceTime;\n                return json;\n            }\n        }\n    });\n    corefn.$id = corefn.getElementById;\n    [\n        corefn$9,\n        corefn$8,\n        elesfn,\n        corefn$7,\n        corefn$6,\n        corefn$5,\n        corefn$4,\n        corefn$3,\n        corefn$2,\n        corefn$1,\n        fn\n    ].forEach(function(props) {\n        extend(corefn, props);\n    });\n    /* eslint-disable no-unused-vars */ var defaults$7 = {\n        fit: true,\n        // whether to fit the viewport to the graph\n        directed: false,\n        // whether the tree is directed downwards (or edges can point in any direction if false)\n        padding: 30,\n        // padding on fit\n        circle: false,\n        // put depths in concentric circles if true, put depths top down if false\n        grid: false,\n        // whether to create an even grid into which the DAG is placed (circle:false only)\n        spacingFactor: 1.75,\n        // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        avoidOverlap: true,\n        // prevents node overlap, may overflow boundingBox if not enough space\n        nodeDimensionsIncludeLabels: false,\n        // Excludes the label when calculating node bounding boxes for the layout algorithm\n        roots: undefined,\n        // the roots of the trees\n        depthSort: undefined,\n        // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled,\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts\n    };\n    var deprecatedOptionDefaults = {\n        maximal: false,\n        // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n        acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n    };\n    /* eslint-enable */ var getInfo = function getInfo(ele) {\n        return ele.scratch(\"breadthfirst\");\n    };\n    var setInfo = function setInfo(ele, obj) {\n        return ele.scratch(\"breadthfirst\", obj);\n    };\n    function BreadthFirstLayout(options) {\n        this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n    }\n    BreadthFirstLayout.prototype.run = function() {\n        var params = this.options;\n        var options = params;\n        var cy = params.cy;\n        var eles = options.eles;\n        var nodes = eles.nodes().filter(function(n) {\n            return !n.isParent();\n        });\n        var graph = eles;\n        var directed = options.directed;\n        var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n        var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n            x1: 0,\n            y1: 0,\n            w: cy.width(),\n            h: cy.height()\n        });\n        var roots;\n        if (elementOrCollection(options.roots)) {\n            roots = options.roots;\n        } else if (array(options.roots)) {\n            var rootsArray = [];\n            for(var i = 0; i < options.roots.length; i++){\n                var id = options.roots[i];\n                var ele = cy.getElementById(id);\n                rootsArray.push(ele);\n            }\n            roots = cy.collection(rootsArray);\n        } else if (string(options.roots)) {\n            roots = cy.$(options.roots);\n        } else {\n            if (directed) {\n                roots = nodes.roots();\n            } else {\n                var components = eles.components();\n                roots = cy.collection();\n                var _loop = function _loop(_i) {\n                    var comp = components[_i];\n                    var maxDegree = comp.maxDegree(false);\n                    var compRoots = comp.filter(function(ele) {\n                        return ele.degree(false) === maxDegree;\n                    });\n                    roots = roots.add(compRoots);\n                };\n                for(var _i = 0; _i < components.length; _i++){\n                    _loop(_i);\n                }\n            }\n        }\n        var depths = [];\n        var foundByBfs = {};\n        var addToDepth = function addToDepth(ele, d) {\n            if (depths[d] == null) {\n                depths[d] = [];\n            }\n            var i = depths[d].length;\n            depths[d].push(ele);\n            setInfo(ele, {\n                index: i,\n                depth: d\n            });\n        };\n        var changeDepth = function changeDepth(ele, newDepth) {\n            var _getInfo = getInfo(ele), depth = _getInfo.depth, index = _getInfo.index;\n            depths[depth][index] = null;\n            addToDepth(ele, newDepth);\n        }; // find the depths of the nodes\n        graph.bfs({\n            roots: roots,\n            directed: options.directed,\n            visit: function visit(node, edge, pNode, i, depth) {\n                var ele = node[0];\n                var id = ele.id();\n                addToDepth(ele, depth);\n                foundByBfs[id] = true;\n            }\n        }); // check for nodes not found by bfs\n        var orphanNodes = [];\n        for(var _i2 = 0; _i2 < nodes.length; _i2++){\n            var _ele = nodes[_i2];\n            if (foundByBfs[_ele.id()]) {\n                continue;\n            } else {\n                orphanNodes.push(_ele);\n            }\n        } // assign the nodes a depth and index\n        var assignDepthsAt = function assignDepthsAt(i) {\n            var eles = depths[i];\n            for(var j = 0; j < eles.length; j++){\n                var _ele2 = eles[j];\n                if (_ele2 == null) {\n                    eles.splice(j, 1);\n                    j--;\n                    continue;\n                }\n                setInfo(_ele2, {\n                    depth: i,\n                    index: j\n                });\n            }\n        };\n        var assignDepths = function assignDepths() {\n            for(var _i3 = 0; _i3 < depths.length; _i3++){\n                assignDepthsAt(_i3);\n            }\n        };\n        var adjustMaximally = function adjustMaximally(ele, shifted) {\n            var eInfo = getInfo(ele);\n            var incomers = ele.incomers().filter(function(el) {\n                return el.isNode() && eles.has(el);\n            });\n            var maxDepth = -1;\n            var id = ele.id();\n            for(var k = 0; k < incomers.length; k++){\n                var incmr = incomers[k];\n                var iInfo = getInfo(incmr);\n                maxDepth = Math.max(maxDepth, iInfo.depth);\n            }\n            if (eInfo.depth <= maxDepth) {\n                if (!options.acyclic && shifted[id]) {\n                    return null;\n                }\n                var newDepth = maxDepth + 1;\n                changeDepth(ele, newDepth);\n                shifted[id] = newDepth;\n                return true;\n            }\n            return false;\n        }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n        if (directed && maximal) {\n            var Q = [];\n            var shifted = {};\n            var enqueue = function enqueue(n) {\n                return Q.push(n);\n            };\n            var dequeue = function dequeue() {\n                return Q.shift();\n            };\n            nodes.forEach(function(n) {\n                return Q.push(n);\n            });\n            while(Q.length > 0){\n                var _ele3 = dequeue();\n                var didShift = adjustMaximally(_ele3, shifted);\n                if (didShift) {\n                    _ele3.outgoers().filter(function(el) {\n                        return el.isNode() && eles.has(el);\n                    }).forEach(enqueue);\n                } else if (didShift === null) {\n                    warn(\"Detected double maximal shift for node `\" + _ele3.id() + \"`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.\");\n                    break; // exit on failure\n                }\n            }\n        }\n        assignDepths(); // clear holes\n        // find min distance we need to leave between nodes\n        var minDistance = 0;\n        if (options.avoidOverlap) {\n            for(var _i4 = 0; _i4 < nodes.length; _i4++){\n                var n = nodes[_i4];\n                var nbb = n.layoutDimensions(options);\n                var w = nbb.w;\n                var h = nbb.h;\n                minDistance = Math.max(minDistance, w, h);\n            }\n        } // get the weighted percent for an element based on its connectivity to other levels\n        var cachedWeightedPercent = {};\n        var getWeightedPercent = function getWeightedPercent(ele) {\n            if (cachedWeightedPercent[ele.id()]) {\n                return cachedWeightedPercent[ele.id()];\n            }\n            var eleDepth = getInfo(ele).depth;\n            var neighbors = ele.neighborhood();\n            var percent = 0;\n            var samples = 0;\n            for(var _i5 = 0; _i5 < neighbors.length; _i5++){\n                var neighbor = neighbors[_i5];\n                if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n                    continue;\n                }\n                var bf = getInfo(neighbor);\n                if (bf == null) {\n                    continue;\n                }\n                var index = bf.index;\n                var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering\n                if (index == null || depth == null) {\n                    continue;\n                }\n                var nDepth = depths[depth].length;\n                if (depth < eleDepth) {\n                    // only get influenced by elements above\n                    percent += index / nDepth;\n                    samples++;\n                }\n            }\n            samples = Math.max(1, samples);\n            percent = percent / samples;\n            if (samples === 0) {\n                // put lone nodes at the start\n                percent = 0;\n            }\n            cachedWeightedPercent[ele.id()] = percent;\n            return percent;\n        }; // rearrange the indices in each depth level based on connectivity\n        var sortFn = function sortFn(a, b) {\n            var apct = getWeightedPercent(a);\n            var bpct = getWeightedPercent(b);\n            var diff = apct - bpct;\n            if (diff === 0) {\n                return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n            } else {\n                return diff;\n            }\n        };\n        if (options.depthSort !== undefined) {\n            sortFn = options.depthSort;\n        } // sort each level to make connected nodes closer\n        for(var _i6 = 0; _i6 < depths.length; _i6++){\n            depths[_i6].sort(sortFn);\n            assignDepthsAt(_i6);\n        } // assign orphan nodes to a new top-level depth\n        var orphanDepth = [];\n        for(var _i7 = 0; _i7 < orphanNodes.length; _i7++){\n            orphanDepth.push(orphanNodes[_i7]);\n        }\n        depths.unshift(orphanDepth);\n        assignDepths();\n        var biggestDepthSize = 0;\n        for(var _i8 = 0; _i8 < depths.length; _i8++){\n            biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n        }\n        var center = {\n            x: bb.x1 + bb.w / 2,\n            y: bb.x1 + bb.h / 2\n        };\n        var maxDepthSize = depths.reduce(function(max, eles) {\n            return Math.max(max, eles.length);\n        }, 0);\n        var getPosition = function getPosition(ele) {\n            var _getInfo2 = getInfo(ele), depth = _getInfo2.depth, index = _getInfo2.index;\n            var depthSize = depths[depth].length;\n            var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n            var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n            var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n            radiusStepSize = Math.max(radiusStepSize, minDistance);\n            if (!options.circle) {\n                var epos = {\n                    x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n                    y: (depth + 1) * distanceY\n                };\n                return epos;\n            } else {\n                var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n                var theta = 2 * Math.PI / depths[depth].length * index;\n                if (depth === 0 && depths[0].length === 1) {\n                    radius = 1;\n                }\n                return {\n                    x: center.x + radius * Math.cos(theta),\n                    y: center.y + radius * Math.sin(theta)\n                };\n            }\n        };\n        eles.nodes().layoutPositions(this, options, getPosition);\n        return this; // chaining\n    };\n    var defaults$6 = {\n        fit: true,\n        // whether to fit the viewport to the graph\n        padding: 30,\n        // the padding on fit\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        avoidOverlap: true,\n        // prevents node overlap, may overflow boundingBox and radius if not enough space\n        nodeDimensionsIncludeLabels: false,\n        // Excludes the label when calculating node bounding boxes for the layout algorithm\n        spacingFactor: undefined,\n        // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n        radius: undefined,\n        // the radius of the circle\n        startAngle: 3 / 2 * Math.PI,\n        // where nodes start in radians\n        sweep: undefined,\n        // how many radians should be between the first and last node (defaults to full circle)\n        clockwise: true,\n        // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n        sort: undefined,\n        // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts \n    };\n    function CircleLayout(options) {\n        this.options = extend({}, defaults$6, options);\n    }\n    CircleLayout.prototype.run = function() {\n        var params = this.options;\n        var options = params;\n        var cy = params.cy;\n        var eles = options.eles;\n        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n        var nodes = eles.nodes().not(\":parent\");\n        if (options.sort) {\n            nodes = nodes.sort(options.sort);\n        }\n        var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n            x1: 0,\n            y1: 0,\n            w: cy.width(),\n            h: cy.height()\n        });\n        var center = {\n            x: bb.x1 + bb.w / 2,\n            y: bb.y1 + bb.h / 2\n        };\n        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n        var dTheta = sweep / Math.max(1, nodes.length - 1);\n        var r;\n        var minDistance = 0;\n        for(var i = 0; i < nodes.length; i++){\n            var n = nodes[i];\n            var nbb = n.layoutDimensions(options);\n            var w = nbb.w;\n            var h = nbb.h;\n            minDistance = Math.max(minDistance, w, h);\n        }\n        if (number$1(options.radius)) {\n            r = options.radius;\n        } else if (nodes.length <= 1) {\n            r = 0;\n        } else {\n            r = Math.min(bb.h, bb.w) / 2 - minDistance;\n        } // calculate the radius\n        if (nodes.length > 1 && options.avoidOverlap) {\n            // but only if more than one node (can't overlap)\n            minDistance *= 1.75; // just to have some nice spacing\n            var dcos = Math.cos(dTheta) - Math.cos(0);\n            var dsin = Math.sin(dTheta) - Math.sin(0);\n            var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n            r = Math.max(rMin, r);\n        }\n        var getPos = function getPos(ele, i) {\n            var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n            var rx = r * Math.cos(theta);\n            var ry = r * Math.sin(theta);\n            var pos = {\n                x: center.x + rx,\n                y: center.y + ry\n            };\n            return pos;\n        };\n        eles.nodes().layoutPositions(this, options, getPos);\n        return this; // chaining\n    };\n    var defaults$5 = {\n        fit: true,\n        // whether to fit the viewport to the graph\n        padding: 30,\n        // the padding on fit\n        startAngle: 3 / 2 * Math.PI,\n        // where nodes start in radians\n        sweep: undefined,\n        // how many radians should be between the first and last node (defaults to full circle)\n        clockwise: true,\n        // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n        equidistant: false,\n        // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n        minNodeSpacing: 10,\n        // min spacing between outside of nodes (used for radius adjustment)\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        avoidOverlap: true,\n        // prevents node overlap, may overflow boundingBox if not enough space\n        nodeDimensionsIncludeLabels: false,\n        // Excludes the label when calculating node bounding boxes for the layout algorithm\n        height: undefined,\n        // height of layout area (overrides container height)\n        width: undefined,\n        // width of layout area (overrides container width)\n        spacingFactor: undefined,\n        // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n        concentric: function concentric(node) {\n            // returns numeric value for each node, placing higher nodes in levels towards the centre\n            return node.degree();\n        },\n        levelWidth: function levelWidth(nodes) {\n            // the variation of concentric values in each level\n            return nodes.maxDegree() / 4;\n        },\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts\n    };\n    function ConcentricLayout(options) {\n        this.options = extend({}, defaults$5, options);\n    }\n    ConcentricLayout.prototype.run = function() {\n        var params = this.options;\n        var options = params;\n        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n        var cy = params.cy;\n        var eles = options.eles;\n        var nodes = eles.nodes().not(\":parent\");\n        var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n            x1: 0,\n            y1: 0,\n            w: cy.width(),\n            h: cy.height()\n        });\n        var center = {\n            x: bb.x1 + bb.w / 2,\n            y: bb.y1 + bb.h / 2\n        };\n        var nodeValues = []; // { node, value }\n        var maxNodeSize = 0;\n        for(var i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            var value = void 0; // calculate the node value\n            value = options.concentric(node);\n            nodeValues.push({\n                value: value,\n                node: node\n            }); // for style mapping\n            node._private.scratch.concentric = value;\n        } // in case we used the `concentric` in style\n        nodes.updateStyle(); // calculate max size now based on potentially updated mappers\n        for(var _i = 0; _i < nodes.length; _i++){\n            var _node = nodes[_i];\n            var nbb = _node.layoutDimensions(options);\n            maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n        } // sort node values in descreasing order\n        nodeValues.sort(function(a, b) {\n            return b.value - a.value;\n        });\n        var levelWidth = options.levelWidth(nodes); // put the values into levels\n        var levels = [\n            []\n        ];\n        var currentLevel = levels[0];\n        for(var _i2 = 0; _i2 < nodeValues.length; _i2++){\n            var val = nodeValues[_i2];\n            if (currentLevel.length > 0) {\n                var diff = Math.abs(currentLevel[0].value - val.value);\n                if (diff >= levelWidth) {\n                    currentLevel = [];\n                    levels.push(currentLevel);\n                }\n            }\n            currentLevel.push(val);\n        } // create positions from levels\n        var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n        if (!options.avoidOverlap) {\n            // then strictly constrain to bb\n            var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n            var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n            var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n            minDist = Math.min(minDist, rStep);\n        } // find the metrics for each level\n        var r = 0;\n        for(var _i3 = 0; _i3 < levels.length; _i3++){\n            var level = levels[_i3];\n            var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n            var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n            if (level.length > 1 && options.avoidOverlap) {\n                // but only if more than one node (can't overlap)\n                var dcos = Math.cos(dTheta) - Math.cos(0);\n                var dsin = Math.sin(dTheta) - Math.sin(0);\n                var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n                r = Math.max(rMin, r);\n            }\n            level.r = r;\n            r += minDist;\n        }\n        if (options.equidistant) {\n            var rDeltaMax = 0;\n            var _r = 0;\n            for(var _i4 = 0; _i4 < levels.length; _i4++){\n                var _level = levels[_i4];\n                var rDelta = _level.r - _r;\n                rDeltaMax = Math.max(rDeltaMax, rDelta);\n            }\n            _r = 0;\n            for(var _i5 = 0; _i5 < levels.length; _i5++){\n                var _level2 = levels[_i5];\n                if (_i5 === 0) {\n                    _r = _level2.r;\n                }\n                _level2.r = _r;\n                _r += rDeltaMax;\n            }\n        } // calculate the node positions\n        var pos = {}; // id => position\n        for(var _i6 = 0; _i6 < levels.length; _i6++){\n            var _level3 = levels[_i6];\n            var _dTheta = _level3.dTheta;\n            var _r2 = _level3.r;\n            for(var j = 0; j < _level3.length; j++){\n                var _val = _level3[j];\n                var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n                var p = {\n                    x: center.x + _r2 * Math.cos(theta),\n                    y: center.y + _r2 * Math.sin(theta)\n                };\n                pos[_val.node.id()] = p;\n            }\n        } // position the nodes\n        eles.nodes().layoutPositions(this, options, function(ele) {\n            var id = ele.id();\n            return pos[id];\n        });\n        return this; // chaining\n    };\n    /*\n  The CoSE layout was written by Gerardo Huck.\n  https://www.linkedin.com/in/gerardohuck/\n\n  Based on the following article:\n  http://dl.acm.org/citation.cfm?id=1498047\n\n  Modifications tracked on Github.\n  */ var DEBUG;\n    /**\n   * @brief :  default layout options\n   */ var defaults$4 = {\n        // Called on `layoutready`\n        ready: function ready() {},\n        // Called on `layoutstop`\n        stop: function stop() {},\n        // Whether to animate while running the layout\n        // true : Animate continuously as the layout is running\n        // false : Just show the end result\n        // 'end' : Animate with the end result, from the initial positions to the end positions\n        animate: true,\n        // Easing of the animation for animate:'end'\n        animationEasing: undefined,\n        // The duration of the animation for animate:'end'\n        animationDuration: undefined,\n        // A function that determines whether the node should be animated\n        // All nodes animated by default on animate enabled\n        // Non-animated nodes are positioned immediately when the layout starts\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // The layout animates only after this many milliseconds for animate:true\n        // (prevents flashing on fast runs)\n        animationThreshold: 250,\n        // Number of iterations between consecutive screen positions update\n        refresh: 20,\n        // Whether to fit the network view after when done\n        fit: true,\n        // Padding on fit\n        padding: 30,\n        // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        boundingBox: undefined,\n        // Excludes the label when calculating node bounding boxes for the layout algorithm\n        nodeDimensionsIncludeLabels: false,\n        // Randomize the initial positions of the nodes (true) or use existing positions (false)\n        randomize: false,\n        // Extra spacing between components in non-compound graphs\n        componentSpacing: 40,\n        // Node repulsion (non overlapping) multiplier\n        nodeRepulsion: function nodeRepulsion(node) {\n            return 2048;\n        },\n        // Node repulsion (overlapping) multiplier\n        nodeOverlap: 4,\n        // Ideal edge (non nested) length\n        idealEdgeLength: function idealEdgeLength(edge) {\n            return 32;\n        },\n        // Divisor to compute edge forces\n        edgeElasticity: function edgeElasticity(edge) {\n            return 32;\n        },\n        // Nesting factor (multiplier) to compute ideal edge length for nested edges\n        nestingFactor: 1.2,\n        // Gravity force (constant)\n        gravity: 1,\n        // Maximum number of iterations to perform\n        numIter: 1000,\n        // Initial temperature (maximum node displacement)\n        initialTemp: 1000,\n        // Cooling factor (how the temperature is reduced between consecutive iterations\n        coolingFactor: 0.99,\n        // Lower temperature threshold (below this point the layout will end)\n        minTemp: 1.0\n    };\n    /**\n   * @brief       : constructor\n   * @arg options : object containing layout options\n   */ function CoseLayout(options) {\n        this.options = extend({}, defaults$4, options);\n        this.options.layout = this;\n    }\n    /**\n   * @brief : runs the layout\n   */ CoseLayout.prototype.run = function() {\n        var options = this.options;\n        var cy = options.cy;\n        var layout = this;\n        layout.stopped = false;\n        if (options.animate === true || options.animate === false) {\n            layout.emit({\n                type: \"layoutstart\",\n                layout: layout\n            });\n        } // Set DEBUG - Global variable\n        if (true === options.debug) {\n            DEBUG = true;\n        } else {\n            DEBUG = false;\n        } // Initialize layout info\n        var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging\n        if (DEBUG) {\n            printLayoutInfo(layoutInfo);\n        } // If required, randomize node positions\n        if (options.randomize) {\n            randomizePositions(layoutInfo);\n        }\n        var startTime = performanceNow();\n        var refresh = function refresh() {\n            refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary\n            if (true === options.fit) {\n                cy.fit(options.padding);\n            }\n        };\n        var mainLoop = function mainLoop(i) {\n            if (layout.stopped || i >= options.numIter) {\n                // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n                return false;\n            } // Do one step in the phisical simulation\n            step(layoutInfo, options); // Update temperature\n            layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug(\"New temperature: \" + layoutInfo.temperature);\n            if (layoutInfo.temperature < options.minTemp) {\n                // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n                return false;\n            }\n            return true;\n        };\n        var done = function done() {\n            if (options.animate === true || options.animate === false) {\n                refresh(); // Layout has finished\n                layout.one(\"layoutstop\", options.stop);\n                layout.emit({\n                    type: \"layoutstop\",\n                    layout: layout\n                });\n            } else {\n                var nodes = options.eles.nodes();\n                var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n                nodes.layoutPositions(layout, options, getScaledPos);\n            }\n        };\n        var i = 0;\n        var loopRet = true;\n        if (options.animate === true) {\n            var frame = function frame() {\n                var f = 0;\n                while(loopRet && f < options.refresh){\n                    loopRet = mainLoop(i);\n                    i++;\n                    f++;\n                }\n                if (!loopRet) {\n                    // it's done\n                    separateComponents(layoutInfo, options);\n                    done();\n                } else {\n                    var now = performanceNow();\n                    if (now - startTime >= options.animationThreshold) {\n                        refresh();\n                    }\n                    requestAnimationFrame(frame);\n                }\n            };\n            frame();\n        } else {\n            while(loopRet){\n                loopRet = mainLoop(i);\n                i++;\n            }\n            separateComponents(layoutInfo, options);\n            done();\n        }\n        return this; // chaining\n    };\n    /**\n   * @brief : called on continuous layouts to stop them before they finish\n   */ CoseLayout.prototype.stop = function() {\n        this.stopped = true;\n        if (this.thread) {\n            this.thread.stop();\n        }\n        this.emit(\"layoutstop\");\n        return this; // chaining\n    };\n    CoseLayout.prototype.destroy = function() {\n        if (this.thread) {\n            this.thread.stop();\n        }\n        return this; // chaining\n    };\n    /**\n   * @brief     : Creates an object which is contains all the data\n   *              used in the layout process\n   * @arg cy    : cytoscape.js object\n   * @return    : layoutInfo object initialized\n   */ var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n        // Shortcut\n        var edges = options.eles.edges();\n        var nodes = options.eles.nodes();\n        var layoutInfo = {\n            isCompound: cy.hasCompoundNodes(),\n            layoutNodes: [],\n            idToIndex: {},\n            nodeSize: nodes.size(),\n            graphSet: [],\n            indexToGraph: [],\n            layoutEdges: [],\n            edgeSize: edges.size(),\n            temperature: options.initialTemp,\n            clientWidth: cy.width(),\n            clientHeight: cy.width(),\n            boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {\n                x1: 0,\n                y1: 0,\n                w: cy.width(),\n                h: cy.height()\n            })\n        };\n        var components = options.eles.components();\n        var id2cmptId = {};\n        for(var i = 0; i < components.length; i++){\n            var component = components[i];\n            for(var j = 0; j < component.length; j++){\n                var node = component[j];\n                id2cmptId[node.id()] = i;\n            }\n        } // Iterate over all nodes, creating layout nodes\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = nodes[i];\n            var nbb = n.layoutDimensions(options);\n            var tempNode = {};\n            tempNode.isLocked = n.locked();\n            tempNode.id = n.data(\"id\");\n            tempNode.parentId = n.data(\"parent\");\n            tempNode.cmptId = id2cmptId[n.id()];\n            tempNode.children = [];\n            tempNode.positionX = n.position(\"x\");\n            tempNode.positionY = n.position(\"y\");\n            tempNode.offsetX = 0;\n            tempNode.offsetY = 0;\n            tempNode.height = nbb.w;\n            tempNode.width = nbb.h;\n            tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n            tempNode.minX = tempNode.positionX - tempNode.width / 2;\n            tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n            tempNode.minY = tempNode.positionY - tempNode.height / 2;\n            tempNode.padLeft = parseFloat(n.style(\"padding\"));\n            tempNode.padRight = parseFloat(n.style(\"padding\"));\n            tempNode.padTop = parseFloat(n.style(\"padding\"));\n            tempNode.padBottom = parseFloat(n.style(\"padding\")); // forces\n            tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node\n            layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map\n            layoutInfo.idToIndex[tempNode.id] = i;\n        } // Inline implementation of a queue, used for traversing the graph in BFS order\n        var queue = [];\n        var start = 0; // Points to the start the queue\n        var end = -1; // Points to the end of the queue\n        var tempGraph = []; // Second pass to add child information and\n        // initialize queue for hierarchical traversal\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = layoutInfo.layoutNodes[i];\n            var p_id = n.parentId; // Check if node n has a parent node\n            if (null != p_id) {\n                // Add node Id to parent's list of children\n                layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n            } else {\n                // If a node doesn't have a parent, then it's in the root graph\n                queue[++end] = n.id;\n                tempGraph.push(n.id);\n            }\n        } // Add root graph to graphSet\n        layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,\n        while(start <= end){\n            // Get the node to visit and remove it from queue\n            var node_id = queue[start++];\n            var node_ix = layoutInfo.idToIndex[node_id];\n            var node = layoutInfo.layoutNodes[node_ix];\n            var children = node.children;\n            if (children.length > 0) {\n                // Add children nodes as a new graph to graph set\n                layoutInfo.graphSet.push(children); // Add children to que queue to be visited\n                for(var i = 0; i < children.length; i++){\n                    queue[++end] = children[i];\n                }\n            }\n        } // Create indexToGraph map\n        for(var i = 0; i < layoutInfo.graphSet.length; i++){\n            var graph = layoutInfo.graphSet[i];\n            for(var j = 0; j < graph.length; j++){\n                var index = layoutInfo.idToIndex[graph[j]];\n                layoutInfo.indexToGraph[index] = i;\n            }\n        } // Iterate over all edges, creating Layout Edges\n        for(var i = 0; i < layoutInfo.edgeSize; i++){\n            var e = edges[i];\n            var tempEdge = {};\n            tempEdge.id = e.data(\"id\");\n            tempEdge.sourceId = e.data(\"source\");\n            tempEdge.targetId = e.data(\"target\"); // Compute ideal length\n            var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n            var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge\n            var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n            var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n            var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n            var targetGraph = layoutInfo.indexToGraph[targetIx];\n            if (sourceGraph != targetGraph) {\n                // Find lowest common graph ancestor\n                var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph\n                var lcaGraph = layoutInfo.graphSet[lca];\n                var depth = 0; // Source depth\n                var tempNode = layoutInfo.layoutNodes[sourceIx];\n                while(-1 === lcaGraph.indexOf(tempNode.id)){\n                    tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                    depth++;\n                } // Target depth\n                tempNode = layoutInfo.layoutNodes[targetIx];\n                while(-1 === lcaGraph.indexOf(tempNode.id)){\n                    tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                    depth++;\n                } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n                //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n                //  \". Depth: \" + depth);\n                // Update idealLength\n                idealLength *= depth * options.nestingFactor;\n            }\n            tempEdge.idealLength = idealLength;\n            tempEdge.elasticity = elasticity;\n            layoutInfo.layoutEdges.push(tempEdge);\n        } // Finally, return layoutInfo object\n        return layoutInfo;\n    };\n    /**\n   * @brief : This function finds the index of the lowest common\n   *          graph ancestor between 2 nodes in the subtree\n   *          (from the graph hierarchy induced tree) whose\n   *          root is graphIx\n   *\n   * @arg node1: node1's ID\n   * @arg node2: node2's ID\n   * @arg layoutInfo: layoutInfo object\n   *\n   */ var findLCA = function findLCA(node1, node2, layoutInfo) {\n        // Find their common ancester, starting from the root graph\n        var res = findLCA_aux(node1, node2, 0, layoutInfo);\n        if (2 > res.count) {\n            // If aux function couldn't find the common ancester,\n            // then it is the root graph\n            return 0;\n        } else {\n            return res.graph;\n        }\n    };\n    /**\n   * @brief          : Auxiliary function used for LCA computation\n   *\n   * @arg node1      : node1's ID\n   * @arg node2      : node2's ID\n   * @arg graphIx    : subgraph index\n   * @arg layoutInfo : layoutInfo object\n   *\n   * @return         : object of the form {count: X, graph: Y}, where:\n   *                   X is the number of ancestors (max: 2) found in\n   *                   graphIx (and it's subgraphs),\n   *                   Y is the graph index of the lowest graph containing\n   *                   all X nodes\n   */ var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n        var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx\n        if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n            return {\n                count: 2,\n                graph: graphIx\n            };\n        } // Make recursive calls for all subgraphs\n        var c = 0;\n        for(var i = 0; i < graph.length; i++){\n            var nodeId = graph[i];\n            var nodeIx = layoutInfo.idToIndex[nodeId];\n            var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it\n            if (0 === children.length) {\n                continue;\n            }\n            var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n            var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n            if (0 === result.count) {\n                continue;\n            } else if (1 === result.count) {\n                // One of (node1, node2) is present in this subgraph\n                c++;\n                if (2 === c) {\n                    break;\n                }\n            } else {\n                // Both nodes are present in this subgraph\n                return result;\n            }\n        }\n        return {\n            count: c,\n            graph: graphIx\n        };\n    };\n    /**\n   * @brief: printsLayoutInfo into js console\n   *         Only used for debbuging\n   */ var printLayoutInfo;\n    /**\n   * @brief : Randomizes the position of all nodes\n   */ var randomizePositions = function randomizePositions(layoutInfo, cy) {\n        var width = layoutInfo.clientWidth;\n        var height = layoutInfo.clientHeight;\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes\n            if (0 === n.children.length && !n.isLocked) {\n                n.positionX = Math.random() * width;\n                n.positionY = Math.random() * height;\n            }\n        }\n    };\n    var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n        var bb = layoutInfo.boundingBox;\n        var coseBB = {\n            x1: Infinity,\n            x2: -Infinity,\n            y1: Infinity,\n            y2: -Infinity\n        };\n        if (options.boundingBox) {\n            nodes.forEach(function(node) {\n                var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data(\"id\")]];\n                coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n                coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n                coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n                coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n            });\n            coseBB.w = coseBB.x2 - coseBB.x1;\n            coseBB.h = coseBB.y2 - coseBB.y1;\n        }\n        return function(ele, i) {\n            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data(\"id\")]];\n            if (options.boundingBox) {\n                // then add extra bounding box constraint\n                var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n                var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n                return {\n                    x: bb.x1 + pctX * bb.w,\n                    y: bb.y1 + pctY * bb.h\n                };\n            } else {\n                return {\n                    x: lnode.positionX,\n                    y: lnode.positionY\n                };\n            }\n        };\n    };\n    /**\n   * @brief          : Updates the positions of nodes in the network\n   * @arg layoutInfo : LayoutInfo object\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */ var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n        // var s = 'Refreshing positions';\n        // logDebug(s);\n        var layout = options.layout;\n        var nodes = options.eles.nodes();\n        var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n        nodes.positions(getScaledPos); // Trigger layoutReady only on first call\n        if (true !== layoutInfo.ready) {\n            // s = 'Triggering layoutready';\n            // logDebug(s);\n            layoutInfo.ready = true;\n            layout.one(\"layoutready\", options.ready);\n            layout.emit({\n                type: \"layoutready\",\n                layout: this\n            });\n        }\n    };\n    /**\n   * @brief : Logs a debug message in JS console, if DEBUG is ON\n   */ // var logDebug = function(text) {\n    //   if (DEBUG) {\n    //     console.debug(text);\n    //   }\n    // };\n    /**\n   * @brief          : Performs one iteration of the physical simulation\n   * @arg layoutInfo : LayoutInfo object already initialized\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */ var step = function step(layoutInfo, options, _step) {\n        // var s = \"\\n\\n###############################\";\n        // s += \"\\nSTEP: \" + step;\n        // s += \"\\n###############################\\n\";\n        // logDebug(s);\n        // Calculate node repulsions\n        calculateNodeForces(layoutInfo, options); // Calculate edge forces\n        calculateEdgeForces(layoutInfo); // Calculate gravity forces\n        calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child\n        propagateForces(layoutInfo); // Update positions based on calculated forces\n        updatePositions(layoutInfo);\n    };\n    /**\n   * @brief : Computes the node repulsion forces\n   */ var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n        // Go through each of the graphs in graphSet\n        // Nodes only repel each other if they belong to the same graph\n        // var s = 'calculateNodeForces';\n        // logDebug(s);\n        for(var i = 0; i < layoutInfo.graphSet.length; i++){\n            var graph = layoutInfo.graphSet[i];\n            var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n            // logDebug(s);\n            // Now get all the pairs of nodes\n            // Only get each pair once, (A, B) = (B, A)\n            for(var j = 0; j < numNodes; j++){\n                var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n                for(var k = j + 1; k < numNodes; k++){\n                    var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n                    nodeRepulsion(node1, node2, layoutInfo, options);\n                }\n            }\n        }\n    };\n    var randomDistance = function randomDistance(max) {\n        return -max + 2 * max * Math.random();\n    };\n    /**\n   * @brief : Compute the node repulsion forces between a pair of nodes\n   */ var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n        // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n        var cmptId1 = node1.cmptId;\n        var cmptId2 = node2.cmptId;\n        if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n            return;\n        } // Get direction of line connecting both node centers\n        var directionX = node2.positionX - node1.positionX;\n        var directionY = node2.positionY - node1.positionY;\n        var maxRandDist = 1; // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n        // If both centers are the same, apply a random force\n        if (0 === directionX && 0 === directionY) {\n            directionX = randomDistance(maxRandDist);\n            directionY = randomDistance(maxRandDist);\n        }\n        var overlap = nodesOverlap(node1, node2, directionX, directionY);\n        if (overlap > 0) {\n            // s += \"\\nNodes DO overlap.\";\n            // s += \"\\nOverlap: \" + overlap;\n            // If nodes overlap, repulsion force is proportional\n            // to the overlap\n            var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector\n            var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += \"\\nDistance: \" + distance;\n            var forceX = force * directionX / distance;\n            var forceY = force * directionY / distance;\n        } else {\n            // s += \"\\nNodes do NOT overlap.\";\n            // If there's no overlap, force is inversely proportional\n            // to squared distance\n            // Get clipping points for both nodes\n            var point1 = findClippingPoint(node1, directionX, directionY);\n            var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance\n            var distanceX = point2.x - point1.x;\n            var distanceY = point2.y - point1.y;\n            var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n            var distance = Math.sqrt(distanceSqr); // s += \"\\nDistance: \" + distance;\n            // Compute the module and components of the force vector\n            var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n            var forceX = force * distanceX / distance;\n            var forceY = force * distanceY / distance;\n        } // Apply force\n        if (!node1.isLocked) {\n            node1.offsetX -= forceX;\n            node1.offsetY -= forceY;\n        }\n        if (!node2.isLocked) {\n            node2.offsetX += forceX;\n            node2.offsetY += forceY;\n        } // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n        // logDebug(s);\n        return;\n    };\n    /**\n   * @brief  : Determines whether two nodes overlap or not\n   * @return : Amount of overlapping (0 => no overlap)\n   */ var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n        if (dX > 0) {\n            var overlapX = node1.maxX - node2.minX;\n        } else {\n            var overlapX = node2.maxX - node1.minX;\n        }\n        if (dY > 0) {\n            var overlapY = node1.maxY - node2.minY;\n        } else {\n            var overlapY = node2.maxY - node1.minY;\n        }\n        if (overlapX >= 0 && overlapY >= 0) {\n            return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n        } else {\n            return 0;\n        }\n    };\n    /**\n   * @brief : Finds the point in which an edge (direction dX, dY) intersects\n   *          the rectangular bounding box of it's source/target node\n   */ var findClippingPoint = function findClippingPoint(node, dX, dY) {\n        // Shorcuts\n        var X = node.positionX;\n        var Y = node.positionY;\n        var H = node.height || 1;\n        var W = node.width || 1;\n        var dirSlope = dY / dX;\n        var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +\n        //   \" . Height:  \" + H + \", Width: \" + W +\n        //   \"\\nDirection \" + dX + \", \" + dY;\n        //\n        // Compute intersection\n        var res = {}; // Case: Vertical direction (up)\n        if (0 === dX && 0 < dY) {\n            res.x = X; // s += \"\\nUp direction\";\n            res.y = Y + H / 2;\n            return res;\n        } // Case: Vertical direction (down)\n        if (0 === dX && 0 > dY) {\n            res.x = X;\n            res.y = Y + H / 2; // s += \"\\nDown direction\";\n            return res;\n        } // Case: Intersects the right border\n        if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n            res.x = X + W / 2;\n            res.y = Y + W * dY / 2 / dX; // s += \"\\nRightborder\";\n            return res;\n        } // Case: Intersects the left border\n        if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n            res.x = X - W / 2;\n            res.y = Y - W * dY / 2 / dX; // s += \"\\nLeftborder\";\n            return res;\n        } // Case: Intersects the top border\n        if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n            res.x = X + H * dX / 2 / dY;\n            res.y = Y + H / 2; // s += \"\\nTop border\";\n            return res;\n        } // Case: Intersects the bottom border\n        if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n            res.x = X - H * dX / 2 / dY;\n            res.y = Y - H / 2; // s += \"\\nBottom border\";\n            return res;\n        } // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n        // logDebug(s);\n        return res;\n    };\n    /**\n   * @brief : Calculates all edge forces\n   */ var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n        // Iterate over all edges\n        for(var i = 0; i < layoutInfo.edgeSize; i++){\n            // Get edge, source & target nodes\n            var edge = layoutInfo.layoutEdges[i];\n            var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n            var source = layoutInfo.layoutNodes[sourceIx];\n            var targetIx = layoutInfo.idToIndex[edge.targetId];\n            var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers\n            var directionX = target.positionX - source.positionX;\n            var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.\n            // A random force has already been applied as node repulsion\n            if (0 === directionX && 0 === directionY) {\n                continue;\n            } // Get clipping points for both nodes\n            var point1 = findClippingPoint(source, directionX, directionY);\n            var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n            var lx = point2.x - point1.x;\n            var ly = point2.y - point1.y;\n            var l = Math.sqrt(lx * lx + ly * ly);\n            var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n            if (0 !== l) {\n                var forceX = force * lx / l;\n                var forceY = force * ly / l;\n            } else {\n                var forceX = 0;\n                var forceY = 0;\n            } // Add this force to target and source nodes\n            if (!source.isLocked) {\n                source.offsetX += forceX;\n                source.offsetY += forceY;\n            }\n            if (!target.isLocked) {\n                target.offsetX -= forceX;\n                target.offsetY -= forceY;\n            } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n        // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n        // logDebug(s);\n        }\n    };\n    /**\n   * @brief : Computes gravity forces for all nodes\n   */ var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n        if (options.gravity === 0) {\n            return;\n        }\n        var distThreshold = 1; // var s = 'calculateGravityForces';\n        // logDebug(s);\n        for(var i = 0; i < layoutInfo.graphSet.length; i++){\n            var graph = layoutInfo.graphSet[i];\n            var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n            // logDebug(s);\n            // Compute graph center\n            if (0 === i) {\n                var centerX = layoutInfo.clientHeight / 2;\n                var centerY = layoutInfo.clientWidth / 2;\n            } else {\n                // Get Parent node for this graph, and use its position as center\n                var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n                var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n                var centerX = parent.positionX;\n                var centerY = parent.positionY;\n            } // s = \"Center found at: \" + centerX + \", \" + centerY;\n            // logDebug(s);\n            // Apply force to all nodes in graph\n            for(var j = 0; j < numNodes; j++){\n                var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = \"Node: \" + node.id;\n                if (node.isLocked) {\n                    continue;\n                }\n                var dx = centerX - node.positionX;\n                var dy = centerY - node.positionY;\n                var d = Math.sqrt(dx * dx + dy * dy);\n                if (d > distThreshold) {\n                    var fx = options.gravity * dx / d;\n                    var fy = options.gravity * dy / d;\n                    node.offsetX += fx;\n                    node.offsetY += fy; // s += \": Applied force: \" + fx + \", \" + fy;\n                } // logDebug(s);\n            }\n        }\n    };\n    /**\n   * @brief          : This function propagates the existing offsets from\n   *                   parent nodes to its descendents.\n   * @arg layoutInfo : layoutInfo Object\n   * @arg cy         : cytoscape Object\n   * @arg options    : Layout options\n   */ var propagateForces = function propagateForces(layoutInfo, options) {\n        // Inline implementation of a queue, used for traversing the graph in BFS order\n        var queue = [];\n        var start = 0; // Points to the start the queue\n        var end = -1; // Points to the end of the queue\n        // logDebug('propagateForces');\n        // Start by visiting the nodes in the root graph\n        queue.push.apply(queue, layoutInfo.graphSet[0]);\n        end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,\n        while(start <= end){\n            // Get the node to visit and remove it from queue\n            var nodeId = queue[start++];\n            var nodeIndex = layoutInfo.idToIndex[nodeId];\n            var node = layoutInfo.layoutNodes[nodeIndex];\n            var children = node.children; // We only need to process the node if it's compound\n            if (0 < children.length && !node.isLocked) {\n                var offX = node.offsetX;\n                var offY = node.offsetY; // var s = \"Propagating offset from parent node : \" + node.id +\n                //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n                // s += \"\\n Children: \" + children.toString();\n                // logDebug(s);\n                for(var i = 0; i < children.length; i++){\n                    var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset\n                    childNode.offsetX += offX;\n                    childNode.offsetY += offY; // Add children to queue to be visited\n                    queue[++end] = children[i];\n                } // Reset parent offsets\n                node.offsetX = 0;\n                node.offsetY = 0;\n            }\n        }\n    };\n    /**\n   * @brief : Updates the layout model positions, based on\n   *          the accumulated forces\n   */ var updatePositions = function updatePositions(layoutInfo, options) {\n        // var s = 'Updating positions';\n        // logDebug(s);\n        // Reset boundaries for compound nodes\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = layoutInfo.layoutNodes[i];\n            if (0 < n.children.length) {\n                // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n                n.maxX = undefined;\n                n.minX = undefined;\n                n.maxY = undefined;\n                n.minY = undefined;\n            }\n        }\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = layoutInfo.layoutNodes[i];\n            if (0 < n.children.length || n.isLocked) {\n                continue;\n            } // s = \"Node: \" + n.id + \" Previous position: (\" +\n            // n.positionX + \", \" + n.positionY + \").\";\n            // Limit displacement in order to improve stability\n            var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n            n.positionX += tempForce.x;\n            n.positionY += tempForce.y;\n            n.offsetX = 0;\n            n.offsetY = 0;\n            n.minX = n.positionX - n.width;\n            n.maxX = n.positionX + n.width;\n            n.minY = n.positionY - n.height;\n            n.maxY = n.positionY + n.height; // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n            // logDebug(s);\n            // Update ancestry boudaries\n            updateAncestryBoundaries(n, layoutInfo);\n        } // Update size, position of compund nodes\n        for(var i = 0; i < layoutInfo.nodeSize; i++){\n            var n = layoutInfo.layoutNodes[i];\n            if (0 < n.children.length && !n.isLocked) {\n                n.positionX = (n.maxX + n.minX) / 2;\n                n.positionY = (n.maxY + n.minY) / 2;\n                n.width = n.maxX - n.minX;\n                n.height = n.maxY - n.minY; // s = \"Updating position, size of compound node \" + n.id;\n            // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n            // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n            // logDebug(s);\n            }\n        }\n    };\n    /**\n   * @brief : Limits a force (forceX, forceY) to be not\n   *          greater (in modulo) than max.\n   8          Preserves force direction.\n    */ var limitForce = function limitForce(forceX, forceY, max) {\n        // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n        var force = Math.sqrt(forceX * forceX + forceY * forceY);\n        if (force > max) {\n            var res = {\n                x: max * forceX / force,\n                y: max * forceY / force\n            };\n        } else {\n            var res = {\n                x: forceX,\n                y: forceY\n            };\n        } // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n        // logDebug(s);\n        return res;\n    };\n    /**\n   * @brief : Function used for keeping track of compound node\n   *          sizes, since they should bound all their subnodes.\n   */ var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n        // var s = \"Propagating new position/size of node \" + node.id;\n        var parentId = node.parentId;\n        if (null == parentId) {\n            // If there's no parent, we are done\n            // s += \". No parent node.\";\n            // logDebug(s);\n            return;\n        } // Get Parent Node\n        var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n        var flag = false; // MaxX\n        if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n            p.maxX = node.maxX + p.padRight;\n            flag = true; // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n        } // MinX\n        if (null == p.minX || node.minX - p.padLeft < p.minX) {\n            p.minX = node.minX - p.padLeft;\n            flag = true; // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n        } // MaxY\n        if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n            p.maxY = node.maxY + p.padBottom;\n            flag = true; // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n        } // MinY\n        if (null == p.minY || node.minY - p.padTop < p.minY) {\n            p.minY = node.minY - p.padTop;\n            flag = true; // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n        } // If updated boundaries, propagate changes upward\n        if (flag) {\n            // logDebug(s);\n            return updateAncestryBoundaries(p, layoutInfo);\n        } // s += \". No changes in boundaries/position of parent node \" + p.id;\n        // logDebug(s);\n        return;\n    };\n    var separateComponents = function separateComponents(layoutInfo, options) {\n        var nodes = layoutInfo.layoutNodes;\n        var components = [];\n        for(var i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            var cid = node.cmptId;\n            var component = components[cid] = components[cid] || [];\n            component.push(node);\n        }\n        var totalA = 0;\n        for(var i = 0; i < components.length; i++){\n            var c = components[i];\n            if (!c) {\n                continue;\n            }\n            c.x1 = Infinity;\n            c.x2 = -Infinity;\n            c.y1 = Infinity;\n            c.y2 = -Infinity;\n            for(var j = 0; j < c.length; j++){\n                var n = c[j];\n                c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n                c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n                c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n                c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n            }\n            c.w = c.x2 - c.x1;\n            c.h = c.y2 - c.y1;\n            totalA += c.w * c.h;\n        }\n        components.sort(function(c1, c2) {\n            return c2.w * c2.h - c1.w * c1.h;\n        });\n        var x = 0;\n        var y = 0;\n        var usedW = 0;\n        var rowH = 0;\n        var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n        for(var i = 0; i < components.length; i++){\n            var c = components[i];\n            if (!c) {\n                continue;\n            }\n            for(var j = 0; j < c.length; j++){\n                var n = c[j];\n                if (!n.isLocked) {\n                    n.positionX += x - c.x1;\n                    n.positionY += y - c.y1;\n                }\n            }\n            x += c.w + options.componentSpacing;\n            usedW += c.w + options.componentSpacing;\n            rowH = Math.max(rowH, c.h);\n            if (usedW > maxRowW) {\n                y += rowH + options.componentSpacing;\n                x = 0;\n                usedW = 0;\n                rowH = 0;\n            }\n        }\n    };\n    var defaults$3 = {\n        fit: true,\n        // whether to fit the viewport to the graph\n        padding: 30,\n        // padding used on fit\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        avoidOverlap: true,\n        // prevents node overlap, may overflow boundingBox if not enough space\n        avoidOverlapPadding: 10,\n        // extra spacing around nodes when avoidOverlap: true\n        nodeDimensionsIncludeLabels: false,\n        // Excludes the label when calculating node bounding boxes for the layout algorithm\n        spacingFactor: undefined,\n        // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n        condense: false,\n        // uses all available space on false, uses minimal space on true\n        rows: undefined,\n        // force num of rows in the grid\n        cols: undefined,\n        // force num of columns in the grid\n        position: function position(node) {},\n        // returns { row, col } for element\n        sort: undefined,\n        // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts \n    };\n    function GridLayout(options) {\n        this.options = extend({}, defaults$3, options);\n    }\n    GridLayout.prototype.run = function() {\n        var params = this.options;\n        var options = params;\n        var cy = params.cy;\n        var eles = options.eles;\n        var nodes = eles.nodes().not(\":parent\");\n        if (options.sort) {\n            nodes = nodes.sort(options.sort);\n        }\n        var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n            x1: 0,\n            y1: 0,\n            w: cy.width(),\n            h: cy.height()\n        });\n        if (bb.h === 0 || bb.w === 0) {\n            eles.nodes().layoutPositions(this, options, function(ele) {\n                return {\n                    x: bb.x1,\n                    y: bb.y1\n                };\n            });\n        } else {\n            // width/height * splits^2 = cells where splits is number of times to split width\n            var cells = nodes.size();\n            var splits = Math.sqrt(cells * bb.h / bb.w);\n            var rows = Math.round(splits);\n            var cols = Math.round(bb.w / bb.h * splits);\n            var small = function small(val) {\n                if (val == null) {\n                    return Math.min(rows, cols);\n                } else {\n                    var min = Math.min(rows, cols);\n                    if (min == rows) {\n                        rows = val;\n                    } else {\n                        cols = val;\n                    }\n                }\n            };\n            var large = function large(val) {\n                if (val == null) {\n                    return Math.max(rows, cols);\n                } else {\n                    var max = Math.max(rows, cols);\n                    if (max == rows) {\n                        rows = val;\n                    } else {\n                        cols = val;\n                    }\n                }\n            };\n            var oRows = options.rows;\n            var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values\n            if (oRows != null && oCols != null) {\n                rows = oRows;\n                cols = oCols;\n            } else if (oRows != null && oCols == null) {\n                rows = oRows;\n                cols = Math.ceil(cells / rows);\n            } else if (oRows == null && oCols != null) {\n                cols = oCols;\n                rows = Math.ceil(cells / cols);\n            } else if (cols * rows > cells) {\n                var sm = small();\n                var lg = large(); // reducing the small side takes away the most cells, so try it first\n                if ((sm - 1) * lg >= cells) {\n                    small(sm - 1);\n                } else if ((lg - 1) * sm >= cells) {\n                    large(lg - 1);\n                }\n            } else {\n                // if rounding was too low, add rows or columns\n                while(cols * rows < cells){\n                    var _sm = small();\n                    var _lg = large(); // try to add to larger side first (adds less in multiplication)\n                    if ((_lg + 1) * _sm >= cells) {\n                        large(_lg + 1);\n                    } else {\n                        small(_sm + 1);\n                    }\n                }\n            }\n            var cellWidth = bb.w / cols;\n            var cellHeight = bb.h / rows;\n            if (options.condense) {\n                cellWidth = 0;\n                cellHeight = 0;\n            }\n            if (options.avoidOverlap) {\n                for(var i = 0; i < nodes.length; i++){\n                    var node = nodes[i];\n                    var pos = node._private.position;\n                    if (pos.x == null || pos.y == null) {\n                        // for bb\n                        pos.x = 0;\n                        pos.y = 0;\n                    }\n                    var nbb = node.layoutDimensions(options);\n                    var p = options.avoidOverlapPadding;\n                    var w = nbb.w + p;\n                    var h = nbb.h + p;\n                    cellWidth = Math.max(cellWidth, w);\n                    cellHeight = Math.max(cellHeight, h);\n                }\n            }\n            var cellUsed = {}; // e.g. 'c-0-2' => true\n            var used = function used(row, col) {\n                return cellUsed[\"c-\" + row + \"-\" + col] ? true : false;\n            };\n            var use = function use(row, col) {\n                cellUsed[\"c-\" + row + \"-\" + col] = true;\n            }; // to keep track of current cell position\n            var row = 0;\n            var col = 0;\n            var moveToNextCell = function moveToNextCell() {\n                col++;\n                if (col >= cols) {\n                    col = 0;\n                    row++;\n                }\n            }; // get a cache of all the manual positions\n            var id2manPos = {};\n            for(var _i = 0; _i < nodes.length; _i++){\n                var _node = nodes[_i];\n                var rcPos = options.position(_node);\n                if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                    // must have at least row or col def'd\n                    var _pos = {\n                        row: rcPos.row,\n                        col: rcPos.col\n                    };\n                    if (_pos.col === undefined) {\n                        // find unused col\n                        _pos.col = 0;\n                        while(used(_pos.row, _pos.col)){\n                            _pos.col++;\n                        }\n                    } else if (_pos.row === undefined) {\n                        // find unused row\n                        _pos.row = 0;\n                        while(used(_pos.row, _pos.col)){\n                            _pos.row++;\n                        }\n                    }\n                    id2manPos[_node.id()] = _pos;\n                    use(_pos.row, _pos.col);\n                }\n            }\n            var getPos = function getPos(element, i) {\n                var x, y;\n                if (element.locked() || element.isParent()) {\n                    return false;\n                } // see if we have a manual position set\n                var rcPos = id2manPos[element.id()];\n                if (rcPos) {\n                    x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n                    y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n                } else {\n                    // otherwise set automatically\n                    while(used(row, col)){\n                        moveToNextCell();\n                    }\n                    x = col * cellWidth + cellWidth / 2 + bb.x1;\n                    y = row * cellHeight + cellHeight / 2 + bb.y1;\n                    use(row, col);\n                    moveToNextCell();\n                }\n                return {\n                    x: x,\n                    y: y\n                };\n            };\n            nodes.layoutPositions(this, options, getPos);\n        }\n        return this; // chaining\n    };\n    var defaults$2 = {\n        ready: function ready() {},\n        // on layoutready\n        stop: function stop() {} // on layoutstop\n    }; // constructor\n    // options : object containing layout options\n    function NullLayout(options) {\n        this.options = extend({}, defaults$2, options);\n    } // runs the layout\n    NullLayout.prototype.run = function() {\n        var options = this.options;\n        var eles = options.eles; // elements to consider in the layout\n        var layout = this; // cy is automatically populated for us in the constructor\n        // (disable eslint for next line as this serves as example layout code to external developers)\n        // eslint-disable-next-line no-unused-vars\n        options.cy;\n        layout.emit(\"layoutstart\"); // puts all nodes at (0, 0)\n        // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n        eles.nodes().positions(function() {\n            return {\n                x: 0,\n                y: 0\n            };\n        }); // trigger layoutready when each node has had its position set at least once\n        layout.one(\"layoutready\", options.ready);\n        layout.emit(\"layoutready\"); // trigger layoutstop when the layout stops (e.g. finishes)\n        layout.one(\"layoutstop\", options.stop);\n        layout.emit(\"layoutstop\");\n        return this; // chaining\n    }; // called on continuous layouts to stop them before they finish\n    NullLayout.prototype.stop = function() {\n        return this; // chaining\n    };\n    var defaults$1 = {\n        positions: undefined,\n        // map of (node id) => (position obj); or function(node){ return somPos; }\n        zoom: undefined,\n        // the zoom level to set (prob want fit = false if set)\n        pan: undefined,\n        // the pan level to set (prob want fit = false if set)\n        fit: true,\n        // whether to fit to viewport\n        padding: 30,\n        // padding on fit\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts\n    };\n    function PresetLayout(options) {\n        this.options = extend({}, defaults$1, options);\n    }\n    PresetLayout.prototype.run = function() {\n        var options = this.options;\n        var eles = options.eles;\n        var nodes = eles.nodes();\n        var posIsFn = fn$6(options.positions);\n        function getPosition(node) {\n            if (options.positions == null) {\n                return copyPosition(node.position());\n            }\n            if (posIsFn) {\n                return options.positions(node);\n            }\n            var pos = options.positions[node._private.data.id];\n            if (pos == null) {\n                return null;\n            }\n            return pos;\n        }\n        nodes.layoutPositions(this, options, function(node, i) {\n            var position = getPosition(node);\n            if (node.locked() || position == null) {\n                return false;\n            }\n            return position;\n        });\n        return this; // chaining\n    };\n    var defaults = {\n        fit: true,\n        // whether to fit to viewport\n        padding: 30,\n        // fit padding\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        animate: false,\n        // whether to transition the node positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        animateFilter: function animateFilter(node, i) {\n            return true;\n        },\n        // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n        ready: undefined,\n        // callback on layoutready\n        stop: undefined,\n        // callback on layoutstop\n        transform: function transform(node, position) {\n            return position;\n        } // transform a given node position. Useful for changing flow direction in discrete layouts \n    };\n    function RandomLayout(options) {\n        this.options = extend({}, defaults, options);\n    }\n    RandomLayout.prototype.run = function() {\n        var options = this.options;\n        var cy = options.cy;\n        var eles = options.eles;\n        var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n            x1: 0,\n            y1: 0,\n            w: cy.width(),\n            h: cy.height()\n        });\n        var getPos = function getPos(node, i) {\n            return {\n                x: bb.x1 + Math.round(Math.random() * bb.w),\n                y: bb.y1 + Math.round(Math.random() * bb.h)\n            };\n        };\n        eles.nodes().layoutPositions(this, options, getPos);\n        return this; // chaining\n    };\n    var layout = [\n        {\n            name: \"breadthfirst\",\n            impl: BreadthFirstLayout\n        },\n        {\n            name: \"circle\",\n            impl: CircleLayout\n        },\n        {\n            name: \"concentric\",\n            impl: ConcentricLayout\n        },\n        {\n            name: \"cose\",\n            impl: CoseLayout\n        },\n        {\n            name: \"grid\",\n            impl: GridLayout\n        },\n        {\n            name: \"null\",\n            impl: NullLayout\n        },\n        {\n            name: \"preset\",\n            impl: PresetLayout\n        },\n        {\n            name: \"random\",\n            impl: RandomLayout\n        }\n    ];\n    function NullRenderer(options) {\n        this.options = options;\n        this.notifications = 0; // for testing\n    }\n    var noop = function noop() {};\n    var throwImgErr = function throwImgErr() {\n        throw new Error(\"A headless instance can not render images\");\n    };\n    NullRenderer.prototype = {\n        recalculateRenderedStyle: noop,\n        notify: function notify() {\n            this.notifications++;\n        },\n        init: noop,\n        isHeadless: function isHeadless() {\n            return true;\n        },\n        png: throwImgErr,\n        jpg: throwImgErr\n    };\n    var BRp$f = {};\n    BRp$f.arrowShapeWidth = 0.3;\n    BRp$f.registerArrowShapes = function() {\n        var arrowShapes = this.arrowShapes = {};\n        var renderer = this; // Contract for arrow shapes:\n        // 0, 0 is arrow tip\n        // (0, 1) is direction towards node\n        // (1, 0) is right\n        //\n        // functional api:\n        // collide: check x, y in shape\n        // roughCollide: called before collide, no false negatives\n        // draw: draw\n        // spacing: dist(arrowTip, nodeBoundary)\n        // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n        var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n            var x1 = translation.x - size / 2 - padding;\n            var x2 = translation.x + size / 2 + padding;\n            var y1 = translation.y - size / 2 - padding;\n            var y2 = translation.y + size / 2 + padding;\n            var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n            return inside;\n        };\n        var transform = function transform(x, y, size, angle, translation) {\n            var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n            var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n            var xScaled = xRotated * size;\n            var yScaled = yRotated * size;\n            var xTranslated = xScaled + translation.x;\n            var yTranslated = yScaled + translation.y;\n            return {\n                x: xTranslated,\n                y: yTranslated\n            };\n        };\n        var transformPoints = function transformPoints(pts, size, angle, translation) {\n            var retPts = [];\n            for(var i = 0; i < pts.length; i += 2){\n                var x = pts[i];\n                var y = pts[i + 1];\n                retPts.push(transform(x, y, size, angle, translation));\n            }\n            return retPts;\n        };\n        var pointsToArr = function pointsToArr(pts) {\n            var ret = [];\n            for(var i = 0; i < pts.length; i++){\n                var p = pts[i];\n                ret.push(p.x, p.y);\n            }\n            return ret;\n        };\n        var standardGap = function standardGap(edge) {\n            return edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").pfValue * 2;\n        };\n        var defineArrowShape = function defineArrowShape(name, defn) {\n            if (string(defn)) {\n                defn = arrowShapes[defn];\n            }\n            arrowShapes[name] = extend({\n                name: name,\n                points: [\n                    -0.15,\n                    -0.3,\n                    0.15,\n                    -0.3,\n                    0.15,\n                    0.3,\n                    -0.15,\n                    0.3\n                ],\n                collide: function collide(x, y, size, angle, translation, padding) {\n                    var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                    var inside = pointInsidePolygonPoints(x, y, points);\n                    return inside;\n                },\n                roughCollide: bbCollide,\n                draw: function draw(context, size, angle, translation) {\n                    var points = transformPoints(this.points, size, angle, translation);\n                    renderer.arrowShapeImpl(\"polygon\")(context, points);\n                },\n                spacing: function spacing(edge) {\n                    return 0;\n                },\n                gap: standardGap\n            }, defn);\n        };\n        defineArrowShape(\"none\", {\n            collide: falsify,\n            roughCollide: falsify,\n            draw: noop$1,\n            spacing: zeroify,\n            gap: zeroify\n        });\n        defineArrowShape(\"triangle\", {\n            points: [\n                -0.15,\n                -0.3,\n                0,\n                0,\n                0.15,\n                -0.3\n            ]\n        });\n        defineArrowShape(\"arrow\", \"triangle\");\n        defineArrowShape(\"triangle-backcurve\", {\n            points: arrowShapes[\"triangle\"].points,\n            controlPoint: [\n                0,\n                -0.15\n            ],\n            roughCollide: bbCollide,\n            draw: function draw(context, size, angle, translation, edgeWidth) {\n                var ptsTrans = transformPoints(this.points, size, angle, translation);\n                var ctrlPt = this.controlPoint;\n                var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n                renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n            },\n            gap: function gap(edge) {\n                return standardGap(edge) * 0.8;\n            }\n        });\n        defineArrowShape(\"triangle-tee\", {\n            points: [\n                0,\n                0,\n                0.15,\n                -0.3,\n                -0.15,\n                -0.3,\n                0,\n                0\n            ],\n            pointsTee: [\n                -0.15,\n                -0.4,\n                -0.15,\n                -0.5,\n                0.15,\n                -0.5,\n                0.15,\n                -0.4\n            ],\n            collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n                var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n                return inside;\n            },\n            draw: function draw(context, size, angle, translation, edgeWidth) {\n                var triPts = transformPoints(this.points, size, angle, translation);\n                var teePts = transformPoints(this.pointsTee, size, angle, translation);\n                renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n            }\n        });\n        defineArrowShape(\"circle-triangle\", {\n            radius: 0.15,\n            pointsTr: [\n                0,\n                -0.15,\n                0.15,\n                -0.45,\n                -0.15,\n                -0.45,\n                0,\n                -0.15\n            ],\n            collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n                var t = translation;\n                var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n            },\n            draw: function draw(context, size, angle, translation, edgeWidth) {\n                var triPts = transformPoints(this.pointsTr, size, angle, translation);\n                renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n            },\n            spacing: function spacing(edge) {\n                return renderer.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.radius;\n            }\n        });\n        defineArrowShape(\"triangle-cross\", {\n            points: [\n                0,\n                0,\n                0.15,\n                -0.3,\n                -0.15,\n                -0.3,\n                0,\n                0\n            ],\n            baseCrossLinePts: [\n                -0.15,\n                -0.4,\n                -0.15,\n                -0.4,\n                0.15,\n                -0.4,\n                0.15,\n                -0.4\n            ],\n            crossLinePts: function crossLinePts(size, edgeWidth) {\n                // shift points so that the distance between the cross points matches edge width\n                var p = this.baseCrossLinePts.slice();\n                var shiftFactor = edgeWidth / size;\n                var y0 = 3;\n                var y1 = 5;\n                p[y0] = p[y0] - shiftFactor;\n                p[y1] = p[y1] - shiftFactor;\n                return p;\n            },\n            collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n                var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n                return inside;\n            },\n            draw: function draw(context, size, angle, translation, edgeWidth) {\n                var triPts = transformPoints(this.points, size, angle, translation);\n                var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n                renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n            }\n        });\n        defineArrowShape(\"vee\", {\n            points: [\n                -0.15,\n                -0.3,\n                0,\n                0,\n                0.15,\n                -0.3,\n                0,\n                -0.15\n            ],\n            gap: function gap(edge) {\n                return standardGap(edge) * 0.525;\n            }\n        });\n        defineArrowShape(\"circle\", {\n            radius: 0.15,\n            collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n                var t = translation;\n                var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n                return inside;\n            },\n            draw: function draw(context, size, angle, translation, edgeWidth) {\n                renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n            },\n            spacing: function spacing(edge) {\n                return renderer.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.radius;\n            }\n        });\n        defineArrowShape(\"tee\", {\n            points: [\n                -0.15,\n                0,\n                -0.15,\n                -0.1,\n                0.15,\n                -0.1,\n                0.15,\n                0\n            ],\n            spacing: function spacing(edge) {\n                return 1;\n            },\n            gap: function gap(edge) {\n                return 1;\n            }\n        });\n        defineArrowShape(\"square\", {\n            points: [\n                -0.15,\n                0.00,\n                0.15,\n                0.00,\n                0.15,\n                -0.3,\n                -0.15,\n                -0.3\n            ]\n        });\n        defineArrowShape(\"diamond\", {\n            points: [\n                -0.15,\n                -0.15,\n                0,\n                -0.3,\n                0.15,\n                -0.15,\n                0,\n                0\n            ],\n            gap: function gap(edge) {\n                return edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").value;\n            }\n        });\n        defineArrowShape(\"chevron\", {\n            points: [\n                0,\n                0,\n                -0.15,\n                -0.15,\n                -0.1,\n                -0.2,\n                0,\n                -0.1,\n                0.1,\n                -0.2,\n                0.15,\n                -0.15\n            ],\n            gap: function gap(edge) {\n                return 0.95 * edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").value;\n            }\n        });\n    };\n    var BRp$e = {}; // Project mouse\n    BRp$e.projectIntoViewport = function(clientX, clientY) {\n        var cy = this.cy;\n        var offsets = this.findContainerClientCoords();\n        var offsetLeft = offsets[0];\n        var offsetTop = offsets[1];\n        var scale = offsets[4];\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n        var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n        return [\n            x,\n            y\n        ];\n    };\n    BRp$e.findContainerClientCoords = function() {\n        if (this.containerBB) {\n            return this.containerBB;\n        }\n        var container = this.container;\n        var rect = container.getBoundingClientRect();\n        var style = window$1.getComputedStyle(container);\n        var styleValue = function styleValue(name) {\n            return parseFloat(style.getPropertyValue(name));\n        };\n        var padding = {\n            left: styleValue(\"padding-left\"),\n            right: styleValue(\"padding-right\"),\n            top: styleValue(\"padding-top\"),\n            bottom: styleValue(\"padding-bottom\")\n        };\n        var border = {\n            left: styleValue(\"border-left-width\"),\n            right: styleValue(\"border-right-width\"),\n            top: styleValue(\"border-top-width\"),\n            bottom: styleValue(\"border-bottom-width\")\n        };\n        var clientWidth = container.clientWidth;\n        var clientHeight = container.clientHeight;\n        var paddingHor = padding.left + padding.right;\n        var paddingVer = padding.top + padding.bottom;\n        var borderHor = border.left + border.right;\n        var scale = rect.width / (clientWidth + borderHor);\n        var unscaledW = clientWidth - paddingHor;\n        var unscaledH = clientHeight - paddingVer;\n        var left = rect.left + padding.left + border.left;\n        var top = rect.top + padding.top + border.top;\n        return this.containerBB = [\n            left,\n            top,\n            unscaledW,\n            unscaledH,\n            scale\n        ];\n    };\n    BRp$e.invalidateContainerClientCoordsCache = function() {\n        this.containerBB = null;\n    };\n    BRp$e.findNearestElement = function(x, y, interactiveElementsOnly, isTouch) {\n        return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n    };\n    BRp$e.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n        var self1 = this;\n        var r = this;\n        var eles = r.getCachedZSortedEles();\n        var near = []; // 1 node max, 1 edge max\n        var zoom = r.cy.zoom();\n        var hasCompounds = r.cy.hasCompoundNodes();\n        var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n        var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n        var labelThreshold = (isTouch ? 8 : 2) / zoom;\n        var minSqDist = Infinity;\n        var nearEdge;\n        var nearNode;\n        if (interactiveElementsOnly) {\n            eles = eles.interactive;\n        }\n        function addEle(ele, sqDist) {\n            if (ele.isNode()) {\n                if (nearNode) {\n                    return; // can't replace node\n                } else {\n                    nearNode = ele;\n                    near.push(ele);\n                }\n            }\n            if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n                if (nearEdge) {\n                    // then replace existing edge\n                    // can replace only if same z-index\n                    if (nearEdge.pstyle(\"z-compound-depth\").value === ele.pstyle(\"z-compound-depth\").value && nearEdge.pstyle(\"z-compound-depth\").value === ele.pstyle(\"z-compound-depth\").value) {\n                        for(var i = 0; i < near.length; i++){\n                            if (near[i].isEdge()) {\n                                near[i] = ele;\n                                nearEdge = ele;\n                                minSqDist = sqDist != null ? sqDist : minSqDist;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    near.push(ele);\n                    nearEdge = ele;\n                    minSqDist = sqDist != null ? sqDist : minSqDist;\n                }\n            }\n        }\n        function checkNode(node) {\n            var width = node.outerWidth() + 2 * nodeThreshold;\n            var height = node.outerHeight() + 2 * nodeThreshold;\n            var hw = width / 2;\n            var hh = height / 2;\n            var pos = node.position();\n            if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n             && pos.y - hh <= y && y <= pos.y + hh // bb check y\n            ) {\n                var shape = r.nodeShapes[self1.getNodeShape(node)];\n                if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n                    addEle(node, 0);\n                    return true;\n                }\n            }\n        }\n        function checkEdge(edge) {\n            var _p = edge._private;\n            var rs = _p.rscratch;\n            var styleWidth = edge.pstyle(\"width\").pfValue;\n            var scale = edge.pstyle(\"arrow-scale\").value;\n            var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n            var widthSq = width * width;\n            var width2 = width * 2;\n            var src = _p.source;\n            var tgt = _p.target;\n            var sqDist;\n            if (rs.edgeType === \"segments\" || rs.edgeType === \"straight\" || rs.edgeType === \"haystack\") {\n                var pts = rs.allpts;\n                for(var i = 0; i + 3 < pts.length; i += 2){\n                    if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n                        addEle(edge, sqDist);\n                        return true;\n                    }\n                }\n            } else if (rs.edgeType === \"bezier\" || rs.edgeType === \"multibezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\") {\n                var pts = rs.allpts;\n                for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                    if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n                        addEle(edge, sqDist);\n                        return true;\n                    }\n                }\n            } // if we're close to the edge but didn't hit it, maybe we hit its arrows\n            var src = src || _p.source;\n            var tgt = tgt || _p.target;\n            var arSize = self1.getArrowWidth(styleWidth, scale);\n            var arrows = [\n                {\n                    name: \"source\",\n                    x: rs.arrowStartX,\n                    y: rs.arrowStartY,\n                    angle: rs.srcArrowAngle\n                },\n                {\n                    name: \"target\",\n                    x: rs.arrowEndX,\n                    y: rs.arrowEndY,\n                    angle: rs.tgtArrowAngle\n                },\n                {\n                    name: \"mid-source\",\n                    x: rs.midX,\n                    y: rs.midY,\n                    angle: rs.midsrcArrowAngle\n                },\n                {\n                    name: \"mid-target\",\n                    x: rs.midX,\n                    y: rs.midY,\n                    angle: rs.midtgtArrowAngle\n                }\n            ];\n            for(var i = 0; i < arrows.length; i++){\n                var ar = arrows[i];\n                var shape = r.arrowShapes[edge.pstyle(ar.name + \"-arrow-shape\").value];\n                var edgeWidth = edge.pstyle(\"width\").pfValue;\n                if (shape.roughCollide(x, y, arSize, ar.angle, {\n                    x: ar.x,\n                    y: ar.y\n                }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n                    x: ar.x,\n                    y: ar.y\n                }, edgeWidth, edgeThreshold)) {\n                    addEle(edge);\n                    return true;\n                }\n            } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n            if (hasCompounds && near.length > 0) {\n                checkNode(src);\n                checkNode(tgt);\n            }\n        }\n        function preprop(obj, name, pre) {\n            return getPrefixedProperty(obj, name, pre);\n        }\n        function checkLabel(ele, prefix) {\n            var _p = ele._private;\n            var th = labelThreshold;\n            var prefixDash;\n            if (prefix) {\n                prefixDash = prefix + \"-\";\n            } else {\n                prefixDash = \"\";\n            }\n            ele.boundingBox();\n            var bb = _p.labelBounds[prefix || \"main\"];\n            var text = ele.pstyle(prefixDash + \"label\").value;\n            var eventsEnabled = ele.pstyle(\"text-events\").strValue === \"yes\";\n            if (!eventsEnabled || !text) {\n                return;\n            }\n            var lx = preprop(_p.rscratch, \"labelX\", prefix);\n            var ly = preprop(_p.rscratch, \"labelY\", prefix);\n            var theta = preprop(_p.rscratch, \"labelAngle\", prefix);\n            var ox = ele.pstyle(prefixDash + \"text-margin-x\").pfValue;\n            var oy = ele.pstyle(prefixDash + \"text-margin-y\").pfValue;\n            var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n            var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n            var ly1 = bb.y1 - th - oy;\n            var ly2 = bb.y2 + th - oy;\n            if (theta) {\n                var cos = Math.cos(theta);\n                var sin = Math.sin(theta);\n                var rotate = function rotate(x, y) {\n                    x = x - lx;\n                    y = y - ly;\n                    return {\n                        x: x * cos - y * sin + lx,\n                        y: x * sin + y * cos + ly\n                    };\n                };\n                var px1y1 = rotate(lx1, ly1);\n                var px1y2 = rotate(lx1, ly2);\n                var px2y1 = rotate(lx2, ly1);\n                var px2y2 = rotate(lx2, ly2);\n                var points = [\n                    px1y1.x + ox,\n                    px1y1.y + oy,\n                    px2y1.x + ox,\n                    px2y1.y + oy,\n                    px2y2.x + ox,\n                    px2y2.y + oy,\n                    px1y2.x + ox,\n                    px1y2.y + oy\n                ];\n                if (pointInsidePolygonPoints(x, y, points)) {\n                    addEle(ele);\n                    return true;\n                }\n            } else {\n                // do a cheaper bb check\n                if (inBoundingBox(bb, x, y)) {\n                    addEle(ele);\n                    return true;\n                }\n            }\n        }\n        for(var i = eles.length - 1; i >= 0; i--){\n            // reverse order for precedence\n            var ele = eles[i];\n            if (ele.isNode()) {\n                checkNode(ele) || checkLabel(ele);\n            } else {\n                // then edge\n                checkEdge(ele) || checkLabel(ele) || checkLabel(ele, \"source\") || checkLabel(ele, \"target\");\n            }\n        }\n        return near;\n    }; // 'Give me everything from this box'\n    BRp$e.getAllInBox = function(x1, y1, x2, y2) {\n        var eles = this.getCachedZSortedEles().interactive;\n        var box = [];\n        var x1c = Math.min(x1, x2);\n        var x2c = Math.max(x1, x2);\n        var y1c = Math.min(y1, y2);\n        var y2c = Math.max(y1, y2);\n        x1 = x1c;\n        x2 = x2c;\n        y1 = y1c;\n        y2 = y2c;\n        var boxBb = makeBoundingBox({\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        });\n        for(var e = 0; e < eles.length; e++){\n            var ele = eles[e];\n            if (ele.isNode()) {\n                var node = ele;\n                var nodeBb = node.boundingBox({\n                    includeNodes: true,\n                    includeEdges: false,\n                    includeLabels: false\n                });\n                if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {\n                    box.push(node);\n                }\n            } else {\n                var edge = ele;\n                var _p = edge._private;\n                var rs = _p.rscratch;\n                if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n                    continue;\n                }\n                if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n                    continue;\n                }\n                if (rs.edgeType === \"bezier\" || rs.edgeType === \"multibezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\" || rs.edgeType === \"segments\" || rs.edgeType === \"haystack\") {\n                    var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    var allInside = true;\n                    for(var i = 0; i < pts.length; i++){\n                        if (!pointInBoundingBox(boxBb, pts[i])) {\n                            allInside = false;\n                            break;\n                        }\n                    }\n                    if (allInside) {\n                        box.push(edge);\n                    }\n                } else if (rs.edgeType === \"haystack\" || rs.edgeType === \"straight\") {\n                    box.push(edge);\n                }\n            }\n        }\n        return box;\n    };\n    var BRp$d = {};\n    BRp$d.calculateArrowAngles = function(edge) {\n        var rs = edge._private.rscratch;\n        var isHaystack = rs.edgeType === \"haystack\";\n        var isBezier = rs.edgeType === \"bezier\";\n        var isMultibezier = rs.edgeType === \"multibezier\";\n        var isSegments = rs.edgeType === \"segments\";\n        var isCompound = rs.edgeType === \"compound\";\n        var isSelf = rs.edgeType === \"self\"; // Displacement gives direction for arrowhead orientation\n        var dispX, dispY;\n        var startX, startY, endX, endY, midX, midY;\n        if (isHaystack) {\n            startX = rs.haystackPts[0];\n            startY = rs.haystackPts[1];\n            endX = rs.haystackPts[2];\n            endY = rs.haystackPts[3];\n        } else {\n            startX = rs.arrowStartX;\n            startY = rs.arrowStartY;\n            endX = rs.arrowEndX;\n            endY = rs.arrowEndY;\n        }\n        midX = rs.midX;\n        midY = rs.midY; // source\n        //\n        if (isSegments) {\n            dispX = startX - rs.segpts[0];\n            dispY = startY - rs.segpts[1];\n        } else if (isMultibezier || isCompound || isSelf || isBezier) {\n            var pts = rs.allpts;\n            var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n            var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n            dispX = startX - bX;\n            dispY = startY - bY;\n        } else {\n            dispX = startX - midX;\n            dispY = startY - midY;\n        }\n        rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target\n        //\n        var midX = rs.midX;\n        var midY = rs.midY;\n        if (isHaystack) {\n            midX = (startX + endX) / 2;\n            midY = (startY + endY) / 2;\n        }\n        dispX = endX - startX;\n        dispY = endY - startY;\n        if (isSegments) {\n            var pts = rs.allpts;\n            if (pts.length / 2 % 2 === 0) {\n                var i2 = pts.length / 2;\n                var i1 = i2 - 2;\n                dispX = pts[i2] - pts[i1];\n                dispY = pts[i2 + 1] - pts[i1 + 1];\n            } else {\n                var i2 = pts.length / 2 - 1;\n                var i1 = i2 - 2;\n                var i3 = i2 + 2;\n                dispX = pts[i2] - pts[i1];\n                dispY = pts[i2 + 1] - pts[i1 + 1];\n            }\n        } else if (isMultibezier || isCompound || isSelf) {\n            var pts = rs.allpts;\n            var cpts = rs.ctrlpts;\n            var bp0x, bp0y;\n            var bp1x, bp1y;\n            if (cpts.length / 2 % 2 === 0) {\n                var p0 = pts.length / 2 - 1; // startpt\n                var ic = p0 + 2;\n                var p1 = ic + 2;\n                bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n                bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n                bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n                bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n            } else {\n                var ic = pts.length / 2 - 1; // ctrpt\n                var p0 = ic - 2; // startpt\n                var p1 = ic + 2; // endpt\n                bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n                bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n                bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n                bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n            }\n            dispX = bp1x - bp0x;\n            dispY = bp1y - bp0y;\n        }\n        rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n        rs.midDispX = dispX;\n        rs.midDispY = dispY; // mid source\n        //\n        dispX *= -1;\n        dispY *= -1;\n        if (isSegments) {\n            var pts = rs.allpts;\n            if (pts.length / 2 % 2 === 0) ;\n            else {\n                var i2 = pts.length / 2 - 1;\n                var i3 = i2 + 2;\n                dispX = -(pts[i3] - pts[i2]);\n                dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n            }\n        }\n        rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target\n        //\n        if (isSegments) {\n            dispX = endX - rs.segpts[rs.segpts.length - 2];\n            dispY = endY - rs.segpts[rs.segpts.length - 1];\n        } else if (isMultibezier || isCompound || isSelf || isBezier) {\n            var pts = rs.allpts;\n            var l = pts.length;\n            var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n            var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n            dispX = endX - bX;\n            dispY = endY - bY;\n        } else {\n            dispX = endX - midX;\n            dispY = endY - midY;\n        }\n        rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    };\n    BRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale) {\n        var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n        var cachedVal = cache[edgeWidth + \", \" + scale];\n        if (cachedVal) {\n            return cachedVal;\n        }\n        cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n        cache[edgeWidth + \", \" + scale] = cachedVal;\n        return cachedVal;\n    };\n    var BRp$c = {};\n    BRp$c.findHaystackPoints = function(edges) {\n        for(var i = 0; i < edges.length; i++){\n            var edge = edges[i];\n            var _p = edge._private;\n            var rs = _p.rscratch;\n            if (!rs.haystack) {\n                var angle = Math.random() * 2 * Math.PI;\n                rs.source = {\n                    x: Math.cos(angle),\n                    y: Math.sin(angle)\n                };\n                angle = Math.random() * 2 * Math.PI;\n                rs.target = {\n                    x: Math.cos(angle),\n                    y: Math.sin(angle)\n                };\n            }\n            var src = _p.source;\n            var tgt = _p.target;\n            var srcPos = src.position();\n            var tgtPos = tgt.position();\n            var srcW = src.width();\n            var tgtW = tgt.width();\n            var srcH = src.height();\n            var tgtH = tgt.height();\n            var radius = edge.pstyle(\"haystack-radius\").value;\n            var halfRadius = radius / 2; // b/c have to half width/height\n            rs.haystackPts = rs.allpts = [\n                rs.source.x * srcW * halfRadius + srcPos.x,\n                rs.source.y * srcH * halfRadius + srcPos.y,\n                rs.target.x * tgtW * halfRadius + tgtPos.x,\n                rs.target.y * tgtH * halfRadius + tgtPos.y\n            ];\n            rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n            rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously\n            rs.edgeType = \"haystack\";\n            rs.haystack = true;\n            this.storeEdgeProjections(edge);\n            this.calculateArrowAngles(edge);\n            this.recalculateEdgeLabelProjections(edge);\n            this.calculateLabelAngles(edge);\n        }\n    };\n    BRp$c.findSegmentsPoints = function(edge, pairInfo) {\n        // Segments (multiple straight lines)\n        var rs = edge._private.rscratch;\n        var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;\n        var edgeDistances = edge.pstyle(\"edge-distances\").value;\n        var segmentWs = edge.pstyle(\"segment-weights\");\n        var segmentDs = edge.pstyle(\"segment-distances\");\n        var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n        rs.edgeType = \"segments\";\n        rs.segpts = [];\n        for(var s = 0; s < segmentsN; s++){\n            var w = segmentWs.pfValue[s];\n            var d = segmentDs.pfValue[s];\n            var w1 = 1 - w;\n            var w2 = w;\n            var midptPts = edgeDistances === \"node-position\" ? posPts : intersectionPts;\n            var adjustedMidpt = {\n                x: midptPts.x1 * w1 + midptPts.x2 * w2,\n                y: midptPts.y1 * w1 + midptPts.y2 * w2\n            };\n            rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n        }\n    };\n    BRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n        // Self-edge\n        var rs = edge._private.rscratch;\n        var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;\n        var ctrlptDists = edge.pstyle(\"control-point-distances\");\n        var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n        var loopDir = edge.pstyle(\"loop-direction\").pfValue;\n        var loopSwp = edge.pstyle(\"loop-sweep\").pfValue;\n        var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n        rs.edgeType = \"self\";\n        var j = i;\n        var loopDist = stepSize;\n        if (edgeIsUnbundled) {\n            j = 0;\n            loopDist = ctrlptDist;\n        }\n        var loopAngle = loopDir - Math.PI / 2;\n        var outAngle = loopAngle - loopSwp / 2;\n        var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values\n        var dc = String(loopDir + \"_\" + loopSwp);\n        j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n        rs.ctrlpts = [\n            srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n            srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n            srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),\n            srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)\n        ];\n    };\n    BRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n        // Compound edge\n        var rs = edge._private.rscratch;\n        rs.edgeType = \"compound\";\n        var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n        var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n        var ctrlptDists = edge.pstyle(\"control-point-distances\");\n        var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n        var j = i;\n        var loopDist = stepSize;\n        if (edgeIsUnbundled) {\n            j = 0;\n            loopDist = ctrlptDist;\n        }\n        var loopW = 50;\n        var loopaPos = {\n            x: srcPos.x - srcW / 2,\n            y: srcPos.y - srcH / 2\n        };\n        var loopbPos = {\n            x: tgtPos.x - tgtW / 2,\n            y: tgtPos.y - tgtH / 2\n        };\n        var loopPos = {\n            x: Math.min(loopaPos.x, loopbPos.x),\n            y: Math.min(loopaPos.y, loopbPos.y)\n        }; // avoids cases with impossible beziers\n        var minCompoundStretch = 0.5;\n        var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n        var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n        rs.ctrlpts = [\n            loopPos.x,\n            loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n            loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n            loopPos.y\n        ];\n    };\n    BRp$c.findStraightEdgePoints = function(edge) {\n        // Straight edge within bundle\n        edge._private.rscratch.edgeType = \"straight\";\n    };\n    BRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n        var rs = edge._private.rscratch;\n        var vectorNormInverse = pairInfo.vectorNormInverse, posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts;\n        var edgeDistances = edge.pstyle(\"edge-distances\").value;\n        var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n        var ctrlptDists = edge.pstyle(\"control-point-distances\");\n        var ctrlptWs = edge.pstyle(\"control-point-weights\");\n        var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n        var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n        var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier\n        var multi = edgeIsUnbundled;\n        rs.edgeType = multi ? \"multibezier\" : \"bezier\";\n        rs.ctrlpts = [];\n        for(var b = 0; b < bezierN; b++){\n            var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n            var manctrlptDist = void 0;\n            var sign = signum(normctrlptDist);\n            if (multi) {\n                ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n                ctrlptWeight = ctrlptWs.value[b];\n            }\n            if (edgeIsUnbundled) {\n                // multi or single unbundled\n                manctrlptDist = ctrlptDist;\n            } else {\n                manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n            }\n            var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n            var w1 = 1 - ctrlptWeight;\n            var w2 = ctrlptWeight;\n            var midptPts = edgeDistances === \"node-position\" ? posPts : intersectionPts;\n            var adjustedMidpt = {\n                x: midptPts.x1 * w1 + midptPts.x2 * w2,\n                y: midptPts.y1 * w1 + midptPts.y2 * w2\n            };\n            rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n        }\n    };\n    BRp$c.findTaxiPoints = function(edge, pairInfo) {\n        // Taxicab geometry with two turns maximum\n        var rs = edge._private.rscratch;\n        rs.edgeType = \"segments\";\n        var VERTICAL = \"vertical\";\n        var HORIZONTAL = \"horizontal\";\n        var LEFTWARD = \"leftward\";\n        var RIGHTWARD = \"rightward\";\n        var DOWNWARD = \"downward\";\n        var UPWARD = \"upward\";\n        var AUTO = \"auto\";\n        var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n        var edgeDistances = edge.pstyle(\"edge-distances\").value;\n        var dIncludesNodeBody = edgeDistances !== \"node-position\";\n        var taxiDir = edge.pstyle(\"taxi-direction\").value;\n        var rawTaxiDir = taxiDir; // unprocessed value\n        var taxiTurn = edge.pstyle(\"taxi-turn\");\n        var turnIsPercent = taxiTurn.units === \"%\";\n        var taxiTurnPfVal = taxiTurn.pfValue;\n        var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n        var minD = edge.pstyle(\"taxi-turn-min-distance\").pfValue;\n        var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n        var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n        var pdx = posPts.x2 - posPts.x1;\n        var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value\n        var subDWH = function subDWH(dxy, dwh) {\n            if (dxy > 0) {\n                return Math.max(dxy - dwh, 0);\n            } else {\n                return Math.min(dxy + dwh, 0);\n            }\n        };\n        var dx = subDWH(pdx, dw);\n        var dy = subDWH(pdy, dh);\n        var isExplicitDir = false;\n        if (rawTaxiDir === AUTO) {\n            taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n        } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n            taxiDir = VERTICAL;\n            isExplicitDir = true;\n        } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n            taxiDir = HORIZONTAL;\n            isExplicitDir = true;\n        }\n        var isVert = taxiDir === VERTICAL;\n        var l = isVert ? dy : dx;\n        var pl = isVert ? pdy : pdx;\n        var sgnL = signum(pl);\n        var forcedDir = false;\n        if (!(isExplicitDir && (turnIsPercent || turnIsNegative) // forcing in this case would cause weird growing in the opposite direction\n        ) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n            sgnL *= -1;\n            l = sgnL * Math.abs(l);\n            forcedDir = true;\n        }\n        var d;\n        if (turnIsPercent) {\n            var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n            d = p * l;\n        } else {\n            var k = taxiTurnPfVal < 0 ? l : 0;\n            d = k + taxiTurnPfVal * sgnL;\n        }\n        var getIsTooClose = function getIsTooClose(d) {\n            return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n        };\n        var isTooCloseSrc = getIsTooClose(d);\n        var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n        var isTooClose = isTooCloseSrc || isTooCloseTgt;\n        if (isTooClose && !forcedDir) {\n            // non-ideal routing\n            if (isVert) {\n                // vertical fallbacks\n                var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n                var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n                if (lShapeInsideSrc) {\n                    // horizontal Z-shape (direction not respected)\n                    var x = (posPts.x1 + posPts.x2) / 2;\n                    var y1 = posPts.y1, y2 = posPts.y2;\n                    rs.segpts = [\n                        x,\n                        y1,\n                        x,\n                        y2\n                    ];\n                } else if (lShapeInsideTgt) {\n                    // vertical Z-shape (distance not respected)\n                    var y = (posPts.y1 + posPts.y2) / 2;\n                    var x1 = posPts.x1, x2 = posPts.x2;\n                    rs.segpts = [\n                        x1,\n                        y,\n                        x2,\n                        y\n                    ];\n                } else {\n                    // L-shape fallback (turn distance not respected, but works well with tree siblings)\n                    rs.segpts = [\n                        posPts.x1,\n                        posPts.y2\n                    ];\n                }\n            } else {\n                // horizontal fallbacks\n                var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n                var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n                if (_lShapeInsideSrc) {\n                    // vertical Z-shape (direction not respected)\n                    var _y = (posPts.y1 + posPts.y2) / 2;\n                    var _x = posPts.x1, _x2 = posPts.x2;\n                    rs.segpts = [\n                        _x,\n                        _y,\n                        _x2,\n                        _y\n                    ];\n                } else if (_lShapeInsideTgt) {\n                    // horizontal Z-shape (turn distance not respected)\n                    var _x3 = (posPts.x1 + posPts.x2) / 2;\n                    var _y2 = posPts.y1, _y3 = posPts.y2;\n                    rs.segpts = [\n                        _x3,\n                        _y2,\n                        _x3,\n                        _y3\n                    ];\n                } else {\n                    // L-shape (turn distance not respected, but works well for tree siblings)\n                    rs.segpts = [\n                        posPts.x2,\n                        posPts.y1\n                    ];\n                }\n            }\n        } else {\n            // ideal routing\n            if (isVert) {\n                var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n                var _x4 = posPts.x1, _x5 = posPts.x2;\n                rs.segpts = [\n                    _x4,\n                    _y4,\n                    _x5,\n                    _y4\n                ];\n            } else {\n                // horizontal\n                var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n                var _y5 = posPts.y1, _y6 = posPts.y2;\n                rs.segpts = [\n                    _x6,\n                    _y5,\n                    _x6,\n                    _y6\n                ];\n            }\n        }\n    };\n    BRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {\n        var rs = edge._private.rscratch; // can only correct beziers for now...\n        if (rs.edgeType === \"bezier\") {\n            var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape;\n            var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n            var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n            var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n            var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n            var minCpADistFactor = 3;\n            var arrowW = this.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.arrowShapeWidth;\n            var minCpADist = minCpADistFactor * arrowW;\n            var startACpDist = dist({\n                x: rs.ctrlpts[0],\n                y: rs.ctrlpts[1]\n            }, {\n                x: rs.startX,\n                y: rs.startY\n            });\n            var closeStartACp = startACpDist < minCpADist;\n            var endACpDist = dist({\n                x: rs.ctrlpts[0],\n                y: rs.ctrlpts[1]\n            }, {\n                x: rs.endX,\n                y: rs.endY\n            });\n            var closeEndACp = endACpDist < minCpADist;\n            var overlapping = false;\n            if (badStart || badAStart || closeStartACp) {\n                overlapping = true; // project control point along line from src centre to outside the src shape\n                // (otherwise intersection will yield nothing)\n                var cpD = {\n                    // delta\n                    x: rs.ctrlpts[0] - srcPos.x,\n                    y: rs.ctrlpts[1] - srcPos.y\n                };\n                var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n                var cpM = {\n                    // normalised delta\n                    x: cpD.x / cpL,\n                    y: cpD.y / cpL\n                };\n                var radius = Math.max(srcW, srcH);\n                var cpProj = {\n                    // *2 radius guarantees outside shape\n                    x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n                    y: rs.ctrlpts[1] + cpM.y * 2 * radius\n                };\n                var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n                if (closeStartACp) {\n                    rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n                    rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n                } else {\n                    rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n                    rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n                }\n            }\n            if (badEnd || badAEnd || closeEndACp) {\n                overlapping = true; // project control point along line from tgt centre to outside the tgt shape\n                // (otherwise intersection will yield nothing)\n                var _cpD = {\n                    // delta\n                    x: rs.ctrlpts[0] - tgtPos.x,\n                    y: rs.ctrlpts[1] - tgtPos.y\n                };\n                var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n                var _cpM = {\n                    // normalised delta\n                    x: _cpD.x / _cpL,\n                    y: _cpD.y / _cpL\n                };\n                var _radius = Math.max(srcW, srcH);\n                var _cpProj = {\n                    // *2 radius guarantees outside shape\n                    x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n                    y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n                };\n                var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);\n                if (closeEndACp) {\n                    rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n                    rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n                } else {\n                    rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n                    rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n                }\n            }\n            if (overlapping) {\n                // recalc endpts\n                this.findEndpoints(edge);\n            }\n        }\n    };\n    BRp$c.storeAllpts = function(edge) {\n        var rs = edge._private.rscratch;\n        if (rs.edgeType === \"multibezier\" || rs.edgeType === \"bezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\") {\n            rs.allpts = [];\n            rs.allpts.push(rs.startX, rs.startY);\n            for(var b = 0; b + 1 < rs.ctrlpts.length; b += 2){\n                // ctrl pt itself\n                rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts\n                if (b + 3 < rs.ctrlpts.length) {\n                    rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n                }\n            }\n            rs.allpts.push(rs.endX, rs.endY);\n            var m1, mt;\n            if (rs.ctrlpts.length / 2 % 2 === 0) {\n                m1 = rs.allpts.length / 2 - 1;\n                rs.midX = rs.allpts[m1];\n                rs.midY = rs.allpts[m1 + 1];\n            } else {\n                m1 = rs.allpts.length / 2 - 3;\n                mt = 0.5;\n                rs.midX = qbezierAt(rs.allpts[m1], rs.allpts[m1 + 2], rs.allpts[m1 + 4], mt);\n                rs.midY = qbezierAt(rs.allpts[m1 + 1], rs.allpts[m1 + 3], rs.allpts[m1 + 5], mt);\n            }\n        } else if (rs.edgeType === \"straight\") {\n            // need to calc these after endpts\n            rs.allpts = [\n                rs.startX,\n                rs.startY,\n                rs.endX,\n                rs.endY\n            ]; // default midpt for labels etc\n            rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n            rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n        } else if (rs.edgeType === \"segments\") {\n            rs.allpts = [];\n            rs.allpts.push(rs.startX, rs.startY);\n            rs.allpts.push.apply(rs.allpts, rs.segpts);\n            rs.allpts.push(rs.endX, rs.endY);\n            if (rs.segpts.length % 4 === 0) {\n                var i2 = rs.segpts.length / 2;\n                var i1 = i2 - 2;\n                rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n                rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n            } else {\n                var _i = rs.segpts.length / 2 - 1;\n                rs.midX = rs.segpts[_i];\n                rs.midY = rs.segpts[_i + 1];\n            }\n        }\n    };\n    BRp$c.checkForInvalidEdgeWarning = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n            rs.loggedErr = false;\n        } else {\n            if (!rs.loggedErr) {\n                rs.loggedErr = true;\n                warn(\"Edge `\" + edge.id() + \"` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.\");\n            }\n        }\n    };\n    BRp$c.findEdgeControlPoints = function(edges) {\n        var _this = this;\n        if (!edges || edges.length === 0) {\n            return;\n        }\n        var r = this;\n        var cy = r.cy;\n        var hasCompounds = cy.hasCompoundNodes();\n        var hashTable = {\n            map: new Map$2(),\n            get: function get(pairId) {\n                var map2 = this.map.get(pairId[0]);\n                if (map2 != null) {\n                    return map2.get(pairId[1]);\n                } else {\n                    return null;\n                }\n            },\n            set: function set(pairId, val) {\n                var map2 = this.map.get(pairId[0]);\n                if (map2 == null) {\n                    map2 = new Map$2();\n                    this.map.set(pairId[0], map2);\n                }\n                map2.set(pairId[1], val);\n            }\n        };\n        var pairIds = [];\n        var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them\n        for(var i = 0; i < edges.length; i++){\n            var edge = edges[i];\n            var _p = edge._private;\n            var curveStyle = edge.pstyle(\"curve-style\").value; // ignore edges who are not to be displayed\n            // they shouldn't take up space\n            if (edge.removed() || !edge.takesUpSpace()) {\n                continue;\n            }\n            if (curveStyle === \"haystack\") {\n                haystackEdges.push(edge);\n                continue;\n            }\n            var edgeIsUnbundled = curveStyle === \"unbundled-bezier\" || curveStyle === \"segments\" || curveStyle === \"straight\" || curveStyle === \"straight-triangle\" || curveStyle === \"taxi\";\n            var edgeIsBezier = curveStyle === \"unbundled-bezier\" || curveStyle === \"bezier\";\n            var src = _p.source;\n            var tgt = _p.target;\n            var srcIndex = src.poolIndex();\n            var tgtIndex = tgt.poolIndex();\n            var pairId = [\n                srcIndex,\n                tgtIndex\n            ].sort();\n            var tableEntry = hashTable.get(pairId);\n            if (tableEntry == null) {\n                tableEntry = {\n                    eles: []\n                };\n                hashTable.set(pairId, tableEntry);\n                pairIds.push(pairId);\n            }\n            tableEntry.eles.push(edge);\n            if (edgeIsUnbundled) {\n                tableEntry.hasUnbundled = true;\n            }\n            if (edgeIsBezier) {\n                tableEntry.hasBezier = true;\n            }\n        } // for each pair (src, tgt), create the ctrl pts\n        // Nested for loop is OK; total number of iterations for both loops = edgeCount\n        var _loop = function _loop(p) {\n            var pairId = pairIds[p];\n            var pairInfo = hashTable.get(pairId);\n            var swappedpairInfo = void 0;\n            if (!pairInfo.hasUnbundled) {\n                var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {\n                    return e.isBundledBezier();\n                });\n                clearArray(pairInfo.eles);\n                pllEdges.forEach(function(edge) {\n                    return pairInfo.eles.push(edge);\n                }); // for each pair id, the edges should be sorted by index\n                pairInfo.eles.sort(function(edge1, edge2) {\n                    return edge1.poolIndex() - edge2.poolIndex();\n                });\n            }\n            var firstEdge = pairInfo.eles[0];\n            var src = firstEdge.source();\n            var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId\n            if (src.poolIndex() > tgt.poolIndex()) {\n                var temp = src;\n                src = tgt;\n                tgt = temp;\n            }\n            var srcPos = pairInfo.srcPos = src.position();\n            var tgtPos = pairInfo.tgtPos = tgt.position();\n            var srcW = pairInfo.srcW = src.outerWidth();\n            var srcH = pairInfo.srcH = src.outerHeight();\n            var tgtW = pairInfo.tgtW = tgt.outerWidth();\n            var tgtH = pairInfo.tgtH = tgt.outerHeight();\n            var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n            var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n            pairInfo.dirCounts = {\n                \"north\": 0,\n                \"west\": 0,\n                \"south\": 0,\n                \"east\": 0,\n                \"northwest\": 0,\n                \"southwest\": 0,\n                \"northeast\": 0,\n                \"southeast\": 0\n            };\n            for(var _i2 = 0; _i2 < pairInfo.eles.length; _i2++){\n                var _edge = pairInfo.eles[_i2];\n                var rs = _edge[0]._private.rscratch;\n                var _curveStyle = _edge.pstyle(\"curve-style\").value;\n                var _edgeIsUnbundled = _curveStyle === \"unbundled-bezier\" || _curveStyle === \"segments\" || _curveStyle === \"taxi\"; // whether the normalised pair order is the reverse of the edge's src-tgt order\n                var edgeIsSwapped = !src.same(_edge.source());\n                if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n                    pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt\n                    var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n                    var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt\n                    var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n                    var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n                    var intersectionPts = pairInfo.intersectionPts = {\n                        x1: srcOutside[0],\n                        x2: tgtOutside[0],\n                        y1: srcOutside[1],\n                        y2: tgtOutside[1]\n                    };\n                    var posPts = pairInfo.posPts = {\n                        x1: srcPos.x,\n                        x2: tgtPos.x,\n                        y1: srcPos.y,\n                        y2: tgtPos.y\n                    };\n                    var dy = tgtOutside[1] - srcOutside[1];\n                    var dx = tgtOutside[0] - srcOutside[0];\n                    var l = Math.sqrt(dx * dx + dy * dy);\n                    var vector = pairInfo.vector = {\n                        x: dx,\n                        y: dy\n                    };\n                    var vectorNorm = pairInfo.vectorNorm = {\n                        x: vector.x / l,\n                        y: vector.y / l\n                    };\n                    var vectorNormInverse = {\n                        x: -vectorNorm.y,\n                        y: vectorNorm.x\n                    }; // if node shapes overlap, then no ctrl pts to draw\n                    pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);\n                    pairInfo.vectorNormInverse = vectorNormInverse;\n                    swappedpairInfo = {\n                        nodesOverlap: pairInfo.nodesOverlap,\n                        dirCounts: pairInfo.dirCounts,\n                        calculatedIntersection: true,\n                        hasBezier: pairInfo.hasBezier,\n                        hasUnbundled: pairInfo.hasUnbundled,\n                        eles: pairInfo.eles,\n                        srcPos: tgtPos,\n                        tgtPos: srcPos,\n                        srcW: tgtW,\n                        srcH: tgtH,\n                        tgtW: srcW,\n                        tgtH: srcH,\n                        srcIntn: tgtIntn,\n                        tgtIntn: srcIntn,\n                        srcShape: tgtShape,\n                        tgtShape: srcShape,\n                        posPts: {\n                            x1: posPts.x2,\n                            y1: posPts.y2,\n                            x2: posPts.x1,\n                            y2: posPts.y1\n                        },\n                        intersectionPts: {\n                            x1: intersectionPts.x2,\n                            y1: intersectionPts.y2,\n                            x2: intersectionPts.x1,\n                            y2: intersectionPts.y1\n                        },\n                        vector: {\n                            x: -vector.x,\n                            y: -vector.y\n                        },\n                        vectorNorm: {\n                            x: -vectorNorm.x,\n                            y: -vectorNorm.y\n                        },\n                        vectorNormInverse: {\n                            x: -vectorNormInverse.x,\n                            y: -vectorNormInverse.y\n                        }\n                    };\n                }\n                var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n                rs.nodesOverlap = passedPairInfo.nodesOverlap;\n                rs.srcIntn = passedPairInfo.srcIntn;\n                rs.tgtIntn = passedPairInfo.tgtIntn;\n                if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n                    _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n                } else if (src === tgt) {\n                    _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n                } else if (_curveStyle === \"segments\") {\n                    _this.findSegmentsPoints(_edge, passedPairInfo);\n                } else if (_curveStyle === \"taxi\") {\n                    _this.findTaxiPoints(_edge, passedPairInfo);\n                } else if (_curveStyle === \"straight\" || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n                    _this.findStraightEdgePoints(_edge);\n                } else {\n                    _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n                }\n                _this.findEndpoints(_edge);\n                _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n                _this.checkForInvalidEdgeWarning(_edge);\n                _this.storeAllpts(_edge);\n                _this.storeEdgeProjections(_edge);\n                _this.calculateArrowAngles(_edge);\n                _this.recalculateEdgeLabelProjections(_edge);\n                _this.calculateLabelAngles(_edge);\n            } // for pair edges\n        };\n        for(var p = 0; p < pairIds.length; p++){\n            _loop(p);\n        } // for pair ids\n        // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n        this.findHaystackPoints(haystackEdges);\n    };\n    function getPts(pts) {\n        var retPts = [];\n        if (pts == null) {\n            return;\n        }\n        for(var i = 0; i < pts.length; i += 2){\n            var x = pts[i];\n            var y = pts[i + 1];\n            retPts.push({\n                x: x,\n                y: y\n            });\n        }\n        return retPts;\n    }\n    BRp$c.getSegmentPoints = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        var type = rs.edgeType;\n        if (type === \"segments\") {\n            this.recalculateRenderedStyle(edge);\n            return getPts(rs.segpts);\n        }\n    };\n    BRp$c.getControlPoints = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        var type = rs.edgeType;\n        if (type === \"bezier\" || type === \"multibezier\" || type === \"self\" || type === \"compound\") {\n            this.recalculateRenderedStyle(edge);\n            return getPts(rs.ctrlpts);\n        }\n    };\n    BRp$c.getEdgeMidpoint = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        this.recalculateRenderedStyle(edge);\n        return {\n            x: rs.midX,\n            y: rs.midY\n        };\n    };\n    var BRp$b = {};\n    BRp$b.manualEndptToPx = function(node, prop) {\n        var r = this;\n        var npos = node.position();\n        var w = node.outerWidth();\n        var h = node.outerHeight();\n        if (prop.value.length === 2) {\n            var p = [\n                prop.pfValue[0],\n                prop.pfValue[1]\n            ];\n            if (prop.units[0] === \"%\") {\n                p[0] = p[0] * w;\n            }\n            if (prop.units[1] === \"%\") {\n                p[1] = p[1] * h;\n            }\n            p[0] += npos.x;\n            p[1] += npos.y;\n            return p;\n        } else {\n            var angle = prop.pfValue[0];\n            angle = -Math.PI / 2 + angle; // start at 12 o'clock\n            var l = 2 * Math.max(w, h);\n            var _p = [\n                npos.x + Math.cos(angle) * l,\n                npos.y + Math.sin(angle) * l\n            ];\n            return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n        }\n    };\n    BRp$b.findEndpoints = function(edge) {\n        var r = this;\n        var intersect;\n        var source = edge.source()[0];\n        var target = edge.target()[0];\n        var srcPos = source.position();\n        var tgtPos = target.position();\n        var tgtArShape = edge.pstyle(\"target-arrow-shape\").value;\n        var srcArShape = edge.pstyle(\"source-arrow-shape\").value;\n        var tgtDist = edge.pstyle(\"target-distance-from-node\").pfValue;\n        var srcDist = edge.pstyle(\"source-distance-from-node\").pfValue;\n        var curveStyle = edge.pstyle(\"curve-style\").value;\n        var rs = edge._private.rscratch;\n        var et = rs.edgeType;\n        var taxi = curveStyle === \"taxi\";\n        var self1 = et === \"self\" || et === \"compound\";\n        var bezier = et === \"bezier\" || et === \"multibezier\" || self1;\n        var multi = et !== \"bezier\";\n        var lines = et === \"straight\" || et === \"segments\";\n        var segments = et === \"segments\";\n        var hasEndpts = bezier || multi || lines;\n        var overrideEndpts = self1 || taxi;\n        var srcManEndpt = edge.pstyle(\"source-endpoint\");\n        var srcManEndptVal = overrideEndpts ? \"outside-to-node\" : srcManEndpt.value;\n        var tgtManEndpt = edge.pstyle(\"target-endpoint\");\n        var tgtManEndptVal = overrideEndpts ? \"outside-to-node\" : tgtManEndpt.value;\n        rs.srcManEndpt = srcManEndpt;\n        rs.tgtManEndpt = tgtManEndpt;\n        var p1; // last known point of edge on target side\n        var p2; // last known point of edge on source side\n        var p1_i; // point to intersect with target shape\n        var p2_i; // point to intersect with source shape\n        if (bezier) {\n            var cpStart = [\n                rs.ctrlpts[0],\n                rs.ctrlpts[1]\n            ];\n            var cpEnd = multi ? [\n                rs.ctrlpts[rs.ctrlpts.length - 2],\n                rs.ctrlpts[rs.ctrlpts.length - 1]\n            ] : cpStart;\n            p1 = cpEnd;\n            p2 = cpStart;\n        } else if (lines) {\n            var srcArrowFromPt = !segments ? [\n                tgtPos.x,\n                tgtPos.y\n            ] : rs.segpts.slice(0, 2);\n            var tgtArrowFromPt = !segments ? [\n                srcPos.x,\n                srcPos.y\n            ] : rs.segpts.slice(rs.segpts.length - 2);\n            p1 = tgtArrowFromPt;\n            p2 = srcArrowFromPt;\n        }\n        if (tgtManEndptVal === \"inside-to-node\") {\n            intersect = [\n                tgtPos.x,\n                tgtPos.y\n            ];\n        } else if (tgtManEndpt.units) {\n            intersect = this.manualEndptToPx(target, tgtManEndpt);\n        } else if (tgtManEndptVal === \"outside-to-line\") {\n            intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n        } else {\n            if (tgtManEndptVal === \"outside-to-node\" || tgtManEndptVal === \"outside-to-node-or-label\") {\n                p1_i = p1;\n            } else if (tgtManEndptVal === \"outside-to-line\" || tgtManEndptVal === \"outside-to-line-or-label\") {\n                p1_i = [\n                    srcPos.x,\n                    srcPos.y\n                ];\n            }\n            intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n            if (tgtManEndptVal === \"outside-to-node-or-label\" || tgtManEndptVal === \"outside-to-line-or-label\") {\n                var trs = target._private.rscratch;\n                var lw = trs.labelWidth;\n                var lh = trs.labelHeight;\n                var lx = trs.labelX;\n                var ly = trs.labelY;\n                var lw2 = lw / 2;\n                var lh2 = lh / 2;\n                var va = target.pstyle(\"text-valign\").value;\n                if (va === \"top\") {\n                    ly -= lh2;\n                } else if (va === \"bottom\") {\n                    ly += lh2;\n                }\n                var ha = target.pstyle(\"text-halign\").value;\n                if (ha === \"left\") {\n                    lx -= lw2;\n                } else if (ha === \"right\") {\n                    lx += lw2;\n                }\n                var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [\n                    lx - lw2,\n                    ly - lh2,\n                    lx + lw2,\n                    ly - lh2,\n                    lx + lw2,\n                    ly + lh2,\n                    lx - lw2,\n                    ly + lh2\n                ], tgtPos.x, tgtPos.y);\n                if (labelIntersect.length > 0) {\n                    var refPt = srcPos;\n                    var intSqdist = sqdist(refPt, array2point(intersect));\n                    var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n                    var minSqDist = intSqdist;\n                    if (labIntSqdist < intSqdist) {\n                        intersect = labelIntersect;\n                        minSqDist = labIntSqdist;\n                    }\n                    if (labelIntersect.length > 2) {\n                        var labInt2SqDist = sqdist(refPt, {\n                            x: labelIntersect[2],\n                            y: labelIntersect[3]\n                        });\n                        if (labInt2SqDist < minSqDist) {\n                            intersect = [\n                                labelIntersect[2],\n                                labelIntersect[3]\n                            ];\n                        }\n                    }\n                }\n            }\n        }\n        var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n        var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n        rs.endX = edgeEnd[0];\n        rs.endY = edgeEnd[1];\n        rs.arrowEndX = arrowEnd[0];\n        rs.arrowEndY = arrowEnd[1];\n        if (srcManEndptVal === \"inside-to-node\") {\n            intersect = [\n                srcPos.x,\n                srcPos.y\n            ];\n        } else if (srcManEndpt.units) {\n            intersect = this.manualEndptToPx(source, srcManEndpt);\n        } else if (srcManEndptVal === \"outside-to-line\") {\n            intersect = rs.srcIntn; // use cached value from ctrlpt calc\n        } else {\n            if (srcManEndptVal === \"outside-to-node\" || srcManEndptVal === \"outside-to-node-or-label\") {\n                p2_i = p2;\n            } else if (srcManEndptVal === \"outside-to-line\" || srcManEndptVal === \"outside-to-line-or-label\") {\n                p2_i = [\n                    tgtPos.x,\n                    tgtPos.y\n                ];\n            }\n            intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n            if (srcManEndptVal === \"outside-to-node-or-label\" || srcManEndptVal === \"outside-to-line-or-label\") {\n                var srs = source._private.rscratch;\n                var _lw = srs.labelWidth;\n                var _lh = srs.labelHeight;\n                var _lx = srs.labelX;\n                var _ly = srs.labelY;\n                var _lw2 = _lw / 2;\n                var _lh2 = _lh / 2;\n                var _va = source.pstyle(\"text-valign\").value;\n                if (_va === \"top\") {\n                    _ly -= _lh2;\n                } else if (_va === \"bottom\") {\n                    _ly += _lh2;\n                }\n                var _ha = source.pstyle(\"text-halign\").value;\n                if (_ha === \"left\") {\n                    _lx -= _lw2;\n                } else if (_ha === \"right\") {\n                    _lx += _lw2;\n                }\n                var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [\n                    _lx - _lw2,\n                    _ly - _lh2,\n                    _lx + _lw2,\n                    _ly - _lh2,\n                    _lx + _lw2,\n                    _ly + _lh2,\n                    _lx - _lw2,\n                    _ly + _lh2\n                ], srcPos.x, srcPos.y);\n                if (_labelIntersect.length > 0) {\n                    var _refPt = tgtPos;\n                    var _intSqdist = sqdist(_refPt, array2point(intersect));\n                    var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n                    var _minSqDist = _intSqdist;\n                    if (_labIntSqdist < _intSqdist) {\n                        intersect = [\n                            _labelIntersect[0],\n                            _labelIntersect[1]\n                        ];\n                        _minSqDist = _labIntSqdist;\n                    }\n                    if (_labelIntersect.length > 2) {\n                        var _labInt2SqDist = sqdist(_refPt, {\n                            x: _labelIntersect[2],\n                            y: _labelIntersect[3]\n                        });\n                        if (_labInt2SqDist < _minSqDist) {\n                            intersect = [\n                                _labelIntersect[2],\n                                _labelIntersect[3]\n                            ];\n                        }\n                    }\n                }\n            }\n        }\n        var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n        var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n        rs.startX = edgeStart[0];\n        rs.startY = edgeStart[1];\n        rs.arrowStartX = arrowStart[0];\n        rs.arrowStartY = arrowStart[1];\n        if (hasEndpts) {\n            if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n                rs.badLine = true;\n            } else {\n                rs.badLine = false;\n            }\n        }\n    };\n    BRp$b.getSourceEndpoint = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        this.recalculateRenderedStyle(edge);\n        switch(rs.edgeType){\n            case \"haystack\":\n                return {\n                    x: rs.haystackPts[0],\n                    y: rs.haystackPts[1]\n                };\n            default:\n                return {\n                    x: rs.arrowStartX,\n                    y: rs.arrowStartY\n                };\n        }\n    };\n    BRp$b.getTargetEndpoint = function(edge) {\n        var rs = edge[0]._private.rscratch;\n        this.recalculateRenderedStyle(edge);\n        switch(rs.edgeType){\n            case \"haystack\":\n                return {\n                    x: rs.haystackPts[2],\n                    y: rs.haystackPts[3]\n                };\n            default:\n                return {\n                    x: rs.arrowEndX,\n                    y: rs.arrowEndY\n                };\n        }\n    };\n    var BRp$a = {};\n    function pushBezierPts(r, edge, pts) {\n        var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n            return qbezierAt(p1, p2, p3, t);\n        };\n        var _p = edge._private;\n        var bpts = _p.rstyle.bezierPts;\n        for(var i = 0; i < r.bezierProjPcts.length; i++){\n            var p = r.bezierProjPcts[i];\n            bpts.push({\n                x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n                y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n            });\n        }\n    }\n    BRp$a.storeEdgeProjections = function(edge) {\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        var et = rs.edgeType; // clear the cached points state\n        _p.rstyle.bezierPts = null;\n        _p.rstyle.linePts = null;\n        _p.rstyle.haystackPts = null;\n        if (et === \"multibezier\" || et === \"bezier\" || et === \"self\" || et === \"compound\") {\n            _p.rstyle.bezierPts = [];\n            for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n            }\n        } else if (et === \"segments\") {\n            var lpts = _p.rstyle.linePts = [];\n            for(var i = 0; i + 1 < rs.allpts.length; i += 2){\n                lpts.push({\n                    x: rs.allpts[i],\n                    y: rs.allpts[i + 1]\n                });\n            }\n        } else if (et === \"haystack\") {\n            var hpts = rs.haystackPts;\n            _p.rstyle.haystackPts = [\n                {\n                    x: hpts[0],\n                    y: hpts[1]\n                },\n                {\n                    x: hpts[2],\n                    y: hpts[3]\n                }\n            ];\n        }\n        _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.arrowShapeWidth;\n    };\n    BRp$a.recalculateEdgeProjections = function(edges) {\n        this.findEdgeControlPoints(edges);\n    };\n    /* global document */ var BRp$9 = {};\n    BRp$9.recalculateNodeLabelProjection = function(node) {\n        var content = node.pstyle(\"label\").strValue;\n        if (emptyString(content)) {\n            return;\n        }\n        var textX, textY;\n        var _p = node._private;\n        var nodeWidth = node.width();\n        var nodeHeight = node.height();\n        var padding = node.padding();\n        var nodePos = node.position();\n        var textHalign = node.pstyle(\"text-halign\").strValue;\n        var textValign = node.pstyle(\"text-valign\").strValue;\n        var rs = _p.rscratch;\n        var rstyle = _p.rstyle;\n        switch(textHalign){\n            case \"left\":\n                textX = nodePos.x - nodeWidth / 2 - padding;\n                break;\n            case \"right\":\n                textX = nodePos.x + nodeWidth / 2 + padding;\n                break;\n            default:\n                // e.g. center\n                textX = nodePos.x;\n        }\n        switch(textValign){\n            case \"top\":\n                textY = nodePos.y - nodeHeight / 2 - padding;\n                break;\n            case \"bottom\":\n                textY = nodePos.y + nodeHeight / 2 + padding;\n                break;\n            default:\n                // e.g. middle\n                textY = nodePos.y;\n        }\n        rs.labelX = textX;\n        rs.labelY = textY;\n        rstyle.labelX = textX;\n        rstyle.labelY = textY;\n        this.calculateLabelAngles(node);\n        this.applyLabelDimensions(node);\n    };\n    var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n        var angle = Math.atan(dy / dx);\n        if (dx === 0 && angle < 0) {\n            angle = angle * -1;\n        }\n        return angle;\n    };\n    var lineAngle = function lineAngle(p0, p1) {\n        var dx = p1.x - p0.x;\n        var dy = p1.y - p0.y;\n        return lineAngleFromDelta(dx, dy);\n    };\n    var bezierAngle = function bezierAngle(p0, p1, p2, t) {\n        var t0 = bound(0, t - 0.001, 1);\n        var t1 = bound(0, t + 0.001, 1);\n        var lp0 = qbezierPtAt(p0, p1, p2, t0);\n        var lp1 = qbezierPtAt(p0, p1, p2, t1);\n        return lineAngle(lp0, lp1);\n    };\n    BRp$9.recalculateEdgeLabelProjections = function(edge) {\n        var p;\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        var r = this;\n        var content = {\n            mid: edge.pstyle(\"label\").strValue,\n            source: edge.pstyle(\"source-label\").strValue,\n            target: edge.pstyle(\"target-label\").strValue\n        };\n        if (content.mid || content.source || content.target) ;\n        else {\n            return; // no labels => no calcs\n        } // add center point to style so bounding box calculations can use it\n        //\n        p = {\n            x: rs.midX,\n            y: rs.midY\n        };\n        var setRs = function setRs(propName, prefix, value) {\n            setPrefixedProperty(_p.rscratch, propName, prefix, value);\n            setPrefixedProperty(_p.rstyle, propName, prefix, value);\n        };\n        setRs(\"labelX\", null, p.x);\n        setRs(\"labelY\", null, p.y);\n        var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n        setRs(\"labelAutoAngle\", null, midAngle);\n        var createControlPointInfo = function createControlPointInfo() {\n            if (createControlPointInfo.cache) {\n                return createControlPointInfo.cache;\n            } // use cache so only 1x per edge\n            var ctrlpts = []; // store each ctrlpt info init\n            for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                var p0 = {\n                    x: rs.allpts[i],\n                    y: rs.allpts[i + 1]\n                };\n                var p1 = {\n                    x: rs.allpts[i + 2],\n                    y: rs.allpts[i + 3]\n                }; // ctrlpt\n                var p2 = {\n                    x: rs.allpts[i + 4],\n                    y: rs.allpts[i + 5]\n                };\n                ctrlpts.push({\n                    p0: p0,\n                    p1: p1,\n                    p2: p2,\n                    startDist: 0,\n                    length: 0,\n                    segments: []\n                });\n            }\n            var bpts = _p.rstyle.bezierPts;\n            var nProjs = r.bezierProjPcts.length;\n            function addSegment(cp, p0, p1, t0, t1) {\n                var length = dist(p0, p1);\n                var prevSegment = cp.segments[cp.segments.length - 1];\n                var segment = {\n                    p0: p0,\n                    p1: p1,\n                    t0: t0,\n                    t1: t1,\n                    startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n                    length: length\n                };\n                cp.segments.push(segment);\n                cp.length += length;\n            } // update each ctrlpt with segment info\n            for(var _i = 0; _i < ctrlpts.length; _i++){\n                var cp = ctrlpts[_i];\n                var prevCp = ctrlpts[_i - 1];\n                if (prevCp) {\n                    cp.startDist = prevCp.startDist + prevCp.length;\n                }\n                addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n                for(var j = 0; j < nProjs - 1; j++){\n                    addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n                }\n                addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n            }\n            return createControlPointInfo.cache = ctrlpts;\n        };\n        var calculateEndProjection = function calculateEndProjection(prefix) {\n            var angle;\n            var isSrc = prefix === \"source\";\n            if (!content[prefix]) {\n                return;\n            }\n            var offset = edge.pstyle(prefix + \"-text-offset\").pfValue;\n            switch(rs.edgeType){\n                case \"self\":\n                case \"compound\":\n                case \"bezier\":\n                case \"multibezier\":\n                    {\n                        var cps = createControlPointInfo();\n                        var selected;\n                        var startDist = 0;\n                        var totalDist = 0; // find the segment we're on\n                        for(var i = 0; i < cps.length; i++){\n                            var _cp = cps[isSrc ? i : cps.length - 1 - i];\n                            for(var j = 0; j < _cp.segments.length; j++){\n                                var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                                var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                                startDist = totalDist;\n                                totalDist += _seg.length;\n                                if (totalDist >= offset || lastSeg) {\n                                    selected = {\n                                        cp: _cp,\n                                        segment: _seg\n                                    };\n                                    break;\n                                }\n                            }\n                            if (selected) {\n                                break;\n                            }\n                        }\n                        var cp = selected.cp;\n                        var seg = selected.segment;\n                        var tSegment = (offset - startDist) / seg.length;\n                        var segDt = seg.t1 - seg.t0;\n                        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n                        t = bound(0, t, 1);\n                        p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n                        angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n                        break;\n                    }\n                case \"straight\":\n                case \"segments\":\n                case \"haystack\":\n                    {\n                        var d = 0, di, d0;\n                        var p0, p1;\n                        var l = rs.allpts.length;\n                        for(var _i2 = 0; _i2 + 3 < l; _i2 += 2){\n                            if (isSrc) {\n                                p0 = {\n                                    x: rs.allpts[_i2],\n                                    y: rs.allpts[_i2 + 1]\n                                };\n                                p1 = {\n                                    x: rs.allpts[_i2 + 2],\n                                    y: rs.allpts[_i2 + 3]\n                                };\n                            } else {\n                                p0 = {\n                                    x: rs.allpts[l - 2 - _i2],\n                                    y: rs.allpts[l - 1 - _i2]\n                                };\n                                p1 = {\n                                    x: rs.allpts[l - 4 - _i2],\n                                    y: rs.allpts[l - 3 - _i2]\n                                };\n                            }\n                            di = dist(p0, p1);\n                            d0 = d;\n                            d += di;\n                            if (d >= offset) {\n                                break;\n                            }\n                        }\n                        var pD = offset - d0;\n                        var _t = pD / di;\n                        _t = bound(0, _t, 1);\n                        p = lineAt(p0, p1, _t);\n                        angle = lineAngle(p0, p1);\n                        break;\n                    }\n            }\n            setRs(\"labelX\", prefix, p.x);\n            setRs(\"labelY\", prefix, p.y);\n            setRs(\"labelAutoAngle\", prefix, angle);\n        };\n        calculateEndProjection(\"source\");\n        calculateEndProjection(\"target\");\n        this.applyLabelDimensions(edge);\n    };\n    BRp$9.applyLabelDimensions = function(ele) {\n        this.applyPrefixedLabelDimensions(ele);\n        if (ele.isEdge()) {\n            this.applyPrefixedLabelDimensions(ele, \"source\");\n            this.applyPrefixedLabelDimensions(ele, \"target\");\n        }\n    };\n    BRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {\n        var _p = ele._private;\n        var text = this.getLabelText(ele, prefix);\n        var labelDims = this.calculateLabelDimensions(ele, text);\n        var lineHeight = ele.pstyle(\"line-height\").pfValue;\n        var textWrap = ele.pstyle(\"text-wrap\").strValue;\n        var lines = getPrefixedProperty(_p.rscratch, \"labelWrapCachedLines\", prefix) || [];\n        var numLines = textWrap !== \"wrap\" ? 1 : Math.max(lines.length, 1);\n        var normPerLineHeight = labelDims.height / numLines;\n        var labelLineHeight = normPerLineHeight * lineHeight;\n        var width = labelDims.width;\n        var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n        setPrefixedProperty(_p.rstyle, \"labelWidth\", prefix, width);\n        setPrefixedProperty(_p.rscratch, \"labelWidth\", prefix, width);\n        setPrefixedProperty(_p.rstyle, \"labelHeight\", prefix, height);\n        setPrefixedProperty(_p.rscratch, \"labelHeight\", prefix, height);\n        setPrefixedProperty(_p.rscratch, \"labelLineHeight\", prefix, labelLineHeight);\n    };\n    BRp$9.getLabelText = function(ele, prefix) {\n        var _p = ele._private;\n        var pfd = prefix ? prefix + \"-\" : \"\";\n        var text = ele.pstyle(pfd + \"label\").strValue;\n        var textTransform = ele.pstyle(\"text-transform\").value;\n        var rscratch = function rscratch(propName, value) {\n            if (value) {\n                setPrefixedProperty(_p.rscratch, propName, prefix, value);\n                return value;\n            } else {\n                return getPrefixedProperty(_p.rscratch, propName, prefix);\n            }\n        }; // for empty text, skip all processing\n        if (!text) {\n            return \"\";\n        }\n        if (textTransform == \"none\") ;\n        else if (textTransform == \"uppercase\") {\n            text = text.toUpperCase();\n        } else if (textTransform == \"lowercase\") {\n            text = text.toLowerCase();\n        }\n        var wrapStyle = ele.pstyle(\"text-wrap\").value;\n        if (wrapStyle === \"wrap\") {\n            var labelKey = rscratch(\"labelKey\"); // save recalc if the label is the same as before\n            if (labelKey != null && rscratch(\"labelWrapKey\") === labelKey) {\n                return rscratch(\"labelWrapCachedText\");\n            }\n            var zwsp = \"​\";\n            var lines = text.split(\"\\n\");\n            var maxW = ele.pstyle(\"text-max-width\").pfValue;\n            var overflow = ele.pstyle(\"text-overflow-wrap\").value;\n            var overflowAny = overflow === \"anywhere\";\n            var wrappedLines = [];\n            var wordsRegex = /[\\s\\u200b]+/;\n            var wordSeparator = overflowAny ? \"\" : \" \";\n            for(var l = 0; l < lines.length; l++){\n                var line = lines[l];\n                var lineDims = this.calculateLabelDimensions(ele, line);\n                var lineW = lineDims.width;\n                if (overflowAny) {\n                    var processedLine = line.split(\"\").join(zwsp);\n                    line = processedLine;\n                }\n                if (lineW > maxW) {\n                    // line is too long\n                    var words = line.split(wordsRegex);\n                    var subline = \"\";\n                    for(var w = 0; w < words.length; w++){\n                        var word = words[w];\n                        var testLine = subline.length === 0 ? word : subline + wordSeparator + word;\n                        var testDims = this.calculateLabelDimensions(ele, testLine);\n                        var testW = testDims.width;\n                        if (testW <= maxW) {\n                            // word fits on current line\n                            subline += word + wordSeparator;\n                        } else {\n                            // word starts new line\n                            if (subline) {\n                                wrappedLines.push(subline);\n                            }\n                            subline = word + wordSeparator;\n                        }\n                    } // if there's remaining text, put it in a wrapped line\n                    if (!subline.match(/^[\\s\\u200b]+$/)) {\n                        wrappedLines.push(subline);\n                    }\n                } else {\n                    // line is already short enough\n                    wrappedLines.push(line);\n                }\n            } // for\n            rscratch(\"labelWrapCachedLines\", wrappedLines);\n            text = rscratch(\"labelWrapCachedText\", wrappedLines.join(\"\\n\"));\n            rscratch(\"labelWrapKey\", labelKey);\n        } else if (wrapStyle === \"ellipsis\") {\n            var _maxW = ele.pstyle(\"text-max-width\").pfValue;\n            var ellipsized = \"\";\n            var ellipsis = \"…\";\n            var incLastCh = false;\n            if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n                // the label already fits\n                return text;\n            }\n            for(var i = 0; i < text.length; i++){\n                var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n                if (widthWithNextCh > _maxW) {\n                    break;\n                }\n                ellipsized += text[i];\n                if (i === text.length - 1) {\n                    incLastCh = true;\n                }\n            }\n            if (!incLastCh) {\n                ellipsized += ellipsis;\n            }\n            return ellipsized;\n        } // if ellipsize\n        return text;\n    };\n    BRp$9.getLabelJustification = function(ele) {\n        var justification = ele.pstyle(\"text-justification\").strValue;\n        var textHalign = ele.pstyle(\"text-halign\").strValue;\n        if (justification === \"auto\") {\n            if (ele.isNode()) {\n                switch(textHalign){\n                    case \"left\":\n                        return \"right\";\n                    case \"right\":\n                        return \"left\";\n                    default:\n                        return \"center\";\n                }\n            } else {\n                return \"center\";\n            }\n        } else {\n            return justification;\n        }\n    };\n    BRp$9.calculateLabelDimensions = function(ele, text) {\n        var r = this;\n        var cacheKey = hashString(text, ele._private.labelDimsKey);\n        var cache = r.labelDimCache || (r.labelDimCache = []);\n        var existingVal = cache[cacheKey];\n        if (existingVal != null) {\n            return existingVal;\n        }\n        var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n        var fStyle = ele.pstyle(\"font-style\").strValue;\n        var size = ele.pstyle(\"font-size\").pfValue;\n        var family = ele.pstyle(\"font-family\").strValue;\n        var weight = ele.pstyle(\"font-weight\").strValue;\n        var canvas = this.labelCalcCanvas;\n        var c2d = this.labelCalcCanvasContext;\n        if (!canvas) {\n            canvas = this.labelCalcCanvas = document.createElement(\"canvas\");\n            c2d = this.labelCalcCanvasContext = canvas.getContext(\"2d\");\n            var ds = canvas.style;\n            ds.position = \"absolute\";\n            ds.left = \"-9999px\";\n            ds.top = \"-9999px\";\n            ds.zIndex = \"-1\";\n            ds.visibility = \"hidden\";\n            ds.pointerEvents = \"none\";\n        }\n        c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n        var width = 0;\n        var height = 0;\n        var lines = text.split(\"\\n\");\n        for(var i = 0; i < lines.length; i++){\n            var line = lines[i];\n            var metrics = c2d.measureText(line);\n            var w = Math.ceil(metrics.width);\n            var h = size;\n            width = Math.max(w, width);\n            height += h;\n        }\n        width += padding;\n        height += padding;\n        return cache[cacheKey] = {\n            width: width,\n            height: height\n        };\n    };\n    BRp$9.calculateLabelAngle = function(ele, prefix) {\n        var _p = ele._private;\n        var rs = _p.rscratch;\n        var isEdge = ele.isEdge();\n        var prefixDash = prefix ? prefix + \"-\" : \"\";\n        var rot = ele.pstyle(prefixDash + \"text-rotation\");\n        var rotStr = rot.strValue;\n        if (rotStr === \"none\") {\n            return 0;\n        } else if (isEdge && rotStr === \"autorotate\") {\n            return rs.labelAutoAngle;\n        } else if (rotStr === \"autorotate\") {\n            return 0;\n        } else {\n            return rot.pfValue;\n        }\n    };\n    BRp$9.calculateLabelAngles = function(ele) {\n        var r = this;\n        var isEdge = ele.isEdge();\n        var _p = ele._private;\n        var rs = _p.rscratch;\n        rs.labelAngle = r.calculateLabelAngle(ele);\n        if (isEdge) {\n            rs.sourceLabelAngle = r.calculateLabelAngle(ele, \"source\");\n            rs.targetLabelAngle = r.calculateLabelAngle(ele, \"target\");\n        }\n    };\n    var BRp$8 = {};\n    var TOO_SMALL_CUT_RECT = 28;\n    var warnedCutRect = false;\n    BRp$8.getNodeShape = function(node) {\n        var r = this;\n        var shape = node.pstyle(\"shape\").value;\n        if (shape === \"cutrectangle\" && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n            if (!warnedCutRect) {\n                warn(\"The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead\");\n                warnedCutRect = true;\n            }\n            return \"rectangle\";\n        }\n        if (node.isParent()) {\n            if (shape === \"rectangle\" || shape === \"roundrectangle\" || shape === \"round-rectangle\" || shape === \"cutrectangle\" || shape === \"cut-rectangle\" || shape === \"barrel\") {\n                return shape;\n            } else {\n                return \"rectangle\";\n            }\n        }\n        if (shape === \"polygon\") {\n            var points = node.pstyle(\"shape-polygon-points\").value;\n            return r.nodeShapes.makePolygon(points).name;\n        }\n        return shape;\n    };\n    var BRp$7 = {};\n    BRp$7.registerCalculationListeners = function() {\n        var cy = this.cy;\n        var elesToUpdate = cy.collection();\n        var r = this;\n        var enqueue = function enqueue(eles) {\n            var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            elesToUpdate.merge(eles);\n            if (dirtyStyleCaches) {\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _p = ele._private;\n                    var rstyle = _p.rstyle;\n                    rstyle.clean = false;\n                    rstyle.cleanConnected = false;\n                }\n            }\n        };\n        r.binder(cy).on(\"bounds.* dirty.*\", function onDirtyBounds(e) {\n            var ele = e.target;\n            enqueue(ele);\n        }).on(\"style.* background.*\", function onDirtyStyle(e) {\n            var ele = e.target;\n            enqueue(ele, false);\n        });\n        var updateEleCalcs = function updateEleCalcs(willDraw) {\n            if (willDraw) {\n                var fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)\n                // before calculating rendered style (and pstyle might not be called yet)\n                elesToUpdate.cleanStyle();\n                for(var i = 0; i < elesToUpdate.length; i++){\n                    var ele = elesToUpdate[i];\n                    var rstyle = ele._private.rstyle;\n                    if (ele.isNode() && !rstyle.cleanConnected) {\n                        enqueue(ele.connectedEdges());\n                        rstyle.cleanConnected = true;\n                    }\n                }\n                if (fns) {\n                    for(var _i = 0; _i < fns.length; _i++){\n                        var fn = fns[_i];\n                        fn(willDraw, elesToUpdate);\n                    }\n                }\n                r.recalculateRenderedStyle(elesToUpdate);\n                elesToUpdate = cy.collection();\n            }\n        };\n        r.flushRenderedStyleQueue = function() {\n            updateEleCalcs(true);\n        };\n        r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n    };\n    BRp$7.onUpdateEleCalcs = function(fn) {\n        var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n        fns.push(fn);\n    };\n    BRp$7.recalculateRenderedStyle = function(eles, useCache) {\n        var isCleanConnected = function isCleanConnected(ele) {\n            return ele._private.rstyle.cleanConnected;\n        };\n        var edges = [];\n        var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n        if (this.destroyed) {\n            return;\n        } // use cache by default for perf\n        if (useCache === undefined) {\n            useCache = true;\n        }\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var _p = ele._private;\n            var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes\n            // (and a request for recalc may come in between frames)\n            if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n                rstyle.clean = false;\n            } // only update if dirty and in graph\n            if (useCache && rstyle.clean || ele.removed()) {\n                continue;\n            } // only update if not display: none\n            if (ele.pstyle(\"display\").value === \"none\") {\n                continue;\n            }\n            if (_p.group === \"nodes\") {\n                nodes.push(ele);\n            } else {\n                // edges\n                edges.push(ele);\n            }\n            rstyle.clean = true;\n        } // update node data from projections\n        for(var _i2 = 0; _i2 < nodes.length; _i2++){\n            var _ele = nodes[_i2];\n            var _p2 = _ele._private;\n            var _rstyle = _p2.rstyle;\n            var pos = _ele.position();\n            this.recalculateNodeLabelProjection(_ele);\n            _rstyle.nodeX = pos.x;\n            _rstyle.nodeY = pos.y;\n            _rstyle.nodeW = _ele.pstyle(\"width\").pfValue;\n            _rstyle.nodeH = _ele.pstyle(\"height\").pfValue;\n        }\n        this.recalculateEdgeProjections(edges); // update edge data from projections\n        for(var _i3 = 0; _i3 < edges.length; _i3++){\n            var _ele2 = edges[_i3];\n            var _p3 = _ele2._private;\n            var _rstyle2 = _p3.rstyle;\n            var rs = _p3.rscratch; // update rstyle positions\n            _rstyle2.srcX = rs.arrowStartX;\n            _rstyle2.srcY = rs.arrowStartY;\n            _rstyle2.tgtX = rs.arrowEndX;\n            _rstyle2.tgtY = rs.arrowEndY;\n            _rstyle2.midX = rs.midX;\n            _rstyle2.midY = rs.midY;\n            _rstyle2.labelAngle = rs.labelAngle;\n            _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n            _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n        }\n    };\n    var BRp$6 = {};\n    BRp$6.updateCachedGrabbedEles = function() {\n        var eles = this.cachedZSortedEles;\n        if (!eles) {\n            // just let this be recalculated on the next z sort tick\n            return;\n        }\n        eles.drag = [];\n        eles.nondrag = [];\n        var grabTargets = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var rs = ele._private.rscratch;\n            if (ele.grabbed() && !ele.isParent()) {\n                grabTargets.push(ele);\n            } else if (rs.inDragLayer) {\n                eles.drag.push(ele);\n            } else {\n                eles.nondrag.push(ele);\n            }\n        } // put the grab target nodes last so it's on top of its neighbourhood\n        for(var i = 0; i < grabTargets.length; i++){\n            var ele = grabTargets[i];\n            eles.drag.push(ele);\n        }\n    };\n    BRp$6.invalidateCachedZSortedEles = function() {\n        this.cachedZSortedEles = null;\n    };\n    BRp$6.getCachedZSortedEles = function(forceRecalc) {\n        if (forceRecalc || !this.cachedZSortedEles) {\n            var eles = this.cy.mutableElements().toArray();\n            eles.sort(zIndexSort);\n            eles.interactive = eles.filter(function(ele) {\n                return ele.interactive();\n            });\n            this.cachedZSortedEles = eles;\n            this.updateCachedGrabbedEles();\n        } else {\n            eles = this.cachedZSortedEles;\n        }\n        return eles;\n    };\n    var BRp$5 = {};\n    [\n        BRp$e,\n        BRp$d,\n        BRp$c,\n        BRp$b,\n        BRp$a,\n        BRp$9,\n        BRp$8,\n        BRp$7,\n        BRp$6\n    ].forEach(function(props) {\n        extend(BRp$5, props);\n    });\n    var BRp$4 = {};\n    BRp$4.getCachedImage = function(url, crossOrigin, onLoad) {\n        var r = this;\n        var imageCache = r.imageCache = r.imageCache || {};\n        var cache = imageCache[url];\n        if (cache) {\n            if (!cache.image.complete) {\n                cache.image.addEventListener(\"load\", onLoad);\n            }\n            return cache.image;\n        } else {\n            cache = imageCache[url] = imageCache[url] || {};\n            var image = cache.image = new Image(); // eslint-disable-line no-undef\n            image.addEventListener(\"load\", onLoad);\n            image.addEventListener(\"error\", function() {\n                image.error = true;\n            }); // #1582 safari doesn't load data uris with crossOrigin properly\n            // https://bugs.webkit.org/show_bug.cgi?id=123978\n            var dataUriPrefix = \"data:\";\n            var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n            if (!isDataUri) {\n                // if crossorigin is 'null'(stringified), then manually set it to null \n                crossOrigin = crossOrigin === \"null\" ? null : crossOrigin;\n                image.crossOrigin = crossOrigin; // prevent tainted canvas\n            }\n            image.src = url;\n            return image;\n        }\n    };\n    var BRp$3 = {};\n    /* global document, window, ResizeObserver, MutationObserver */ BRp$3.registerBinding = function(target, event, handler, useCapture) {\n        // eslint-disable-line no-unused-vars\n        var args = Array.prototype.slice.apply(arguments, [\n            1\n        ]); // copy\n        var b = this.binder(target);\n        return b.on.apply(b, args);\n    };\n    BRp$3.binder = function(tgt) {\n        var r = this;\n        var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);\n        if (r.supportsPassiveEvents == null) {\n            // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n            var supportsPassive = false;\n            try {\n                var opts = Object.defineProperty({}, \"passive\", {\n                    get: function get() {\n                        supportsPassive = true;\n                        return true;\n                    }\n                });\n                window.addEventListener(\"test\", null, opts);\n            } catch (err) {}\n            r.supportsPassiveEvents = supportsPassive;\n        }\n        var on = function on(event, handler, useCapture) {\n            var args = Array.prototype.slice.call(arguments);\n            if (tgtIsDom && r.supportsPassiveEvents) {\n                // replace useCapture w/ opts obj\n                args[2] = {\n                    capture: useCapture != null ? useCapture : false,\n                    passive: false,\n                    once: false\n                };\n            }\n            r.bindings.push({\n                target: tgt,\n                args: args\n            });\n            (tgt.addEventListener || tgt.on).apply(tgt, args);\n            return this;\n        };\n        return {\n            on: on,\n            addEventListener: on,\n            addListener: on,\n            bind: on\n        };\n    };\n    BRp$3.nodeIsDraggable = function(node) {\n        return node && node.isNode() && !node.locked() && node.grabbable();\n    };\n    BRp$3.nodeIsGrabbable = function(node) {\n        return this.nodeIsDraggable(node) && node.interactive();\n    };\n    BRp$3.load = function() {\n        var r = this;\n        var isSelected = function isSelected(ele) {\n            return ele.selected();\n        };\n        var triggerEvents = function triggerEvents(target, names, e, position) {\n            if (target == null) {\n                target = r.cy;\n            }\n            for(var i = 0; i < names.length; i++){\n                var name = names[i];\n                target.emit({\n                    originalEvent: e,\n                    type: name,\n                    position: position\n                });\n            }\n        };\n        var isMultSelKeyDown = function isMultSelKeyDown(e) {\n            return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n        };\n        var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n            var allowPassthrough = true;\n            if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n                // a grabbable compound node below the ele => no passthrough panning\n                for(var i = 0; downs && i < downs.length; i++){\n                    var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough\n                    if (down.isNode() && down.isParent() && !down.pannable()) {\n                        allowPassthrough = false;\n                        break;\n                    }\n                }\n            } else {\n                allowPassthrough = true;\n            }\n            return allowPassthrough;\n        };\n        var setGrabbed = function setGrabbed(ele) {\n            ele[0]._private.grabbed = true;\n        };\n        var setFreed = function setFreed(ele) {\n            ele[0]._private.grabbed = false;\n        };\n        var setInDragLayer = function setInDragLayer(ele) {\n            ele[0]._private.rscratch.inDragLayer = true;\n        };\n        var setOutDragLayer = function setOutDragLayer(ele) {\n            ele[0]._private.rscratch.inDragLayer = false;\n        };\n        var setGrabTarget = function setGrabTarget(ele) {\n            ele[0]._private.rscratch.isGrabTarget = true;\n        };\n        var removeGrabTarget = function removeGrabTarget(ele) {\n            ele[0]._private.rscratch.isGrabTarget = false;\n        };\n        var addToDragList = function addToDragList(ele, opts) {\n            var list = opts.addToList;\n            var listHasEle = list.has(ele);\n            if (!listHasEle && ele.grabbable() && !ele.locked()) {\n                list.merge(ele);\n                setGrabbed(ele);\n            }\n        }; // helper function to determine which child nodes and inner edges\n        // of a compound node to be dragged as well as the grabbed and selected nodes\n        var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n            if (!node.cy().hasCompoundNodes()) {\n                return;\n            }\n            if (opts.inDragLayer == null && opts.addToList == null) {\n                return;\n            } // nothing to do\n            var innerNodes = node.descendants();\n            if (opts.inDragLayer) {\n                innerNodes.forEach(setInDragLayer);\n                innerNodes.connectedEdges().forEach(setInDragLayer);\n            }\n            if (opts.addToList) {\n                addToDragList(innerNodes, opts);\n            }\n        }; // adds the given nodes and its neighbourhood to the drag layer\n        var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n            opts = opts || {};\n            var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n            if (opts.inDragLayer) {\n                nodes.forEach(setInDragLayer);\n                nodes.neighborhood().stdFilter(function(ele) {\n                    return !hasCompoundNodes || ele.isEdge();\n                }).forEach(setInDragLayer);\n            }\n            if (opts.addToList) {\n                nodes.forEach(function(ele) {\n                    addToDragList(ele, opts);\n                });\n            }\n            addDescendantsToDrag(nodes, opts); // always add to drag\n            // also add nodes and edges related to the topmost ancestor\n            updateAncestorsInDragLayer(nodes, {\n                inDragLayer: opts.inDragLayer\n            });\n            r.updateCachedGrabbedEles();\n        };\n        var addNodeToDrag = addNodesToDrag;\n        var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n            if (!grabbedEles) {\n                return;\n            } // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n            r.getCachedZSortedEles().forEach(function(ele) {\n                setFreed(ele);\n                setOutDragLayer(ele);\n                removeGrabTarget(ele);\n            });\n            r.updateCachedGrabbedEles();\n        }; // helper function to determine which ancestor nodes and edges should go\n        // to the drag layer (or should be removed from drag layer).\n        var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n            if (opts.inDragLayer == null && opts.addToList == null) {\n                return;\n            } // nothing to do\n            if (!node.cy().hasCompoundNodes()) {\n                return;\n            } // find top-level parent\n            var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer\n            if (parent.same(node)) {\n                return;\n            }\n            var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n            var edges = nodes.connectedEdges();\n            if (opts.inDragLayer) {\n                edges.forEach(setInDragLayer);\n                nodes.forEach(setInDragLayer);\n            }\n            if (opts.addToList) {\n                nodes.forEach(function(ele) {\n                    addToDragList(ele, opts);\n                });\n            }\n        };\n        var blurActiveDomElement = function blurActiveDomElement() {\n            if (document.activeElement != null && document.activeElement.blur != null) {\n                document.activeElement.blur();\n            }\n        };\n        var haveMutationsApi = typeof MutationObserver !== \"undefined\";\n        var haveResizeObserverApi = typeof ResizeObserver !== \"undefined\"; // watch for when the cy container is removed from the dom\n        if (haveMutationsApi) {\n            r.removeObserver = new MutationObserver(function(mutns) {\n                // eslint-disable-line no-undef\n                for(var i = 0; i < mutns.length; i++){\n                    var mutn = mutns[i];\n                    var rNodes = mutn.removedNodes;\n                    if (rNodes) {\n                        for(var j = 0; j < rNodes.length; j++){\n                            var rNode = rNodes[j];\n                            if (rNode === r.container) {\n                                r.destroy();\n                                break;\n                            }\n                        }\n                    }\n                }\n            });\n            if (r.container.parentNode) {\n                r.removeObserver.observe(r.container.parentNode, {\n                    childList: true\n                });\n            }\n        } else {\n            r.registerBinding(r.container, \"DOMNodeRemoved\", function(e) {\n                // eslint-disable-line no-unused-vars\n                r.destroy();\n            });\n        }\n        var onResize = debounce_1(function() {\n            r.cy.resize();\n        }, 100);\n        if (haveMutationsApi) {\n            r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n            r.styleObserver.observe(r.container, {\n                attributes: true\n            });\n        } // auto resize\n        r.registerBinding(window, \"resize\", onResize); // eslint-disable-line no-undef\n        if (haveResizeObserverApi) {\n            r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n            r.resizeObserver.observe(r.container);\n        }\n        var forEachUp = function forEachUp(domEle, fn) {\n            while(domEle != null){\n                fn(domEle);\n                domEle = domEle.parentNode;\n            }\n        };\n        var invalidateCoords = function invalidateCoords() {\n            r.invalidateContainerClientCoordsCache();\n        };\n        forEachUp(r.container, function(domEle) {\n            r.registerBinding(domEle, \"transitionend\", invalidateCoords);\n            r.registerBinding(domEle, \"animationend\", invalidateCoords);\n            r.registerBinding(domEle, \"scroll\", invalidateCoords);\n        }); // stop right click menu from appearing on cy\n        r.registerBinding(r.container, \"contextmenu\", function(e) {\n            e.preventDefault();\n        });\n        var inBoxSelection = function inBoxSelection() {\n            return r.selection[4] !== 0;\n        };\n        var eventInContainer = function eventInContainer(e) {\n            // save cycles if mouse events aren't to be captured\n            var containerPageCoords = r.findContainerClientCoords();\n            var x = containerPageCoords[0];\n            var y = containerPageCoords[1];\n            var width = containerPageCoords[2];\n            var height = containerPageCoords[3];\n            var positions = e.touches ? e.touches : [\n                e\n            ];\n            var atLeastOnePosInside = false;\n            for(var i = 0; i < positions.length; i++){\n                var p = positions[i];\n                if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n                    atLeastOnePosInside = true;\n                    break;\n                }\n            }\n            if (!atLeastOnePosInside) {\n                return false;\n            }\n            var container = r.container;\n            var target = e.target;\n            var tParent = target.parentNode;\n            var containerIsTarget = false;\n            while(tParent){\n                if (tParent === container) {\n                    containerIsTarget = true;\n                    break;\n                }\n                tParent = tParent.parentNode;\n            }\n            if (!containerIsTarget) {\n                return false;\n            } // if target is outisde cy container, then this event is not for us\n            return true;\n        }; // Primary key\n        r.registerBinding(r.container, \"mousedown\", function mousedownHandler(e) {\n            if (!eventInContainer(e)) {\n                return;\n            }\n            e.preventDefault();\n            blurActiveDomElement();\n            r.hoverData.capture = true;\n            r.hoverData.which = e.which;\n            var cy = r.cy;\n            var gpos = [\n                e.clientX,\n                e.clientY\n            ];\n            var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n            var select = r.selection;\n            var nears = r.findNearestElements(pos[0], pos[1], true, false);\n            var near = nears[0];\n            var draggedElements = r.dragData.possibleDragElements;\n            r.hoverData.mdownPos = pos;\n            r.hoverData.mdownGPos = gpos;\n            var checkForTaphold = function checkForTaphold() {\n                r.hoverData.tapholdCancelled = false;\n                clearTimeout(r.hoverData.tapholdTimeout);\n                r.hoverData.tapholdTimeout = setTimeout(function() {\n                    if (r.hoverData.tapholdCancelled) {\n                        return;\n                    } else {\n                        var ele = r.hoverData.down;\n                        if (ele) {\n                            ele.emit({\n                                originalEvent: e,\n                                type: \"taphold\",\n                                position: {\n                                    x: pos[0],\n                                    y: pos[1]\n                                }\n                            });\n                        } else {\n                            cy.emit({\n                                originalEvent: e,\n                                type: \"taphold\",\n                                position: {\n                                    x: pos[0],\n                                    y: pos[1]\n                                }\n                            });\n                        }\n                    }\n                }, r.tapholdDuration);\n            }; // Right click button\n            if (e.which == 3) {\n                r.hoverData.cxtStarted = true;\n                var cxtEvt = {\n                    originalEvent: e,\n                    type: \"cxttapstart\",\n                    position: {\n                        x: pos[0],\n                        y: pos[1]\n                    }\n                };\n                if (near) {\n                    near.activate();\n                    near.emit(cxtEvt);\n                    r.hoverData.down = near;\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                r.hoverData.downTime = new Date().getTime();\n                r.hoverData.cxtDragged = false; // Primary button\n            } else if (e.which == 1) {\n                if (near) {\n                    near.activate();\n                } // Element dragging\n                {\n                    // If something is under the cursor and it is draggable, prepare to grab it\n                    if (near != null) {\n                        if (r.nodeIsGrabbable(near)) {\n                            var makeEvent = function makeEvent(type) {\n                                return {\n                                    originalEvent: e,\n                                    type: type,\n                                    position: {\n                                        x: pos[0],\n                                        y: pos[1]\n                                    }\n                                };\n                            };\n                            var triggerGrab = function triggerGrab(ele) {\n                                ele.emit(makeEvent(\"grab\"));\n                            };\n                            setGrabTarget(near);\n                            if (!near.selected()) {\n                                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                                addNodeToDrag(near, {\n                                    addToList: draggedElements\n                                });\n                                near.emit(makeEvent(\"grabon\")).emit(makeEvent(\"grab\"));\n                            } else {\n                                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                                var selectedNodes = cy.$(function(ele) {\n                                    return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                                });\n                                addNodesToDrag(selectedNodes, {\n                                    addToList: draggedElements\n                                });\n                                near.emit(makeEvent(\"grabon\"));\n                                selectedNodes.forEach(triggerGrab);\n                            }\n                            r.redrawHint(\"eles\", true);\n                            r.redrawHint(\"drag\", true);\n                        }\n                    }\n                    r.hoverData.down = near;\n                    r.hoverData.downs = nears;\n                    r.hoverData.downTime = new Date().getTime();\n                }\n                triggerEvents(near, [\n                    \"mousedown\",\n                    \"tapstart\",\n                    \"vmousedown\"\n                ], e, {\n                    x: pos[0],\n                    y: pos[1]\n                });\n                if (near == null) {\n                    select[4] = 1;\n                    r.data.bgActivePosistion = {\n                        x: pos[0],\n                        y: pos[1]\n                    };\n                    r.redrawHint(\"select\", true);\n                    r.redraw();\n                } else if (near.pannable()) {\n                    select[4] = 1; // for future pan\n                }\n                checkForTaphold();\n            } // Initialize selection box coordinates\n            select[0] = select[2] = pos[0];\n            select[1] = select[3] = pos[1];\n        }, false);\n        r.registerBinding(window, \"mousemove\", function mousemoveHandler(e) {\n            // eslint-disable-line no-undef\n            var capture = r.hoverData.capture;\n            if (!capture && !eventInContainer(e)) {\n                return;\n            }\n            var preventDefault = false;\n            var cy = r.cy;\n            var zoom = cy.zoom();\n            var gpos = [\n                e.clientX,\n                e.clientY\n            ];\n            var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n            var mdownPos = r.hoverData.mdownPos;\n            var mdownGPos = r.hoverData.mdownGPos;\n            var select = r.selection;\n            var near = null;\n            if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n                near = r.findNearestElement(pos[0], pos[1], true, false);\n            }\n            var last = r.hoverData.last;\n            var down = r.hoverData.down;\n            var disp = [\n                pos[0] - select[2],\n                pos[1] - select[3]\n            ];\n            var draggedElements = r.dragData.possibleDragElements;\n            var isOverThresholdDrag;\n            if (mdownGPos) {\n                var dx = gpos[0] - mdownGPos[0];\n                var dx2 = dx * dx;\n                var dy = gpos[1] - mdownGPos[1];\n                var dy2 = dy * dy;\n                var dist2 = dx2 + dy2;\n                r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n            }\n            var multSelKeyDown = isMultSelKeyDown(e);\n            if (isOverThresholdDrag) {\n                r.hoverData.tapholdCancelled = true;\n            }\n            var updateDragDelta = function updateDragDelta() {\n                var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n                if (dragDelta.length === 0) {\n                    dragDelta.push(disp[0]);\n                    dragDelta.push(disp[1]);\n                } else {\n                    dragDelta[0] += disp[0];\n                    dragDelta[1] += disp[1];\n                }\n            };\n            preventDefault = true;\n            triggerEvents(near, [\n                \"mousemove\",\n                \"vmousemove\",\n                \"tapdrag\"\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            var goIntoBoxMode = function goIntoBoxMode() {\n                r.data.bgActivePosistion = undefined;\n                if (!r.hoverData.selecting) {\n                    cy.emit({\n                        originalEvent: e,\n                        type: \"boxstart\",\n                        position: {\n                            x: pos[0],\n                            y: pos[1]\n                        }\n                    });\n                }\n                select[4] = 1;\n                r.hoverData.selecting = true;\n                r.redrawHint(\"select\", true);\n                r.redraw();\n            }; // trigger context drag if rmouse down\n            if (r.hoverData.which === 3) {\n                // but only if over threshold\n                if (isOverThresholdDrag) {\n                    var cxtEvt = {\n                        originalEvent: e,\n                        type: \"cxtdrag\",\n                        position: {\n                            x: pos[0],\n                            y: pos[1]\n                        }\n                    };\n                    if (down) {\n                        down.emit(cxtEvt);\n                    } else {\n                        cy.emit(cxtEvt);\n                    }\n                    r.hoverData.cxtDragged = true;\n                    if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n                        if (r.hoverData.cxtOver) {\n                            r.hoverData.cxtOver.emit({\n                                originalEvent: e,\n                                type: \"cxtdragout\",\n                                position: {\n                                    x: pos[0],\n                                    y: pos[1]\n                                }\n                            });\n                        }\n                        r.hoverData.cxtOver = near;\n                        if (near) {\n                            near.emit({\n                                originalEvent: e,\n                                type: \"cxtdragover\",\n                                position: {\n                                    x: pos[0],\n                                    y: pos[1]\n                                }\n                            });\n                        }\n                    }\n                } // Check if we are drag panning the entire graph\n            } else if (r.hoverData.dragging) {\n                preventDefault = true;\n                if (cy.panningEnabled() && cy.userPanningEnabled()) {\n                    var deltaP;\n                    if (r.hoverData.justStartedPan) {\n                        var mdPos = r.hoverData.mdownPos;\n                        deltaP = {\n                            x: (pos[0] - mdPos[0]) * zoom,\n                            y: (pos[1] - mdPos[1]) * zoom\n                        };\n                        r.hoverData.justStartedPan = false;\n                    } else {\n                        deltaP = {\n                            x: disp[0] * zoom,\n                            y: disp[1] * zoom\n                        };\n                    }\n                    cy.panBy(deltaP);\n                    cy.emit(\"dragpan\");\n                    r.hoverData.dragged = true;\n                } // Needs reproject due to pan changing viewport\n                pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much\n            } else if (select[4] == 1 && (down == null || down.pannable())) {\n                if (isOverThresholdDrag) {\n                    if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n                        goIntoBoxMode();\n                    } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n                        var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n                        if (allowPassthrough) {\n                            r.hoverData.dragging = true;\n                            r.hoverData.justStartedPan = true;\n                            select[4] = 0;\n                            r.data.bgActivePosistion = array2point(mdownPos);\n                            r.redrawHint(\"select\", true);\n                            r.redraw();\n                        }\n                    }\n                    if (down && down.pannable() && down.active()) {\n                        down.unactivate();\n                    }\n                }\n            } else {\n                if (down && down.pannable() && down.active()) {\n                    down.unactivate();\n                }\n                if ((!down || !down.grabbed()) && near != last) {\n                    if (last) {\n                        triggerEvents(last, [\n                            \"mouseout\",\n                            \"tapdragout\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    }\n                    if (near) {\n                        triggerEvents(near, [\n                            \"mouseover\",\n                            \"tapdragover\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    }\n                    r.hoverData.last = near;\n                }\n                if (down) {\n                    if (isOverThresholdDrag) {\n                        // then we can take action\n                        if (cy.boxSelectionEnabled() && multSelKeyDown) {\n                            // then selection overrides\n                            if (down && down.grabbed()) {\n                                freeDraggedElements(draggedElements);\n                                down.emit(\"freeon\");\n                                draggedElements.emit(\"free\");\n                                if (r.dragData.didDrag) {\n                                    down.emit(\"dragfreeon\");\n                                    draggedElements.emit(\"dragfree\");\n                                }\n                            }\n                            goIntoBoxMode();\n                        } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n                            // drag node\n                            var justStartedDrag = !r.dragData.didDrag;\n                            if (justStartedDrag) {\n                                r.redrawHint(\"eles\", true);\n                            }\n                            r.dragData.didDrag = true; // indicate that we actually did drag the node\n                            // now, add the elements to the drag layer if not done already\n                            if (!r.hoverData.draggingEles) {\n                                addNodesToDrag(draggedElements, {\n                                    inDragLayer: true\n                                });\n                            }\n                            var totalShift = {\n                                x: 0,\n                                y: 0\n                            };\n                            if (number$1(disp[0]) && number$1(disp[1])) {\n                                totalShift.x += disp[0];\n                                totalShift.y += disp[1];\n                                if (justStartedDrag) {\n                                    var dragDelta = r.hoverData.dragDelta;\n                                    if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                        totalShift.x += dragDelta[0];\n                                        totalShift.y += dragDelta[1];\n                                    }\n                                }\n                            }\n                            r.hoverData.draggingEles = true;\n                            draggedElements.silentShift(totalShift).emit(\"position drag\");\n                            r.redrawHint(\"drag\", true);\n                            r.redraw();\n                        }\n                    } else {\n                        // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n                        updateDragDelta();\n                    }\n                } // prevent the dragging from triggering text selection on the page\n                preventDefault = true;\n            }\n            select[2] = pos[0];\n            select[3] = pos[1];\n            if (preventDefault) {\n                if (e.stopPropagation) e.stopPropagation();\n                if (e.preventDefault) e.preventDefault();\n                return false;\n            }\n        }, false);\n        var clickTimeout, didDoubleClick, prevClickTimeStamp;\n        r.registerBinding(window, \"mouseup\", function mouseupHandler(e) {\n            // eslint-disable-line no-undef\n            var capture = r.hoverData.capture;\n            if (!capture) {\n                return;\n            }\n            r.hoverData.capture = false;\n            var cy = r.cy;\n            var pos = r.projectIntoViewport(e.clientX, e.clientY);\n            var select = r.selection;\n            var near = r.findNearestElement(pos[0], pos[1], true, false);\n            var draggedElements = r.dragData.possibleDragElements;\n            var down = r.hoverData.down;\n            var multSelKeyDown = isMultSelKeyDown(e);\n            if (r.data.bgActivePosistion) {\n                r.redrawHint(\"select\", true);\n                r.redraw();\n            }\n            r.hoverData.tapholdCancelled = true;\n            r.data.bgActivePosistion = undefined; // not active bg now\n            if (down) {\n                down.unactivate();\n            }\n            if (r.hoverData.which === 3) {\n                var cxtEvt = {\n                    originalEvent: e,\n                    type: \"cxttapend\",\n                    position: {\n                        x: pos[0],\n                        y: pos[1]\n                    }\n                };\n                if (down) {\n                    down.emit(cxtEvt);\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                if (!r.hoverData.cxtDragged) {\n                    var cxtTap = {\n                        originalEvent: e,\n                        type: \"cxttap\",\n                        position: {\n                            x: pos[0],\n                            y: pos[1]\n                        }\n                    };\n                    if (down) {\n                        down.emit(cxtTap);\n                    } else {\n                        cy.emit(cxtTap);\n                    }\n                }\n                r.hoverData.cxtDragged = false;\n                r.hoverData.which = null;\n            } else if (r.hoverData.which === 1) {\n                triggerEvents(near, [\n                    \"mouseup\",\n                    \"tapend\",\n                    \"vmouseup\"\n                ], e, {\n                    x: pos[0],\n                    y: pos[1]\n                });\n                if (!r.dragData.didDrag && // didn't move a node around\n                !r.hoverData.dragged && // didn't pan\n                !r.hoverData.selecting && // not box selection\n                !r.hoverData.isOverThresholdDrag // didn't move too much\n                ) {\n                    triggerEvents(down, [\n                        \"click\",\n                        \"tap\",\n                        \"vclick\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                    didDoubleClick = false;\n                    if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n                        clickTimeout && clearTimeout(clickTimeout);\n                        didDoubleClick = true;\n                        prevClickTimeStamp = null;\n                        triggerEvents(down, [\n                            \"dblclick\",\n                            \"dbltap\",\n                            \"vdblclick\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    } else {\n                        clickTimeout = setTimeout(function() {\n                            if (didDoubleClick) return;\n                            triggerEvents(down, [\n                                \"oneclick\",\n                                \"onetap\",\n                                \"voneclick\"\n                            ], e, {\n                                x: pos[0],\n                                y: pos[1]\n                            });\n                        }, cy.multiClickDebounceTime());\n                        prevClickTimeStamp = e.timeStamp;\n                    }\n                } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n                if (down == null // not mousedown on node\n                 && !r.dragData.didDrag // didn't move the node around\n                 && !r.hoverData.selecting // not box selection\n                 && !r.hoverData.dragged // didn't pan\n                 && !isMultSelKeyDown(e)) {\n                    cy.$(isSelected).unselect([\n                        \"tapunselect\"\n                    ]);\n                    if (draggedElements.length > 0) {\n                        r.redrawHint(\"eles\", true);\n                    }\n                    r.dragData.possibleDragElements = draggedElements = cy.collection();\n                } // Single selection\n                if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n                    if (near != null && near._private.selectable) {\n                        if (r.hoverData.dragging) ;\n                        else if (cy.selectionType() === \"additive\" || multSelKeyDown) {\n                            if (near.selected()) {\n                                near.unselect([\n                                    \"tapunselect\"\n                                ]);\n                            } else {\n                                near.select([\n                                    \"tapselect\"\n                                ]);\n                            }\n                        } else {\n                            if (!multSelKeyDown) {\n                                cy.$(isSelected).unmerge(near).unselect([\n                                    \"tapunselect\"\n                                ]);\n                                near.select([\n                                    \"tapselect\"\n                                ]);\n                            }\n                        }\n                        r.redrawHint(\"eles\", true);\n                    }\n                }\n                if (r.hoverData.selecting) {\n                    var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n                    r.redrawHint(\"select\", true);\n                    if (box.length > 0) {\n                        r.redrawHint(\"eles\", true);\n                    }\n                    cy.emit({\n                        type: \"boxend\",\n                        originalEvent: e,\n                        position: {\n                            x: pos[0],\n                            y: pos[1]\n                        }\n                    });\n                    var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                        return ele.selectable() && !ele.selected();\n                    };\n                    if (cy.selectionType() === \"additive\") {\n                        box.emit(\"box\").stdFilter(eleWouldBeSelected).select().emit(\"boxselect\");\n                    } else {\n                        if (!multSelKeyDown) {\n                            cy.$(isSelected).unmerge(box).unselect();\n                        }\n                        box.emit(\"box\").stdFilter(eleWouldBeSelected).select().emit(\"boxselect\");\n                    } // always need redraw in case eles unselectable\n                    r.redraw();\n                } // Cancel drag pan\n                if (r.hoverData.dragging) {\n                    r.hoverData.dragging = false;\n                    r.redrawHint(\"select\", true);\n                    r.redrawHint(\"eles\", true);\n                    r.redraw();\n                }\n                if (!select[4]) {\n                    r.redrawHint(\"drag\", true);\n                    r.redrawHint(\"eles\", true);\n                    var downWasGrabbed = down && down.grabbed();\n                    freeDraggedElements(draggedElements);\n                    if (downWasGrabbed) {\n                        down.emit(\"freeon\");\n                        draggedElements.emit(\"free\");\n                        if (r.dragData.didDrag) {\n                            down.emit(\"dragfreeon\");\n                            draggedElements.emit(\"dragfree\");\n                        }\n                    }\n                }\n            } // else not right mouse\n            select[4] = 0;\n            r.hoverData.down = null;\n            r.hoverData.cxtStarted = false;\n            r.hoverData.draggingEles = false;\n            r.hoverData.selecting = false;\n            r.hoverData.isOverThresholdDrag = false;\n            r.dragData.didDrag = false;\n            r.hoverData.dragged = false;\n            r.hoverData.dragDelta = [];\n            r.hoverData.mdownPos = null;\n            r.hoverData.mdownGPos = null;\n        }, false);\n        var wheelHandler = function wheelHandler(e) {\n            if (r.scrollingPage) {\n                return;\n            } // while scrolling, ignore wheel-to-zoom\n            var cy = r.cy;\n            var zoom = cy.zoom();\n            var pan = cy.pan();\n            var pos = r.projectIntoViewport(e.clientX, e.clientY);\n            var rpos = [\n                pos[0] * zoom + pan.x,\n                pos[1] * zoom + pan.y\n            ];\n            if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n                // if pan dragging or cxt dragging, wheel movements make no zoom\n                e.preventDefault();\n                return;\n            }\n            if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n                e.preventDefault();\n                r.data.wheelZooming = true;\n                clearTimeout(r.data.wheelTimeout);\n                r.data.wheelTimeout = setTimeout(function() {\n                    r.data.wheelZooming = false;\n                    r.redrawHint(\"eles\", true);\n                    r.redraw();\n                }, 150);\n                var diff;\n                if (e.deltaY != null) {\n                    diff = e.deltaY / -250;\n                } else if (e.wheelDeltaY != null) {\n                    diff = e.wheelDeltaY / 1000;\n                } else {\n                    diff = e.wheelDelta / 1000;\n                }\n                diff = diff * r.wheelSensitivity;\n                var needsWheelFix = e.deltaMode === 1;\n                if (needsWheelFix) {\n                    // fixes slow wheel events on ff/linux and ff/windows\n                    diff *= 33;\n                }\n                var newZoom = cy.zoom() * Math.pow(10, diff);\n                if (e.type === \"gesturechange\") {\n                    newZoom = r.gestureStartZoom * e.scale;\n                }\n                cy.zoom({\n                    level: newZoom,\n                    renderedPosition: {\n                        x: rpos[0],\n                        y: rpos[1]\n                    }\n                });\n                cy.emit(e.type === \"gesturechange\" ? \"pinchzoom\" : \"scrollzoom\");\n            }\n        }; // Functions to help with whether mouse wheel should trigger zooming\n        // --\n        r.registerBinding(r.container, \"wheel\", wheelHandler, true); // disable nonstandard wheel events\n        // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n        // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n        // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n        r.registerBinding(window, \"scroll\", function scrollHandler(e) {\n            // eslint-disable-line no-unused-vars\n            r.scrollingPage = true;\n            clearTimeout(r.scrollingPageTimeout);\n            r.scrollingPageTimeout = setTimeout(function() {\n                r.scrollingPage = false;\n            }, 250);\n        }, true); // desktop safari pinch to zoom start\n        r.registerBinding(r.container, \"gesturestart\", function gestureStartHandler(e) {\n            r.gestureStartZoom = r.cy.zoom();\n            if (!r.hasTouchStarted) {\n                // don't affect touch devices like iphone\n                e.preventDefault();\n            }\n        }, true);\n        r.registerBinding(r.container, \"gesturechange\", function(e) {\n            if (!r.hasTouchStarted) {\n                // don't affect touch devices like iphone\n                wheelHandler(e);\n            }\n        }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container\n        // Handle mouseout on Cytoscape container\n        r.registerBinding(r.container, \"mouseout\", function mouseOutHandler(e) {\n            var pos = r.projectIntoViewport(e.clientX, e.clientY);\n            r.cy.emit({\n                originalEvent: e,\n                type: \"mouseout\",\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            });\n        }, false);\n        r.registerBinding(r.container, \"mouseover\", function mouseOverHandler(e) {\n            var pos = r.projectIntoViewport(e.clientX, e.clientY);\n            r.cy.emit({\n                originalEvent: e,\n                type: \"mouseover\",\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            });\n        }, false);\n        var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n        var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n        var center1, modelCenter1; // center point on start pinch to zoom\n        var offsetLeft, offsetTop;\n        var containerWidth, containerHeight;\n        var twoFingersStartInside;\n        var distance = function distance(x1, y1, x2, y2) {\n            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n        };\n        var distanceSq = function distanceSq(x1, y1, x2, y2) {\n            return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        };\n        var touchstartHandler;\n        r.registerBinding(r.container, \"touchstart\", touchstartHandler = function touchstartHandler(e) {\n            r.hasTouchStarted = true;\n            if (!eventInContainer(e)) {\n                return;\n            }\n            blurActiveDomElement();\n            r.touchData.capture = true;\n            r.data.bgActivePosistion = undefined;\n            var cy = r.cy;\n            var now = r.touchData.now;\n            var earlier = r.touchData.earlier;\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            } // record starting points for pinch-to-zoom\n            if (e.touches[1]) {\n                r.touchData.singleTouchMoved = true;\n                freeDraggedElements(r.dragData.touchDragEles);\n                var offsets = r.findContainerClientCoords();\n                offsetLeft = offsets[0];\n                offsetTop = offsets[1];\n                containerWidth = offsets[2];\n                containerHeight = offsets[3];\n                f1x1 = e.touches[0].clientX - offsetLeft;\n                f1y1 = e.touches[0].clientY - offsetTop;\n                f2x1 = e.touches[1].clientX - offsetLeft;\n                f2y1 = e.touches[1].clientY - offsetTop;\n                twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n                var pan = cy.pan();\n                var zoom = cy.zoom();\n                distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n                distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n                center1 = [\n                    (f1x1 + f2x1) / 2,\n                    (f1y1 + f2y1) / 2\n                ];\n                modelCenter1 = [\n                    (center1[0] - pan.x) / zoom,\n                    (center1[1] - pan.y) / zoom\n                ]; // consider context tap\n                var cxtDistThreshold = 200;\n                var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n                if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n                    var near1 = r.findNearestElement(now[0], now[1], true, true);\n                    var near2 = r.findNearestElement(now[2], now[3], true, true);\n                    if (near1 && near1.isNode()) {\n                        near1.activate().emit({\n                            originalEvent: e,\n                            type: \"cxttapstart\",\n                            position: {\n                                x: now[0],\n                                y: now[1]\n                            }\n                        });\n                        r.touchData.start = near1;\n                    } else if (near2 && near2.isNode()) {\n                        near2.activate().emit({\n                            originalEvent: e,\n                            type: \"cxttapstart\",\n                            position: {\n                                x: now[0],\n                                y: now[1]\n                            }\n                        });\n                        r.touchData.start = near2;\n                    } else {\n                        cy.emit({\n                            originalEvent: e,\n                            type: \"cxttapstart\",\n                            position: {\n                                x: now[0],\n                                y: now[1]\n                            }\n                        });\n                    }\n                    if (r.touchData.start) {\n                        r.touchData.start._private.grabbed = false;\n                    }\n                    r.touchData.cxt = true;\n                    r.touchData.cxtDragged = false;\n                    r.data.bgActivePosistion = undefined;\n                    r.redraw();\n                    return;\n                }\n            }\n            if (e.touches[2]) {\n                // ignore\n                // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n                if (cy.boxSelectionEnabled()) {\n                    e.preventDefault();\n                }\n            } else if (e.touches[1]) ;\n            else if (e.touches[0]) {\n                var nears = r.findNearestElements(now[0], now[1], true, true);\n                var near = nears[0];\n                if (near != null) {\n                    near.activate();\n                    r.touchData.start = near;\n                    r.touchData.starts = nears;\n                    if (r.nodeIsGrabbable(near)) {\n                        var draggedEles = r.dragData.touchDragEles = cy.collection();\n                        var selectedNodes = null;\n                        r.redrawHint(\"eles\", true);\n                        r.redrawHint(\"drag\", true);\n                        if (near.selected()) {\n                            // reset drag elements, since near will be added again\n                            selectedNodes = cy.$(function(ele) {\n                                return ele.selected() && r.nodeIsGrabbable(ele);\n                            });\n                            addNodesToDrag(selectedNodes, {\n                                addToList: draggedEles\n                            });\n                        } else {\n                            addNodeToDrag(near, {\n                                addToList: draggedEles\n                            });\n                        }\n                        setGrabTarget(near);\n                        var makeEvent = function makeEvent(type) {\n                            return {\n                                originalEvent: e,\n                                type: type,\n                                position: {\n                                    x: now[0],\n                                    y: now[1]\n                                }\n                            };\n                        };\n                        near.emit(makeEvent(\"grabon\"));\n                        if (selectedNodes) {\n                            selectedNodes.forEach(function(n) {\n                                n.emit(makeEvent(\"grab\"));\n                            });\n                        } else {\n                            near.emit(makeEvent(\"grab\"));\n                        }\n                    }\n                }\n                triggerEvents(near, [\n                    \"touchstart\",\n                    \"tapstart\",\n                    \"vmousedown\"\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                if (near == null) {\n                    r.data.bgActivePosistion = {\n                        x: pos[0],\n                        y: pos[1]\n                    };\n                    r.redrawHint(\"select\", true);\n                    r.redraw();\n                } // Tap, taphold\n                // -----\n                r.touchData.singleTouchMoved = false;\n                r.touchData.singleTouchStartTime = +new Date();\n                clearTimeout(r.touchData.tapholdTimeout);\n                r.touchData.tapholdTimeout = setTimeout(function() {\n                    if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n                     && !r.touchData.selecting // box selection shouldn't allow taphold through\n                    ) {\n                        triggerEvents(r.touchData.start, [\n                            \"taphold\"\n                        ], e, {\n                            x: now[0],\n                            y: now[1]\n                        });\n                    }\n                }, r.tapholdDuration);\n            }\n            if (e.touches.length >= 1) {\n                var sPos = r.touchData.startPosition = [];\n                for(var i = 0; i < now.length; i++){\n                    sPos[i] = earlier[i] = now[i];\n                }\n                var touch0 = e.touches[0];\n                r.touchData.startGPosition = [\n                    touch0.clientX,\n                    touch0.clientY\n                ];\n            }\n        }, false);\n        var touchmoveHandler;\n        r.registerBinding(window, \"touchmove\", touchmoveHandler = function touchmoveHandler(e) {\n            // eslint-disable-line no-undef\n            var capture = r.touchData.capture;\n            if (!capture && !eventInContainer(e)) {\n                return;\n            }\n            var select = r.selection;\n            var cy = r.cy;\n            var now = r.touchData.now;\n            var earlier = r.touchData.earlier;\n            var zoom = cy.zoom();\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            }\n            var startGPos = r.touchData.startGPosition;\n            var isOverThresholdDrag;\n            if (capture && e.touches[0] && startGPos) {\n                var disp = [];\n                for(var j = 0; j < now.length; j++){\n                    disp[j] = now[j] - earlier[j];\n                }\n                var dx = e.touches[0].clientX - startGPos[0];\n                var dx2 = dx * dx;\n                var dy = e.touches[0].clientY - startGPos[1];\n                var dy2 = dy * dy;\n                var dist2 = dx2 + dy2;\n                isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n            } // context swipe cancelling\n            if (capture && r.touchData.cxt) {\n                e.preventDefault();\n                var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n                var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n                var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n                var factorSq = distance2Sq / distance1Sq;\n                var distThreshold = 150;\n                var distThresholdSq = distThreshold * distThreshold;\n                var factorThreshold = 1.5;\n                var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases\n                if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n                    r.touchData.cxt = false;\n                    r.data.bgActivePosistion = undefined;\n                    r.redrawHint(\"select\", true);\n                    var cxtEvt = {\n                        originalEvent: e,\n                        type: \"cxttapend\",\n                        position: {\n                            x: now[0],\n                            y: now[1]\n                        }\n                    };\n                    if (r.touchData.start) {\n                        r.touchData.start.unactivate().emit(cxtEvt);\n                        r.touchData.start = null;\n                    } else {\n                        cy.emit(cxtEvt);\n                    }\n                }\n            } // context swipe\n            if (capture && r.touchData.cxt) {\n                var cxtEvt = {\n                    originalEvent: e,\n                    type: \"cxtdrag\",\n                    position: {\n                        x: now[0],\n                        y: now[1]\n                    }\n                };\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n                if (r.touchData.start) {\n                    r.touchData.start.emit(cxtEvt);\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                if (r.touchData.start) {\n                    r.touchData.start._private.grabbed = false;\n                }\n                r.touchData.cxtDragged = true;\n                var near = r.findNearestElement(now[0], now[1], true, true);\n                if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n                    if (r.touchData.cxtOver) {\n                        r.touchData.cxtOver.emit({\n                            originalEvent: e,\n                            type: \"cxtdragout\",\n                            position: {\n                                x: now[0],\n                                y: now[1]\n                            }\n                        });\n                    }\n                    r.touchData.cxtOver = near;\n                    if (near) {\n                        near.emit({\n                            originalEvent: e,\n                            type: \"cxtdragover\",\n                            position: {\n                                x: now[0],\n                                y: now[1]\n                            }\n                        });\n                    }\n                } // box selection\n            } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n                e.preventDefault();\n                r.data.bgActivePosistion = undefined;\n                this.lastThreeTouch = +new Date();\n                if (!r.touchData.selecting) {\n                    cy.emit({\n                        originalEvent: e,\n                        type: \"boxstart\",\n                        position: {\n                            x: now[0],\n                            y: now[1]\n                        }\n                    });\n                }\n                r.touchData.selecting = true;\n                r.touchData.didSelect = true;\n                select[4] = 1;\n                if (!select || select.length === 0 || select[0] === undefined) {\n                    select[0] = (now[0] + now[2] + now[4]) / 3;\n                    select[1] = (now[1] + now[3] + now[5]) / 3;\n                    select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n                    select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n                } else {\n                    select[2] = (now[0] + now[2] + now[4]) / 3;\n                    select[3] = (now[1] + now[3] + now[5]) / 3;\n                }\n                r.redrawHint(\"select\", true);\n                r.redraw(); // pinch to zoom\n            } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n             && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n                // two fingers => pinch to zoom\n                e.preventDefault();\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n                var draggedEles = r.dragData.touchDragEles;\n                if (draggedEles) {\n                    r.redrawHint(\"drag\", true);\n                    for(var i = 0; i < draggedEles.length; i++){\n                        var de_p = draggedEles[i]._private;\n                        de_p.grabbed = false;\n                        de_p.rscratch.inDragLayer = false;\n                    }\n                }\n                var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2\n                var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n                var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n                var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n                // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n                var factor = distance2 / distance1;\n                if (twoFingersStartInside) {\n                    // delta finger1\n                    var df1x = f1x2 - f1x1;\n                    var df1y = f1y2 - f1y1; // delta finger 2\n                    var df2x = f2x2 - f2x1;\n                    var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement\n                    // i.e. so pinching cancels out and moving together pans\n                    var tx = (df1x + df2x) / 2;\n                    var ty = (df1y + df2y) / 2; // now calculate the zoom\n                    var zoom1 = cy.zoom();\n                    var zoom2 = zoom1 * factor;\n                    var pan1 = cy.pan(); // the model center point converted to the current rendered pos\n                    var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n                    var ctry = modelCenter1[1] * zoom1 + pan1.y;\n                    var pan2 = {\n                        x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n                        y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n                    }; // remove dragged eles\n                    if (_start && _start.active()) {\n                        var draggedEles = r.dragData.touchDragEles;\n                        freeDraggedElements(draggedEles);\n                        r.redrawHint(\"drag\", true);\n                        r.redrawHint(\"eles\", true);\n                        _start.unactivate().emit(\"freeon\");\n                        draggedEles.emit(\"free\");\n                        if (r.dragData.didDrag) {\n                            _start.emit(\"dragfreeon\");\n                            draggedEles.emit(\"dragfree\");\n                        }\n                    }\n                    cy.viewport({\n                        zoom: zoom2,\n                        pan: pan2,\n                        cancelOnFailedZoom: true\n                    });\n                    cy.emit(\"pinchzoom\");\n                    distance1 = distance2;\n                    f1x1 = f1x2;\n                    f1y1 = f1y2;\n                    f2x1 = f2x2;\n                    f2y1 = f2y2;\n                    r.pinching = true;\n                } // Re-project\n                if (e.touches[0]) {\n                    var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                    now[0] = pos[0];\n                    now[1] = pos[1];\n                }\n                if (e.touches[1]) {\n                    var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                    now[2] = pos[0];\n                    now[3] = pos[1];\n                }\n                if (e.touches[2]) {\n                    var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                    now[4] = pos[0];\n                    now[5] = pos[1];\n                }\n            } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n            ) {\n                var start = r.touchData.start;\n                var last = r.touchData.last;\n                var near;\n                if (!r.hoverData.draggingEles && !r.swipePanning) {\n                    near = r.findNearestElement(now[0], now[1], true, true);\n                }\n                if (capture && start != null) {\n                    e.preventDefault();\n                } // dragging nodes\n                if (capture && start != null && r.nodeIsDraggable(start)) {\n                    if (isOverThresholdDrag) {\n                        // then dragging can happen\n                        var draggedEles = r.dragData.touchDragEles;\n                        var justStartedDrag = !r.dragData.didDrag;\n                        if (justStartedDrag) {\n                            addNodesToDrag(draggedEles, {\n                                inDragLayer: true\n                            });\n                        }\n                        r.dragData.didDrag = true;\n                        var totalShift = {\n                            x: 0,\n                            y: 0\n                        };\n                        if (number$1(disp[0]) && number$1(disp[1])) {\n                            totalShift.x += disp[0];\n                            totalShift.y += disp[1];\n                            if (justStartedDrag) {\n                                r.redrawHint(\"eles\", true);\n                                var dragDelta = r.touchData.dragDelta;\n                                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                    totalShift.x += dragDelta[0];\n                                    totalShift.y += dragDelta[1];\n                                }\n                            }\n                        }\n                        r.hoverData.draggingEles = true;\n                        draggedEles.silentShift(totalShift).emit(\"position drag\");\n                        r.redrawHint(\"drag\", true);\n                        if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n                            r.redrawHint(\"eles\", true);\n                        }\n                        r.redraw();\n                    } else {\n                        // otherwise keep track of drag delta for later\n                        var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n                        if (dragDelta.length === 0) {\n                            dragDelta.push(disp[0]);\n                            dragDelta.push(disp[1]);\n                        } else {\n                            dragDelta[0] += disp[0];\n                            dragDelta[1] += disp[1];\n                        }\n                    }\n                } // touchmove\n                {\n                    triggerEvents(start || near, [\n                        \"touchmove\",\n                        \"tapdrag\",\n                        \"vmousemove\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                    if ((!start || !start.grabbed()) && near != last) {\n                        if (last) {\n                            last.emit({\n                                originalEvent: e,\n                                type: \"tapdragout\",\n                                position: {\n                                    x: now[0],\n                                    y: now[1]\n                                }\n                            });\n                        }\n                        if (near) {\n                            near.emit({\n                                originalEvent: e,\n                                type: \"tapdragover\",\n                                position: {\n                                    x: now[0],\n                                    y: now[1]\n                                }\n                            });\n                        }\n                    }\n                    r.touchData.last = near;\n                }\n                if (capture) {\n                    for(var i = 0; i < now.length; i++){\n                        if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n                            r.touchData.singleTouchMoved = true;\n                        }\n                    }\n                } // panning\n                if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n                    var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n                    if (allowPassthrough) {\n                        e.preventDefault();\n                        if (!r.data.bgActivePosistion) {\n                            r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n                        }\n                        if (r.swipePanning) {\n                            cy.panBy({\n                                x: disp[0] * zoom,\n                                y: disp[1] * zoom\n                            });\n                            cy.emit(\"dragpan\");\n                        } else if (isOverThresholdDrag) {\n                            r.swipePanning = true;\n                            cy.panBy({\n                                x: dx * zoom,\n                                y: dy * zoom\n                            });\n                            cy.emit(\"dragpan\");\n                            if (start) {\n                                start.unactivate();\n                                r.redrawHint(\"select\", true);\n                                r.touchData.start = null;\n                            }\n                        }\n                    } // Re-project\n                    var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                    now[0] = pos[0];\n                    now[1] = pos[1];\n                }\n            }\n            for(var j = 0; j < now.length; j++){\n                earlier[j] = now[j];\n            } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n            if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n                r.redraw();\n            }\n        }, false);\n        var touchcancelHandler;\n        r.registerBinding(window, \"touchcancel\", touchcancelHandler = function touchcancelHandler(e) {\n            // eslint-disable-line no-unused-vars\n            var start = r.touchData.start;\n            r.touchData.capture = false;\n            if (start) {\n                start.unactivate();\n            }\n        });\n        var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n        r.registerBinding(window, \"touchend\", touchendHandler = function touchendHandler(e) {\n            // eslint-disable-line no-unused-vars\n            var start = r.touchData.start;\n            var capture = r.touchData.capture;\n            if (capture) {\n                if (e.touches.length === 0) {\n                    r.touchData.capture = false;\n                }\n                e.preventDefault();\n            } else {\n                return;\n            }\n            var select = r.selection;\n            r.swipePanning = false;\n            r.hoverData.draggingEles = false;\n            var cy = r.cy;\n            var zoom = cy.zoom();\n            var now = r.touchData.now;\n            var earlier = r.touchData.earlier;\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            }\n            if (start) {\n                start.unactivate();\n            }\n            var ctxTapend;\n            if (r.touchData.cxt) {\n                ctxTapend = {\n                    originalEvent: e,\n                    type: \"cxttapend\",\n                    position: {\n                        x: now[0],\n                        y: now[1]\n                    }\n                };\n                if (start) {\n                    start.emit(ctxTapend);\n                } else {\n                    cy.emit(ctxTapend);\n                }\n                if (!r.touchData.cxtDragged) {\n                    var ctxTap = {\n                        originalEvent: e,\n                        type: \"cxttap\",\n                        position: {\n                            x: now[0],\n                            y: now[1]\n                        }\n                    };\n                    if (start) {\n                        start.emit(ctxTap);\n                    } else {\n                        cy.emit(ctxTap);\n                    }\n                }\n                if (r.touchData.start) {\n                    r.touchData.start._private.grabbed = false;\n                }\n                r.touchData.cxt = false;\n                r.touchData.start = null;\n                r.redraw();\n                return;\n            } // no more box selection if we don't have three fingers\n            if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n                r.touchData.selecting = false;\n                var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n                select[0] = undefined;\n                select[1] = undefined;\n                select[2] = undefined;\n                select[3] = undefined;\n                select[4] = 0;\n                r.redrawHint(\"select\", true);\n                cy.emit({\n                    type: \"boxend\",\n                    originalEvent: e,\n                    position: {\n                        x: now[0],\n                        y: now[1]\n                    }\n                });\n                var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                    return ele.selectable() && !ele.selected();\n                };\n                box.emit(\"box\").stdFilter(eleWouldBeSelected).select().emit(\"boxselect\");\n                if (box.nonempty()) {\n                    r.redrawHint(\"eles\", true);\n                }\n                r.redraw();\n            }\n            if (start != null) {\n                start.unactivate();\n            }\n            if (e.touches[2]) {\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n            } else if (e.touches[1]) ;\n            else if (e.touches[0]) ;\n            else if (!e.touches[0]) {\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n                var draggedEles = r.dragData.touchDragEles;\n                if (start != null) {\n                    var startWasGrabbed = start._private.grabbed;\n                    freeDraggedElements(draggedEles);\n                    r.redrawHint(\"drag\", true);\n                    r.redrawHint(\"eles\", true);\n                    if (startWasGrabbed) {\n                        start.emit(\"freeon\");\n                        draggedEles.emit(\"free\");\n                        if (r.dragData.didDrag) {\n                            start.emit(\"dragfreeon\");\n                            draggedEles.emit(\"dragfree\");\n                        }\n                    }\n                    triggerEvents(start, [\n                        \"touchend\",\n                        \"tapend\",\n                        \"vmouseup\",\n                        \"tapdragout\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                    start.unactivate();\n                    r.touchData.start = null;\n                } else {\n                    var near = r.findNearestElement(now[0], now[1], true, true);\n                    triggerEvents(near, [\n                        \"touchend\",\n                        \"tapend\",\n                        \"vmouseup\",\n                        \"tapdragout\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                }\n                var dx = r.touchData.startPosition[0] - now[0];\n                var dx2 = dx * dx;\n                var dy = r.touchData.startPosition[1] - now[1];\n                var dy2 = dy * dy;\n                var dist2 = dx2 + dy2;\n                var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch\n                if (!r.touchData.singleTouchMoved) {\n                    if (!start) {\n                        cy.$(\":selected\").unselect([\n                            \"tapunselect\"\n                        ]);\n                    }\n                    triggerEvents(start, [\n                        \"tap\",\n                        \"vclick\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                    didDoubleTouch = false;\n                    if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n                        touchTimeout && clearTimeout(touchTimeout);\n                        didDoubleTouch = true;\n                        prevTouchTimeStamp = null;\n                        triggerEvents(start, [\n                            \"dbltap\",\n                            \"vdblclick\"\n                        ], e, {\n                            x: now[0],\n                            y: now[1]\n                        });\n                    } else {\n                        touchTimeout = setTimeout(function() {\n                            if (didDoubleTouch) return;\n                            triggerEvents(start, [\n                                \"onetap\",\n                                \"voneclick\"\n                            ], e, {\n                                x: now[0],\n                                y: now[1]\n                            });\n                        }, cy.multiClickDebounceTime());\n                        prevTouchTimeStamp = e.timeStamp;\n                    }\n                } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n                if (start != null && !r.dragData.didDrag // didn't drag nodes around\n                 && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n                ) {\n                    if (cy.selectionType() === \"single\") {\n                        cy.$(isSelected).unmerge(start).unselect([\n                            \"tapunselect\"\n                        ]);\n                        start.select([\n                            \"tapselect\"\n                        ]);\n                    } else {\n                        if (start.selected()) {\n                            start.unselect([\n                                \"tapunselect\"\n                            ]);\n                        } else {\n                            start.select([\n                                \"tapselect\"\n                            ]);\n                        }\n                    }\n                    r.redrawHint(\"eles\", true);\n                }\n                r.touchData.singleTouchMoved = true;\n            }\n            for(var j = 0; j < now.length; j++){\n                earlier[j] = now[j];\n            }\n            r.dragData.didDrag = false; // reset for next touchstart\n            if (e.touches.length === 0) {\n                r.touchData.dragDelta = [];\n                r.touchData.startPosition = null;\n                r.touchData.startGPosition = null;\n                r.touchData.didSelect = false;\n            }\n            if (e.touches.length < 2) {\n                if (e.touches.length === 1) {\n                    // the old start global pos'n may not be the same finger that remains\n                    r.touchData.startGPosition = [\n                        e.touches[0].clientX,\n                        e.touches[0].clientY\n                    ];\n                }\n                r.pinching = false;\n                r.redrawHint(\"eles\", true);\n                r.redraw();\n            } //r.redraw();\n        }, false); // fallback compatibility layer for ms pointer events\n        if (typeof TouchEvent === \"undefined\") {\n            var pointers = [];\n            var makeTouch = function makeTouch(e) {\n                return {\n                    clientX: e.clientX,\n                    clientY: e.clientY,\n                    force: 1,\n                    identifier: e.pointerId,\n                    pageX: e.pageX,\n                    pageY: e.pageY,\n                    radiusX: e.width / 2,\n                    radiusY: e.height / 2,\n                    screenX: e.screenX,\n                    screenY: e.screenY,\n                    target: e.target\n                };\n            };\n            var makePointer = function makePointer(e) {\n                return {\n                    event: e,\n                    touch: makeTouch(e)\n                };\n            };\n            var addPointer = function addPointer(e) {\n                pointers.push(makePointer(e));\n            };\n            var removePointer = function removePointer(e) {\n                for(var i = 0; i < pointers.length; i++){\n                    var p = pointers[i];\n                    if (p.event.pointerId === e.pointerId) {\n                        pointers.splice(i, 1);\n                        return;\n                    }\n                }\n            };\n            var updatePointer = function updatePointer(e) {\n                var p = pointers.filter(function(p) {\n                    return p.event.pointerId === e.pointerId;\n                })[0];\n                p.event = e;\n                p.touch = makeTouch(e);\n            };\n            var addTouchesToEvent = function addTouchesToEvent(e) {\n                e.touches = pointers.map(function(p) {\n                    return p.touch;\n                });\n            };\n            var pointerIsMouse = function pointerIsMouse(e) {\n                return e.pointerType === \"mouse\" || e.pointerType === 4;\n            };\n            r.registerBinding(r.container, \"pointerdown\", function(e) {\n                if (pointerIsMouse(e)) {\n                    return;\n                } // mouse already handled\n                e.preventDefault();\n                addPointer(e);\n                addTouchesToEvent(e);\n                touchstartHandler(e);\n            });\n            r.registerBinding(r.container, \"pointerup\", function(e) {\n                if (pointerIsMouse(e)) {\n                    return;\n                } // mouse already handled\n                removePointer(e);\n                addTouchesToEvent(e);\n                touchendHandler(e);\n            });\n            r.registerBinding(r.container, \"pointercancel\", function(e) {\n                if (pointerIsMouse(e)) {\n                    return;\n                } // mouse already handled\n                removePointer(e);\n                addTouchesToEvent(e);\n                touchcancelHandler(e);\n            });\n            r.registerBinding(r.container, \"pointermove\", function(e) {\n                if (pointerIsMouse(e)) {\n                    return;\n                } // mouse already handled\n                e.preventDefault();\n                updatePointer(e);\n                addTouchesToEvent(e);\n                touchmoveHandler(e);\n            });\n        }\n    };\n    var BRp$2 = {};\n    BRp$2.generatePolygon = function(name, points) {\n        return this.nodeShapes[name] = {\n            renderer: this,\n            name: name,\n            points: points,\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(\"polygon\", context, centerX, centerY, width, height, this.points);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [\n                    0,\n                    -1\n                ], padding);\n            }\n        };\n    };\n    BRp$2.generateEllipse = function() {\n        return this.nodeShapes[\"ellipse\"] = {\n            renderer: this,\n            name: \"ellipse\",\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n            }\n        };\n    };\n    BRp$2.generateRoundPolygon = function(name, points) {\n        // Pre-compute control points\n        // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute\n        // the unit vectors.\n        // For simplicity the layout will be:\n        // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]\n        var allPoints = new Array(points.length * 2);\n        for(var i = 0; i < points.length / 2; i++){\n            var sourceIndex = i * 2;\n            var destIndex = void 0;\n            if (i < points.length / 2 - 1) {\n                destIndex = (i + 1) * 2;\n            } else {\n                destIndex = 0;\n            }\n            allPoints[i * 4] = points[sourceIndex];\n            allPoints[i * 4 + 1] = points[sourceIndex + 1];\n            var xDest = points[destIndex] - points[sourceIndex];\n            var yDest = points[destIndex + 1] - points[sourceIndex + 1];\n            var norm = Math.sqrt(xDest * xDest + yDest * yDest);\n            allPoints[i * 4 + 2] = xDest / norm;\n            allPoints[i * 4 + 3] = yDest / norm;\n        }\n        return this.nodeShapes[name] = {\n            renderer: this,\n            name: name,\n            points: allPoints,\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(\"round-polygon\", context, centerX, centerY, width, height, this.points);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);\n            }\n        };\n    };\n    BRp$2.generateRoundRectangle = function() {\n        return this.nodeShapes[\"round-rectangle\"] = this.nodeShapes[\"roundrectangle\"] = {\n            renderer: this,\n            name: \"round-rectangle\",\n            points: generateUnitNgonPointsFitToSquare(4, 0),\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                var cornerRadius = getRoundRectangleRadius(width, height);\n                var diam = cornerRadius * 2; // Check hBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // Check vBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // Check top left quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n                    return true;\n                } // Check top right quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n                    return true;\n                } // Check bottom right quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                    return true;\n                } // Check bottom left quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                    return true;\n                }\n                return false;\n            }\n        };\n    };\n    BRp$2.generateCutRectangle = function() {\n        return this.nodeShapes[\"cut-rectangle\"] = this.nodeShapes[\"cutrectangle\"] = {\n            renderer: this,\n            name: \"cut-rectangle\",\n            cornerLength: getCutRectangleCornerLength(),\n            points: generateUnitNgonPointsFitToSquare(4, 0),\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n            },\n            generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n                var cl = this.cornerLength;\n                var hh = height / 2;\n                var hw = width / 2;\n                var xBegin = centerX - hw;\n                var xEnd = centerX + hw;\n                var yBegin = centerY - hh;\n                var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n                return {\n                    topLeft: [\n                        xBegin,\n                        yBegin + cl,\n                        xBegin + cl,\n                        yBegin,\n                        xBegin + cl,\n                        yBegin + cl\n                    ],\n                    topRight: [\n                        xEnd - cl,\n                        yBegin,\n                        xEnd,\n                        yBegin + cl,\n                        xEnd - cl,\n                        yBegin + cl\n                    ],\n                    bottomRight: [\n                        xEnd,\n                        yEnd - cl,\n                        xEnd - cl,\n                        yEnd,\n                        xEnd - cl,\n                        yEnd - cl\n                    ],\n                    bottomLeft: [\n                        xBegin + cl,\n                        yEnd,\n                        xBegin,\n                        yEnd - cl,\n                        xBegin + cl,\n                        yEnd - cl\n                    ]\n                };\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n                var pts = [].concat.apply([], [\n                    cPts.topLeft.splice(0, 4),\n                    cPts.topRight.splice(0, 4),\n                    cPts.bottomRight.splice(0, 4),\n                    cPts.bottomLeft.splice(0, 4)\n                ]);\n                return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                // Check hBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // Check vBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                }\n                var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n                return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n            }\n        };\n    };\n    BRp$2.generateBarrel = function() {\n        return this.nodeShapes[\"barrel\"] = {\n            renderer: this,\n            name: \"barrel\",\n            points: generateUnitNgonPointsFitToSquare(4, 0),\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                // use two fixed t values for the bezier curve approximation\n                var t0 = 0.15;\n                var t1 = 0.5;\n                var t2 = 0.85;\n                var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n                var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n                    // approximate curve pts based on the two t values\n                    var m0 = qbezierPtAt({\n                        x: pts[0],\n                        y: pts[1]\n                    }, {\n                        x: pts[2],\n                        y: pts[3]\n                    }, {\n                        x: pts[4],\n                        y: pts[5]\n                    }, t0);\n                    var m1 = qbezierPtAt({\n                        x: pts[0],\n                        y: pts[1]\n                    }, {\n                        x: pts[2],\n                        y: pts[3]\n                    }, {\n                        x: pts[4],\n                        y: pts[5]\n                    }, t1);\n                    var m2 = qbezierPtAt({\n                        x: pts[0],\n                        y: pts[1]\n                    }, {\n                        x: pts[2],\n                        y: pts[3]\n                    }, {\n                        x: pts[4],\n                        y: pts[5]\n                    }, t2);\n                    return [\n                        pts[0],\n                        pts[1],\n                        m0.x,\n                        m0.y,\n                        m1.x,\n                        m1.y,\n                        m2.x,\n                        m2.y,\n                        pts[4],\n                        pts[5]\n                    ];\n                };\n                var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n                return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n            },\n            generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n                var hh = height / 2;\n                var hw = width / 2;\n                var xBegin = centerX - hw;\n                var xEnd = centerX + hw;\n                var yBegin = centerY - hh;\n                var yEnd = centerY + hh;\n                var curveConstants = getBarrelCurveConstants(width, height);\n                var hOffset = curveConstants.heightOffset;\n                var wOffset = curveConstants.widthOffset;\n                var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n                var pts = {\n                    topLeft: [\n                        xBegin,\n                        yBegin + hOffset,\n                        xBegin + ctrlPtXOffset,\n                        yBegin,\n                        xBegin + wOffset,\n                        yBegin\n                    ],\n                    topRight: [\n                        xEnd - wOffset,\n                        yBegin,\n                        xEnd - ctrlPtXOffset,\n                        yBegin,\n                        xEnd,\n                        yBegin + hOffset\n                    ],\n                    bottomRight: [\n                        xEnd,\n                        yEnd - hOffset,\n                        xEnd - ctrlPtXOffset,\n                        yEnd,\n                        xEnd - wOffset,\n                        yEnd\n                    ],\n                    bottomLeft: [\n                        xBegin + wOffset,\n                        yEnd,\n                        xBegin + ctrlPtXOffset,\n                        yEnd,\n                        xBegin,\n                        yEnd - hOffset\n                    ]\n                };\n                pts.topLeft.isTop = true;\n                pts.topRight.isTop = true;\n                pts.bottomLeft.isBottom = true;\n                pts.bottomRight.isBottom = true;\n                return pts;\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                var curveConstants = getBarrelCurveConstants(width, height);\n                var hOffset = curveConstants.heightOffset;\n                var wOffset = curveConstants.widthOffset; // Check hBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // Check vBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                }\n                var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n                var getCurveT = function getCurveT(x, y, curvePts) {\n                    var x0 = curvePts[4];\n                    var x1 = curvePts[2];\n                    var x2 = curvePts[0];\n                    var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];\n                    var y2 = curvePts[1];\n                    var xMin = Math.min(x0, x2);\n                    var xMax = Math.max(x0, x2);\n                    var yMin = Math.min(y0, y2);\n                    var yMax = Math.max(y0, y2);\n                    if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n                        var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n                        var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n                        var validRoots = roots.filter(function(r) {\n                            return 0 <= r && r <= 1;\n                        });\n                        if (validRoots.length > 0) {\n                            return validRoots[0];\n                        }\n                    }\n                    return null;\n                };\n                var curveRegions = Object.keys(barrelCurvePts);\n                for(var i = 0; i < curveRegions.length; i++){\n                    var corner = curveRegions[i];\n                    var cornerPts = barrelCurvePts[corner];\n                    var t = getCurveT(x, y, cornerPts);\n                    if (t == null) {\n                        continue;\n                    }\n                    var y0 = cornerPts[5];\n                    var y1 = cornerPts[3];\n                    var y2 = cornerPts[1];\n                    var bezY = qbezierAt(y0, y1, y2, t);\n                    if (cornerPts.isTop && bezY <= y) {\n                        return true;\n                    }\n                    if (cornerPts.isBottom && y <= bezY) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n    };\n    BRp$2.generateBottomRoundrectangle = function() {\n        return this.nodeShapes[\"bottom-round-rectangle\"] = this.nodeShapes[\"bottomroundrectangle\"] = {\n            renderer: this,\n            name: \"bottom-round-rectangle\",\n            points: generateUnitNgonPointsFitToSquare(4, 0),\n            draw: function draw(context, centerX, centerY, width, height) {\n                this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n            },\n            intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n                var topStartX = nodeX - (width / 2 + padding);\n                var topStartY = nodeY - (height / 2 + padding);\n                var topEndY = topStartY;\n                var topEndX = nodeX + (width / 2 + padding);\n                var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n                if (topIntersections.length > 0) {\n                    return topIntersections;\n                }\n                return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n            },\n            checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n                var cornerRadius = getRoundRectangleRadius(width, height);\n                var diam = 2 * cornerRadius; // Check hBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // Check vBox\n                if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                    0,\n                    -1\n                ], padding)) {\n                    return true;\n                } // check non-rounded top side\n                var outerWidth = width / 2 + 2 * padding;\n                var outerHeight = height / 2 + 2 * padding;\n                var points = [\n                    centerX - outerWidth,\n                    centerY - outerHeight,\n                    centerX - outerWidth,\n                    centerY,\n                    centerX + outerWidth,\n                    centerY,\n                    centerX + outerWidth,\n                    centerY - outerHeight\n                ];\n                if (pointInsidePolygonPoints(x, y, points)) {\n                    return true;\n                } // Check bottom right quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                    return true;\n                } // Check bottom left quarter circle\n                if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                    return true;\n                }\n                return false;\n            }\n        };\n    };\n    BRp$2.registerNodeShapes = function() {\n        var nodeShapes = this.nodeShapes = {};\n        var renderer = this;\n        this.generateEllipse();\n        this.generatePolygon(\"triangle\", generateUnitNgonPointsFitToSquare(3, 0));\n        this.generateRoundPolygon(\"round-triangle\", generateUnitNgonPointsFitToSquare(3, 0));\n        this.generatePolygon(\"rectangle\", generateUnitNgonPointsFitToSquare(4, 0));\n        nodeShapes[\"square\"] = nodeShapes[\"rectangle\"];\n        this.generateRoundRectangle();\n        this.generateCutRectangle();\n        this.generateBarrel();\n        this.generateBottomRoundrectangle();\n        {\n            var diamondPoints = [\n                0,\n                1,\n                1,\n                0,\n                0,\n                -1,\n                -1,\n                0\n            ];\n            this.generatePolygon(\"diamond\", diamondPoints);\n            this.generateRoundPolygon(\"round-diamond\", diamondPoints);\n        }\n        this.generatePolygon(\"pentagon\", generateUnitNgonPointsFitToSquare(5, 0));\n        this.generateRoundPolygon(\"round-pentagon\", generateUnitNgonPointsFitToSquare(5, 0));\n        this.generatePolygon(\"hexagon\", generateUnitNgonPointsFitToSquare(6, 0));\n        this.generateRoundPolygon(\"round-hexagon\", generateUnitNgonPointsFitToSquare(6, 0));\n        this.generatePolygon(\"heptagon\", generateUnitNgonPointsFitToSquare(7, 0));\n        this.generateRoundPolygon(\"round-heptagon\", generateUnitNgonPointsFitToSquare(7, 0));\n        this.generatePolygon(\"octagon\", generateUnitNgonPointsFitToSquare(8, 0));\n        this.generateRoundPolygon(\"round-octagon\", generateUnitNgonPointsFitToSquare(8, 0));\n        var star5Points = new Array(20);\n        {\n            var outerPoints = generateUnitNgonPoints(5, 0);\n            var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller\n            var innerRadius = 0.5 * (3 - Math.sqrt(5));\n            innerRadius *= 1.57;\n            for(var i = 0; i < innerPoints.length / 2; i++){\n                innerPoints[i * 2] *= innerRadius;\n                innerPoints[i * 2 + 1] *= innerRadius;\n            }\n            for(var i = 0; i < 20 / 4; i++){\n                star5Points[i * 4] = outerPoints[i * 2];\n                star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n                star5Points[i * 4 + 2] = innerPoints[i * 2];\n                star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n            }\n        }\n        star5Points = fitPolygonToSquare(star5Points);\n        this.generatePolygon(\"star\", star5Points);\n        this.generatePolygon(\"vee\", [\n            -1,\n            -1,\n            0,\n            -0.333,\n            1,\n            -1,\n            0,\n            1\n        ]);\n        this.generatePolygon(\"rhomboid\", [\n            -1,\n            -1,\n            0.333,\n            -1,\n            1,\n            1,\n            -0.333,\n            1\n        ]);\n        this.nodeShapes[\"concavehexagon\"] = this.generatePolygon(\"concave-hexagon\", [\n            -1,\n            -0.95,\n            -0.75,\n            0,\n            -1,\n            0.95,\n            1,\n            0.95,\n            0.75,\n            0,\n            1,\n            -0.95\n        ]);\n        {\n            var tagPoints = [\n                -1,\n                -1,\n                0.25,\n                -1,\n                1,\n                0,\n                0.25,\n                1,\n                -1,\n                1\n            ];\n            this.generatePolygon(\"tag\", tagPoints);\n            this.generateRoundPolygon(\"round-tag\", tagPoints);\n        }\n        nodeShapes.makePolygon = function(points) {\n            // use caching on user-specified polygons so they are as fast as native shapes\n            var key = points.join(\"$\");\n            var name = \"polygon-\" + key;\n            var shape;\n            if (shape = this[name]) {\n                // got cached shape\n                return shape;\n            } // create and cache new shape\n            return renderer.generatePolygon(name, points);\n        };\n    };\n    var BRp$1 = {};\n    BRp$1.timeToRender = function() {\n        return this.redrawTotalTime / this.redrawCount;\n    };\n    BRp$1.redraw = function(options) {\n        options = options || staticEmptyObject();\n        var r = this;\n        if (r.averageRedrawTime === undefined) {\n            r.averageRedrawTime = 0;\n        }\n        if (r.lastRedrawTime === undefined) {\n            r.lastRedrawTime = 0;\n        }\n        if (r.lastDrawTime === undefined) {\n            r.lastDrawTime = 0;\n        }\n        r.requestedFrame = true;\n        r.renderOptions = options;\n    };\n    BRp$1.beforeRender = function(fn, priority) {\n        // the renderer can't add tick callbacks when destroyed\n        if (this.destroyed) {\n            return;\n        }\n        if (priority == null) {\n            error(\"Priority is not optional for beforeRender\");\n        }\n        var cbs = this.beforeRenderCallbacks;\n        cbs.push({\n            fn: fn,\n            priority: priority\n        }); // higher priority callbacks executed first\n        cbs.sort(function(a, b) {\n            return b.priority - a.priority;\n        });\n    };\n    var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n        var cbs = r.beforeRenderCallbacks;\n        for(var i = 0; i < cbs.length; i++){\n            cbs[i].fn(willDraw, startTime);\n        }\n    };\n    BRp$1.startRenderLoop = function() {\n        var r = this;\n        var cy = r.cy;\n        if (r.renderLoopStarted) {\n            return;\n        } else {\n            r.renderLoopStarted = true;\n        }\n        var renderFn = function renderFn(requestTime) {\n            if (r.destroyed) {\n                return;\n            }\n            if (cy.batching()) ;\n            else if (r.requestedFrame && !r.skipFrame) {\n                beforeRenderCallbacks(r, true, requestTime);\n                var startTime = performanceNow();\n                r.render(r.renderOptions);\n                var endTime = r.lastDrawTime = performanceNow();\n                if (r.averageRedrawTime === undefined) {\n                    r.averageRedrawTime = endTime - startTime;\n                }\n                if (r.redrawCount === undefined) {\n                    r.redrawCount = 0;\n                }\n                r.redrawCount++;\n                if (r.redrawTotalTime === undefined) {\n                    r.redrawTotalTime = 0;\n                }\n                var duration = endTime - startTime;\n                r.redrawTotalTime += duration;\n                r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily\n                r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n                r.requestedFrame = false;\n            } else {\n                beforeRenderCallbacks(r, false, requestTime);\n            }\n            r.skipFrame = false;\n            requestAnimationFrame(renderFn);\n        };\n        requestAnimationFrame(renderFn);\n    };\n    var BaseRenderer = function BaseRenderer(options) {\n        this.init(options);\n    };\n    var BR = BaseRenderer;\n    var BRp = BR.prototype;\n    BRp.clientFunctions = [\n        \"redrawHint\",\n        \"render\",\n        \"renderTo\",\n        \"matchCanvasSize\",\n        \"nodeShapeImpl\",\n        \"arrowShapeImpl\"\n    ];\n    BRp.init = function(options) {\n        var r = this;\n        r.options = options;\n        r.cy = options.cy;\n        var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that\n        if (window$1) {\n            var document1 = window$1.document;\n            var head = document1.head;\n            var stylesheetId = \"__________cytoscape_stylesheet\";\n            var className = \"__________cytoscape_container\";\n            var stylesheetAlreadyExists = document1.getElementById(stylesheetId) != null;\n            if (ctr.className.indexOf(className) < 0) {\n                ctr.className = (ctr.className || \"\") + \" \" + className;\n            }\n            if (!stylesheetAlreadyExists) {\n                var stylesheet = document1.createElement(\"style\");\n                stylesheet.id = stylesheetId;\n                stylesheet.innerHTML = \".\" + className + \" { position: relative; }\";\n                head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n            }\n            var computedStyle = window$1.getComputedStyle(ctr);\n            var position = computedStyle.getPropertyValue(\"position\");\n            if (position === \"static\") {\n                warn(\"A Cytoscape container has style position:static and so can not use UI extensions properly\");\n            }\n        }\n        r.selection = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            0\n        ]; // Coordinates for selection box, plus enabled flag\n        r.bezierProjPcts = [\n            0.05,\n            0.225,\n            0.4,\n            0.5,\n            0.6,\n            0.775,\n            0.95\n        ]; //--Pointer-related data\n        r.hoverData = {\n            down: null,\n            last: null,\n            downTime: null,\n            triggerMode: null,\n            dragging: false,\n            initialPan: [\n                null,\n                null\n            ],\n            capture: false\n        };\n        r.dragData = {\n            possibleDragElements: []\n        };\n        r.touchData = {\n            start: null,\n            capture: false,\n            // These 3 fields related to tap, taphold events\n            startPosition: [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ],\n            singleTouchStartTime: null,\n            singleTouchMoved: true,\n            now: [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ],\n            earlier: [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ]\n        };\n        r.redraws = 0;\n        r.showFps = options.showFps;\n        r.debug = options.debug;\n        r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n        r.textureOnViewport = options.textureOnViewport;\n        r.wheelSensitivity = options.wheelSensitivity;\n        r.motionBlurEnabled = options.motionBlur; // on by default\n        r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n        r.motionBlur = options.motionBlur; // for initial kick off\n        r.motionBlurOpacity = options.motionBlurOpacity;\n        r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n        r.motionBlurPxRatio = 1;\n        r.mbPxRBlurry = 1; //0.8;\n        r.minMbLowQualFrames = 4;\n        r.fullQualityMb = false;\n        r.clearedForMotionBlur = [];\n        r.desktopTapThreshold = options.desktopTapThreshold;\n        r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n        r.touchTapThreshold = options.touchTapThreshold;\n        r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n        r.tapholdDuration = 500;\n        r.bindings = [];\n        r.beforeRenderCallbacks = [];\n        r.beforeRenderPriorities = {\n            // higher priority execs before lower one\n            animations: 400,\n            eleCalcs: 300,\n            eleTxrDeq: 200,\n            lyrTxrDeq: 150,\n            lyrTxrSkip: 100\n        };\n        r.registerNodeShapes();\n        r.registerArrowShapes();\n        r.registerCalculationListeners();\n    };\n    BRp.notify = function(eventName, eles) {\n        var r = this;\n        var cy = r.cy; // the renderer can't be notified after it's destroyed\n        if (this.destroyed) {\n            return;\n        }\n        if (eventName === \"init\") {\n            r.load();\n            return;\n        }\n        if (eventName === \"destroy\") {\n            r.destroy();\n            return;\n        }\n        if (eventName === \"add\" || eventName === \"remove\" || eventName === \"move\" && cy.hasCompoundNodes() || eventName === \"load\" || eventName === \"zorder\" || eventName === \"mount\") {\n            r.invalidateCachedZSortedEles();\n        }\n        if (eventName === \"viewport\") {\n            r.redrawHint(\"select\", true);\n        }\n        if (eventName === \"load\" || eventName === \"resize\" || eventName === \"mount\") {\n            r.invalidateContainerClientCoordsCache();\n            r.matchCanvasSize(r.container);\n        }\n        r.redrawHint(\"eles\", true);\n        r.redrawHint(\"drag\", true);\n        this.startRenderLoop();\n        this.redraw();\n    };\n    BRp.destroy = function() {\n        var r = this;\n        r.destroyed = true;\n        r.cy.stopAnimationLoop();\n        for(var i = 0; i < r.bindings.length; i++){\n            var binding = r.bindings[i];\n            var b = binding;\n            var tgt = b.target;\n            (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n        }\n        r.bindings = [];\n        r.beforeRenderCallbacks = [];\n        r.onUpdateEleCalcsFns = [];\n        if (r.removeObserver) {\n            r.removeObserver.disconnect();\n        }\n        if (r.styleObserver) {\n            r.styleObserver.disconnect();\n        }\n        if (r.resizeObserver) {\n            r.resizeObserver.disconnect();\n        }\n        if (r.labelCalcDiv) {\n            try {\n                document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n            } catch (e) {}\n        }\n    };\n    BRp.isHeadless = function() {\n        return false;\n    };\n    [\n        BRp$f,\n        BRp$5,\n        BRp$4,\n        BRp$3,\n        BRp$2,\n        BRp$1\n    ].forEach(function(props) {\n        extend(BRp, props);\n    });\n    var fullFpsTime = 1000 / 60; // assume 60 frames per second\n    var defs = {\n        setupDequeueing: function setupDequeueing(opts) {\n            return function setupDequeueingImpl() {\n                var self1 = this;\n                var r = this.renderer;\n                if (self1.dequeueingSetup) {\n                    return;\n                } else {\n                    self1.dequeueingSetup = true;\n                }\n                var queueRedraw = debounce_1(function() {\n                    r.redrawHint(\"eles\", true);\n                    r.redrawHint(\"drag\", true);\n                    r.redraw();\n                }, opts.deqRedrawThreshold);\n                var dequeue = function dequeue(willDraw, frameStartTime) {\n                    var startTime = performanceNow();\n                    var avgRenderTime = r.averageRedrawTime;\n                    var renderTime = r.lastRedrawTime;\n                    var deqd = [];\n                    var extent = r.cy.extent();\n                    var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style\n                    // queue won't automatically be flushed before dequeueing starts\n                    if (!willDraw) {\n                        r.flushRenderedStyleQueue();\n                    }\n                    while(true){\n                        // eslint-disable-line no-constant-condition\n                        var now = performanceNow();\n                        var duration = now - startTime;\n                        var frameDuration = now - frameStartTime;\n                        if (renderTime < fullFpsTime) {\n                            // if we're rendering faster than the ideal fps, then do dequeueing\n                            // during all of the remaining frame time\n                            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n                            if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                                break;\n                            }\n                        } else {\n                            if (willDraw) {\n                                if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                                    break;\n                                }\n                            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                                break;\n                            }\n                        }\n                        var thisDeqd = opts.deq(self1, pixelRatio, extent);\n                        if (thisDeqd.length > 0) {\n                            for(var i = 0; i < thisDeqd.length; i++){\n                                deqd.push(thisDeqd[i]);\n                            }\n                        } else {\n                            break;\n                        }\n                    } // callbacks on dequeue\n                    if (deqd.length > 0) {\n                        opts.onDeqd(self1, deqd);\n                        if (!willDraw && opts.shouldRedraw(self1, deqd, pixelRatio, extent)) {\n                            queueRedraw();\n                        }\n                    }\n                };\n                var priority = opts.priority || noop$1;\n                r.beforeRender(dequeue, priority(self1));\n            };\n        }\n    };\n    // Uses keys so elements may share the same cache.\n    var ElementTextureCacheLookup = /*#__PURE__*/ function() {\n        function ElementTextureCacheLookup(getKey) {\n            var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n            _classCallCheck(this, ElementTextureCacheLookup);\n            this.idsByKey = new Map$2();\n            this.keyForId = new Map$2();\n            this.cachesByLvl = new Map$2();\n            this.lvls = [];\n            this.getKey = getKey;\n            this.doesEleInvalidateKey = doesEleInvalidateKey;\n        }\n        _createClass(ElementTextureCacheLookup, [\n            {\n                key: \"getIdsFor\",\n                value: function getIdsFor(key) {\n                    if (key == null) {\n                        error(\"Can not get id list for null key\");\n                    }\n                    var idsByKey = this.idsByKey;\n                    var ids = this.idsByKey.get(key);\n                    if (!ids) {\n                        ids = new Set$1();\n                        idsByKey.set(key, ids);\n                    }\n                    return ids;\n                }\n            },\n            {\n                key: \"addIdForKey\",\n                value: function addIdForKey(key, id) {\n                    if (key != null) {\n                        this.getIdsFor(key).add(id);\n                    }\n                }\n            },\n            {\n                key: \"deleteIdForKey\",\n                value: function deleteIdForKey(key, id) {\n                    if (key != null) {\n                        this.getIdsFor(key)[\"delete\"](id);\n                    }\n                }\n            },\n            {\n                key: \"getNumberOfIdsForKey\",\n                value: function getNumberOfIdsForKey(key) {\n                    if (key == null) {\n                        return 0;\n                    } else {\n                        return this.getIdsFor(key).size;\n                    }\n                }\n            },\n            {\n                key: \"updateKeyMappingFor\",\n                value: function updateKeyMappingFor(ele) {\n                    var id = ele.id();\n                    var prevKey = this.keyForId.get(id);\n                    var currKey = this.getKey(ele);\n                    this.deleteIdForKey(prevKey, id);\n                    this.addIdForKey(currKey, id);\n                    this.keyForId.set(id, currKey);\n                }\n            },\n            {\n                key: \"deleteKeyMappingFor\",\n                value: function deleteKeyMappingFor(ele) {\n                    var id = ele.id();\n                    var prevKey = this.keyForId.get(id);\n                    this.deleteIdForKey(prevKey, id);\n                    this.keyForId[\"delete\"](id);\n                }\n            },\n            {\n                key: \"keyHasChangedFor\",\n                value: function keyHasChangedFor(ele) {\n                    var id = ele.id();\n                    var prevKey = this.keyForId.get(id);\n                    var newKey = this.getKey(ele);\n                    return prevKey !== newKey;\n                }\n            },\n            {\n                key: \"isInvalid\",\n                value: function isInvalid(ele) {\n                    return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n                }\n            },\n            {\n                key: \"getCachesAt\",\n                value: function getCachesAt(lvl) {\n                    var cachesByLvl = this.cachesByLvl, lvls = this.lvls;\n                    var caches = cachesByLvl.get(lvl);\n                    if (!caches) {\n                        caches = new Map$2();\n                        cachesByLvl.set(lvl, caches);\n                        lvls.push(lvl);\n                    }\n                    return caches;\n                }\n            },\n            {\n                key: \"getCache\",\n                value: function getCache(key, lvl) {\n                    return this.getCachesAt(lvl).get(key);\n                }\n            },\n            {\n                key: \"get\",\n                value: function get(ele, lvl) {\n                    var key = this.getKey(ele);\n                    var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys\n                    if (cache != null) {\n                        this.updateKeyMappingFor(ele);\n                    }\n                    return cache;\n                }\n            },\n            {\n                key: \"getForCachedKey\",\n                value: function getForCachedKey(ele, lvl) {\n                    var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n                    var cache = this.getCache(key, lvl);\n                    return cache;\n                }\n            },\n            {\n                key: \"hasCache\",\n                value: function hasCache(key, lvl) {\n                    return this.getCachesAt(lvl).has(key);\n                }\n            },\n            {\n                key: \"has\",\n                value: function has(ele, lvl) {\n                    var key = this.getKey(ele);\n                    return this.hasCache(key, lvl);\n                }\n            },\n            {\n                key: \"setCache\",\n                value: function setCache(key, lvl, cache) {\n                    cache.key = key;\n                    this.getCachesAt(lvl).set(key, cache);\n                }\n            },\n            {\n                key: \"set\",\n                value: function set(ele, lvl, cache) {\n                    var key = this.getKey(ele);\n                    this.setCache(key, lvl, cache);\n                    this.updateKeyMappingFor(ele);\n                }\n            },\n            {\n                key: \"deleteCache\",\n                value: function deleteCache(key, lvl) {\n                    this.getCachesAt(lvl)[\"delete\"](key);\n                }\n            },\n            {\n                key: \"delete\",\n                value: function _delete(ele, lvl) {\n                    var key = this.getKey(ele);\n                    this.deleteCache(key, lvl);\n                }\n            },\n            {\n                key: \"invalidateKey\",\n                value: function invalidateKey(key) {\n                    var _this = this;\n                    this.lvls.forEach(function(lvl) {\n                        return _this.deleteCache(key, lvl);\n                    });\n                } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)\n            },\n            {\n                key: \"invalidate\",\n                value: function invalidate(ele) {\n                    var id = ele.id();\n                    var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n                    this.deleteKeyMappingFor(ele);\n                    var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n                    if (entireKeyInvalidated) {\n                        // clear mapping for current key\n                        this.invalidateKey(key);\n                    }\n                    return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n                }\n            }\n        ]);\n        return ElementTextureCacheLookup;\n    }();\n    var minTxrH = 25; // the size of the texture cache for small height eles (special case)\n    var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n    var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\n    var maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\n    var maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\n    var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n    var defTxrWidth = 1024; // default/minimum texture width\n    var maxTxrW = 1024; // the maximum width of a texture\n    var maxTxrH = 1024; // the maximum height of a texture\n    var minUtility = 0.2; // if usage of texture is less than this, it is retired\n    var maxFullness = 0.8; // fullness of texture after which queue removal is checked\n    var maxFullnessChecks = 10; // dequeued after this many checks\n    var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n    var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\n    var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n    var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\n    var deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n    var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\n    var getTxrReasons = {\n        dequeue: \"dequeue\",\n        downscale: \"downscale\",\n        highQuality: \"highQuality\"\n    };\n    var initDefaults = defaults$g({\n        getKey: null,\n        doesEleInvalidateKey: falsify,\n        drawElement: null,\n        getBoundingBox: null,\n        getRotationPoint: null,\n        getRotationOffset: null,\n        isVisible: trueify,\n        allowEdgeTxrCaching: true,\n        allowParentTxrCaching: true\n    });\n    var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n        var self1 = this;\n        self1.renderer = renderer;\n        self1.onDequeues = [];\n        var opts = initDefaults(initOptions);\n        extend(self1, opts);\n        self1.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n        self1.setupDequeueing();\n    };\n    var ETCp = ElementTextureCache.prototype;\n    ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed\n    ETCp.getTextureQueue = function(txrH) {\n        var self1 = this;\n        self1.eleImgCaches = self1.eleImgCaches || {};\n        return self1.eleImgCaches[txrH] = self1.eleImgCaches[txrH] || [];\n    }; // the list of usused textures which can be recycled (in use in texture queue)\n    ETCp.getRetiredTextureQueue = function(txrH) {\n        var self1 = this;\n        var rtxtrQs = self1.eleImgCaches.retired = self1.eleImgCaches.retired || {};\n        var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n        return rtxtrQ;\n    }; // queue of element draw requests at different scale levels\n    ETCp.getElementQueue = function() {\n        var self1 = this;\n        var q = self1.eleCacheQueue = self1.eleCacheQueue || new heap(function(a, b) {\n            return b.reqs - a.reqs;\n        });\n        return q;\n    }; // queue of element draw requests at different scale levels (element id lookup)\n    ETCp.getElementKeyToQueue = function() {\n        var self1 = this;\n        var k2q = self1.eleKeyToCacheQueue = self1.eleKeyToCacheQueue || {};\n        return k2q;\n    };\n    ETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {\n        var self1 = this;\n        var r = this.renderer;\n        var zoom = r.cy.zoom();\n        var lookup = this.lookup;\n        if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n            return null;\n        }\n        if (!self1.allowEdgeTxrCaching && ele.isEdge() || !self1.allowParentTxrCaching && ele.isParent()) {\n            return null;\n        }\n        if (lvl == null) {\n            lvl = Math.ceil(log2(zoom * pxRatio));\n        }\n        if (lvl < minLvl$1) {\n            lvl = minLvl$1;\n        } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n            return null;\n        }\n        var scale = Math.pow(2, lvl);\n        var eleScaledH = bb.h * scale;\n        var eleScaledW = bb.w * scale;\n        var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n        if (!this.isVisible(ele, scaledLabelShown)) {\n            return null;\n        }\n        var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric\n        if (eleCache && eleCache.invalidated) {\n            eleCache.invalidated = false;\n            eleCache.texture.invalidatedWidth -= eleCache.width;\n        }\n        if (eleCache) {\n            return eleCache;\n        }\n        var txrH; // which texture height this ele belongs to\n        if (eleScaledH <= minTxrH) {\n            txrH = minTxrH;\n        } else if (eleScaledH <= txrStepH) {\n            txrH = txrStepH;\n        } else {\n            txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n        }\n        if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n            return null; // caching large elements is not efficient\n        }\n        var txrQ = self1.getTextureQueue(txrH); // first try the second last one in case it has space at the end\n        var txr = txrQ[txrQ.length - 2];\n        var addNewTxr = function addNewTxr() {\n            return self1.recycleTexture(txrH, eleScaledW) || self1.addTexture(txrH, eleScaledW);\n        }; // try the last one if there is no second last one\n        if (!txr) {\n            txr = txrQ[txrQ.length - 1];\n        } // if the last one doesn't exist, we need a first one\n        if (!txr) {\n            txr = addNewTxr();\n        } // if there's no room in the current texture, we need a new one\n        if (txr.width - txr.usedWidth < eleScaledW) {\n            txr = addNewTxr();\n        }\n        var scalableFrom = function scalableFrom(otherCache) {\n            return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n        };\n        var deqing = reason && reason === getTxrReasons.dequeue;\n        var highQualityReq = reason && reason === getTxrReasons.highQuality;\n        var downscaleReq = reason && reason === getTxrReasons.downscale;\n        var higherCache; // the nearest cache with a higher level\n        for(var l = lvl + 1; l <= maxLvl$1; l++){\n            var c = lookup.get(ele, l);\n            if (c) {\n                higherCache = c;\n                break;\n            }\n        }\n        var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n        var downscale = function downscale() {\n            txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n        }; // reset ele area in texture\n        txr.context.setTransform(1, 0, 0, 1, 0, 0);\n        txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n        if (scalableFrom(oneUpCache)) {\n            // then we can relatively cheaply rescale the existing image w/o rerendering\n            downscale();\n        } else if (scalableFrom(higherCache)) {\n            // then use the higher cache for now and queue the next level down\n            // to cheaply scale towards the smaller level\n            if (highQualityReq) {\n                for(var _l = higherCache.level; _l > lvl; _l--){\n                    oneUpCache = self1.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n                }\n                downscale();\n            } else {\n                self1.queueElement(ele, higherCache.level - 1);\n                return higherCache;\n            }\n        } else {\n            var lowerCache; // the nearest cache with a lower level\n            if (!deqing && !highQualityReq && !downscaleReq) {\n                for(var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--){\n                    var _c = lookup.get(ele, _l2);\n                    if (_c) {\n                        lowerCache = _c;\n                        break;\n                    }\n                }\n            }\n            if (scalableFrom(lowerCache)) {\n                // then use the lower quality cache for now and queue the better one for later\n                self1.queueElement(ele, lvl);\n                return lowerCache;\n            }\n            txr.context.translate(txr.usedWidth, 0);\n            txr.context.scale(scale, scale);\n            this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n            txr.context.scale(1 / scale, 1 / scale);\n            txr.context.translate(-txr.usedWidth, 0);\n        }\n        eleCache = {\n            x: txr.usedWidth,\n            texture: txr,\n            level: lvl,\n            scale: scale,\n            width: eleScaledW,\n            height: eleScaledH,\n            scaledLabelShown: scaledLabelShown\n        };\n        txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n        txr.eleCaches.push(eleCache);\n        lookup.set(ele, lvl, eleCache);\n        self1.checkTextureFullness(txr);\n        return eleCache;\n    };\n    ETCp.invalidateElements = function(eles) {\n        for(var i = 0; i < eles.length; i++){\n            this.invalidateElement(eles[i]);\n        }\n    };\n    ETCp.invalidateElement = function(ele) {\n        var self1 = this;\n        var lookup = self1.lookup;\n        var caches = [];\n        var invalid = lookup.isInvalid(ele);\n        if (!invalid) {\n            return; // override the invalidation request if the element key has not changed\n        }\n        for(var lvl = minLvl$1; lvl <= maxLvl$1; lvl++){\n            var cache = lookup.getForCachedKey(ele, lvl);\n            if (cache) {\n                caches.push(cache);\n            }\n        }\n        var noOtherElesUseCache = lookup.invalidate(ele);\n        if (noOtherElesUseCache) {\n            for(var i = 0; i < caches.length; i++){\n                var _cache = caches[i];\n                var txr = _cache.texture; // remove space from the texture it belongs to\n                txr.invalidatedWidth += _cache.width; // mark the cache as invalidated\n                _cache.invalidated = true; // retire the texture if its utility is low\n                self1.checkTextureUtility(txr);\n            }\n        } // remove from queue since the old req was for the old state\n        self1.removeFromQueue(ele);\n    };\n    ETCp.checkTextureUtility = function(txr) {\n        // invalidate all entries in the cache if the cache size is small\n        if (txr.invalidatedWidth >= minUtility * txr.width) {\n            this.retireTexture(txr);\n        }\n    };\n    ETCp.checkTextureFullness = function(txr) {\n        // if texture has been mostly filled and passed over several times, remove\n        // it from the queue so we don't need to waste time looking at it to put new things\n        var self1 = this;\n        var txrQ = self1.getTextureQueue(txr.height);\n        if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n            removeFromArray(txrQ, txr);\n        } else {\n            txr.fullnessChecks++;\n        }\n    };\n    ETCp.retireTexture = function(txr) {\n        var self1 = this;\n        var txrH = txr.height;\n        var txrQ = self1.getTextureQueue(txrH);\n        var lookup = this.lookup; // retire the texture from the active / searchable queue:\n        removeFromArray(txrQ, txr);\n        txr.retired = true; // remove the refs from the eles to the caches:\n        var eleCaches = txr.eleCaches;\n        for(var i = 0; i < eleCaches.length; i++){\n            var eleCache = eleCaches[i];\n            lookup.deleteCache(eleCache.key, eleCache.level);\n        }\n        clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:\n        var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n        rtxtrQ.push(txr);\n    };\n    ETCp.addTexture = function(txrH, minW) {\n        var self1 = this;\n        var txrQ = self1.getTextureQueue(txrH);\n        var txr = {};\n        txrQ.push(txr);\n        txr.eleCaches = [];\n        txr.height = txrH;\n        txr.width = Math.max(defTxrWidth, minW);\n        txr.usedWidth = 0;\n        txr.invalidatedWidth = 0;\n        txr.fullnessChecks = 0;\n        txr.canvas = self1.renderer.makeOffscreenCanvas(txr.width, txr.height);\n        txr.context = txr.canvas.getContext(\"2d\");\n        return txr;\n    };\n    ETCp.recycleTexture = function(txrH, minW) {\n        var self1 = this;\n        var txrQ = self1.getTextureQueue(txrH);\n        var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n        for(var i = 0; i < rtxtrQ.length; i++){\n            var txr = rtxtrQ[i];\n            if (txr.width >= minW) {\n                txr.retired = false;\n                txr.usedWidth = 0;\n                txr.invalidatedWidth = 0;\n                txr.fullnessChecks = 0;\n                clearArray(txr.eleCaches);\n                txr.context.setTransform(1, 0, 0, 1, 0, 0);\n                txr.context.clearRect(0, 0, txr.width, txr.height);\n                removeFromArray(rtxtrQ, txr);\n                txrQ.push(txr);\n                return txr;\n            }\n        }\n    };\n    ETCp.queueElement = function(ele, lvl) {\n        var self1 = this;\n        var q = self1.getElementQueue();\n        var k2q = self1.getElementKeyToQueue();\n        var key = this.getKey(ele);\n        var existingReq = k2q[key];\n        if (existingReq) {\n            // use the max lvl b/c in between lvls are cheap to make\n            existingReq.level = Math.max(existingReq.level, lvl);\n            existingReq.eles.merge(ele);\n            existingReq.reqs++;\n            q.updateItem(existingReq);\n        } else {\n            var req = {\n                eles: ele.spawn().merge(ele),\n                level: lvl,\n                reqs: 1,\n                key: key\n            };\n            q.push(req);\n            k2q[key] = req;\n        }\n    };\n    ETCp.dequeue = function(pxRatio) {\n        var self1 = this;\n        var q = self1.getElementQueue();\n        var k2q = self1.getElementKeyToQueue();\n        var dequeued = [];\n        var lookup = self1.lookup;\n        for(var i = 0; i < maxDeqSize$1; i++){\n            if (q.size() > 0) {\n                var req = q.pop();\n                var key = req.key;\n                var ele = req.eles[0]; // all eles have the same key\n                var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup\n                k2q[key] = null; // dequeueing isn't necessary with an existing cache\n                if (cacheExists) {\n                    continue;\n                }\n                dequeued.push(req);\n                var bb = self1.getBoundingBox(ele);\n                self1.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n            } else {\n                break;\n            }\n        }\n        return dequeued;\n    };\n    ETCp.removeFromQueue = function(ele) {\n        var self1 = this;\n        var q = self1.getElementQueue();\n        var k2q = self1.getElementKeyToQueue();\n        var key = this.getKey(ele);\n        var req = k2q[key];\n        if (req != null) {\n            if (req.eles.length === 1) {\n                // remove if last ele in the req\n                // bring to front of queue\n                req.reqs = MAX_INT$1;\n                q.updateItem(req);\n                q.pop(); // remove from queue\n                k2q[key] = null; // remove from lookup map\n            } else {\n                // otherwise just remove ele from req\n                req.eles.unmerge(ele);\n            }\n        }\n    };\n    ETCp.onDequeue = function(fn) {\n        this.onDequeues.push(fn);\n    };\n    ETCp.offDequeue = function(fn) {\n        removeFromArray(this.onDequeues, fn);\n    };\n    ETCp.setupDequeueing = defs.setupDequeueing({\n        deqRedrawThreshold: deqRedrawThreshold$1,\n        deqCost: deqCost$1,\n        deqAvgCost: deqAvgCost$1,\n        deqNoDrawCost: deqNoDrawCost$1,\n        deqFastCost: deqFastCost$1,\n        deq: function deq(self1, pxRatio, extent) {\n            return self1.dequeue(pxRatio, extent);\n        },\n        onDeqd: function onDeqd(self1, deqd) {\n            for(var i = 0; i < self1.onDequeues.length; i++){\n                var fn = self1.onDequeues[i];\n                fn(deqd);\n            }\n        },\n        shouldRedraw: function shouldRedraw(self1, deqd, pxRatio, extent) {\n            for(var i = 0; i < deqd.length; i++){\n                var eles = deqd[i].eles;\n                for(var j = 0; j < eles.length; j++){\n                    var bb = eles[j].boundingBox();\n                    if (boundingBoxesIntersect(bb, extent)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        priority: function priority(self1) {\n            return self1.renderer.beforeRenderPriorities.eleTxrDeq;\n        }\n    });\n    var defNumLayers = 1; // default number of layers to use\n    var minLvl = -4; // when scaling smaller than that we don't need to re-render\n    var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n    var maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n    var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n    var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n    var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n    var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n    var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n    var deqFastCost = 0.9; // % of frame time to be used when >60fps\n    var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n    var invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n    var maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n    var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n    // var log = function(){ console.log.apply( console, arguments ); };\n    var LayeredTextureCache = function LayeredTextureCache(renderer) {\n        var self1 = this;\n        var r = self1.renderer = renderer;\n        var cy = r.cy;\n        self1.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n        self1.firstGet = true;\n        self1.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n        self1.skipping = false;\n        self1.eleTxrDeqs = cy.collection();\n        self1.scheduleElementRefinement = debounce_1(function() {\n            self1.refineElementTextures(self1.eleTxrDeqs);\n            self1.eleTxrDeqs.unmerge(self1.eleTxrDeqs);\n        }, refineEleDebounceTime);\n        r.beforeRender(function(willDraw, now) {\n            if (now - self1.lastInvalidationTime <= invalidThreshold) {\n                self1.skipping = true;\n            } else {\n                self1.skipping = false;\n            }\n        }, r.beforeRenderPriorities.lyrTxrSkip);\n        var qSort = function qSort(a, b) {\n            return b.reqs - a.reqs;\n        };\n        self1.layersQueue = new heap(qSort);\n        self1.setupDequeueing();\n    };\n    var LTCp = LayeredTextureCache.prototype;\n    var layerIdPool = 0;\n    var MAX_INT = Math.pow(2, 53) - 1;\n    LTCp.makeLayer = function(bb, lvl) {\n        var scale = Math.pow(2, lvl);\n        var w = Math.ceil(bb.w * scale);\n        var h = Math.ceil(bb.h * scale);\n        var canvas = this.renderer.makeOffscreenCanvas(w, h);\n        var layer = {\n            id: layerIdPool = ++layerIdPool % MAX_INT,\n            bb: bb,\n            level: lvl,\n            width: w,\n            height: h,\n            canvas: canvas,\n            context: canvas.getContext(\"2d\"),\n            eles: [],\n            elesQueue: [],\n            reqs: 0\n        }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n        var cxt = layer.context;\n        var dx = -layer.bb.x1;\n        var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)\n        cxt.scale(scale, scale);\n        cxt.translate(dx, dy);\n        return layer;\n    };\n    LTCp.getLayers = function(eles, pxRatio, lvl) {\n        var self1 = this;\n        var r = self1.renderer;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var firstGet = self1.firstGet;\n        self1.firstGet = false; // log('--\\nget layers with %s eles', eles.length);\n        //log eles.map(function(ele){ return ele.id() }) );\n        if (lvl == null) {\n            lvl = Math.ceil(log2(zoom * pxRatio));\n            if (lvl < minLvl) {\n                lvl = minLvl;\n            } else if (zoom >= maxZoom || lvl > maxLvl) {\n                return null;\n            }\n        }\n        self1.validateLayersElesOrdering(lvl, eles);\n        var layersByLvl = self1.layersByLevel;\n        var scale = Math.pow(2, lvl);\n        var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n        var bb;\n        var lvlComplete = self1.levelIsComplete(lvl, eles);\n        var tmpLayers;\n        var checkTempLevels = function checkTempLevels() {\n            var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n                self1.validateLayersElesOrdering(l, eles);\n                if (self1.levelIsComplete(l, eles)) {\n                    tmpLayers = layersByLvl[l];\n                    return true;\n                }\n            };\n            var checkLvls = function checkLvls(dir) {\n                if (tmpLayers) {\n                    return;\n                }\n                for(var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir){\n                    if (canUseAsTmpLvl(l)) {\n                        break;\n                    }\n                }\n            };\n            checkLvls(+1);\n            checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function\n            for(var i = layers.length - 1; i >= 0; i--){\n                var layer = layers[i];\n                if (layer.invalid) {\n                    removeFromArray(layers, layer);\n                }\n            }\n        };\n        if (!lvlComplete) {\n            // if the current level is incomplete, then use the closest, best quality layerset temporarily\n            // and later queue the current layerset so we can get the proper quality level soon\n            checkTempLevels();\n        } else {\n            // log('level complete, using existing layers\\n--');\n            return layers;\n        }\n        var getBb = function getBb() {\n            if (!bb) {\n                bb = makeBoundingBox();\n                for(var i = 0; i < eles.length; i++){\n                    updateBoundingBox(bb, eles[i].boundingBox());\n                }\n            }\n            return bb;\n        };\n        var makeLayer = function makeLayer(opts) {\n            opts = opts || {};\n            var after = opts.after;\n            getBb();\n            var area = bb.w * scale * (bb.h * scale);\n            if (area > maxLayerArea) {\n                return null;\n            }\n            var layer = self1.makeLayer(bb, lvl);\n            if (after != null) {\n                var index = layers.indexOf(after) + 1;\n                layers.splice(index, 0, layer);\n            } else if (opts.insert === undefined || opts.insert) {\n                // no after specified => first layer made so put at start\n                layers.unshift(layer);\n            } // if( tmpLayers ){\n            //self.queueLayer( layer );\n            // }\n            return layer;\n        };\n        if (self1.skipping && !firstGet) {\n            // log('skip layers');\n            return null;\n        } // log('do layers');\n        var layer = null;\n        var maxElesPerLayer = eles.length / defNumLayers;\n        var allowLazyQueueing = !firstGet;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var rs = ele._private.rscratch;\n            var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());\n            var existingLayer = caches[lvl];\n            if (existingLayer) {\n                // reuse layer for later eles\n                // log('reuse layer for', ele.id());\n                layer = existingLayer;\n                continue;\n            }\n            if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n                // log('make new layer for ele %s', ele.id());\n                layer = makeLayer({\n                    insert: true,\n                    after: layer\n                }); // if now layer can be built then we can't use layers at this level\n                if (!layer) {\n                    return null;\n                } // log('new layer with id %s', layer.id);\n            }\n            if (tmpLayers || allowLazyQueueing) {\n                // log('queue ele %s in layer %s', ele.id(), layer.id);\n                self1.queueLayer(layer, ele);\n            } else {\n                // log('draw ele %s in layer %s', ele.id(), layer.id);\n                self1.drawEleInLayer(layer, ele, lvl, pxRatio);\n            }\n            layer.eles.push(ele);\n            caches[lvl] = layer;\n        } // log('--');\n        if (tmpLayers) {\n            // then we only queued the current layerset and can't draw it yet\n            return tmpLayers;\n        }\n        if (allowLazyQueueing) {\n            // log('lazy queue level', lvl);\n            return null;\n        }\n        return layers;\n    }; // a layer may want to use an ele cache of a higher level to avoid blurriness\n    // so the layer level might not equal the ele level\n    LTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {\n        return lvl;\n    };\n    LTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {\n        var self1 = this;\n        var r = this.renderer;\n        var context = layer.context;\n        var bb = ele.boundingBox();\n        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n            return;\n        }\n        lvl = self1.getEleLevelForLayerLevel(lvl, pxRatio);\n        {\n            r.setImgSmoothing(context, false);\n        }\n        {\n            r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n        }\n        {\n            r.setImgSmoothing(context, true);\n        }\n    };\n    LTCp.levelIsComplete = function(lvl, eles) {\n        var self1 = this;\n        var layers = self1.layersByLevel[lvl];\n        if (!layers || layers.length === 0) {\n            return false;\n        }\n        var numElesInLayers = 0;\n        for(var i = 0; i < layers.length; i++){\n            var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete\n            if (layer.reqs > 0) {\n                return false;\n            } // if the layer is invalid, the level is not complete\n            if (layer.invalid) {\n                return false;\n            }\n            numElesInLayers += layer.eles.length;\n        } // we should have exactly the number of eles passed in to be complete\n        if (numElesInLayers !== eles.length) {\n            return false;\n        }\n        return true;\n    };\n    LTCp.validateLayersElesOrdering = function(lvl, eles) {\n        var layers = this.layersByLevel[lvl];\n        if (!layers) {\n            return;\n        } // if in a layer the eles are not in the same order, then the layer is invalid\n        // (i.e. there is an ele in between the eles in the layer)\n        for(var i = 0; i < layers.length; i++){\n            var layer = layers[i];\n            var offset = -1; // find the offset\n            for(var j = 0; j < eles.length; j++){\n                if (layer.eles[0] === eles[j]) {\n                    offset = j;\n                    break;\n                }\n            }\n            if (offset < 0) {\n                // then the layer has nonexistent elements and is invalid\n                this.invalidateLayer(layer);\n                continue;\n            } // the eles in the layer must be in the same continuous order, else the layer is invalid\n            var o = offset;\n            for(var j = 0; j < layer.eles.length; j++){\n                if (layer.eles[j] !== eles[o + j]) {\n                    // log('invalidate based on ordering', layer.id);\n                    this.invalidateLayer(layer);\n                    break;\n                }\n            }\n        }\n    };\n    LTCp.updateElementsInLayers = function(eles, update) {\n        var self1 = this;\n        var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each\n        // layer itself along the way\n        for(var i = 0; i < eles.length; i++){\n            var req = isEles ? null : eles[i];\n            var ele = isEles ? eles[i] : eles[i].ele;\n            var rs = ele._private.rscratch;\n            var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n            for(var l = minLvl; l <= maxLvl; l++){\n                var layer = caches[l];\n                if (!layer) {\n                    continue;\n                } // if update is a request from the ele cache, then it affects only\n                // the matching level\n                if (req && self1.getEleLevelForLayerLevel(layer.level) !== req.level) {\n                    continue;\n                }\n                update(layer, ele, req);\n            }\n        }\n    };\n    LTCp.haveLayers = function() {\n        var self1 = this;\n        var haveLayers = false;\n        for(var l = minLvl; l <= maxLvl; l++){\n            var layers = self1.layersByLevel[l];\n            if (layers && layers.length > 0) {\n                haveLayers = true;\n                break;\n            }\n        }\n        return haveLayers;\n    };\n    LTCp.invalidateElements = function(eles) {\n        var self1 = this;\n        if (eles.length === 0) {\n            return;\n        }\n        self1.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');\n        if (eles.length === 0 || !self1.haveLayers()) {\n            return;\n        }\n        self1.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n            self1.invalidateLayer(layer);\n        });\n    };\n    LTCp.invalidateLayer = function(layer) {\n        // log('update invalidate layer time');\n        this.lastInvalidationTime = performanceNow();\n        if (layer.invalid) {\n            return;\n        } // save cycles\n        var lvl = layer.level;\n        var eles = layer.eles;\n        var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );\n        removeFromArray(layers, layer); // layer.eles = [];\n        layer.elesQueue = [];\n        layer.invalid = true;\n        if (layer.replacement) {\n            layer.replacement.invalid = true;\n        }\n        for(var i = 0; i < eles.length; i++){\n            var caches = eles[i]._private.rscratch.imgLayerCaches;\n            if (caches) {\n                caches[lvl] = null;\n            }\n        }\n    };\n    LTCp.refineElementTextures = function(eles) {\n        var self1 = this; // log('refine', eles.length);\n        self1.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n            var rLyr = layer.replacement;\n            if (!rLyr) {\n                rLyr = layer.replacement = self1.makeLayer(layer.bb, layer.level);\n                rLyr.replaces = layer;\n                rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n            }\n            if (!rLyr.reqs) {\n                for(var i = 0; i < rLyr.eles.length; i++){\n                    self1.queueLayer(rLyr, rLyr.eles[i]);\n                } // log('queue replacement layer refinement', rLyr.id);\n            }\n        });\n    };\n    LTCp.enqueueElementRefinement = function(ele) {\n        this.eleTxrDeqs.merge(ele);\n        this.scheduleElementRefinement();\n    };\n    LTCp.queueLayer = function(layer, ele) {\n        var self1 = this;\n        var q = self1.layersQueue;\n        var elesQ = layer.elesQueue;\n        var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time\n        if (layer.replacement) {\n            return;\n        }\n        if (ele) {\n            if (hasId[ele.id()]) {\n                return;\n            }\n            elesQ.push(ele);\n            hasId[ele.id()] = true;\n        }\n        if (layer.reqs) {\n            layer.reqs++;\n            q.updateItem(layer);\n        } else {\n            layer.reqs = 1;\n            q.push(layer);\n        }\n    };\n    LTCp.dequeue = function(pxRatio) {\n        var self1 = this;\n        var q = self1.layersQueue;\n        var deqd = [];\n        var eleDeqs = 0;\n        while(eleDeqs < maxDeqSize){\n            if (q.size() === 0) {\n                break;\n            }\n            var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it\n            if (layer.replacement) {\n                // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n                q.pop();\n                continue;\n            } // if this is a replacement layer that has been superceded, then forget it\n            if (layer.replaces && layer !== layer.replaces.replacement) {\n                // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n                q.pop();\n                continue;\n            }\n            if (layer.invalid) {\n                // log('replacement layer %s is invalid; dequeued', layer.id);\n                q.pop();\n                continue;\n            }\n            var ele = layer.elesQueue.shift();\n            if (ele) {\n                // log('dequeue layer %s', layer.id);\n                self1.drawEleInLayer(layer, ele, layer.level, pxRatio);\n                eleDeqs++;\n            }\n            if (deqd.length === 0) {\n                // we need only one entry in deqd to queue redrawing etc\n                deqd.push(true);\n            } // if the layer has all its eles done, then remove from the queue\n            if (layer.elesQueue.length === 0) {\n                q.pop();\n                layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);\n                // when a replacement layer is dequeued, it replaces the old layer in the level\n                if (layer.replaces) {\n                    self1.applyLayerReplacement(layer);\n                }\n                self1.requestRedraw();\n            }\n        }\n        return deqd;\n    };\n    LTCp.applyLayerReplacement = function(layer) {\n        var self1 = this;\n        var layersInLevel = self1.layersByLevel[layer.level];\n        var replaced = layer.replaces;\n        var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing\n        // refs would be a mistake (i.e. overwriting the true active layer)\n        if (index < 0 || replaced.invalid) {\n            // log('replacement layer would have no effect', layer.id);\n            return;\n        }\n        layersInLevel[index] = layer; // replace level ref\n        // replace refs in eles\n        for(var i = 0; i < layer.eles.length; i++){\n            var _p = layer.eles[i]._private;\n            var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n            if (cache) {\n                cache[layer.level] = layer;\n            }\n        } // log('apply replacement layer %s over %s', layer.id, replaced.id);\n        self1.requestRedraw();\n    };\n    LTCp.requestRedraw = debounce_1(function() {\n        var r = this.renderer;\n        r.redrawHint(\"eles\", true);\n        r.redrawHint(\"drag\", true);\n        r.redraw();\n    }, 100);\n    LTCp.setupDequeueing = defs.setupDequeueing({\n        deqRedrawThreshold: deqRedrawThreshold,\n        deqCost: deqCost,\n        deqAvgCost: deqAvgCost,\n        deqNoDrawCost: deqNoDrawCost,\n        deqFastCost: deqFastCost,\n        deq: function deq(self1, pxRatio) {\n            return self1.dequeue(pxRatio);\n        },\n        onDeqd: noop$1,\n        shouldRedraw: trueify,\n        priority: function priority(self1) {\n            return self1.renderer.beforeRenderPriorities.lyrTxrDeq;\n        }\n    });\n    var CRp$a = {};\n    var impl;\n    function polygon(context, points) {\n        for(var i = 0; i < points.length; i++){\n            var pt = points[i];\n            context.lineTo(pt.x, pt.y);\n        }\n    }\n    function triangleBackcurve(context, points, controlPoint) {\n        var firstPt;\n        for(var i = 0; i < points.length; i++){\n            var pt = points[i];\n            if (i === 0) {\n                firstPt = pt;\n            }\n            context.lineTo(pt.x, pt.y);\n        }\n        context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n    }\n    function triangleTee(context, trianglePoints, teePoints) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        var triPts = trianglePoints;\n        for(var i = 0; i < triPts.length; i++){\n            var pt = triPts[i];\n            context.lineTo(pt.x, pt.y);\n        }\n        var teePts = teePoints;\n        var firstTeePt = teePoints[0];\n        context.moveTo(firstTeePt.x, firstTeePt.y);\n        for(var i = 1; i < teePts.length; i++){\n            var pt = teePts[i];\n            context.lineTo(pt.x, pt.y);\n        }\n        if (context.closePath) {\n            context.closePath();\n        }\n    }\n    function circleTriangle(context, trianglePoints, rx, ry, r) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.arc(rx, ry, r, 0, Math.PI * 2, false);\n        var triPts = trianglePoints;\n        var firstTrPt = triPts[0];\n        context.moveTo(firstTrPt.x, firstTrPt.y);\n        for(var i = 0; i < triPts.length; i++){\n            var pt = triPts[i];\n            context.lineTo(pt.x, pt.y);\n        }\n        if (context.closePath) {\n            context.closePath();\n        }\n    }\n    function circle(context, rx, ry, r) {\n        context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    }\n    CRp$a.arrowShapeImpl = function(name) {\n        return (impl || (impl = {\n            \"polygon\": polygon,\n            \"triangle-backcurve\": triangleBackcurve,\n            \"triangle-tee\": triangleTee,\n            \"circle-triangle\": circleTriangle,\n            \"triangle-cross\": triangleTee,\n            \"circle\": circle\n        }))[name];\n    };\n    var CRp$9 = {};\n    CRp$9.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n        var r = this;\n        if (ele.isNode()) {\n            r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n        } else {\n            r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n        }\n    };\n    CRp$9.drawElementOverlay = function(context, ele) {\n        var r = this;\n        if (ele.isNode()) {\n            r.drawNodeOverlay(context, ele);\n        } else {\n            r.drawEdgeOverlay(context, ele);\n        }\n    };\n    CRp$9.drawElementUnderlay = function(context, ele) {\n        var r = this;\n        if (ele.isNode()) {\n            r.drawNodeUnderlay(context, ele);\n        } else {\n            r.drawEdgeUnderlay(context, ele);\n        }\n    };\n    CRp$9.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n        var r = this;\n        var bb = eleTxrCache.getBoundingBox(ele);\n        if (bb.w === 0 || bb.h === 0) {\n            return;\n        } // ignore zero size case\n        var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n        if (eleCache != null) {\n            var opacity = getOpacity(r, ele);\n            if (opacity === 0) {\n                return;\n            }\n            var theta = getRotation(r, ele);\n            var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;\n            var x, y, sx, sy, smooth;\n            if (theta !== 0) {\n                var rotPt = eleTxrCache.getRotationPoint(ele);\n                sx = rotPt.x;\n                sy = rotPt.y;\n                context.translate(sx, sy);\n                context.rotate(theta);\n                smooth = r.getImgSmoothing(context);\n                if (!smooth) {\n                    r.setImgSmoothing(context, true);\n                }\n                var off = eleTxrCache.getRotationOffset(ele);\n                x = off.x;\n                y = off.y;\n            } else {\n                x = x1;\n                y = y1;\n            }\n            var oldGlobalAlpha;\n            if (opacity !== 1) {\n                oldGlobalAlpha = context.globalAlpha;\n                context.globalAlpha = oldGlobalAlpha * opacity;\n            }\n            context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n            if (opacity !== 1) {\n                context.globalAlpha = oldGlobalAlpha;\n            }\n            if (theta !== 0) {\n                context.rotate(-theta);\n                context.translate(-sx, -sy);\n                if (!smooth) {\n                    r.setImgSmoothing(context, false);\n                }\n            }\n        } else {\n            eleTxrCache.drawElement(context, ele); // direct draw fallback\n        }\n    };\n    var getZeroRotation = function getZeroRotation() {\n        return 0;\n    };\n    var getLabelRotation = function getLabelRotation(r, ele) {\n        return r.getTextAngle(ele, null);\n    };\n    var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n        return r.getTextAngle(ele, \"source\");\n    };\n    var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n        return r.getTextAngle(ele, \"target\");\n    };\n    var getOpacity = function getOpacity(r, ele) {\n        return ele.effectiveOpacity();\n    };\n    var getTextOpacity = function getTextOpacity(e, ele) {\n        return ele.pstyle(\"text-opacity\").pfValue * ele.effectiveOpacity();\n    };\n    CRp$9.drawCachedElement = function(context, ele, pxRatio, extent, lvl, requestHighQuality) {\n        var r = this;\n        var _r$data = r.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;\n        var bb = ele.boundingBox();\n        var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n            return;\n        }\n        if (!extent || boundingBoxesIntersect(bb, extent)) {\n            var isEdge = ele.isEdge();\n            var badLine = ele.element()._private.rscratch.badLine;\n            r.drawElementUnderlay(context, ele);\n            r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n            if (!isEdge || !badLine) {\n                r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n            }\n            if (isEdge && !badLine) {\n                r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n                r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n            }\n            r.drawElementOverlay(context, ele);\n        }\n    };\n    CRp$9.drawElements = function(context, eles) {\n        var r = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            r.drawElement(context, ele);\n        }\n    };\n    CRp$9.drawCachedElements = function(context, eles, pxRatio, extent) {\n        var r = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            r.drawCachedElement(context, ele, pxRatio, extent);\n        }\n    };\n    CRp$9.drawCachedNodes = function(context, eles, pxRatio, extent) {\n        var r = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            r.drawCachedElement(context, ele, pxRatio, extent);\n        }\n    };\n    CRp$9.drawLayeredElements = function(context, eles, pxRatio, extent) {\n        var r = this;\n        var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n        if (layers) {\n            for(var i = 0; i < layers.length; i++){\n                var layer = layers[i];\n                var bb = layer.bb;\n                if (bb.w === 0 || bb.h === 0) {\n                    continue;\n                }\n                context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n            }\n        } else {\n            // fall back on plain caching if no layers\n            r.drawCachedElements(context, eles, pxRatio, extent);\n        }\n    };\n    /* global Path2D */ var CRp$8 = {};\n    CRp$8.drawEdge = function(context, edge, shiftToOriginWithBb) {\n        var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        var r = this;\n        var rs = edge._private.rscratch;\n        if (shouldDrawOpacity && !edge.visible()) {\n            return;\n        } // if bezier ctrl pts can not be calculated, then die\n        if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n            // isNaN in case edge is impossible and browser bugs (e.g. safari)\n            return;\n        }\n        var bb;\n        if (shiftToOriginWithBb) {\n            bb = shiftToOriginWithBb;\n            context.translate(-bb.x1, -bb.y1);\n        }\n        var opacity = shouldDrawOpacity ? edge.pstyle(\"opacity\").value : 1;\n        var lineOpacity = shouldDrawOpacity ? edge.pstyle(\"line-opacity\").value : 1;\n        var curveStyle = edge.pstyle(\"curve-style\").value;\n        var lineStyle = edge.pstyle(\"line-style\").value;\n        var edgeWidth = edge.pstyle(\"width\").pfValue;\n        var lineCap = edge.pstyle(\"line-cap\").value;\n        var effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property\n        var effectiveArrowOpacity = opacity * lineOpacity;\n        var drawLine = function drawLine() {\n            var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n            if (curveStyle === \"straight-triangle\") {\n                r.eleStrokeStyle(context, edge, strokeOpacity);\n                r.drawEdgeTrianglePath(edge, context, rs.allpts);\n            } else {\n                context.lineWidth = edgeWidth;\n                context.lineCap = lineCap;\n                r.eleStrokeStyle(context, edge, strokeOpacity);\n                r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n                context.lineCap = \"butt\"; // reset for other drawing functions\n            }\n        };\n        var drawOverlay = function drawOverlay() {\n            if (!shouldDrawOverlay) {\n                return;\n            }\n            r.drawEdgeOverlay(context, edge);\n        };\n        var drawUnderlay = function drawUnderlay() {\n            if (!shouldDrawOverlay) {\n                return;\n            }\n            r.drawEdgeUnderlay(context, edge);\n        };\n        var drawArrows = function drawArrows() {\n            var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n            r.drawArrowheads(context, edge, arrowOpacity);\n        };\n        var drawText = function drawText() {\n            r.drawElementText(context, edge, null, drawLabel);\n        };\n        context.lineJoin = \"round\";\n        var ghost = edge.pstyle(\"ghost\").value === \"yes\";\n        if (ghost) {\n            var gx = edge.pstyle(\"ghost-offset-x\").pfValue;\n            var gy = edge.pstyle(\"ghost-offset-y\").pfValue;\n            var ghostOpacity = edge.pstyle(\"ghost-opacity\").value;\n            var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n            context.translate(gx, gy);\n            drawLine(effectiveGhostOpacity);\n            drawArrows(effectiveGhostOpacity);\n            context.translate(-gx, -gy);\n        }\n        drawUnderlay();\n        drawLine();\n        drawArrows();\n        drawOverlay();\n        drawText();\n        if (shiftToOriginWithBb) {\n            context.translate(bb.x1, bb.y1);\n        }\n    };\n    var drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n        if (![\n            \"overlay\",\n            \"underlay\"\n        ].includes(overlayOrUnderlay)) {\n            throw new Error(\"Invalid state\");\n        }\n        return function(context, edge) {\n            if (!edge.visible()) {\n                return;\n            }\n            var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n            if (opacity === 0) {\n                return;\n            }\n            var r = this;\n            var usePaths = r.usePaths();\n            var rs = edge._private.rscratch;\n            var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n            var width = 2 * padding;\n            var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n            context.lineWidth = width;\n            if (rs.edgeType === \"self\" && !usePaths) {\n                context.lineCap = \"butt\";\n            } else {\n                context.lineCap = \"round\";\n            }\n            r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n            r.drawEdgePath(edge, context, rs.allpts, \"solid\");\n        };\n    };\n    CRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay(\"overlay\");\n    CRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay(\"underlay\");\n    CRp$8.drawEdgePath = function(edge, context, pts, type) {\n        var rs = edge._private.rscratch;\n        var canvasCxt = context;\n        var path;\n        var pathCacheHit = false;\n        var usePaths = this.usePaths();\n        var lineDashPattern = edge.pstyle(\"line-dash-pattern\").pfValue;\n        var lineDashOffset = edge.pstyle(\"line-dash-offset\").pfValue;\n        if (usePaths) {\n            var pathCacheKey = pts.join(\"$\");\n            var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n            if (keyMatches) {\n                path = context = rs.pathCache;\n                pathCacheHit = true;\n            } else {\n                path = context = new Path2D();\n                rs.pathCacheKey = pathCacheKey;\n                rs.pathCache = path;\n            }\n        }\n        if (canvasCxt.setLineDash) {\n            // for very outofdate browsers\n            switch(type){\n                case \"dotted\":\n                    canvasCxt.setLineDash([\n                        1,\n                        1\n                    ]);\n                    break;\n                case \"dashed\":\n                    canvasCxt.setLineDash(lineDashPattern);\n                    canvasCxt.lineDashOffset = lineDashOffset;\n                    break;\n                case \"solid\":\n                    canvasCxt.setLineDash([]);\n                    break;\n            }\n        }\n        if (!pathCacheHit && !rs.badLine) {\n            if (context.beginPath) {\n                context.beginPath();\n            }\n            context.moveTo(pts[0], pts[1]);\n            switch(rs.edgeType){\n                case \"bezier\":\n                case \"self\":\n                case \"compound\":\n                case \"multibezier\":\n                    for(var i = 2; i + 3 < pts.length; i += 4){\n                        context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n                    }\n                    break;\n                case \"straight\":\n                case \"segments\":\n                case \"haystack\":\n                    for(var _i = 2; _i + 1 < pts.length; _i += 2){\n                        context.lineTo(pts[_i], pts[_i + 1]);\n                    }\n                    break;\n            }\n        }\n        context = canvasCxt;\n        if (usePaths) {\n            context.stroke(path);\n        } else {\n            context.stroke();\n        } // reset any line dashes\n        if (context.setLineDash) {\n            // for very outofdate browsers\n            context.setLineDash([]);\n        }\n    };\n    CRp$8.drawEdgeTrianglePath = function(edge, context, pts) {\n        // use line stroke style for triangle fill style\n        context.fillStyle = context.strokeStyle;\n        var edgeWidth = edge.pstyle(\"width\").pfValue;\n        for(var i = 0; i + 1 < pts.length; i += 2){\n            var vector = [\n                pts[i + 2] - pts[i],\n                pts[i + 3] - pts[i + 1]\n            ];\n            var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n            var normal = [\n                vector[1] / length,\n                -vector[0] / length\n            ];\n            var triangleHead = [\n                normal[0] * edgeWidth / 2,\n                normal[1] * edgeWidth / 2\n            ];\n            context.beginPath();\n            context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n            context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n            context.lineTo(pts[i + 2], pts[i + 3]);\n            context.closePath();\n            context.fill();\n        }\n    };\n    CRp$8.drawArrowheads = function(context, edge, opacity) {\n        var rs = edge._private.rscratch;\n        var isHaystack = rs.edgeType === \"haystack\";\n        if (!isHaystack) {\n            this.drawArrowhead(context, edge, \"source\", rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n        }\n        this.drawArrowhead(context, edge, \"mid-target\", rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n        this.drawArrowhead(context, edge, \"mid-source\", rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n        if (!isHaystack) {\n            this.drawArrowhead(context, edge, \"target\", rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n        }\n    };\n    CRp$8.drawArrowhead = function(context, edge, prefix, x, y, angle, opacity) {\n        if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n            return;\n        }\n        var self1 = this;\n        var arrowShape = edge.pstyle(prefix + \"-arrow-shape\").value;\n        if (arrowShape === \"none\") {\n            return;\n        }\n        var arrowClearFill = edge.pstyle(prefix + \"-arrow-fill\").value === \"hollow\" ? \"both\" : \"filled\";\n        var arrowFill = edge.pstyle(prefix + \"-arrow-fill\").value;\n        var edgeWidth = edge.pstyle(\"width\").pfValue;\n        var edgeOpacity = edge.pstyle(\"opacity\").value;\n        if (opacity === undefined) {\n            opacity = edgeOpacity;\n        }\n        var gco = context.globalCompositeOperation;\n        if (opacity !== 1 || arrowFill === \"hollow\") {\n            // then extra clear is needed\n            context.globalCompositeOperation = \"destination-out\";\n            self1.colorFillStyle(context, 255, 255, 255, 1);\n            self1.colorStrokeStyle(context, 255, 255, 255, 1);\n            self1.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n            context.globalCompositeOperation = gco;\n        } // otherwise, the opaque arrow clears it for free :)\n        var color = edge.pstyle(prefix + \"-arrow-color\").value;\n        self1.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        self1.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n        self1.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n    };\n    CRp$8.drawArrowShape = function(edge, context, fill, edgeWidth, shape, x, y, angle) {\n        var r = this;\n        var usePaths = this.usePaths() && shape !== \"triangle-cross\";\n        var pathCacheHit = false;\n        var path;\n        var canvasContext = context;\n        var translation = {\n            x: x,\n            y: y\n        };\n        var scale = edge.pstyle(\"arrow-scale\").value;\n        var size = this.getArrowWidth(edgeWidth, scale);\n        var shapeImpl = r.arrowShapes[shape];\n        if (usePaths) {\n            var cache = r.arrowPathCache = r.arrowPathCache || [];\n            var key = hashString(shape);\n            var cachedPath = cache[key];\n            if (cachedPath != null) {\n                path = context = cachedPath;\n                pathCacheHit = true;\n            } else {\n                path = context = new Path2D();\n                cache[key] = path;\n            }\n        }\n        if (!pathCacheHit) {\n            if (context.beginPath) {\n                context.beginPath();\n            }\n            if (usePaths) {\n                // store in the path cache with values easily manipulated later\n                shapeImpl.draw(context, 1, 0, {\n                    x: 0,\n                    y: 0\n                }, 1);\n            } else {\n                shapeImpl.draw(context, size, angle, translation, edgeWidth);\n            }\n            if (context.closePath) {\n                context.closePath();\n            }\n        }\n        context = canvasContext;\n        if (usePaths) {\n            // set transform to arrow position/orientation\n            context.translate(x, y);\n            context.rotate(angle);\n            context.scale(size, size);\n        }\n        if (fill === \"filled\" || fill === \"both\") {\n            if (usePaths) {\n                context.fill(path);\n            } else {\n                context.fill();\n            }\n        }\n        if (fill === \"hollow\" || fill === \"both\") {\n            context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);\n            context.lineJoin = \"miter\";\n            if (usePaths) {\n                context.stroke(path);\n            } else {\n                context.stroke();\n            }\n        }\n        if (usePaths) {\n            // reset transform by applying inverse\n            context.scale(1 / size, 1 / size);\n            context.rotate(-angle);\n            context.translate(-x, -y);\n        }\n    };\n    var CRp$7 = {};\n    CRp$7.safeDrawImage = function(context, img, ix, iy, iw, ih, x, y, w, h) {\n        // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n        if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n            return;\n        }\n        try {\n            context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n        } catch (e) {\n            warn(e);\n        }\n    };\n    CRp$7.drawInscribedImage = function(context, img, node, index, nodeOpacity) {\n        var r = this;\n        var pos = node.position();\n        var nodeX = pos.x;\n        var nodeY = pos.y;\n        var styleObj = node.cy().style();\n        var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n        var fit = getIndexedStyle(node, \"background-fit\", \"value\", index);\n        var repeat = getIndexedStyle(node, \"background-repeat\", \"value\", index);\n        var nodeW = node.width();\n        var nodeH = node.height();\n        var paddingX2 = node.padding() * 2;\n        var nodeTW = nodeW + (getIndexedStyle(node, \"background-width-relative-to\", \"value\", index) === \"inner\" ? 0 : paddingX2);\n        var nodeTH = nodeH + (getIndexedStyle(node, \"background-height-relative-to\", \"value\", index) === \"inner\" ? 0 : paddingX2);\n        var rs = node._private.rscratch;\n        var clip = getIndexedStyle(node, \"background-clip\", \"value\", index);\n        var shouldClip = clip === \"node\";\n        var imgOpacity = getIndexedStyle(node, \"background-image-opacity\", \"value\", index) * nodeOpacity;\n        var smooth = getIndexedStyle(node, \"background-image-smoothing\", \"value\", index);\n        var imgW = img.width || img.cachedW;\n        var imgH = img.height || img.cachedH; // workaround for broken browsers like ie\n        if (null == imgW || null == imgH) {\n            document.body.appendChild(img); // eslint-disable-line no-undef\n            imgW = img.cachedW = img.width || img.offsetWidth;\n            imgH = img.cachedH = img.height || img.offsetHeight;\n            document.body.removeChild(img); // eslint-disable-line no-undef\n        }\n        var w = imgW;\n        var h = imgH;\n        if (getIndexedStyle(node, \"background-width\", \"value\", index) !== \"auto\") {\n            if (getIndexedStyle(node, \"background-width\", \"units\", index) === \"%\") {\n                w = getIndexedStyle(node, \"background-width\", \"pfValue\", index) * nodeTW;\n            } else {\n                w = getIndexedStyle(node, \"background-width\", \"pfValue\", index);\n            }\n        }\n        if (getIndexedStyle(node, \"background-height\", \"value\", index) !== \"auto\") {\n            if (getIndexedStyle(node, \"background-height\", \"units\", index) === \"%\") {\n                h = getIndexedStyle(node, \"background-height\", \"pfValue\", index) * nodeTH;\n            } else {\n                h = getIndexedStyle(node, \"background-height\", \"pfValue\", index);\n            }\n        }\n        if (w === 0 || h === 0) {\n            return; // no point in drawing empty image (and chrome is broken in this case)\n        }\n        if (fit === \"contain\") {\n            var scale = Math.min(nodeTW / w, nodeTH / h);\n            w *= scale;\n            h *= scale;\n        } else if (fit === \"cover\") {\n            var scale = Math.max(nodeTW / w, nodeTH / h);\n            w *= scale;\n            h *= scale;\n        }\n        var x = nodeX - nodeTW / 2; // left\n        var posXUnits = getIndexedStyle(node, \"background-position-x\", \"units\", index);\n        var posXPfVal = getIndexedStyle(node, \"background-position-x\", \"pfValue\", index);\n        if (posXUnits === \"%\") {\n            x += (nodeTW - w) * posXPfVal;\n        } else {\n            x += posXPfVal;\n        }\n        var offXUnits = getIndexedStyle(node, \"background-offset-x\", \"units\", index);\n        var offXPfVal = getIndexedStyle(node, \"background-offset-x\", \"pfValue\", index);\n        if (offXUnits === \"%\") {\n            x += (nodeTW - w) * offXPfVal;\n        } else {\n            x += offXPfVal;\n        }\n        var y = nodeY - nodeTH / 2; // top\n        var posYUnits = getIndexedStyle(node, \"background-position-y\", \"units\", index);\n        var posYPfVal = getIndexedStyle(node, \"background-position-y\", \"pfValue\", index);\n        if (posYUnits === \"%\") {\n            y += (nodeTH - h) * posYPfVal;\n        } else {\n            y += posYPfVal;\n        }\n        var offYUnits = getIndexedStyle(node, \"background-offset-y\", \"units\", index);\n        var offYPfVal = getIndexedStyle(node, \"background-offset-y\", \"pfValue\", index);\n        if (offYUnits === \"%\") {\n            y += (nodeTH - h) * offYPfVal;\n        } else {\n            y += offYPfVal;\n        }\n        if (rs.pathCache) {\n            x -= nodeX;\n            y -= nodeY;\n            nodeX = 0;\n            nodeY = 0;\n        }\n        var gAlpha = context.globalAlpha;\n        context.globalAlpha = imgOpacity;\n        var smoothingEnabled = r.getImgSmoothing(context);\n        var isSmoothingSwitched = false;\n        if (smooth === \"no\" && smoothingEnabled) {\n            r.setImgSmoothing(context, false);\n            isSmoothingSwitched = true;\n        } else if (smooth === \"yes\" && !smoothingEnabled) {\n            r.setImgSmoothing(context, true);\n            isSmoothingSwitched = true;\n        }\n        if (repeat === \"no-repeat\") {\n            if (shouldClip) {\n                context.save();\n                if (rs.pathCache) {\n                    context.clip(rs.pathCache);\n                } else {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n                    context.clip();\n                }\n            }\n            r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n            if (shouldClip) {\n                context.restore();\n            }\n        } else {\n            var pattern = context.createPattern(img, repeat);\n            context.fillStyle = pattern;\n            r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n            context.translate(x, y);\n            context.fill();\n            context.translate(-x, -y);\n        }\n        context.globalAlpha = gAlpha;\n        if (isSmoothingSwitched) {\n            r.setImgSmoothing(context, smoothingEnabled);\n        }\n    };\n    var CRp$6 = {};\n    CRp$6.eleTextBiggerThanMin = function(ele, scale) {\n        if (!scale) {\n            var zoom = ele.cy().zoom();\n            var pxRatio = this.getPixelRatio();\n            var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n            scale = Math.pow(2, lvl);\n        }\n        var computedSize = ele.pstyle(\"font-size\").pfValue * scale;\n        var minSize = ele.pstyle(\"min-zoomed-font-size\").pfValue;\n        if (computedSize < minSize) {\n            return false;\n        }\n        return true;\n    };\n    CRp$6.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {\n        var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        var r = this;\n        if (force == null) {\n            if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n                return;\n            }\n        } else if (force === false) {\n            return;\n        }\n        if (ele.isNode()) {\n            var label = ele.pstyle(\"label\");\n            if (!label || !label.value) {\n                return;\n            }\n            var justification = r.getLabelJustification(ele);\n            context.textAlign = justification;\n            context.textBaseline = \"bottom\";\n        } else {\n            var badLine = ele.element()._private.rscratch.badLine;\n            var _label = ele.pstyle(\"label\");\n            var srcLabel = ele.pstyle(\"source-label\");\n            var tgtLabel = ele.pstyle(\"target-label\");\n            if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n                return;\n            }\n            context.textAlign = \"center\";\n            context.textBaseline = \"bottom\";\n        }\n        var applyRotation = !shiftToOriginWithBb;\n        var bb;\n        if (shiftToOriginWithBb) {\n            bb = shiftToOriginWithBb;\n            context.translate(-bb.x1, -bb.y1);\n        }\n        if (prefix == null) {\n            r.drawText(context, ele, null, applyRotation, useEleOpacity);\n            if (ele.isEdge()) {\n                r.drawText(context, ele, \"source\", applyRotation, useEleOpacity);\n                r.drawText(context, ele, \"target\", applyRotation, useEleOpacity);\n            }\n        } else {\n            r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n        }\n        if (shiftToOriginWithBb) {\n            context.translate(bb.x1, bb.y1);\n        }\n    };\n    CRp$6.getFontCache = function(context) {\n        var cache;\n        this.fontCaches = this.fontCaches || [];\n        for(var i = 0; i < this.fontCaches.length; i++){\n            cache = this.fontCaches[i];\n            if (cache.context === context) {\n                return cache;\n            }\n        }\n        cache = {\n            context: context\n        };\n        this.fontCaches.push(cache);\n        return cache;\n    }; // set up canvas context with font\n    // returns transformed text string\n    CRp$6.setupTextStyle = function(context, ele) {\n        var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        // Font style\n        var labelStyle = ele.pstyle(\"font-style\").strValue;\n        var labelSize = ele.pstyle(\"font-size\").pfValue + \"px\";\n        var labelFamily = ele.pstyle(\"font-family\").strValue;\n        var labelWeight = ele.pstyle(\"font-weight\").strValue;\n        var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle(\"text-opacity\").value : 1;\n        var outlineOpacity = ele.pstyle(\"text-outline-opacity\").value * opacity;\n        var color = ele.pstyle(\"color\").value;\n        var outlineColor = ele.pstyle(\"text-outline-color\").value;\n        context.font = labelStyle + \" \" + labelWeight + \" \" + labelSize + \" \" + labelFamily;\n        context.lineJoin = \"round\"; // so text outlines aren't jagged\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n    }; // TODO ensure re-used\n    function roundRect(ctx, x, y, width, height) {\n        var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + width - radius, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n        ctx.lineTo(x + width, y + height - radius);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n        ctx.lineTo(x + radius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n        ctx.fill();\n    }\n    CRp$6.getTextAngle = function(ele, prefix) {\n        var theta;\n        var _p = ele._private;\n        var rscratch = _p.rscratch;\n        var pdash = prefix ? prefix + \"-\" : \"\";\n        var rotation = ele.pstyle(pdash + \"text-rotation\");\n        var textAngle = getPrefixedProperty(rscratch, \"labelAngle\", prefix);\n        if (rotation.strValue === \"autorotate\") {\n            theta = ele.isEdge() ? textAngle : 0;\n        } else if (rotation.strValue === \"none\") {\n            theta = 0;\n        } else {\n            theta = rotation.pfValue;\n        }\n        return theta;\n    };\n    CRp$6.drawText = function(context, ele, prefix) {\n        var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var _p = ele._private;\n        var rscratch = _p.rscratch;\n        var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n        if (useEleOpacity && (parentOpacity === 0 || ele.pstyle(\"text-opacity\").value === 0)) {\n            return;\n        } // use 'main' as an alias for the main label (i.e. null prefix)\n        if (prefix === \"main\") {\n            prefix = null;\n        }\n        var textX = getPrefixedProperty(rscratch, \"labelX\", prefix);\n        var textY = getPrefixedProperty(rscratch, \"labelY\", prefix);\n        var orgTextX, orgTextY; // used for rotation\n        var text = this.getLabelText(ele, prefix);\n        if (text != null && text !== \"\" && !isNaN(textX) && !isNaN(textY)) {\n            this.setupTextStyle(context, ele, useEleOpacity);\n            var pdash = prefix ? prefix + \"-\" : \"\";\n            var textW = getPrefixedProperty(rscratch, \"labelWidth\", prefix);\n            var textH = getPrefixedProperty(rscratch, \"labelHeight\", prefix);\n            var marginX = ele.pstyle(pdash + \"text-margin-x\").pfValue;\n            var marginY = ele.pstyle(pdash + \"text-margin-y\").pfValue;\n            var isEdge = ele.isEdge();\n            var halign = ele.pstyle(\"text-halign\").value;\n            var valign = ele.pstyle(\"text-valign\").value;\n            if (isEdge) {\n                halign = \"center\";\n                valign = \"center\";\n            }\n            textX += marginX;\n            textY += marginY;\n            var theta;\n            if (!applyRotation) {\n                theta = 0;\n            } else {\n                theta = this.getTextAngle(ele, prefix);\n            }\n            if (theta !== 0) {\n                orgTextX = textX;\n                orgTextY = textY;\n                context.translate(orgTextX, orgTextY);\n                context.rotate(theta);\n                textX = 0;\n                textY = 0;\n            }\n            switch(valign){\n                case \"top\":\n                    break;\n                case \"center\":\n                    textY += textH / 2;\n                    break;\n                case \"bottom\":\n                    textY += textH;\n                    break;\n            }\n            var backgroundOpacity = ele.pstyle(\"text-background-opacity\").value;\n            var borderOpacity = ele.pstyle(\"text-border-opacity\").value;\n            var textBorderWidth = ele.pstyle(\"text-border-width\").pfValue;\n            var backgroundPadding = ele.pstyle(\"text-background-padding\").pfValue;\n            if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n                var bgX = textX - backgroundPadding;\n                switch(halign){\n                    case \"left\":\n                        bgX -= textW;\n                        break;\n                    case \"center\":\n                        bgX -= textW / 2;\n                        break;\n                }\n                var bgY = textY - textH - backgroundPadding;\n                var bgW = textW + 2 * backgroundPadding;\n                var bgH = textH + 2 * backgroundPadding;\n                if (backgroundOpacity > 0) {\n                    var textFill = context.fillStyle;\n                    var textBackgroundColor = ele.pstyle(\"text-background-color\").value;\n                    context.fillStyle = \"rgba(\" + textBackgroundColor[0] + \",\" + textBackgroundColor[1] + \",\" + textBackgroundColor[2] + \",\" + backgroundOpacity * parentOpacity + \")\";\n                    var styleShape = ele.pstyle(\"text-background-shape\").strValue;\n                    if (styleShape.indexOf(\"round\") === 0) {\n                        roundRect(context, bgX, bgY, bgW, bgH, 2);\n                    } else {\n                        context.fillRect(bgX, bgY, bgW, bgH);\n                    }\n                    context.fillStyle = textFill;\n                }\n                if (textBorderWidth > 0 && borderOpacity > 0) {\n                    var textStroke = context.strokeStyle;\n                    var textLineWidth = context.lineWidth;\n                    var textBorderColor = ele.pstyle(\"text-border-color\").value;\n                    var textBorderStyle = ele.pstyle(\"text-border-style\").value;\n                    context.strokeStyle = \"rgba(\" + textBorderColor[0] + \",\" + textBorderColor[1] + \",\" + textBorderColor[2] + \",\" + borderOpacity * parentOpacity + \")\";\n                    context.lineWidth = textBorderWidth;\n                    if (context.setLineDash) {\n                        // for very outofdate browsers\n                        switch(textBorderStyle){\n                            case \"dotted\":\n                                context.setLineDash([\n                                    1,\n                                    1\n                                ]);\n                                break;\n                            case \"dashed\":\n                                context.setLineDash([\n                                    4,\n                                    2\n                                ]);\n                                break;\n                            case \"double\":\n                                context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n                                context.setLineDash([]);\n                                break;\n                            case \"solid\":\n                                context.setLineDash([]);\n                                break;\n                        }\n                    }\n                    context.strokeRect(bgX, bgY, bgW, bgH);\n                    if (textBorderStyle === \"double\") {\n                        var whiteWidth = textBorderWidth / 2;\n                        context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n                    }\n                    if (context.setLineDash) {\n                        // for very outofdate browsers\n                        context.setLineDash([]);\n                    }\n                    context.lineWidth = textLineWidth;\n                    context.strokeStyle = textStroke;\n                }\n            }\n            var lineWidth = 2 * ele.pstyle(\"text-outline-width\").pfValue; // *2 b/c the stroke is drawn centred on the middle\n            if (lineWidth > 0) {\n                context.lineWidth = lineWidth;\n            }\n            if (ele.pstyle(\"text-wrap\").value === \"wrap\") {\n                var lines = getPrefixedProperty(rscratch, \"labelWrapCachedLines\", prefix);\n                var lineHeight = getPrefixedProperty(rscratch, \"labelLineHeight\", prefix);\n                var halfTextW = textW / 2;\n                var justification = this.getLabelJustification(ele);\n                if (justification === \"auto\") ;\n                else if (halign === \"left\") {\n                    // auto justification : right\n                    if (justification === \"left\") {\n                        textX += -textW;\n                    } else if (justification === \"center\") {\n                        textX += -halfTextW;\n                    } // else same as auto\n                } else if (halign === \"center\") {\n                    // auto justfication : center\n                    if (justification === \"left\") {\n                        textX += -halfTextW;\n                    } else if (justification === \"right\") {\n                        textX += halfTextW;\n                    } // else same as auto\n                } else if (halign === \"right\") {\n                    // auto justification : left\n                    if (justification === \"center\") {\n                        textX += halfTextW;\n                    } else if (justification === \"right\") {\n                        textX += textW;\n                    } // else same as auto\n                }\n                switch(valign){\n                    case \"top\":\n                        textY -= (lines.length - 1) * lineHeight;\n                        break;\n                    case \"center\":\n                    case \"bottom\":\n                        textY -= (lines.length - 1) * lineHeight;\n                        break;\n                }\n                for(var l = 0; l < lines.length; l++){\n                    if (lineWidth > 0) {\n                        context.strokeText(lines[l], textX, textY);\n                    }\n                    context.fillText(lines[l], textX, textY);\n                    textY += lineHeight;\n                }\n            } else {\n                if (lineWidth > 0) {\n                    context.strokeText(text, textX, textY);\n                }\n                context.fillText(text, textX, textY);\n            }\n            if (theta !== 0) {\n                context.rotate(-theta);\n                context.translate(-orgTextX, -orgTextY);\n            }\n        }\n    };\n    /* global Path2D */ var CRp$5 = {};\n    CRp$5.drawNode = function(context, node, shiftToOriginWithBb) {\n        var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        var r = this;\n        var nodeWidth, nodeHeight;\n        var _p = node._private;\n        var rs = _p.rscratch;\n        var pos = node.position();\n        if (!number$1(pos.x) || !number$1(pos.y)) {\n            return; // can't draw node with undefined position\n        }\n        if (shouldDrawOpacity && !node.visible()) {\n            return;\n        }\n        var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n        var usePaths = r.usePaths();\n        var path;\n        var pathCacheHit = false;\n        var padding = node.padding();\n        nodeWidth = node.width() + 2 * padding;\n        nodeHeight = node.height() + 2 * padding; //\n        // setup shift\n        var bb;\n        if (shiftToOriginWithBb) {\n            bb = shiftToOriginWithBb;\n            context.translate(-bb.x1, -bb.y1);\n        } //\n        // load bg image\n        var bgImgProp = node.pstyle(\"background-image\");\n        var urls = bgImgProp.value;\n        var urlDefined = new Array(urls.length);\n        var image = new Array(urls.length);\n        var numImages = 0;\n        for(var i = 0; i < urls.length; i++){\n            var url = urls[i];\n            var defd = urlDefined[i] = url != null && url !== \"none\";\n            if (defd) {\n                var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, \"background-image-crossorigin\", \"value\", i);\n                numImages++; // get image, and if not loaded then ask to redraw when later loaded\n                image[i] = r.getCachedImage(url, bgImgCrossOrigin, function() {\n                    _p.backgroundTimestamp = Date.now();\n                    node.emitAndNotify(\"background\");\n                });\n            }\n        } //\n        // setup styles\n        var darkness = node.pstyle(\"background-blacken\").value;\n        var borderWidth = node.pstyle(\"border-width\").pfValue;\n        var bgOpacity = node.pstyle(\"background-opacity\").value * eleOpacity;\n        var borderColor = node.pstyle(\"border-color\").value;\n        var borderStyle = node.pstyle(\"border-style\").value;\n        var borderOpacity = node.pstyle(\"border-opacity\").value * eleOpacity;\n        context.lineJoin = \"miter\"; // so borders are square with the node shape\n        var setupShapeColor = function setupShapeColor() {\n            var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n            r.eleFillStyle(context, node, bgOpy);\n        };\n        var setupBorderColor = function setupBorderColor() {\n            var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n            r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n        }; //\n        // setup shape\n        var styleShape = node.pstyle(\"shape\").strValue;\n        var shapePts = node.pstyle(\"shape-polygon-points\").pfValue;\n        if (usePaths) {\n            context.translate(pos.x, pos.y);\n            var pathCache = r.nodePathCache = r.nodePathCache || [];\n            var key = hashStrings(styleShape === \"polygon\" ? styleShape + \",\" + shapePts.join(\",\") : styleShape, \"\" + nodeHeight, \"\" + nodeWidth);\n            var cachedPath = pathCache[key];\n            if (cachedPath != null) {\n                path = cachedPath;\n                pathCacheHit = true;\n                rs.pathCache = path;\n            } else {\n                path = new Path2D();\n                pathCache[key] = rs.pathCache = path;\n            }\n        }\n        var drawShape = function drawShape() {\n            if (!pathCacheHit) {\n                var npos = pos;\n                if (usePaths) {\n                    npos = {\n                        x: 0,\n                        y: 0\n                    };\n                }\n                r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n            }\n            if (usePaths) {\n                context.fill(path);\n            } else {\n                context.fill();\n            }\n        };\n        var drawImages = function drawImages() {\n            var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n            var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var prevBging = _p.backgrounding;\n            var totalCompleted = 0;\n            for(var _i = 0; _i < image.length; _i++){\n                var bgContainment = node.cy().style().getIndexedStyle(node, \"background-image-containment\", \"value\", _i);\n                if (inside && bgContainment === \"over\" || !inside && bgContainment === \"inside\") {\n                    totalCompleted++;\n                    continue;\n                }\n                if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n                    totalCompleted++;\n                    r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n                }\n            }\n            _p.backgrounding = !(totalCompleted === numImages);\n            if (prevBging !== _p.backgrounding) {\n                // update style b/c :backgrounding state changed\n                node.updateStyle(false);\n            }\n        };\n        var drawPie = function drawPie() {\n            var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n            var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n            if (r.hasPie(node)) {\n                r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it\n                if (redrawShape) {\n                    if (!usePaths) {\n                        r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n                    }\n                }\n            }\n        };\n        var darken = function darken() {\n            var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n            var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n            var c = darkness > 0 ? 0 : 255;\n            if (darkness !== 0) {\n                r.colorFillStyle(context, c, c, c, opacity);\n                if (usePaths) {\n                    context.fill(path);\n                } else {\n                    context.fill();\n                }\n            }\n        };\n        var drawBorder = function drawBorder() {\n            if (borderWidth > 0) {\n                context.lineWidth = borderWidth;\n                context.lineCap = \"butt\";\n                if (context.setLineDash) {\n                    // for very outofdate browsers\n                    switch(borderStyle){\n                        case \"dotted\":\n                            context.setLineDash([\n                                1,\n                                1\n                            ]);\n                            break;\n                        case \"dashed\":\n                            context.setLineDash([\n                                4,\n                                2\n                            ]);\n                            break;\n                        case \"solid\":\n                        case \"double\":\n                            context.setLineDash([]);\n                            break;\n                    }\n                }\n                if (usePaths) {\n                    context.stroke(path);\n                } else {\n                    context.stroke();\n                }\n                if (borderStyle === \"double\") {\n                    context.lineWidth = borderWidth / 3;\n                    var gco = context.globalCompositeOperation;\n                    context.globalCompositeOperation = \"destination-out\";\n                    if (usePaths) {\n                        context.stroke(path);\n                    } else {\n                        context.stroke();\n                    }\n                    context.globalCompositeOperation = gco;\n                } // reset in case we changed the border style\n                if (context.setLineDash) {\n                    // for very outofdate browsers\n                    context.setLineDash([]);\n                }\n            }\n        };\n        var drawOverlay = function drawOverlay() {\n            if (shouldDrawOverlay) {\n                r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n            }\n        };\n        var drawUnderlay = function drawUnderlay() {\n            if (shouldDrawOverlay) {\n                r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n            }\n        };\n        var drawText = function drawText() {\n            r.drawElementText(context, node, null, drawLabel);\n        };\n        var ghost = node.pstyle(\"ghost\").value === \"yes\";\n        if (ghost) {\n            var gx = node.pstyle(\"ghost-offset-x\").pfValue;\n            var gy = node.pstyle(\"ghost-offset-y\").pfValue;\n            var ghostOpacity = node.pstyle(\"ghost-opacity\").value;\n            var effGhostOpacity = ghostOpacity * eleOpacity;\n            context.translate(gx, gy);\n            setupShapeColor(ghostOpacity * bgOpacity);\n            drawShape();\n            drawImages(effGhostOpacity, true);\n            setupBorderColor(ghostOpacity * borderOpacity);\n            drawBorder();\n            drawPie(darkness !== 0 || borderWidth !== 0);\n            drawImages(effGhostOpacity, false);\n            darken(effGhostOpacity);\n            context.translate(-gx, -gy);\n        }\n        if (usePaths) {\n            context.translate(-pos.x, -pos.y);\n        }\n        drawUnderlay();\n        if (usePaths) {\n            context.translate(pos.x, pos.y);\n        }\n        setupShapeColor();\n        drawShape();\n        drawImages(eleOpacity, true);\n        setupBorderColor();\n        drawBorder();\n        drawPie(darkness !== 0 || borderWidth !== 0);\n        drawImages(eleOpacity, false);\n        darken();\n        if (usePaths) {\n            context.translate(-pos.x, -pos.y);\n        }\n        drawText();\n        drawOverlay(); //\n        // clean up shift\n        if (shiftToOriginWithBb) {\n            context.translate(bb.x1, bb.y1);\n        }\n    };\n    var drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n        if (![\n            \"overlay\",\n            \"underlay\"\n        ].includes(overlayOrUnderlay)) {\n            throw new Error(\"Invalid state\");\n        }\n        return function(context, node, pos, nodeWidth, nodeHeight) {\n            var r = this;\n            if (!node.visible()) {\n                return;\n            }\n            var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n            var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n            var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n            var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n            if (opacity > 0) {\n                pos = pos || node.position();\n                if (nodeWidth == null || nodeHeight == null) {\n                    var _padding = node.padding();\n                    nodeWidth = node.width() + 2 * _padding;\n                    nodeHeight = node.height() + 2 * _padding;\n                }\n                r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n                r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2);\n                context.fill();\n            }\n        };\n    };\n    CRp$5.drawNodeOverlay = drawNodeOverlayUnderlay(\"overlay\");\n    CRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay(\"underlay\"); // does the node have at least one pie piece?\n    CRp$5.hasPie = function(node) {\n        node = node[0]; // ensure ele ref\n        return node._private.hasPie;\n    };\n    CRp$5.drawPie = function(context, node, nodeOpacity, pos) {\n        node = node[0]; // ensure ele ref\n        pos = pos || node.position();\n        var cyStyle = node.cy().style();\n        var pieSize = node.pstyle(\"pie-size\");\n        var x = pos.x;\n        var y = pos.y;\n        var nodeW = node.width();\n        var nodeH = node.height();\n        var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n        var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n        var usePaths = this.usePaths();\n        if (usePaths) {\n            x = 0;\n            y = 0;\n        }\n        if (pieSize.units === \"%\") {\n            radius = radius * pieSize.pfValue;\n        } else if (pieSize.pfValue !== undefined) {\n            radius = pieSize.pfValue / 2;\n        }\n        for(var i = 1; i <= cyStyle.pieBackgroundN; i++){\n            // 1..N\n            var size = node.pstyle(\"pie-\" + i + \"-background-size\").value;\n            var color = node.pstyle(\"pie-\" + i + \"-background-color\").value;\n            var opacity = node.pstyle(\"pie-\" + i + \"-background-opacity\").value * nodeOpacity;\n            var percent = size / 100; // map integer range [0, 100] to [0, 1]\n            // percent can't push beyond 1\n            if (percent + lastPercent > 1) {\n                percent = 1 - lastPercent;\n            }\n            var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n            var angleDelta = 2 * Math.PI * percent;\n            var angleEnd = angleStart + angleDelta; // ignore if\n            // - zero size\n            // - we're already beyond the full circle\n            // - adding the current slice would go beyond the full circle\n            if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n                continue;\n            }\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.closePath();\n            this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n            context.fill();\n            lastPercent += percent;\n        }\n    };\n    var CRp$4 = {};\n    var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';\n    CRp$4.getPixelRatio = function() {\n        var context = this.data.contexts[0];\n        if (this.forcedPixelRatio != null) {\n            return this.forcedPixelRatio;\n        }\n        var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n        return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n    };\n    CRp$4.paintCache = function(context) {\n        var caches = this.paintCaches = this.paintCaches || [];\n        var needToCreateCache = true;\n        var cache;\n        for(var i = 0; i < caches.length; i++){\n            cache = caches[i];\n            if (cache.context === context) {\n                needToCreateCache = false;\n                break;\n            }\n        }\n        if (needToCreateCache) {\n            cache = {\n                context: context\n            };\n            caches.push(cache);\n        }\n        return cache;\n    };\n    CRp$4.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {\n        var gradientStyle;\n        var usePaths = this.usePaths();\n        var colors = ele.pstyle(shapeStyleName + \"-gradient-stop-colors\").value, positions = ele.pstyle(shapeStyleName + \"-gradient-stop-positions\").pfValue;\n        if (fill === \"radial-gradient\") {\n            if (ele.isEdge()) {\n                var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();\n                var d1 = dist(start, mid);\n                var d2 = dist(end, mid);\n                gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n            } else {\n                var pos = usePaths ? {\n                    x: 0,\n                    y: 0\n                } : ele.position(), width = ele.paddedWidth(), height = ele.paddedHeight();\n                gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n            }\n        } else {\n            if (ele.isEdge()) {\n                var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();\n                gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n            } else {\n                var _pos = usePaths ? {\n                    x: 0,\n                    y: 0\n                } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;\n                var direction = ele.pstyle(\"background-gradient-direction\").value;\n                switch(direction){\n                    case \"to-bottom\":\n                        gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n                        break;\n                    case \"to-top\":\n                        gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n                        break;\n                    case \"to-left\":\n                        gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n                        break;\n                    case \"to-right\":\n                        gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n                        break;\n                    case \"to-bottom-right\":\n                    case \"to-right-bottom\":\n                        gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n                        break;\n                    case \"to-top-right\":\n                    case \"to-right-top\":\n                        gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n                        break;\n                    case \"to-bottom-left\":\n                    case \"to-left-bottom\":\n                        gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n                        break;\n                    case \"to-top-left\":\n                    case \"to-left-top\":\n                        gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n                        break;\n                }\n            }\n        }\n        if (!gradientStyle) return null; // invalid gradient style\n        var hasPositions = positions.length === colors.length;\n        var length = colors.length;\n        for(var i = 0; i < length; i++){\n            gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), \"rgba(\" + colors[i][0] + \",\" + colors[i][1] + \",\" + colors[i][2] + \",\" + opacity + \")\");\n        }\n        return gradientStyle;\n    };\n    CRp$4.gradientFillStyle = function(context, ele, fill, opacity) {\n        var gradientStyle = this.createGradientStyleFor(context, \"background\", ele, fill, opacity);\n        if (!gradientStyle) return null; // error\n        context.fillStyle = gradientStyle;\n    };\n    CRp$4.colorFillStyle = function(context, r, g, b, a) {\n        context.fillStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\"; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.fillStyle !== fillStyle ){\n    //   context.fillStyle = cache.fillStyle = fillStyle;\n    // }\n    };\n    CRp$4.eleFillStyle = function(context, ele, opacity) {\n        var backgroundFill = ele.pstyle(\"background-fill\").value;\n        if (backgroundFill === \"linear-gradient\" || backgroundFill === \"radial-gradient\") {\n            this.gradientFillStyle(context, ele, backgroundFill, opacity);\n        } else {\n            var backgroundColor = ele.pstyle(\"background-color\").value;\n            this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n        }\n    };\n    CRp$4.gradientStrokeStyle = function(context, ele, fill, opacity) {\n        var gradientStyle = this.createGradientStyleFor(context, \"line\", ele, fill, opacity);\n        if (!gradientStyle) return null; // error\n        context.strokeStyle = gradientStyle;\n    };\n    CRp$4.colorStrokeStyle = function(context, r, g, b, a) {\n        context.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\"; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.strokeStyle !== strokeStyle ){\n    //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n    // }\n    };\n    CRp$4.eleStrokeStyle = function(context, ele, opacity) {\n        var lineFill = ele.pstyle(\"line-fill\").value;\n        if (lineFill === \"linear-gradient\" || lineFill === \"radial-gradient\") {\n            this.gradientStrokeStyle(context, ele, lineFill, opacity);\n        } else {\n            var lineColor = ele.pstyle(\"line-color\").value;\n            this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n        }\n    }; // Resize canvas\n    CRp$4.matchCanvasSize = function(container) {\n        var r = this;\n        var data = r.data;\n        var bb = r.findContainerClientCoords();\n        var width = bb[2];\n        var height = bb[3];\n        var pixelRatio = r.getPixelRatio();\n        var mbPxRatio = r.motionBlurPxRatio;\n        if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n            pixelRatio = mbPxRatio;\n        }\n        var canvasWidth = width * pixelRatio;\n        var canvasHeight = height * pixelRatio;\n        var canvas;\n        if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n            return; // save cycles if same\n        }\n        r.fontCaches = null; // resizing resets the style\n        var canvasContainer = data.canvasContainer;\n        canvasContainer.style.width = width + \"px\";\n        canvasContainer.style.height = height + \"px\";\n        for(var i = 0; i < r.CANVAS_LAYERS; i++){\n            canvas = data.canvases[i];\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            canvas.style.width = width + \"px\";\n            canvas.style.height = height + \"px\";\n        }\n        for(var i = 0; i < r.BUFFER_COUNT; i++){\n            canvas = data.bufferCanvases[i];\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            canvas.style.width = width + \"px\";\n            canvas.style.height = height + \"px\";\n        }\n        r.textureMult = 1;\n        if (pixelRatio <= 1) {\n            canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n            r.textureMult = 2;\n            canvas.width = canvasWidth * r.textureMult;\n            canvas.height = canvasHeight * r.textureMult;\n        }\n        r.canvasWidth = canvasWidth;\n        r.canvasHeight = canvasHeight;\n    };\n    CRp$4.renderTo = function(cxt, zoom, pan, pxRatio) {\n        this.render({\n            forcedContext: cxt,\n            forcedZoom: zoom,\n            forcedPan: pan,\n            drawAllLayers: true,\n            forcedPxRatio: pxRatio\n        });\n    };\n    CRp$4.render = function(options) {\n        options = options || staticEmptyObject();\n        var forcedContext = options.forcedContext;\n        var drawAllLayers = options.drawAllLayers;\n        var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n        var forcedZoom = options.forcedZoom;\n        var forcedPan = options.forcedPan;\n        var r = this;\n        var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n        var cy = r.cy;\n        var data = r.data;\n        var needDraw = data.canvasNeedsRedraw;\n        var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n        var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n        var mbPxRatio = r.motionBlurPxRatio;\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        var inNodeDragGesture = r.hoverData.draggingEles;\n        var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n        motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n        var motionBlurFadeEffect = motionBlur;\n        if (!forcedContext) {\n            if (r.prevPxRatio !== pixelRatio) {\n                r.invalidateContainerClientCoordsCache();\n                r.matchCanvasSize(r.container);\n                r.redrawHint(\"eles\", true);\n                r.redrawHint(\"drag\", true);\n            }\n            r.prevPxRatio = pixelRatio;\n        }\n        if (!forcedContext && r.motionBlurTimeout) {\n            clearTimeout(r.motionBlurTimeout);\n        }\n        if (motionBlur) {\n            if (r.mbFrames == null) {\n                r.mbFrames = 0;\n            }\n            r.mbFrames++;\n            if (r.mbFrames < 3) {\n                // need several frames before even high quality motionblur\n                motionBlurFadeEffect = false;\n            } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n            if (r.mbFrames > r.minMbLowQualFrames) {\n                //r.fullQualityMb = false;\n                r.motionBlurPxRatio = r.mbPxRBlurry;\n            }\n        }\n        if (r.clearingMotionBlur) {\n            r.motionBlurPxRatio = 1;\n        } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n        // because a rogue async texture frame would clear needDraw\n        if (r.textureDrawLastFrame && !textureDraw) {\n            needDraw[r.NODE] = true;\n            needDraw[r.SELECT_BOX] = true;\n        }\n        var style = cy.style();\n        var zoom = cy.zoom();\n        var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n        var pan = cy.pan();\n        var effectivePan = {\n            x: pan.x,\n            y: pan.y\n        };\n        var vp = {\n            zoom: zoom,\n            pan: {\n                x: pan.x,\n                y: pan.y\n            }\n        };\n        var prevVp = r.prevViewport;\n        var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n        if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n            r.motionBlurPxRatio = 1;\n        }\n        if (forcedPan) {\n            effectivePan = forcedPan;\n        } // apply pixel ratio\n        effectiveZoom *= pixelRatio;\n        effectivePan.x *= pixelRatio;\n        effectivePan.y *= pixelRatio;\n        var eles = r.getCachedZSortedEles();\n        function mbclear(context, x, y, w, h) {\n            var gco = context.globalCompositeOperation;\n            context.globalCompositeOperation = \"destination-out\";\n            r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n            context.fillRect(x, y, w, h);\n            context.globalCompositeOperation = gco;\n        }\n        function setContextTransform(context, clear) {\n            var ePan, eZoom, w, h;\n            if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n                ePan = {\n                    x: pan.x * mbPxRatio,\n                    y: pan.y * mbPxRatio\n                };\n                eZoom = zoom * mbPxRatio;\n                w = r.canvasWidth * mbPxRatio;\n                h = r.canvasHeight * mbPxRatio;\n            } else {\n                ePan = effectivePan;\n                eZoom = effectiveZoom;\n                w = r.canvasWidth;\n                h = r.canvasHeight;\n            }\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            if (clear === \"motionBlur\") {\n                mbclear(context, 0, 0, w, h);\n            } else if (!forcedContext && (clear === undefined || clear)) {\n                context.clearRect(0, 0, w, h);\n            }\n            if (!drawAllLayers) {\n                context.translate(ePan.x, ePan.y);\n                context.scale(eZoom, eZoom);\n            }\n            if (forcedPan) {\n                context.translate(forcedPan.x, forcedPan.y);\n            }\n            if (forcedZoom) {\n                context.scale(forcedZoom, forcedZoom);\n            }\n        }\n        if (!textureDraw) {\n            r.textureDrawLastFrame = false;\n        }\n        if (textureDraw) {\n            r.textureDrawLastFrame = true;\n            if (!r.textureCache) {\n                r.textureCache = {};\n                r.textureCache.bb = cy.mutableElements().boundingBox();\n                r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n                var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n                cxt.setTransform(1, 0, 0, 1, 0, 0);\n                cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n                r.render({\n                    forcedContext: cxt,\n                    drawOnlyNodeLayer: true,\n                    forcedPxRatio: pixelRatio * r.textureMult\n                });\n                var vp = r.textureCache.viewport = {\n                    zoom: cy.zoom(),\n                    pan: cy.pan(),\n                    width: r.canvasWidth,\n                    height: r.canvasHeight\n                };\n                vp.mpan = {\n                    x: (0 - vp.pan.x) / vp.zoom,\n                    y: (0 - vp.pan.y) / vp.zoom\n                };\n            }\n            needDraw[r.DRAG] = false;\n            needDraw[r.NODE] = false;\n            var context = data.contexts[r.NODE];\n            var texture = r.textureCache.texture;\n            var vp = r.textureCache.viewport;\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            if (motionBlur) {\n                mbclear(context, 0, 0, vp.width, vp.height);\n            } else {\n                context.clearRect(0, 0, vp.width, vp.height);\n            }\n            var outsideBgColor = style.core(\"outside-texture-bg-color\").value;\n            var outsideBgOpacity = style.core(\"outside-texture-bg-opacity\").value;\n            r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n            context.fillRect(0, 0, vp.width, vp.height);\n            var zoom = cy.zoom();\n            setContextTransform(context, false);\n            context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n            context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n        } else if (r.textureOnViewport && !forcedContext) {\n            // clear the cache since we don't need it\n            r.textureCache = null;\n        }\n        var extent = cy.extent();\n        var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n        var hideEdges = r.hideEdgesOnViewport && vpManip;\n        var needMbClear = [];\n        needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n        if (needMbClear[r.NODE]) {\n            r.clearedForMotionBlur[r.NODE] = true;\n        }\n        needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n        if (needMbClear[r.DRAG]) {\n            r.clearedForMotionBlur[r.DRAG] = true;\n        }\n        if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n            var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n            var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n            var clear = motionBlur && !useBuffer ? \"motionBlur\" : undefined;\n            setContextTransform(context, clear);\n            if (hideEdges) {\n                r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n            } else {\n                r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n            }\n            if (r.debug) {\n                r.drawDebugPoints(context, eles.nondrag);\n            }\n            if (!drawAllLayers && !motionBlur) {\n                needDraw[r.NODE] = false;\n            }\n        }\n        if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n            var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n            var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n            setContextTransform(context, motionBlur && !useBuffer ? \"motionBlur\" : undefined);\n            if (hideEdges) {\n                r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n            } else {\n                r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n            }\n            if (r.debug) {\n                r.drawDebugPoints(context, eles.drag);\n            }\n            if (!drawAllLayers && !motionBlur) {\n                needDraw[r.DRAG] = false;\n            }\n        }\n        if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n            var context = forcedContext || data.contexts[r.SELECT_BOX];\n            setContextTransform(context);\n            if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n                var zoom = r.cy.zoom();\n                var borderWidth = style.core(\"selection-box-border-width\").value / zoom;\n                context.lineWidth = borderWidth;\n                context.fillStyle = \"rgba(\" + style.core(\"selection-box-color\").value[0] + \",\" + style.core(\"selection-box-color\").value[1] + \",\" + style.core(\"selection-box-color\").value[2] + \",\" + style.core(\"selection-box-opacity\").value + \")\";\n                context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n                if (borderWidth > 0) {\n                    context.strokeStyle = \"rgba(\" + style.core(\"selection-box-border-color\").value[0] + \",\" + style.core(\"selection-box-border-color\").value[1] + \",\" + style.core(\"selection-box-border-color\").value[2] + \",\" + style.core(\"selection-box-opacity\").value + \")\";\n                    context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n                }\n            }\n            if (data.bgActivePosistion && !r.hoverData.selecting) {\n                var zoom = r.cy.zoom();\n                var pos = data.bgActivePosistion;\n                context.fillStyle = \"rgba(\" + style.core(\"active-bg-color\").value[0] + \",\" + style.core(\"active-bg-color\").value[1] + \",\" + style.core(\"active-bg-color\").value[2] + \",\" + style.core(\"active-bg-opacity\").value + \")\";\n                context.beginPath();\n                context.arc(pos.x, pos.y, style.core(\"active-bg-size\").pfValue / zoom, 0, 2 * Math.PI);\n                context.fill();\n            }\n            var timeToRender = r.lastRedrawTime;\n            if (r.showFps && timeToRender) {\n                timeToRender = Math.round(timeToRender);\n                var fps = Math.round(1000 / timeToRender);\n                context.setTransform(1, 0, 0, 1, 0, 0);\n                context.fillStyle = \"rgba(255, 0, 0, 0.75)\";\n                context.strokeStyle = \"rgba(255, 0, 0, 0.75)\";\n                context.lineWidth = 1;\n                context.fillText(\"1 frame = \" + timeToRender + \" ms = \" + fps + \" fps\", 0, 20);\n                var maxFps = 60;\n                context.strokeRect(0, 30, 250, 20);\n                context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n            }\n            if (!drawAllLayers) {\n                needDraw[r.SELECT_BOX] = false;\n            }\n        } // motionblur: blit rendered blurry frames\n        if (motionBlur && mbPxRatio !== 1) {\n            var cxtNode = data.contexts[r.NODE];\n            var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n            var cxtDrag = data.contexts[r.DRAG];\n            var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n            var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n                cxt.setTransform(1, 0, 0, 1, 0, 0);\n                if (needClear || !motionBlurFadeEffect) {\n                    cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n                } else {\n                    mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n                }\n                var pxr = mbPxRatio;\n                cxt.drawImage(txt, 0, 0, r.canvasWidth * pxr, r.canvasHeight * pxr, 0, 0, r.canvasWidth, r.canvasHeight // w, h\n                );\n            };\n            if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n                drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n                needDraw[r.NODE] = false;\n            }\n            if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n                drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n                needDraw[r.DRAG] = false;\n            }\n        }\n        r.prevViewport = vp;\n        if (r.clearingMotionBlur) {\n            r.clearingMotionBlur = false;\n            r.motionBlurCleared = true;\n            r.motionBlur = true;\n        }\n        if (motionBlur) {\n            r.motionBlurTimeout = setTimeout(function() {\n                r.motionBlurTimeout = null;\n                r.clearedForMotionBlur[r.NODE] = false;\n                r.clearedForMotionBlur[r.DRAG] = false;\n                r.motionBlur = false;\n                r.clearingMotionBlur = !textureDraw;\n                r.mbFrames = 0;\n                needDraw[r.NODE] = true;\n                needDraw[r.DRAG] = true;\n                r.redraw();\n            }, motionBlurDelay);\n        }\n        if (!forcedContext) {\n            cy.emit(\"render\");\n        }\n    };\n    var CRp$3 = {}; // @O Polygon drawing\n    CRp$3.drawPolygonPath = function(context, x, y, width, height, points) {\n        var halfW = width / 2;\n        var halfH = height / 2;\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n        for(var i = 1; i < points.length / 2; i++){\n            context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n        }\n        context.closePath();\n    };\n    CRp$3.drawRoundPolygonPath = function(context, x, y, width, height, points) {\n        var halfW = width / 2;\n        var halfH = height / 2;\n        var cornerRadius = getRoundPolygonRadius(width, height);\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        for(var _i = 0; _i < points.length / 4; _i++){\n            var sourceUv = void 0, destUv = void 0;\n            if (_i === 0) {\n                sourceUv = points.length - 2;\n            } else {\n                sourceUv = _i * 4 - 2;\n            }\n            destUv = _i * 4 + 2;\n            var px = x + halfW * points[_i * 4];\n            var py = y + halfH * points[_i * 4 + 1];\n            var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];\n            var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n            var cp0x = px - offset * points[sourceUv];\n            var cp0y = py - offset * points[sourceUv + 1];\n            var cp1x = px + offset * points[destUv];\n            var cp1y = py + offset * points[destUv + 1];\n            if (_i === 0) {\n                context.moveTo(cp0x, cp0y);\n            } else {\n                context.lineTo(cp0x, cp0y);\n            }\n            context.arcTo(px, py, cp1x, cp1y, cornerRadius);\n        }\n        context.closePath();\n    }; // Round rectangle drawing\n    CRp$3.drawRoundRectanglePath = function(context, x, y, width, height) {\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        if (context.beginPath) {\n            context.beginPath();\n        } // Start at top middle\n        context.moveTo(x, y - halfHeight); // Arc from middle top to right side\n        context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom\n        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side\n        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder\n        context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line\n        context.lineTo(x, y - halfHeight);\n        context.closePath();\n    };\n    CRp$3.drawBottomRoundRectanglePath = function(context, x, y, width, height) {\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        if (context.beginPath) {\n            context.beginPath();\n        } // Start at top middle\n        context.moveTo(x, y - halfHeight);\n        context.lineTo(x + halfWidth, y - halfHeight);\n        context.lineTo(x + halfWidth, y);\n        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n        context.lineTo(x - halfWidth, y - halfHeight);\n        context.lineTo(x, y - halfHeight);\n        context.closePath();\n    };\n    CRp$3.drawCutRectanglePath = function(context, x, y, width, height) {\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var cornerLength = getCutRectangleCornerLength();\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n        context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n        context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n        context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n        context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n        context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n        context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n        context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n        context.closePath();\n    };\n    CRp$3.drawBarrelPath = function(context, x, y, width, height) {\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var xBegin = x - halfWidth;\n        var xEnd = x + halfWidth;\n        var yBegin = y - halfHeight;\n        var yEnd = y + halfHeight;\n        var barrelCurveConstants = getBarrelCurveConstants(width, height);\n        var wOffset = barrelCurveConstants.widthOffset;\n        var hOffset = barrelCurveConstants.heightOffset;\n        var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(xBegin, yBegin + hOffset);\n        context.lineTo(xBegin, yEnd - hOffset);\n        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n        context.lineTo(xEnd - wOffset, yEnd);\n        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n        context.lineTo(xEnd, yBegin + hOffset);\n        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n        context.lineTo(xBegin + wOffset, yBegin);\n        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n        context.closePath();\n    };\n    var sin0 = Math.sin(0);\n    var cos0 = Math.cos(0);\n    var sin = {};\n    var cos = {};\n    var ellipseStepSize = Math.PI / 40;\n    for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n        sin[i] = Math.sin(i);\n        cos[i] = Math.cos(i);\n    }\n    CRp$3.drawEllipsePath = function(context, centerX, centerY, width, height) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        if (context.ellipse) {\n            context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n        } else {\n            var xPos, yPos;\n            var rw = width / 2;\n            var rh = height / 2;\n            for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n                xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n                yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n                if (i === 0) {\n                    context.moveTo(xPos, yPos);\n                } else {\n                    context.lineTo(xPos, yPos);\n                }\n            }\n        }\n        context.closePath();\n    };\n    /* global atob, ArrayBuffer, Uint8Array, Blob */ var CRp$2 = {};\n    CRp$2.createBuffer = function(w, h) {\n        var buffer = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n        buffer.width = w;\n        buffer.height = h;\n        return [\n            buffer,\n            buffer.getContext(\"2d\")\n        ];\n    };\n    CRp$2.bufferCanvasImage = function(options) {\n        var cy = this.cy;\n        var eles = cy.mutableElements();\n        var bb = eles.boundingBox();\n        var ctrRect = this.findContainerClientCoords();\n        var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n        var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n        var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n        var pxRatio = this.getPixelRatio();\n        var scale = 1;\n        if (options.scale !== undefined) {\n            width *= options.scale;\n            height *= options.scale;\n            scale = options.scale;\n        } else if (specdMaxDims) {\n            var maxScaleW = Infinity;\n            var maxScaleH = Infinity;\n            if (number$1(options.maxWidth)) {\n                maxScaleW = scale * options.maxWidth / width;\n            }\n            if (number$1(options.maxHeight)) {\n                maxScaleH = scale * options.maxHeight / height;\n            }\n            scale = Math.min(maxScaleW, maxScaleH);\n            width *= scale;\n            height *= scale;\n        }\n        if (!specdMaxDims) {\n            width *= pxRatio;\n            height *= pxRatio;\n            scale *= pxRatio;\n        }\n        var buffCanvas = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n        buffCanvas.width = width;\n        buffCanvas.height = height;\n        buffCanvas.style.width = width + \"px\";\n        buffCanvas.style.height = height + \"px\";\n        var buffCxt = buffCanvas.getContext(\"2d\"); // Rasterize the layers, but only if container has nonzero size\n        if (width > 0 && height > 0) {\n            buffCxt.clearRect(0, 0, width, height);\n            buffCxt.globalCompositeOperation = \"source-over\";\n            var zsortedEles = this.getCachedZSortedEles();\n            if (options.full) {\n                // draw the full bounds of the graph\n                buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n                buffCxt.scale(scale, scale);\n                this.drawElements(buffCxt, zsortedEles);\n                buffCxt.scale(1 / scale, 1 / scale);\n                buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n            } else {\n                // draw the current view\n                var pan = cy.pan();\n                var translation = {\n                    x: pan.x * scale,\n                    y: pan.y * scale\n                };\n                scale *= cy.zoom();\n                buffCxt.translate(translation.x, translation.y);\n                buffCxt.scale(scale, scale);\n                this.drawElements(buffCxt, zsortedEles);\n                buffCxt.scale(1 / scale, 1 / scale);\n                buffCxt.translate(-translation.x, -translation.y);\n            } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n            if (options.bg) {\n                buffCxt.globalCompositeOperation = \"destination-over\";\n                buffCxt.fillStyle = options.bg;\n                buffCxt.rect(0, 0, width, height);\n                buffCxt.fill();\n            }\n        }\n        return buffCanvas;\n    };\n    function b64ToBlob(b64, mimeType) {\n        var bytes = atob(b64);\n        var buff = new ArrayBuffer(bytes.length);\n        var buffUint8 = new Uint8Array(buff);\n        for(var i = 0; i < bytes.length; i++){\n            buffUint8[i] = bytes.charCodeAt(i);\n        }\n        return new Blob([\n            buff\n        ], {\n            type: mimeType\n        });\n    }\n    function b64UriToB64(b64uri) {\n        var i = b64uri.indexOf(\",\");\n        return b64uri.substr(i + 1);\n    }\n    function output(options, canvas, mimeType) {\n        var getB64Uri = function getB64Uri() {\n            return canvas.toDataURL(mimeType, options.quality);\n        };\n        switch(options.output){\n            case \"blob-promise\":\n                return new Promise$1(function(resolve, reject) {\n                    try {\n                        canvas.toBlob(function(blob) {\n                            if (blob != null) {\n                                resolve(blob);\n                            } else {\n                                reject(new Error(\"`canvas.toBlob()` sent a null value in its callback\"));\n                            }\n                        }, mimeType, options.quality);\n                    } catch (err) {\n                        reject(err);\n                    }\n                });\n            case \"blob\":\n                return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n            case \"base64\":\n                return b64UriToB64(getB64Uri());\n            case \"base64uri\":\n            default:\n                return getB64Uri();\n        }\n    }\n    CRp$2.png = function(options) {\n        return output(options, this.bufferCanvasImage(options), \"image/png\");\n    };\n    CRp$2.jpg = function(options) {\n        return output(options, this.bufferCanvasImage(options), \"image/jpeg\");\n    };\n    var CRp$1 = {};\n    CRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width, height, points) {\n        switch(name){\n            case \"ellipse\":\n                return this.drawEllipsePath(context, centerX, centerY, width, height);\n            case \"polygon\":\n                return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n            case \"round-polygon\":\n                return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);\n            case \"roundrectangle\":\n            case \"round-rectangle\":\n                return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n            case \"cutrectangle\":\n            case \"cut-rectangle\":\n                return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n            case \"bottomroundrectangle\":\n            case \"bottom-round-rectangle\":\n                return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n            case \"barrel\":\n                return this.drawBarrelPath(context, centerX, centerY, width, height);\n        }\n    };\n    var CR = CanvasRenderer;\n    var CRp = CanvasRenderer.prototype;\n    CRp.CANVAS_LAYERS = 3; //\n    CRp.SELECT_BOX = 0;\n    CRp.DRAG = 1;\n    CRp.NODE = 2;\n    CRp.BUFFER_COUNT = 3; //\n    CRp.TEXTURE_BUFFER = 0;\n    CRp.MOTIONBLUR_BUFFER_NODE = 1;\n    CRp.MOTIONBLUR_BUFFER_DRAG = 2;\n    function CanvasRenderer(options) {\n        var r = this;\n        r.data = {\n            canvases: new Array(CRp.CANVAS_LAYERS),\n            contexts: new Array(CRp.CANVAS_LAYERS),\n            canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n            bufferCanvases: new Array(CRp.BUFFER_COUNT),\n            bufferContexts: new Array(CRp.CANVAS_LAYERS)\n        };\n        var tapHlOffAttr = \"-webkit-tap-highlight-color\";\n        var tapHlOffStyle = \"rgba(0,0,0,0)\";\n        r.data.canvasContainer = document.createElement(\"div\"); // eslint-disable-line no-undef\n        var containerStyle = r.data.canvasContainer.style;\n        r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n        containerStyle.position = \"relative\";\n        containerStyle.zIndex = \"0\";\n        containerStyle.overflow = \"hidden\";\n        var container = options.cy.container();\n        container.appendChild(r.data.canvasContainer);\n        container.style[tapHlOffAttr] = tapHlOffStyle;\n        var styleMap = {\n            \"-webkit-user-select\": \"none\",\n            \"-moz-user-select\": \"-moz-none\",\n            \"user-select\": \"none\",\n            \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n            \"outline-style\": \"none\"\n        };\n        if (ms()) {\n            styleMap[\"-ms-touch-action\"] = \"none\";\n            styleMap[\"touch-action\"] = \"none\";\n        }\n        for(var i = 0; i < CRp.CANVAS_LAYERS; i++){\n            var canvas = r.data.canvases[i] = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n            r.data.contexts[i] = canvas.getContext(\"2d\");\n            Object.keys(styleMap).forEach(function(k) {\n                canvas.style[k] = styleMap[k];\n            });\n            canvas.style.position = \"absolute\";\n            canvas.setAttribute(\"data-id\", \"layer\" + i);\n            canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n            r.data.canvasContainer.appendChild(canvas);\n            r.data.canvasNeedsRedraw[i] = false;\n        }\n        r.data.topCanvas = r.data.canvases[0];\n        r.data.canvases[CRp.NODE].setAttribute(\"data-id\", \"layer\" + CRp.NODE + \"-node\");\n        r.data.canvases[CRp.SELECT_BOX].setAttribute(\"data-id\", \"layer\" + CRp.SELECT_BOX + \"-selectbox\");\n        r.data.canvases[CRp.DRAG].setAttribute(\"data-id\", \"layer\" + CRp.DRAG + \"-drag\");\n        for(var i = 0; i < CRp.BUFFER_COUNT; i++){\n            r.data.bufferCanvases[i] = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n            r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext(\"2d\");\n            r.data.bufferCanvases[i].style.position = \"absolute\";\n            r.data.bufferCanvases[i].setAttribute(\"data-id\", \"buffer\" + i);\n            r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n            r.data.bufferCanvases[i].style.visibility = \"hidden\"; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n        }\n        r.pathsEnabled = true;\n        var emptyBb = makeBoundingBox();\n        var getBoxCenter = function getBoxCenter(bb) {\n            return {\n                x: (bb.x1 + bb.x2) / 2,\n                y: (bb.y1 + bb.y2) / 2\n            };\n        };\n        var getCenterOffset = function getCenterOffset(bb) {\n            return {\n                x: -bb.w / 2,\n                y: -bb.h / 2\n            };\n        };\n        var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n            var _p = ele[0]._private;\n            var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n            return !same;\n        };\n        var getStyleKey = function getStyleKey(ele) {\n            return ele[0]._private.nodeKey;\n        };\n        var getLabelKey = function getLabelKey(ele) {\n            return ele[0]._private.labelStyleKey;\n        };\n        var getSourceLabelKey = function getSourceLabelKey(ele) {\n            return ele[0]._private.sourceLabelStyleKey;\n        };\n        var getTargetLabelKey = function getTargetLabelKey(ele) {\n            return ele[0]._private.targetLabelStyleKey;\n        };\n        var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n            return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n        };\n        var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n            return r.drawElementText(context, ele, bb, scaledLabelShown, \"main\", useEleOpacity);\n        };\n        var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n            return r.drawElementText(context, ele, bb, scaledLabelShown, \"source\", useEleOpacity);\n        };\n        var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n            return r.drawElementText(context, ele, bb, scaledLabelShown, \"target\", useEleOpacity);\n        };\n        var getElementBox = function getElementBox(ele) {\n            ele.boundingBox();\n            return ele[0]._private.bodyBounds;\n        };\n        var getLabelBox = function getLabelBox(ele) {\n            ele.boundingBox();\n            return ele[0]._private.labelBounds.main || emptyBb;\n        };\n        var getSourceLabelBox = function getSourceLabelBox(ele) {\n            ele.boundingBox();\n            return ele[0]._private.labelBounds.source || emptyBb;\n        };\n        var getTargetLabelBox = function getTargetLabelBox(ele) {\n            ele.boundingBox();\n            return ele[0]._private.labelBounds.target || emptyBb;\n        };\n        var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n            return scaledLabelShown;\n        };\n        var getElementRotationPoint = function getElementRotationPoint(ele) {\n            return getBoxCenter(getElementBox(ele));\n        };\n        var addTextMargin = function addTextMargin(prefix, pt, ele) {\n            var pre = prefix ? prefix + \"-\" : \"\";\n            return {\n                x: pt.x + ele.pstyle(pre + \"text-margin-x\").pfValue,\n                y: pt.y + ele.pstyle(pre + \"text-margin-y\").pfValue\n            };\n        };\n        var getRsPt = function getRsPt(ele, x, y) {\n            var rs = ele[0]._private.rscratch;\n            return {\n                x: rs[x],\n                y: rs[y]\n            };\n        };\n        var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n            return addTextMargin(\"\", getRsPt(ele, \"labelX\", \"labelY\"), ele);\n        };\n        var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n            return addTextMargin(\"source\", getRsPt(ele, \"sourceLabelX\", \"sourceLabelY\"), ele);\n        };\n        var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n            return addTextMargin(\"target\", getRsPt(ele, \"targetLabelX\", \"targetLabelY\"), ele);\n        };\n        var getElementRotationOffset = function getElementRotationOffset(ele) {\n            return getCenterOffset(getElementBox(ele));\n        };\n        var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n            return getCenterOffset(getSourceLabelBox(ele));\n        };\n        var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n            return getCenterOffset(getTargetLabelBox(ele));\n        };\n        var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n            var bb = getLabelBox(ele);\n            var p = getCenterOffset(getLabelBox(ele));\n            if (ele.isNode()) {\n                switch(ele.pstyle(\"text-halign\").value){\n                    case \"left\":\n                        p.x = -bb.w;\n                        break;\n                    case \"right\":\n                        p.x = 0;\n                        break;\n                }\n                switch(ele.pstyle(\"text-valign\").value){\n                    case \"top\":\n                        p.y = -bb.h;\n                        break;\n                    case \"bottom\":\n                        p.y = 0;\n                        break;\n                }\n            }\n            return p;\n        };\n        var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n            getKey: getStyleKey,\n            doesEleInvalidateKey: backgroundTimestampHasChanged,\n            drawElement: drawElement,\n            getBoundingBox: getElementBox,\n            getRotationPoint: getElementRotationPoint,\n            getRotationOffset: getElementRotationOffset,\n            allowEdgeTxrCaching: false,\n            allowParentTxrCaching: false\n        });\n        var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n            getKey: getLabelKey,\n            drawElement: drawLabel,\n            getBoundingBox: getLabelBox,\n            getRotationPoint: getLabelRotationPoint,\n            getRotationOffset: getLabelRotationOffset,\n            isVisible: isLabelVisibleAtScale\n        });\n        var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n            getKey: getSourceLabelKey,\n            drawElement: drawSourceLabel,\n            getBoundingBox: getSourceLabelBox,\n            getRotationPoint: getSourceLabelRotationPoint,\n            getRotationOffset: getSourceLabelRotationOffset,\n            isVisible: isLabelVisibleAtScale\n        });\n        var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n            getKey: getTargetLabelKey,\n            drawElement: drawTargetLabel,\n            getBoundingBox: getTargetLabelBox,\n            getRotationPoint: getTargetLabelRotationPoint,\n            getRotationOffset: getTargetLabelRotationOffset,\n            isVisible: isLabelVisibleAtScale\n        });\n        var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n        r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n            // each cache should check for sub-key diff to see that the update affects that cache particularly\n            eleTxrCache.invalidateElements(eles);\n            lblTxrCache.invalidateElements(eles);\n            slbTxrCache.invalidateElements(eles);\n            tlbTxrCache.invalidateElements(eles); // any change invalidates the layers\n            lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches\n            for(var _i = 0; _i < eles.length; _i++){\n                var _p = eles[_i]._private;\n                _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n            }\n        });\n        var refineInLayers = function refineInLayers(reqs) {\n            for(var i = 0; i < reqs.length; i++){\n                lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n            }\n        };\n        eleTxrCache.onDequeue(refineInLayers);\n        lblTxrCache.onDequeue(refineInLayers);\n        slbTxrCache.onDequeue(refineInLayers);\n        tlbTxrCache.onDequeue(refineInLayers);\n    }\n    CRp.redrawHint = function(group, bool) {\n        var r = this;\n        switch(group){\n            case \"eles\":\n                r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n                break;\n            case \"drag\":\n                r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n                break;\n            case \"select\":\n                r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n                break;\n        }\n    }; // whether to use Path2D caching for drawing\n    var pathsImpld = typeof Path2D !== \"undefined\";\n    CRp.path2dEnabled = function(on) {\n        if (on === undefined) {\n            return this.pathsEnabled;\n        }\n        this.pathsEnabled = on ? true : false;\n    };\n    CRp.usePaths = function() {\n        return pathsImpld && this.pathsEnabled;\n    };\n    CRp.setImgSmoothing = function(context, bool) {\n        if (context.imageSmoothingEnabled != null) {\n            context.imageSmoothingEnabled = bool;\n        } else {\n            context.webkitImageSmoothingEnabled = bool;\n            context.mozImageSmoothingEnabled = bool;\n            context.msImageSmoothingEnabled = bool;\n        }\n    };\n    CRp.getImgSmoothing = function(context) {\n        if (context.imageSmoothingEnabled != null) {\n            return context.imageSmoothingEnabled;\n        } else {\n            return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n        }\n    };\n    CRp.makeOffscreenCanvas = function(width, height) {\n        var canvas;\n        if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== \"undefined\") {\n            canvas = new OffscreenCanvas(width, height);\n        } else {\n            canvas = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n            canvas.width = width;\n            canvas.height = height;\n        }\n        return canvas;\n    };\n    [\n        CRp$a,\n        CRp$9,\n        CRp$8,\n        CRp$7,\n        CRp$6,\n        CRp$5,\n        CRp$4,\n        CRp$3,\n        CRp$2,\n        CRp$1\n    ].forEach(function(props) {\n        extend(CRp, props);\n    });\n    var renderer = [\n        {\n            name: \"null\",\n            impl: NullRenderer\n        },\n        {\n            name: \"base\",\n            impl: BR\n        },\n        {\n            name: \"canvas\",\n            impl: CR\n        }\n    ];\n    var incExts = [\n        {\n            type: \"layout\",\n            extensions: layout\n        },\n        {\n            type: \"renderer\",\n            extensions: renderer\n        }\n    ];\n    var extensions = {}; // registered modules for extensions, indexed by name\n    var modules = {};\n    function setExtension(type, name, registrant) {\n        var ext = registrant;\n        var overrideErr = function overrideErr(field) {\n            warn(\"Can not register `\" + name + \"` for `\" + type + \"` since `\" + field + \"` already exists in the prototype and can not be overridden\");\n        };\n        if (type === \"core\") {\n            if (Core.prototype[name]) {\n                return overrideErr(name);\n            } else {\n                Core.prototype[name] = registrant;\n            }\n        } else if (type === \"collection\") {\n            if (Collection.prototype[name]) {\n                return overrideErr(name);\n            } else {\n                Collection.prototype[name] = registrant;\n            }\n        } else if (type === \"layout\") {\n            // fill in missing layout functions in the prototype\n            var Layout = function Layout(options) {\n                this.options = options;\n                registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()\n                if (!plainObject(this._private)) {\n                    this._private = {};\n                }\n                this._private.cy = options.cy;\n                this._private.listeners = [];\n                this.createEmitter();\n            };\n            var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n            var optLayoutFns = [];\n            for(var i = 0; i < optLayoutFns.length; i++){\n                var fnName = optLayoutFns[i];\n                layoutProto[fnName] = layoutProto[fnName] || function() {\n                    return this;\n                };\n            } // either .start() or .run() is defined, so autogen the other\n            if (layoutProto.start && !layoutProto.run) {\n                layoutProto.run = function() {\n                    this.start();\n                    return this;\n                };\n            } else if (!layoutProto.start && layoutProto.run) {\n                layoutProto.start = function() {\n                    this.run();\n                    return this;\n                };\n            }\n            var regStop = registrant.prototype.stop;\n            layoutProto.stop = function() {\n                var opts = this.options;\n                if (opts && opts.animate) {\n                    var anis = this.animations;\n                    if (anis) {\n                        for(var _i = 0; _i < anis.length; _i++){\n                            anis[_i].stop();\n                        }\n                    }\n                }\n                if (regStop) {\n                    regStop.call(this);\n                } else {\n                    this.emit(\"layoutstop\");\n                }\n                return this;\n            };\n            if (!layoutProto.destroy) {\n                layoutProto.destroy = function() {\n                    return this;\n                };\n            }\n            layoutProto.cy = function() {\n                return this._private.cy;\n            };\n            var getCy = function getCy(layout) {\n                return layout._private.cy;\n            };\n            var emitterOpts = {\n                addEventFields: function addEventFields(layout, evt) {\n                    evt.layout = layout;\n                    evt.cy = getCy(layout);\n                    evt.target = layout;\n                },\n                bubble: function bubble() {\n                    return true;\n                },\n                parent: function parent(layout) {\n                    return getCy(layout);\n                }\n            };\n            extend(layoutProto, {\n                createEmitter: function createEmitter() {\n                    this._private.emitter = new Emitter(emitterOpts, this);\n                    return this;\n                },\n                emitter: function emitter() {\n                    return this._private.emitter;\n                },\n                on: function on(evt, cb) {\n                    this.emitter().on(evt, cb);\n                    return this;\n                },\n                one: function one(evt, cb) {\n                    this.emitter().one(evt, cb);\n                    return this;\n                },\n                once: function once(evt, cb) {\n                    this.emitter().one(evt, cb);\n                    return this;\n                },\n                removeListener: function removeListener(evt, cb) {\n                    this.emitter().removeListener(evt, cb);\n                    return this;\n                },\n                removeAllListeners: function removeAllListeners() {\n                    this.emitter().removeAllListeners();\n                    return this;\n                },\n                emit: function emit(evt, params) {\n                    this.emitter().emit(evt, params);\n                    return this;\n                }\n            });\n            define1.eventAliasesOn(layoutProto);\n            ext = Layout; // replace with our wrapped layout\n        } else if (type === \"renderer\" && name !== \"null\" && name !== \"base\") {\n            // user registered renderers inherit from base\n            var BaseRenderer = getExtension(\"renderer\", \"base\");\n            var bProto = BaseRenderer.prototype;\n            var RegistrantRenderer = registrant;\n            var rProto = registrant.prototype;\n            var Renderer = function Renderer() {\n                BaseRenderer.apply(this, arguments);\n                RegistrantRenderer.apply(this, arguments);\n            };\n            var proto = Renderer.prototype;\n            for(var pName in bProto){\n                var pVal = bProto[pName];\n                var existsInR = rProto[pName] != null;\n                if (existsInR) {\n                    return overrideErr(pName);\n                }\n                proto[pName] = pVal; // take impl from base\n            }\n            for(var _pName in rProto){\n                proto[_pName] = rProto[_pName]; // take impl from registrant\n            }\n            bProto.clientFunctions.forEach(function(name) {\n                proto[name] = proto[name] || function() {\n                    error(\"Renderer does not implement `renderer.\" + name + \"()` on its prototype\");\n                };\n            });\n            ext = Renderer;\n        } else if (type === \"__proto__\" || type === \"constructor\" || type === \"prototype\") {\n            // to avoid potential prototype pollution\n            return error(type + \" is an illegal type to be registered, possibly lead to prototype pollutions\");\n        }\n        return setMap({\n            map: extensions,\n            keys: [\n                type,\n                name\n            ],\n            value: ext\n        });\n    }\n    function getExtension(type, name) {\n        return getMap({\n            map: extensions,\n            keys: [\n                type,\n                name\n            ]\n        });\n    }\n    function setModule(type, name, moduleType, moduleName, registrant) {\n        return setMap({\n            map: modules,\n            keys: [\n                type,\n                name,\n                moduleType,\n                moduleName\n            ],\n            value: registrant\n        });\n    }\n    function getModule(type, name, moduleType, moduleName) {\n        return getMap({\n            map: modules,\n            keys: [\n                type,\n                name,\n                moduleType,\n                moduleName\n            ]\n        });\n    }\n    var extension = function extension() {\n        // e.g. extension('renderer', 'svg')\n        if (arguments.length === 2) {\n            return getExtension.apply(null, arguments);\n        } else if (arguments.length === 3) {\n            return setExtension.apply(null, arguments);\n        } else if (arguments.length === 4) {\n            return getModule.apply(null, arguments);\n        } else if (arguments.length === 5) {\n            return setModule.apply(null, arguments);\n        } else {\n            error(\"Invalid extension access syntax\");\n        }\n    }; // allows a core instance to access extensions internally\n    Core.prototype.extension = extension; // included extensions\n    incExts.forEach(function(group) {\n        group.extensions.forEach(function(ext) {\n            setExtension(group.type, ext.name, ext.impl);\n        });\n    });\n    // (useful for init)\n    var Stylesheet = function Stylesheet() {\n        if (!(this instanceof Stylesheet)) {\n            return new Stylesheet();\n        }\n        this.length = 0;\n    };\n    var sheetfn = Stylesheet.prototype;\n    sheetfn.instanceString = function() {\n        return \"stylesheet\";\n    }; // just store the selector to be parsed later\n    sheetfn.selector = function(selector) {\n        var i = this.length++;\n        this[i] = {\n            selector: selector,\n            properties: []\n        };\n        return this; // chaining\n    }; // just store the property to be parsed later\n    sheetfn.css = function(name, value) {\n        var i = this.length - 1;\n        if (string(name)) {\n            this[i].properties.push({\n                name: name,\n                value: value\n            });\n        } else if (plainObject(name)) {\n            var map = name;\n            var propNames = Object.keys(map);\n            for(var j = 0; j < propNames.length; j++){\n                var key = propNames[j];\n                var mapVal = map[key];\n                if (mapVal == null) {\n                    continue;\n                }\n                var prop = Style.properties[key] || Style.properties[dash2camel(key)];\n                if (prop == null) {\n                    continue;\n                }\n                var _name = prop.name;\n                var _value = mapVal;\n                this[i].properties.push({\n                    name: _name,\n                    value: _value\n                });\n            }\n        }\n        return this; // chaining\n    };\n    sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet\n    sheetfn.generateStyle = function(cy) {\n        var style = new Style(cy);\n        return this.appendToStyle(style);\n    }; // append a dummy stylesheet object on a real style object\n    sheetfn.appendToStyle = function(style) {\n        for(var i = 0; i < this.length; i++){\n            var context = this[i];\n            var selector = context.selector;\n            var props = context.properties;\n            style.selector(selector); // apply selector\n            for(var j = 0; j < props.length; j++){\n                var prop = props[j];\n                style.css(prop.name, prop.value); // apply property\n            }\n        }\n        return style;\n    };\n    var version = \"3.24.0\";\n    var cytoscape = function cytoscape(options) {\n        // if no options specified, use default\n        if (options === undefined) {\n            options = {};\n        } // create instance\n        if (plainObject(options)) {\n            return new Core(options);\n        } else if (string(options)) {\n            return extension.apply(extension, arguments);\n        }\n    }; // e.g. cytoscape.use( require('cytoscape-foo'), bar )\n    cytoscape.use = function(ext) {\n        var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n        args.unshift(cytoscape); // cytoscape is first arg to ext\n        ext.apply(null, args);\n        return this;\n    };\n    cytoscape.warnings = function(bool) {\n        return warnings(bool);\n    }; // replaced by build system\n    cytoscape.version = version; // expose public apis (mostly for extensions)\n    cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n    return cytoscape;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLnVtZC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUEsVUFBVUEsT0FBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNFLE9BQU9ELE9BQU8sR0FBR0QsWUFDaEYsQ0FDdUc7QUFDekcsR0FBRyxRQUFPO0lBQWM7SUFFdEIsU0FBU1EsUUFBUUMsR0FBRztRQUNsQjtRQUVBLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLEdBQUc7WUFDaEcsT0FBTyxPQUFPQTtRQUNoQixJQUFJLFNBQVVBLEdBQUc7WUFDZixPQUFPQSxPQUFPLGNBQWMsT0FBT0MsVUFBVUQsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtRQUMxSCxHQUFHRCxRQUFRQztJQUNiO0lBRUEsU0FBU0ssZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7UUFDNUMsSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtZQUN0QyxNQUFNLElBQUlDLFVBQVU7UUFDdEI7SUFDRjtJQUVBLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO1FBQ3RDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7WUFDckMsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1lBQ3pCRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtZQUNqREQsV0FBV0UsWUFBWSxHQUFHO1lBQzFCLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1lBQ2pEQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47UUFDaEQ7SUFDRjtJQUVBLFNBQVNPLGFBQWFkLFdBQVcsRUFBRWUsVUFBVSxFQUFFQyxXQUFX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RyxHQUFHLEdBQUcsU0FBVXM4QyxHQUFHO1FBQzNCLElBQUl0bUosT0FBT3pFLE1BQU01QixTQUFTLENBQUM4QyxLQUFLLENBQUNWLElBQUksQ0FBQ2dFLFdBQVcsSUFBSSxzQkFBc0I7UUFFM0VDLEtBQUswZSxPQUFPLENBQUNybEIsWUFBWSxnQ0FBZ0M7UUFFekRpdEosSUFBSWptSixLQUFLLENBQUMsTUFBTUw7UUFDaEIsT0FBTyxJQUFJO0lBQ2I7SUFFQTNHLFVBQVV1ZCxRQUFRLEdBQUcsU0FBVTBvRSxJQUFJO1FBQ2pDLE9BQU8xb0UsU0FBUzBvRTtJQUNsQixHQUFHLDJCQUEyQjtJQUc5QmptRixVQUFVd3VKLE9BQU8sR0FBR0EsU0FBUyw2Q0FBNkM7SUFFMUV4dUosVUFBVXlGLFVBQVUsR0FBR3pGLFVBQVVzdUosVUFBVSxHQUFHQTtJQUU5QyxPQUFPdHVKO0FBRVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Y2hhdC8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUudW1kLmpzP2ZlN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMywgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmN5dG9zY2FwZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH0sIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQxKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuXG4gICAgdmFyIF9zLCBfZTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgd2luZG93JDEgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICB2YXIgbmF2aWdhdG9yID0gd2luZG93JDEgPyB3aW5kb3ckMS5uYXZpZ2F0b3IgOiBudWxsO1xuICB3aW5kb3ckMSA/IHdpbmRvdyQxLmRvY3VtZW50IDogbnVsbDtcblxuICB2YXIgdHlwZW9mc3RyID0gX3R5cGVvZignJyk7XG5cbiAgdmFyIHR5cGVvZm9iaiA9IF90eXBlb2Yoe30pO1xuXG4gIHZhciB0eXBlb2ZmbiA9IF90eXBlb2YoZnVuY3Rpb24gKCkge30pO1xuXG4gIHZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoSFRNTEVsZW1lbnQpO1xuXG4gIHZhciBpbnN0YW5jZVN0ciA9IGZ1bmN0aW9uIGluc3RhbmNlU3RyKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGZuJDYob2JqLmluc3RhbmNlU3RyaW5nKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbiAgfTtcblxuICB2YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT0gdHlwZW9mc3RyO1xuICB9O1xuICB2YXIgZm4kNiA9IGZ1bmN0aW9uIGZuKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZmZuO1xuICB9O1xuICB2YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShvYmopIHtcbiAgICByZXR1cm4gIWVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSAmJiAoQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbiAgfTtcbiAgdmFyIHBsYWluT2JqZWN0ID0gZnVuY3Rpb24gcGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqICYmICFhcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9O1xuICB2YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iajtcbiAgfTtcbiAgdmFyIG51bWJlciQxID0gZnVuY3Rpb24gbnVtYmVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IF90eXBlb2YoMSkgJiYgIWlzTmFOKG9iaik7XG4gIH07XG4gIHZhciBpbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihvYmopIHtcbiAgICByZXR1cm4gbnVtYmVyJDEob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbiAgfTtcbiAgdmFyIGh0bWxFbGVtZW50ID0gZnVuY3Rpb24gaHRtbEVsZW1lbnQob2JqKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2ZodG1sZWxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbCAhPSBvYmogJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgZWxlbWVudE9yQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQob2JqKSB8fCBjb2xsZWN0aW9uKG9iaik7XG4gIH07XG4gIHZhciBlbGVtZW50ID0gZnVuY3Rpb24gZWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gIH07XG4gIHZhciBjb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9O1xuICB2YXIgY29yZSA9IGZ1bmN0aW9uIGNvcmUob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbiAgfTtcbiAgdmFyIHN0eWxlc2hlZXQgPSBmdW5jdGlvbiBzdHlsZXNoZWV0KG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG4gIH07XG4gIHZhciBldmVudCA9IGZ1bmN0aW9uIGV2ZW50KG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xuICB9O1xuICB2YXIgZW1wdHlTdHJpbmcgPSBmdW5jdGlvbiBlbXB0eVN0cmluZyhvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGVtcHR5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG4gIH07XG4gIHZhciBkb21FbGVtZW50ID0gZnVuY3Rpb24gZG9tRWxlbWVudChvYmopIHtcbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH07XG4gIHZhciBib3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94KG9iaikge1xuICAgIHJldHVybiBwbGFpbk9iamVjdChvYmopICYmIG51bWJlciQxKG9iai54MSkgJiYgbnVtYmVyJDEob2JqLngyKSAmJiBudW1iZXIkMShvYmoueTEpICYmIG51bWJlciQxKG9iai55Mik7XG4gIH07XG4gIHZhciBwcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZShvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0KG9iaikgJiYgZm4kNihvYmoudGhlbik7XG4gIH07XG4gIHZhciBtcyA9IGZ1bmN0aW9uIG1zKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZXx0cmlkZW50fGVkZ2UvaSk7XG4gIH07IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuXG4gIHZhciBtZW1vaXplJDEgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICAgIGlmICgha2V5Rm4pIHtcbiAgICAgIGtleUZuID0gZnVuY3Rpb24ga2V5Rm4oKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uIG1lbW9pemVkRm4oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgayA9IGtleUZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWRGbi5jYWNoZTtcblxuICAgICAgaWYgKCEocmV0ID0gY2FjaGVba10pKSB7XG4gICAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIG1lbW9pemVkRm4uY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZWRGbjtcbiAgfTtcblxuICB2YXIgY2FtZWwyZGFzaCA9IG1lbW9pemUkMShmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gJy0nICsgdi50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIGRhc2gyY2FtZWwgPSBtZW1vaXplJDEoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdlsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIHByZXBlbmRDYW1lbCA9IG1lbW9pemUkMShmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICB9LCBmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJyQnICsgc3RyO1xuICB9KTtcbiAgdmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgIGlmIChlbXB0eVN0cmluZyhzdHIpKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICB9O1xuXG4gIHZhciBudW1iZXIgPSAnKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKSc7XG4gIHZhciByZ2JhID0gJ3JnYlthXT9cXFxcKCgnICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbiAgdmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuICB2YXIgaHNsYSA9ICdoc2xbYV0/XFxcXCgoJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG4gIHZhciBoc2xhTm9CYWNrUmVmcyA9ICdoc2xbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcbiAgdmFyIGhleDMgPSAnXFxcXCNbMC05YS1mQS1GXXszfSc7XG4gIHZhciBoZXg2ID0gJ1xcXFwjWzAtOWEtZkEtRl17Nn0nO1xuXG4gIHZhciBhc2NlbmRpbmcgPSBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIHZhciBkZXNjZW5kaW5nID0gZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xuICB9O1xuXG4gIHZhciBleHRlbmQgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KSA6IGZ1bmN0aW9uICh0Z3QpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGFyZ3NbaV07XG5cbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgICB0Z3Rba10gPSBvYmpba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRndDtcbiAgfTtcblxuICB2YXIgaGV4MnR1cGxlID0gZnVuY3Rpb24gaGV4MnR1cGxlKGhleCkge1xuICAgIGlmICghKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSAnIycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRIZXggPSBoZXgubGVuZ3RoID09PSA0O1xuICAgIHZhciByLCBnLCBiO1xuICAgIHZhciBiYXNlID0gMTY7XG5cbiAgICBpZiAoc2hvcnRIZXgpIHtcbiAgICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMV0sIGJhc2UpO1xuICAgICAgZyA9IHBhcnNlSW50KGhleFsyXSArIGhleFsyXSwgYmFzZSk7XG4gICAgICBiID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzNdLCBiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsyXSwgYmFzZSk7XG4gICAgICBnID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzRdLCBiYXNlKTtcbiAgICAgIGIgPSBwYXJzZUludChoZXhbNV0gKyBoZXhbNl0sIGJhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYl07XG4gIH07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuXG4gIHZhciBoc2wydHVwbGUgPSBmdW5jdGlvbiBoc2wydHVwbGUoaHNsKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgaHNsYSArICckJykuZXhlYyhoc2wpO1xuXG4gICAgaWYgKG0pIHtcbiAgICAgIC8vIGdldCBodWVcbiAgICAgIGggPSBwYXJzZUludChtWzFdKTtcblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAoMzYwIC0gLTEgKiBoICUgMzYwKSAlIDM2MDtcbiAgICAgIH0gZWxzZSBpZiAoaCA+IDM2MCkge1xuICAgICAgICBoID0gaCAlIDM2MDtcbiAgICAgIH1cblxuICAgICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgcyA9IHBhcnNlRmxvYXQobVsyXSk7XG5cbiAgICAgIGlmIChzIDwgMCB8fCBzID4gMTAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuXG5cbiAgICAgIHMgPSBzIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGwgPSBwYXJzZUZsb2F0KG1bM10pO1xuXG4gICAgICBpZiAobCA8IDAgfHwgbCA+IDEwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuXG5cbiAgICAgIGwgPSBsIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGEgPSBtWzRdO1xuXG4gICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgICAgIGlmIChhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBhbHBoYSBpcyBbMCwgMV1cblxuICAgICAgfSAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuXG5cbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICAgIGcgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCkpO1xuICAgICAgICBiID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxIC8gMykpO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBbciwgZywgYiwgYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTsgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG5cbiAgdmFyIHJnYjJ0dXBsZSA9IGZ1bmN0aW9uIHJnYjJ0dXBsZShyZ2IpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyByZ2JhICsgJyQnKS5leGVjKHJnYik7XG5cbiAgICBpZiAobSkge1xuICAgICAgcmV0ID0gW107XG4gICAgICB2YXIgaXNQY3QgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICBpZiAoY2hhbm5lbFtjaGFubmVsLmxlbmd0aCAtIDFdID09PSAnJScpIHtcbiAgICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFubmVsID0gcGFyc2VGbG9hdChjaGFubmVsKTtcblxuICAgICAgICBpZiAoaXNQY3RbaV0pIHtcbiAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuXG4gICAgICAgIHJldC5wdXNoKE1hdGguZmxvb3IoY2hhbm5lbCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG5cbiAgICAgIGlmIChhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG5cbiAgICAgIHZhciBhbHBoYSA9IG1bNF07XG5cbiAgICAgIGlmIChhbHBoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFscGhhID0gcGFyc2VGbG9hdChhbHBoYSk7XG5cbiAgICAgICAgaWYgKGFscGhhIDwgMCB8fCBhbHBoYSA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG5cbiAgICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIHZhciBjb2xvcm5hbWUydHVwbGUgPSBmdW5jdGlvbiBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3JzW2NvbG9yLnRvTG93ZXJDYXNlKCldO1xuICB9O1xuICB2YXIgY29sb3IydHVwbGUgPSBmdW5jdGlvbiBjb2xvcjJ0dXBsZShjb2xvcikge1xuICAgIHJldHVybiAoYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsKSB8fCBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHx8IGhleDJ0dXBsZShjb2xvcikgfHwgcmdiMnR1cGxlKGNvbG9yKSB8fCBoc2wydHVwbGUoY29sb3IpO1xuICB9O1xuICB2YXIgY29sb3JzID0ge1xuICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSxcbiAgICAvLyBOQiBhbHBoYSA9PT0gMFxuICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICAgIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICAgIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gICAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgICBibGFjazogWzAsIDAsIDBdLFxuICAgIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gICAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gICAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gICAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gICAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICAgIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gICAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICAgIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gICAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICAgIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICAgIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICAgIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICAgIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICAgIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gICAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gICAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICAgIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICAgIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gICAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gICAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICAgIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gICAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICAgIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gICAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICAgIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICAgIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gICAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICAgIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICAgIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gICAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICAgIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gICAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gICAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gICAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gICAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICAgIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICAgIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgbmF2eTogWzAsIDAsIDEyOF0sXG4gICAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICAgIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICAgIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gICAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICAgIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICAgIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICAgIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICAgIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gICAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICAgIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICAgIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICAgIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICAgIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICAgIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICAgIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICAgIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICAgIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICAgIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gICAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICAgIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxuICB9O1xuXG4gIHZhciBzZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAob3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChvYmpba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICBvYmpba2V5XSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuXG4gIHZhciBnZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAob3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqW2tleV07XG5cbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07IC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3Qoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG5cbiAgdmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICBcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG4gIHZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICB2YXIgX3Jvb3QgPSByb290O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDIuNC4wXG4gICAqIEBjYXRlZ29yeSBEYXRlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAqIH0sIF8ubm93KCkpO1xuICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgKi9cbiAgdmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcm9vdC5EYXRlLm5vdygpO1xuICB9O1xuXG4gIHZhciBub3dfMSA9IG5vdztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHZhciBfdHJpbW1lZEVuZEluZGV4ID0gdHJpbW1lZEVuZEluZGV4O1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmdcbiAgICAgID8gc3RyaW5nLnNsaWNlKDAsIF90cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgICAgOiBzdHJpbmc7XG4gIH1cblxuICB2YXIgX2Jhc2VUcmltID0gYmFzZVRyaW07XG5cbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gIHZhciBTeW1ib2wkMSA9IF9yb290LlN5bWJvbDtcblxuICB2YXIgX1N5bWJvbCA9IFN5bWJvbCQxO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkNCA9IG9iamVjdFByb3RvJDUuaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAqIG9mIHZhbHVlcy5cbiAgICovXG4gIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kNS50b1N0cmluZztcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkNC5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSxcbiAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG5cbiAgICB0cnkge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgIGlmIChpc093bikge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfZ2V0UmF3VGFnID0gZ2V0UmF3VGFnO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgKiBvZiB2YWx1ZXMuXG4gICAqL1xuICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90byQ0LnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgdmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHN5bVRvU3RyaW5nVGFnID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgfVxuICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICAgIDogX29iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIHZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuXG4gIHZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgIChpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgX2Jhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gIH1cblxuICB2YXIgaXNTeW1ib2xfMSA9IGlzU3ltYm9sO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b051bWJlcigzLjIpO1xuICAgKiAvLyA9PiAzLjJcbiAgICpcbiAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICogLy8gPT4gNWUtMzI0XG4gICAqXG4gICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgKiAvLyA9PiBJbmZpbml0eVxuICAgKlxuICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICogLy8gPT4gMy4yXG4gICAqL1xuICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTkFOO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gaXNPYmplY3RfMShvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gX2Jhc2VUcmltKHZhbHVlKTtcbiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgfVxuXG4gIHZhciB0b051bWJlcl8xID0gdG9OdW1iZXI7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgRlVOQ19FUlJPUl9URVhUJDEgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICB2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAqIGludm9jYXRpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgKlxuICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICpcbiAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICogfSkpO1xuICAgKlxuICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAqXG4gICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgKi9cbiAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgIG1heFdhaXQsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgdGltZXJJZCxcbiAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCQxKTtcbiAgICB9XG4gICAgd2FpdCA9IHRvTnVtYmVyXzEod2FpdCkgfHwgMDtcbiAgICBpZiAoaXNPYmplY3RfMShvcHRpb25zKSkge1xuICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyXzEob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgIHZhciB0aW1lID0gbm93XzEoKTtcbiAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICB9XG4gICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgIH1cbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3dfMSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICB2YXIgdGltZSA9IG5vd18xKCksXG4gICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICByZXR1cm4gZGVib3VuY2VkO1xuICB9XG5cbiAgdmFyIGRlYm91bmNlXzEgPSBkZWJvdW5jZTtcblxuICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLnBlcmZvcm1hbmNlIDogbnVsbDtcbiAgdmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xuXG4gIHZhciByYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdpbmRvdyQxKSB7XG4gICAgICBpZiAod2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB3aW5kb3ckMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHdpbmRvdyQxLm1velJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgd2luZG93JDEud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93JDEubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHdpbmRvdyQxLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm4ocG5vdygpKTtcbiAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICAgIHJldHVybiByYWYoZm4pO1xuICB9O1xuICB2YXIgcGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG4gIHZhciBERUZBVUxUX0hBU0hfU0VFRCA9IDkyNjE7XG4gIHZhciBLID0gNjU1OTk7IC8vIDM3IGFsc28gd29ya3MgcHJldHR5IHdlbGxcblxuICB2YXIgREVGQVVMVF9IQVNIX1NFRURfQUxUID0gNTM4MTtcbiAgdmFyIGhhc2hJdGVyYWJsZUludHMgPSBmdW5jdGlvbiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yKSB7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAgIC8vIHNkYm0vc3RyaW5nLWhhc2hcbiAgICB2YXIgaGFzaCA9IHNlZWQ7XG4gICAgdmFyIGVudHJ5O1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBoYXNoID0gaGFzaCAqIEsgKyBlbnRyeS52YWx1ZSB8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG4gIHZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRUQ7XG4gICAgLy8gc2RibS9zdHJpbmctaGFzaFxuICAgIHJldHVybiBzZWVkICogSyArIG51bSB8IDA7XG4gIH07XG4gIHZhciBoYXNoSW50QWx0ID0gZnVuY3Rpb24gaGFzaEludEFsdChudW0pIHtcbiAgICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAgIC8vIGRqYjIvc3RyaW5nLWhhc2hcbiAgICByZXR1cm4gKHNlZWQgPDwgNSkgKyBzZWVkICsgbnVtIHwgMDtcbiAgfTtcbiAgdmFyIGNvbWJpbmVIYXNoZXMgPSBmdW5jdGlvbiBjb21iaW5lSGFzaGVzKGhhc2gxLCBoYXNoMikge1xuICAgIHJldHVybiBoYXNoMSAqIDB4MjAwMDAwICsgaGFzaDI7XG4gIH07XG4gIHZhciBjb21iaW5lSGFzaGVzQXJyYXkgPSBmdW5jdGlvbiBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaGVzKSB7XG4gICAgcmV0dXJuIGhhc2hlc1swXSAqIDB4MjAwMDAwICsgaGFzaGVzWzFdO1xuICB9O1xuICB2YXIgaGFzaEFycmF5cyA9IGZ1bmN0aW9uIGhhc2hBcnJheXMoaGFzaGVzMSwgaGFzaGVzMikge1xuICAgIHJldHVybiBbaGFzaEludChoYXNoZXMxWzBdLCBoYXNoZXMyWzBdKSwgaGFzaEludEFsdChoYXNoZXMxWzFdLCBoYXNoZXMyWzFdKV07XG4gIH07XG4gIHZhciBoYXNoSW50c0FycmF5ID0gZnVuY3Rpb24gaGFzaEludHNBcnJheShpbnRzLCBzZWVkKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW5ndGggPSBpbnRzLmxlbmd0aDtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gaW50c1tpKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xuICB9O1xuICB2YXIgaGFzaFN0cmluZyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyLCBzZWVkKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xuICB9O1xuICB2YXIgaGFzaFN0cmluZ3MgPSBmdW5jdGlvbiBoYXNoU3RyaW5ncygpIHtcbiAgICByZXR1cm4gaGFzaFN0cmluZ3NBcnJheShhcmd1bWVudHMpO1xuICB9O1xuICB2YXIgaGFzaFN0cmluZ3NBcnJheSA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzQXJyYXkoc3Rycykge1xuICAgIHZhciBoYXNoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyID0gc3Ryc1tpXTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0ciwgaGFzaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLypnbG9iYWwgY29uc29sZSAqL1xuICB2YXIgd2FybmluZ3NFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIHdhcm5TdXBwb3J0ZWQgPSBjb25zb2xlLndhcm4gIT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgdmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICB2YXIgTUFYX0lOVCQxID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbiAgdmFyIHRydWVpZnkgPSBmdW5jdGlvbiB0cnVlaWZ5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgZmFsc2lmeSA9IGZ1bmN0aW9uIGZhbHNpZnkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICB2YXIgemVyb2lmeSA9IGZ1bmN0aW9uIHplcm9pZnkoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIHZhciBub29wJDEgPSBmdW5jdGlvbiBub29wKCkge307XG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9O1xuICB2YXIgd2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncyhlbmFibGVkKSB7XG4gICAgaWYgKGVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZ3NFbmFibGVkID0gISFlbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2FybmluZ3NFbmFibGVkO1xuICAgIH1cbiAgfTtcbiAgdmFyIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBpZiAoIXdhcm5pbmdzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2FyblN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG5cbiAgICAgIGlmICh0cmFjZVN1cHBvcnRlZCkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgdmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbiAgfTsgLy8gZ2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnRcblxuICB2YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChhcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gY2xvbmUob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG4gIHZhciBjb3B5QXJyYXkkMSA9IGZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gIH07XG4gIHZhciB1dWlkID0gZnVuY3Rpb24gdXVpZChhLCBiXG4gIC8qIHBsYWNlaG9sZGVycyAqL1xuICApIHtcbiAgICBmb3IgKCAvLyBsb29wIDopXG4gICAgYiA9IGEgPSAnJzsgLy8gYiAtIHJlc3VsdCAsIGEgLSBudW1lcmljIGxldGlhYmxlXG4gICAgYSsrIDwgMzY7IC8vXG4gICAgYiArPSBhICogNTEgJiA1MiAvLyBpZiBcImFcIiBpcyBub3QgOSBvciAxNCBvciAxOSBvciAyNFxuICAgID8gLy8gIHJldHVybiBhIHJhbmRvbSBudW1iZXIgb3IgNFxuICAgIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gICAgPyAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgZnJvbSAwIHRvIDE1XG4gICAgOCBeIE1hdGgucmFuZG9tKCkgKiAoYSBeIDIwID8gMTYgOiA0KSAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICAgIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgICApLnRvU3RyaW5nKDE2KSA6ICctJyAvLyAgaW4gb3RoZXIgY2FzZXMgKGlmIFwiYVwiIGlzIDksMTQsMTksMjQpIGluc2VydCBcIi1cIlxuICAgICkge1xuICAgIH1cblxuICAgIHJldHVybiBiO1xuICB9O1xuICB2YXIgX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG4gIHZhciBzdGF0aWNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uIHN0YXRpY0VtcHR5T2JqZWN0KCkge1xuICAgIHJldHVybiBfc3RhdGljRW1wdHlPYmplY3Q7XG4gIH07XG4gIHZhciBkZWZhdWx0cyRnID0gZnVuY3Rpb24gZGVmYXVsdHMoX2RlZmF1bHRzKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgdmFyIGZpbGxlZE9wdHMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgb3B0VmFsID0gb3B0cyA9PSBudWxsID8gdW5kZWZpbmVkIDogb3B0c1trZXldO1xuICAgICAgICBmaWxsZWRPcHRzW2tleV0gPSBvcHRWYWwgPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0c1trZXldIDogb3B0VmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsbGVkT3B0cztcbiAgICB9O1xuICB9O1xuICB2YXIgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgZWxlLCBvbmVDb3B5KSB7XG4gICAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFycltpXSA9PT0gZWxlKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgaWYgKG9uZUNvcHkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICAgIGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCk7XG4gIH07XG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gb3RoZXJBcnJbaV07XG4gICAgICBhcnIucHVzaChlbCk7XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICAgIH1cblxuICAgIHJldHVybiBvYmpbcHJvcE5hbWVdO1xuICB9O1xuICB2YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByb3BOYW1lID0gcHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgICB9XG5cbiAgICBvYmpbcHJvcE5hbWVdID0gdmFsdWU7XG4gIH07XG5cbiAgLyogZ2xvYmFsIE1hcCAqL1xuICB2YXIgT2JqZWN0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RNYXAoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcblxuICAgICAgdGhpcy5fb2JqID0ge307XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE9iamVjdE1hcCwgW3tcbiAgICAgIGtleTogXCJzZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgdGhpcy5fb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgICB0aGlzLl9vYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JqZWN0TWFwO1xuICB9KCk7XG5cbiAgdmFyIE1hcCQyID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5cbiAgLyogZ2xvYmFsIFNldCAqL1xuICB2YXIgdW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcblxuICB2YXIgT2JqZWN0U2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXQoYXJyYXlPck9iamVjdFNldCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFNldCk7XG5cbiAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuXG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBhcnI7XG5cbiAgICAgICAgaWYgKGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcgIT0gbnVsbCAmJiBhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nKCkgPT09IHRoaXMuaW5zdGFuY2VTdHJpbmcoKSkge1xuICAgICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoT2JqZWN0U2V0LCBbe1xuICAgICAga2V5OiBcImluc3RhbmNlU3RyaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnc2V0JztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuX29iajtcblxuICAgICAgICBpZiAob1t2YWxdICE9PSAxKSB7XG4gICAgICAgICAgb1t2YWxdID0gMTtcbiAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHZhbCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuX29iajtcblxuICAgICAgICBpZiAob1t2YWxdID09PSAxKSB7XG4gICAgICAgICAgb1t2YWxdID0gMDtcbiAgICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXModmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmpbdmFsXSA9PT0gMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaGFzKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE9iamVjdFNldDtcbiAgfSgpO1xuXG4gIHZhciBTZXQkMSA9ICh0eXBlb2YgU2V0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU2V0KSkgIT09IHVuZGVmID8gU2V0IDogT2JqZWN0U2V0O1xuXG4gIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gRWxlbWVudChjeSwgcGFyYW1zKSB7XG4gICAgdmFyIHJlc3RvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDsgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG5cbiAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgaWYgKHBhcmFtcy5kYXRhICYmIHBhcmFtcy5kYXRhLnNvdXJjZSAhPSBudWxsICYmIHBhcmFtcy5kYXRhLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3VwID0gJ25vZGVzJztcbiAgICAgIH1cbiAgICB9IC8vIHZhbGlkYXRlIGdyb3VwXG5cblxuICAgIGlmIChncm91cCAhPT0gJ25vZGVzJyAmJiBncm91cCAhPT0gJ2VkZ2VzJykge1xuICAgICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG1ha2UgdGhlIGVsZW1lbnQgYXJyYXktbGlrZSwganVzdCBsaWtlIGEgY29sbGVjdGlvblxuXG5cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpc1swXSA9IHRoaXM7IC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBzaW5nbGU6IHRydWUsXG4gICAgICAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSxcbiAgICAgIC8vIGRhdGEgb2JqZWN0XG4gICAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgIGF1dG9QYWRkaW5nOiB1bmRlZmluZWQsXG4gICAgICBjb21wb3VuZEJvdW5kc0NsZWFuOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGNvbXBvdW5kIGRpbWVuc2lvbnMgbmVlZCB0byBiZSByZWNhbGN1bGF0ZWQgdGhlIG5leHQgdGltZSBkaW1lbnNpb25zIGFyZSByZWFkXG4gICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgICBncm91cDogZ3JvdXAsXG4gICAgICAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgICAgc3R5bGU6IHt9LFxuICAgICAgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgICByc3R5bGU6IHt9LFxuICAgICAgLy8gcHJvcGVydGllcyBmb3Igc3R5bGUgc2VudCBmcm9tIHRoZSByZW5kZXJlciB0byB0aGUgY29yZVxuICAgICAgc3R5bGVDeHRzOiBbXSxcbiAgICAgIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgICBzdHlsZUtleXM6IHt9LFxuICAgICAgLy8gcGVyLWdyb3VwIGtleXMgb2Ygc3R5bGUgcHJvcGVydHkgdmFsdWVzXG4gICAgICByZW1vdmVkOiB0cnVlLFxuICAgICAgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RlZFxuICAgICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RhYmxlXG4gICAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgICAgZ3JhYmJlZDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgICAgcGFubmFibGU6IHBhcmFtcy5wYW5uYWJsZSA9PT0gdW5kZWZpbmVkID8gZ3JvdXAgPT09ICdlZGdlcycgPyB0cnVlIDogZmFsc2UgOiBwYXJhbXMucGFubmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyBwYXNzdGhyb3VnaCBwYW5uaW5nIGVuYWJsZWRcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgIGNsYXNzZXM6IG5ldyBTZXQkMSgpLFxuICAgICAgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgcXVldWU6IFtdXG4gICAgICB9LFxuICAgICAgcnNjcmF0Y2g6IHt9LFxuICAgICAgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICAgIHNjcmF0Y2g6IHBhcmFtcy5zY3JhdGNoIHx8IHt9LFxuICAgICAgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgICBlZGdlczogW10sXG4gICAgICAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgICBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQgJiYgcGFyYW1zLnBhcmVudC5pc05vZGUoKSA/IHBhcmFtcy5wYXJlbnQgOiBudWxsLFxuICAgICAgLy8gcGFyZW50IHJlZlxuICAgICAgdHJhdmVyc2FsQ2FjaGU6IHt9LFxuICAgICAgLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgICAgIGJhY2tncm91bmRpbmc6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciBiYWNrZ3JvdW5kIGltYWdlcyBhcmUgbG9hZGluZ1xuICAgICAgYmJDYWNoZTogbnVsbCxcbiAgICAgIC8vIGNhY2hlIG9mIHRoZSBjdXJyZW50IGJvdW5kaW5nIGJveFxuICAgICAgYmJDYWNoZVNoaWZ0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICAvLyBzaGlmdCBhcHBsaWVkIHRvIGNhY2hlZCBiYiB0byBiZSBhcHBsaWVkIG9uIG5leHQgZ2V0XG4gICAgICBib2R5Qm91bmRzOiBudWxsLFxuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgdy9vIG92ZXJsYXlcbiAgICAgIG92ZXJsYXlCb3VuZHM6IG51bGwsXG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCBpbmNsdWRpbmcgb3ZlcmxheVxuICAgICAgbGFiZWxCb3VuZHM6IHtcbiAgICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGxhYmVsc1xuICAgICAgICBhbGw6IG51bGwsXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBtYWluOiBudWxsXG4gICAgICB9LFxuICAgICAgYXJyb3dCb3VuZHM6IHtcbiAgICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGVkZ2UgYXJyb3dzXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAnbWlkLXNvdXJjZSc6IG51bGwsXG4gICAgICAgICdtaWQtdGFyZ2V0JzogbnVsbFxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoX3AucG9zaXRpb24ueCA9PSBudWxsKSB7XG4gICAgICBfcC5wb3NpdGlvbi54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3AucG9zaXRpb24ueSA9PSBudWxsKSB7XG4gICAgICBfcC5wb3NpdGlvbi55ID0gMDtcbiAgICB9IC8vIHJlbmRlcmVkUG9zaXRpb24gb3ZlcnJpZGVzIGlmIHNwZWNpZmllZFxuXG5cbiAgICBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24pIHtcbiAgICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIF9wLnBvc2l0aW9uID0ge1xuICAgICAgICB4OiAocnBvcy54IC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChhcnJheShwYXJhbXMuY2xhc3NlcykpIHtcbiAgICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcztcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhwYXJhbXMuY2xhc3NlcykpIHtcbiAgICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuXG4gICAgICBpZiAoIWNscyB8fCBjbHMgPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBfcC5jbGFzc2VzLmFkZChjbHMpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIHZhciBieXBhc3MgPSBwYXJhbXMuc3R5bGUgfHwgcGFyYW1zLmNzcztcblxuICAgIGlmIChieXBhc3MpIHtcbiAgICAgIHdhcm4oJ1NldHRpbmcgYSBgc3R5bGVgIGJ5cGFzcyBhdCBlbGVtZW50IGNyZWF0aW9uIHNob3VsZCBiZSBkb25lIG9ubHkgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4gIFRyeSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW5zdGVhZC4nKTtcbiAgICAgIHRoaXMuc3R5bGUoYnlwYXNzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVmaW5lU2VhcmNoID0gZnVuY3Rpb24gZGVmaW5lU2VhcmNoKHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHtcbiAgICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICAgIGRmczogcGFyYW1zLmRmcyB8fCAhcGFyYW1zLmJmc1xuICAgIH07IC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcblxuICAgIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbihyb290cywgZm4sIGRpcmVjdGVkKSB7XG4gICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KHJvb3RzKSAmJiAhZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgICByb290cyA9IG9wdGlvbnMucm9vdHMgfHwgb3B0aW9ucy5yb290O1xuICAgICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFmbiQ2KGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgICBmbiA9IGZuJDYoZm4pID8gZm4gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgdiA9IHJvb3RzID0gc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgICAgdmFyIFEgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICAgIHZhciBWID0ge307XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgZm91bmQ7XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlczsgLy8gZW5xdWV1ZSB2XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2aSA9IHZbaV07XG4gICAgICAgIHZhciB2aUlkID0gdmkuaWQoKTtcblxuICAgICAgICBpZiAodmkuaXNOb2RlKCkpIHtcbiAgICAgICAgICBRLnVuc2hpZnQodmkpO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgIFZbdmlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2aSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWQyZGVwdGhbdmlJZF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuICAgICAgICB2YXIgdklkID0gdi5pZCgpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuZGZzKSB7XG4gICAgICAgICAgaWYgKFZbdklkXSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBWW3ZJZF0gPSB0cnVlO1xuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFt2SWRdO1xuICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVt2SWRdO1xuICAgICAgICB2YXIgc3JjID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnNvdXJjZSgpIDogbnVsbDtcbiAgICAgICAgdmFyIHRndCA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS50YXJnZXQoKSA6IG51bGw7XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiB2LnNhbWUoc3JjKSA/IHRndFswXSA6IHNyY1swXTtcbiAgICAgICAgdmFyIHJldCA9IHZvaWQgMDtcbiAgICAgICAgcmV0ID0gZm4odiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcblxuICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gKCFkaXJlY3RlZCB8fCBlLnNvdXJjZSgpLnNhbWUodikpICYmIGVkZ2VzLmhhcyhlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdndFZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW19pMl07XG4gICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gIW4uc2FtZSh2KSAmJiBub2Rlcy5oYXMobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcblxuICAgICAgICAgIGlmICh3Lmxlbmd0aCAhPT0gMCAmJiAhVlt3SWRdKSB7XG4gICAgICAgICAgICB3ID0gd1swXTtcbiAgICAgICAgICAgIFEucHVzaCh3KTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgICAgVlt3SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29ubmVjdGVkQnlbd0lkXSA9IGU7XG4gICAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoUS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcCgpO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tfaV07XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbbm9kZS5pZCgpXTtcblxuICAgICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBjeS5jb2xsZWN0aW9uKGNvbm5lY3RlZEVsZXMpLFxuICAgICAgICBmb3VuZDogY3kuY29sbGVjdGlvbihmb3VuZClcbiAgICAgIH07XG4gICAgfTtcbiAgfTsgLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG5cblxuICB2YXIgZWxlc2ZuJHYgPSB7XG4gICAgYnJlYWR0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgICAgYmZzOiB0cnVlXG4gICAgfSksXG4gICAgZGVwdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICAgIGRmczogdHJ1ZVxuICAgIH0pXG4gIH07IC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuXG4gIGVsZXNmbiR2LmJmcyA9IGVsZXNmbiR2LmJyZWFkdGhGaXJzdFNlYXJjaDtcbiAgZWxlc2ZuJHYuZGZzID0gZWxlc2ZuJHYuZGVwdGhGaXJzdFNlYXJjaDtcblxuICB2YXIgaGVhcCQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgICAvKlxuICAgIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAgICovXG5cbiAgICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKHggPCB5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh4ID4geSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cbiAgICBcbiAgICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gICAgXG4gICAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICAgIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAgICovXG5cbiAgICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgICAgdmFyIG1pZDtcbiAgICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICAgIGxvID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgaWYgKGxvIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgICB9XG4gICAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgICBoaSA9IGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAgICovXG5cbiAgICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAgICovXG5cbiAgICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5pdGVtO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuICAgIFxuICAgIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICAgIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICAgIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAgICovXG5cbiAgICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICAgIHZhciByZXR1cm5pdGVtO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgICAgcmV0dXJuIHJldHVybml0ZW07XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAgICovXG5cbiAgICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgICAqL1xuXG4gICAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICAgIHZhciBpLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqL1xuXG4gICAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICAgIHZhciBwb3M7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgICAqL1xuXG4gICAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAgICovXG5cbiAgICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgICB2YXIgZWxlbSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgfTtcblxuICAgIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICAgIH07XG5cbiAgICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYXA7XG4gICAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgcmV0dXJuIGhlYXA7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgICByZXR1cm4gSGVhcDtcblxuICAgIH0pKCk7XG5cbiAgICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICAge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICB9XG4gICAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSGVhcDtcbiAgICB9KTtcblxuICB9KS5jYWxsKGNvbW1vbmpzR2xvYmFsKTtcbiAgfSk7XG5cbiAgdmFyIGhlYXAgPSBoZWFwJDE7XG5cbiAgdmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICByb290OiBudWxsLFxuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJHUgPSB7XG4gICAgZGlqa3N0cmE6IGZ1bmN0aW9uIGRpamtzdHJhKG9wdGlvbnMpIHtcbiAgICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgICB3ZWlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9kaWprc3RyYURlZmF1bHRzID0gZGlqa3N0cmFEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICByb290ID0gX2RpamtzdHJhRGVmYXVsdHMucm9vdCxcbiAgICAgICAgICB3ZWlnaHQgPSBfZGlqa3N0cmFEZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfZGlqa3N0cmFEZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgICAgdmFyIHNvdXJjZSA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICAgIHZhciBkaXN0ID0ge307XG4gICAgICB2YXIgcHJldiA9IHt9O1xuICAgICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNMb29wKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3Rbbm9kZS5pZCgpXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24gc2V0RGlzdChub2RlLCBkKSB7XG4gICAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IGQ7XG4gICAgICAgIFEudXBkYXRlSXRlbShub2RlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBRID0gbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZGlzdFtub2RlLmlkKCldID0gbm9kZS5zYW1lKHNvdXJjZSkgPyAwIDogSW5maW5pdHk7XG4gICAgICAgIFEucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24gZGlzdEJldHdlZW4odSwgdikge1xuICAgICAgICB2YXIgdXZzID0gKGRpcmVjdGVkID8gdS5lZGdlc1RvKHYpIDogdS5lZGdlc1dpdGgodikpLmludGVyc2VjdChlZGdlcyk7XG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHV2cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IHV2c1tfaV07XG5cbiAgICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAgICAgaWYgKF93ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UpIHtcbiAgICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBfd2VpZ2h0O1xuICAgICAgICAgICAgc21hbGxlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICAgIHZhciB1ID0gUS5wb3AoKTtcbiAgICAgICAgdmFyIHNtYWxsZXRzRGlzdCA9IGdldERpc3QodSk7XG4gICAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICAgIGtub3duRGlzdFt1aWRdID0gc21hbGxldHNEaXN0O1xuXG4gICAgICAgIGlmIChzbWFsbGV0c0Rpc3QgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdS5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3Qobm9kZXMpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbX2kyXTtcbiAgICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICAgIHZhciBhbHQgPSBzbWFsbGV0c0Rpc3QgKyB2RGlzdC5kaXN0O1xuXG4gICAgICAgICAgaWYgKGFsdCA8IGdldERpc3QodikpIHtcbiAgICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcbiAgICAgICAgICAgIHByZXZbdmlkXSA9IHtcbiAgICAgICAgICAgICAgbm9kZTogdSxcbiAgICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yXG5cbiAgICAgIH0gLy8gd2hpbGVcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgICByZXR1cm4ga25vd25EaXN0W3RhcmdldC5pZCgpXTtcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aFRvOiBmdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICAgIHZhciBTID0gW107XG4gICAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG4gICAgICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcblxuICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgUy51bnNoaWZ0KHRhcmdldCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwcmV2W3VpZF0pIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSBwcmV2W3VpZF07XG4gICAgICAgICAgICAgIFMudW5zaGlmdChwLmVkZ2UpO1xuICAgICAgICAgICAgICBTLnVuc2hpZnQocC5ub2RlKTtcbiAgICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgICAgdWlkID0gdS5pZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVzLnNwYXduKFMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgZWxlc2ZuJHQgPSB7XG4gICAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gICAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgICAgd2VpZ2h0Rm4gPSB3ZWlnaHRGbiB8fCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIGZvcmVzdCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICB2YXIgQSA9IG5vZGVzOyAvLyBhc3N1bWVzIGJ5R3JvdXAoKSBjcmVhdGVzIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgbXV0YXRlZFxuXG4gICAgICB2YXIgZmluZFNldEluZGV4ID0gZnVuY3Rpb24gZmluZFNldEluZGV4KGVsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgICAgaWYgKGVsZXMuaGFzKGVsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gc3RhcnQgd2l0aCBvbmUgZm9yZXN0IHBlciBub2RlXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGZvcmVzdFtpXSA9IHRoaXMuc3Bhd24obm9kZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHdlaWdodEZuKGEpIC0gd2VpZ2h0Rm4oYik7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gU1tfaV07XG4gICAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgc2V0VUluZGV4ID0gZmluZFNldEluZGV4KHUpO1xuICAgICAgICB2YXIgc2V0VkluZGV4ID0gZmluZFNldEluZGV4KHYpO1xuICAgICAgICB2YXIgc2V0VSA9IGZvcmVzdFtzZXRVSW5kZXhdO1xuICAgICAgICB2YXIgc2V0ViA9IGZvcmVzdFtzZXRWSW5kZXhdO1xuXG4gICAgICAgIGlmIChzZXRVSW5kZXggIT09IHNldFZJbmRleCkge1xuICAgICAgICAgIEEubWVyZ2UoZWRnZSk7IC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuXG4gICAgICAgICAgc2V0VS5tZXJnZShzZXRWKTtcbiAgICAgICAgICBmb3Jlc3Quc3BsaWNlKHNldFZJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhU3RhckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgcm9vdDogbnVsbCxcbiAgICBnb2FsOiBudWxsLFxuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgaGV1cmlzdGljOiBmdW5jdGlvbiBoZXVyaXN0aWMoZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kcyA9IHtcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBhU3RhcjogZnVuY3Rpb24gYVN0YXIob3B0aW9ucykge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICB2YXIgX2FTdGFyRGVmYXVsdHMgPSBhU3RhckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIHJvb3QgPSBfYVN0YXJEZWZhdWx0cy5yb290LFxuICAgICAgICAgIGdvYWwgPSBfYVN0YXJEZWZhdWx0cy5nb2FsLFxuICAgICAgICAgIGhldXJpc3RpYyA9IF9hU3RhckRlZmF1bHRzLmhldXJpc3RpYyxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9hU3RhckRlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICAgIHdlaWdodCA9IF9hU3RhckRlZmF1bHRzLndlaWdodDtcblxuICAgICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgICBnb2FsID0gY3kuY29sbGVjdGlvbihnb2FsKVswXTtcbiAgICAgIHZhciBzaWQgPSByb290LmlkKCk7XG4gICAgICB2YXIgdGlkID0gZ29hbC5pZCgpO1xuICAgICAgdmFyIGdTY29yZSA9IHt9O1xuICAgICAgdmFyIGZTY29yZSA9IHt9O1xuICAgICAgdmFyIGNsb3NlZFNldElkcyA9IHt9O1xuICAgICAgdmFyIG9wZW5TZXQgPSBuZXcgaGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZlNjb3JlW2EuaWQoKV0gLSBmU2NvcmVbYi5pZCgpXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG9wZW5TZXRJZHMgPSBuZXcgU2V0JDEoKTtcbiAgICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuXG4gICAgICB2YXIgYWRkVG9PcGVuU2V0ID0gZnVuY3Rpb24gYWRkVG9PcGVuU2V0KGVsZSwgaWQpIHtcbiAgICAgICAgb3BlblNldC5wdXNoKGVsZSk7XG4gICAgICAgIG9wZW5TZXRJZHMuYWRkKGlkKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjTWluLCBjTWluSWQ7XG5cbiAgICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgICBjTWluID0gb3BlblNldC5wb3AoKTtcbiAgICAgICAgY01pbklkID0gY01pbi5pZCgpO1xuICAgICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaXNJbk9wZW5TZXQgPSBmdW5jdGlvbiBpc0luT3BlblNldChpZCkge1xuICAgICAgICByZXR1cm4gb3BlblNldElkcy5oYXMoaWQpO1xuICAgICAgfTtcblxuICAgICAgYWRkVG9PcGVuU2V0KHJvb3QsIHNpZCk7XG4gICAgICBnU2NvcmVbc2lkXSA9IDA7XG4gICAgICBmU2NvcmVbc2lkXSA9IGhldXJpc3RpYyhyb290KTsgLy8gQ291bnRlclxuXG4gICAgICB2YXIgc3RlcHMgPSAwOyAvLyBNYWluIGxvb3BcblxuICAgICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgICBwb3BGcm9tT3BlblNldCgpO1xuICAgICAgICBzdGVwcysrOyAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuXG4gICAgICAgIGlmIChjTWluSWQgPT09IHRpZCkge1xuICAgICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgICAgdmFyIHBhdGhOb2RlID0gZ29hbDtcbiAgICAgICAgICB2YXIgcGF0aE5vZGVJZCA9IHRpZDtcbiAgICAgICAgICB2YXIgcGF0aEVkZ2UgPSBjYW1lRnJvbUVkZ2VbcGF0aE5vZGVJZF07XG5cbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAocGF0aEVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aEVkZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXRoTm9kZSA9IGNhbWVGcm9tW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgICAgICBpZiAocGF0aE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aE5vZGVJZCA9IHBhdGhOb2RlLmlkKCk7XG4gICAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZTogZ1Njb3JlW2NNaW5JZF0sXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnNwYXduKHBhdGgpLFxuICAgICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcblxuXG4gICAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTsgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaWYgZ3JhcGggaXMgZGlyZWN0ZWQgb3Igbm90XG5cbiAgICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTsgLy8gZWRnZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcblxuICAgICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKGUuaWQoKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gY01pbiBtdXN0IGJlIHRoZSBzb3VyY2Ugb2YgZWRnZSBpZiBkaXJlY3RlZFxuXG5cbiAgICAgICAgICBpZiAoZGlyZWN0ZWQgJiYgZS5kYXRhKCdzb3VyY2UnKSAhPT0gY01pbklkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd1NyYyA9IGUuc291cmNlKCk7XG4gICAgICAgICAgdmFyIHdUZ3QgPSBlLnRhcmdldCgpO1xuICAgICAgICAgIHZhciB3ID0gd1NyYy5pZCgpICE9PSBjTWluSWQgPyB3U3JjIDogd1RndDtcbiAgICAgICAgICB2YXIgd2lkID0gdy5pZCgpOyAvLyBub2RlIG11c3QgYmUgaW4gc2V0IG9mIGNhbGxpbmcgZWxlc1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQod2lkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG5cblxuICAgICAgICAgIGlmIChjbG9zZWRTZXRJZHNbd2lkXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcblxuXG4gICAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpOyAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgICAvLyBPUlxuICAgICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG5cbiAgICAgICAgICBpZiAoIWlzSW5PcGVuU2V0KHdpZCkpIHtcbiAgICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBhZGRUb09wZW5TZXQodywgd2lkKTtcbiAgICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcblxuXG4gICAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3aWRdKSB7XG4gICAgICAgICAgICBnU2NvcmVbd2lkXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgICBjYW1lRnJvbUVkZ2Vbd2lkXSA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgICBkaXN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgfTtcbiAgICB9XG4gIH07IC8vIGVsZXNmblxuXG4gIHZhciBmbG95ZFdhcnNoYWxsRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiRyID0ge1xuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwob3B0aW9ucykge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICB2YXIgX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0ID0gZmxveWRXYXJzaGFsbERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIHdlaWdodCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQuZGlyZWN0ZWQ7XG5cbiAgICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgICB2YXIgTiA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBOc3EgPSBOICogTjtcblxuICAgICAgdmFyIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYXRJbmRleCA9IGZ1bmN0aW9uIGF0SW5kZXgoaSkge1xuICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICB9OyAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuXG5cbiAgICAgIHZhciBkaXN0ID0gbmV3IEFycmF5KE5zcSk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTnNxOyBuKyspIHtcbiAgICAgICAgdmFyIGogPSBuICUgTjtcbiAgICAgICAgdmFyIGkgPSAobiAtIGopIC8gTjtcblxuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgIGRpc3Rbbl0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3Rbbl0gPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuXG5cbiAgICAgIHZhciBuZXh0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgICB2YXIgZWRnZU5leHQgPSBuZXcgQXJyYXkoTnNxKTsgLy8gUHJvY2VzcyBlZGdlc1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KClbMF07XG5cbiAgICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZXhjbHVkZSBsb29wc1xuXG5cbiAgICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICAgIHZhciB0ID0gaW5kZXhPZih0Z3QpO1xuICAgICAgICB2YXIgc3QgPSBzICogTiArIHQ7IC8vIHNvdXJjZSB0byB0YXJnZXQgaW5kZXhcblxuICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpOyAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG5cblxuICAgICAgICBpZiAoZGlzdFtzdF0gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFtzdF0gPSBfd2VpZ2h0O1xuICAgICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgICBlZGdlTmV4dFtzdF0gPSBlZGdlO1xuICAgICAgICB9IC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlXG5cblxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgdmFyIHRzID0gdCAqIE4gKyBzOyAvLyB0YXJnZXQgdG8gc291cmNlIGluZGV4XG5cbiAgICAgICAgICBpZiAoIWRpcmVjdGVkICYmIGRpc3RbdHNdID4gX3dlaWdodCkge1xuICAgICAgICAgICAgZGlzdFt0c10gPSBfd2VpZ2h0O1xuICAgICAgICAgICAgbmV4dFt0c10gPSBzO1xuICAgICAgICAgICAgZWRnZU5leHRbdHNdID0gZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTWFpbiBsb29wXG5cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBOOyBrKyspIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgaWsgPSBfaTIgKiBOICsgaztcblxuICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgaWogPSBfaTIgKiBOICsgX2o7XG4gICAgICAgICAgICB2YXIga2ogPSBrICogTiArIF9qO1xuXG4gICAgICAgICAgICBpZiAoZGlzdFtpa10gKyBkaXN0W2tqXSA8IGRpc3RbaWpdKSB7XG4gICAgICAgICAgICAgIGRpc3RbaWpdID0gZGlzdFtpa10gKyBkaXN0W2tqXTtcbiAgICAgICAgICAgICAgbmV4dFtpal0gPSBuZXh0W2lrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdldEFyZ0VsZSA9IGZ1bmN0aW9uIGdldEFyZ0VsZShlbGUpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcoZWxlKSA/IGN5LmZpbHRlcihlbGUpIDogZWxlKVswXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleE9mQXJnRWxlID0gZnVuY3Rpb24gaW5kZXhPZkFyZ0VsZShlbGUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YoZ2V0QXJnRWxlKGVsZSkpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uIGRpc3RhbmNlKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgICAgcmV0dXJuIGRpc3RbaSAqIE4gKyBqXTtcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gcGF0aChmcm9tLCB0bykge1xuICAgICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICAgIHZhciBmcm9tTm9kZSA9IGF0SW5kZXgoaSk7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Ob2RlLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dFtpICogTiArIGpdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGggPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHByZXYgPSBpO1xuICAgICAgICAgIHZhciBlZGdlO1xuICAgICAgICAgIHBhdGgubWVyZ2UoZnJvbU5vZGUpO1xuXG4gICAgICAgICAgd2hpbGUgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHByZXYgPSBpO1xuICAgICAgICAgICAgaSA9IG5leHRbaSAqIE4gKyBqXTtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlTmV4dFtwcmV2ICogTiArIGldO1xuICAgICAgICAgICAgcGF0aC5tZXJnZShlZGdlKTtcbiAgICAgICAgICAgIHBhdGgubWVyZ2UoYXRJbmRleChpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gZmxveWRXYXJzaGFsbFxuXG4gIH07IC8vIGVsZXNmblxuXG4gIHZhciBiZWxsbWFuRm9yZERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgcm9vdDogbnVsbFxuICB9KTtcbiAgdmFyIGVsZXNmbiRxID0ge1xuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbiBiZWxsbWFuRm9yZChvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX2JlbGxtYW5Gb3JkRGVmYXVsdHMgPSBiZWxsbWFuRm9yZERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIHdlaWdodCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICAgIHJvb3QgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5yb290O1xuXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcztcblxuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIGluZm9NYXAgPSBuZXcgTWFwJDIoKTtcbiAgICAgIHZhciBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gZmFsc2U7XG4gICAgICB2YXIgbmVnYXRpdmVXZWlnaHRDeWNsZXMgPSBbXTtcbiAgICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdOyAvLyBpbiBjYXNlIHNlbGVjdG9yIHBhc3NlZFxuXG4gICAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgdmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKG5vZGUpIHtcbiAgICAgICAgdmFyIG9iaiA9IGluZm9NYXAuZ2V0KG5vZGUuaWQoKSk7XG5cbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICBpbmZvTWFwLnNldChub2RlLmlkKCksIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdldE5vZGVGcm9tVG8gPSBmdW5jdGlvbiBnZXROb2RlRnJvbVRvKHRvKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nKHRvKSA/IGN5LiQodG8pIDogdG8pWzBdO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRpc3RhbmNlVG8gPSBmdW5jdGlvbiBkaXN0YW5jZVRvKHRvKSB7XG4gICAgICAgIHJldHVybiBnZXRJbmZvKGdldE5vZGVGcm9tVG8odG8pKS5kaXN0O1xuICAgICAgfTtcblxuICAgICAgdmFyIHBhdGhUbyA9IGZ1bmN0aW9uIHBhdGhUbyh0bykge1xuICAgICAgICB2YXIgdGhpc1N0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiByb290O1xuICAgICAgICB2YXIgZW5kID0gZ2V0Tm9kZUZyb21Ubyh0byk7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIHZhciBub2RlID0gZW5kO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc3Bhd24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKG5vZGUpLFxuICAgICAgICAgICAgICBlZGdlID0gX2dldEluZm8uZWRnZSxcbiAgICAgICAgICAgICAgcHJlZCA9IF9nZXRJbmZvLnByZWQ7XG5cbiAgICAgICAgICBwYXRoLnVuc2hpZnQobm9kZVswXSk7XG5cbiAgICAgICAgICBpZiAobm9kZS5zYW1lKHRoaXNTdGFydCkgJiYgcGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQoZWRnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IHByZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihwYXRoKTtcbiAgICAgIH07IC8vIEluaXRpYWxpemF0aW9ucyB7IGRpc3QsIHByZWQsIGVkZ2UgfVxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgaW5mbyA9IGdldEluZm8obm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUuc2FtZShyb290KSkge1xuICAgICAgICAgIGluZm8uZGlzdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mby5kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvLnByZWQgPSBudWxsO1xuICAgICAgICBpbmZvLmVkZ2UgPSBudWxsO1xuICAgICAgfSAvLyBFZGdlcyByZWxheGF0aW9uXG5cblxuICAgICAgdmFyIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChub2RlMSwgbm9kZTIsIGVkZ2UsIGluZm8xLCBpbmZvMiwgd2VpZ2h0KSB7XG4gICAgICAgIHZhciBkaXN0ID0gaW5mbzEuZGlzdCArIHdlaWdodDtcblxuICAgICAgICBpZiAoZGlzdCA8IGluZm8yLmRpc3QgJiYgIWVkZ2Uuc2FtZShpbmZvMS5lZGdlKSkge1xuICAgICAgICAgIGluZm8yLmRpc3QgPSBkaXN0O1xuICAgICAgICAgIGluZm8yLnByZWQgPSBub2RlMTtcbiAgICAgICAgICBpbmZvMi5lZGdlID0gZWRnZTtcbiAgICAgICAgICByZXBsYWNlZEVkZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgICAgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBudW1FZGdlczsgZSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG5cbiAgICAgICAgICB2YXIgc3JjSW5mbyA9IGdldEluZm8oc3JjKTtcbiAgICAgICAgICB2YXIgdGd0SW5mbyA9IGdldEluZm8odGd0KTtcbiAgICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChzcmMsIHRndCwgZWRnZSwgc3JjSW5mbywgdGd0SW5mbywgX3dlaWdodCk7IC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG5cbiAgICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCh0Z3QsIHNyYywgZWRnZSwgdGd0SW5mbywgc3JjSW5mbywgX3dlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXBsYWNlZEVkZ2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVwbGFjZWRFZGdlKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2UgPSAwOyBfZSA8IG51bUVkZ2VzOyBfZSsrKSB7XG4gICAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2VdO1xuXG4gICAgICAgICAgdmFyIF9zcmMgPSBfZWRnZS5zb3VyY2UoKTtcblxuICAgICAgICAgIHZhciBfdGd0ID0gX2VkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgICB2YXIgX3dlaWdodDIgPSB3ZWlnaHRGbihfZWRnZSk7XG5cbiAgICAgICAgICB2YXIgc3JjRGlzdCA9IGdldEluZm8oX3NyYykuZGlzdDtcbiAgICAgICAgICB2YXIgdGd0RGlzdCA9IGdldEluZm8oX3RndCkuZGlzdDtcblxuICAgICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0IHx8ICFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUpIHtcbiAgICAgICAgICAgICAgd2FybignR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZCcpO1xuICAgICAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmluZE5lZ2F0aXZlV2VpZ2h0Q3ljbGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB2YXIgbmVnYXRpdmVOb2RlcyA9IFtdO1xuXG4gICAgICAgICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0KSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVOb2Rlcy5wdXNoKF9zcmMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVOb2Rlcy5wdXNoKF90Z3QpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG51bU5lZ2F0aXZlTm9kZXMgPSBuZWdhdGl2ZU5vZGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG51bU5lZ2F0aXZlTm9kZXM7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG5lZ2F0aXZlTm9kZXNbbl07XG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xlID0gW3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKGdldEluZm8oc3RhcnQpLmVkZ2UpO1xuICAgICAgICAgICAgICAgIHZhciBfbm9kZSA9IGdldEluZm8oc3RhcnQpLnByZWQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3ljbGUuaW5kZXhPZihfbm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKF9ub2RlKTtcbiAgICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhfbm9kZSkuZWRnZSk7XG4gICAgICAgICAgICAgICAgICBfbm9kZSA9IGdldEluZm8oX25vZGUpLnByZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShjeWNsZS5pbmRleE9mKF9ub2RlKSk7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SWQgPSBjeWNsZVswXS5pZCgpO1xuICAgICAgICAgICAgICAgIHZhciBzbWFsbGVzdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAyOyBjIDwgY3ljbGUubGVuZ3RoOyBjICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjeWNsZVtjXS5pZCgpIDwgc21hbGxlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdElkID0gY3ljbGVbY10uaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RJbmRleCA9IGM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShzbWFsbGVzdEluZGV4KS5jb25jYXQoY3ljbGUuc2xpY2UoMCwgc21hbGxlc3RJbmRleCkpO1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goY3ljbGVbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBjeWNsZUlkID0gY3ljbGUubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmlkKCk7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIixcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5pbmRleE9mKGN5Y2xlSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXMucHVzaChlbGVzLnNwYXduKGN5Y2xlKSk7XG4gICAgICAgICAgICAgICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLnB1c2goY3ljbGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2VUbzogZGlzdGFuY2VUbyxcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUsXG4gICAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzOiBuZWdhdGl2ZVdlaWdodEN5Y2xlc1xuICAgICAgfTtcbiAgICB9IC8vIGJlbGxtYW5Gb3JkXG5cbiAgfTsgLy8gZWxlc2ZuXG5cbiAgdmFyIHNxcnQyID0gTWF0aC5zcXJ0KDIpOyAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuICAvLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG5cbiAgdmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICAgIGlmIChyZW1haW5pbmdFZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGVycm9yKFwiS2FyZ2VyLVN0ZWluIG11c3QgYmUgcnVuIG9uIGEgY29ubmVjdGVkIChzdWIpZ3JhcGhcIik7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICAgIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFt0YXJnZXRJbl07XG4gICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7IC8vIHJlLXVzZSBhcnJheVxuICAgIC8vIERlbGV0ZSBhbGwgZWRnZXMgYmV0d2VlbiBwYXJ0aXRpb24xIGFuZCBwYXJ0aXRpb24yXG5cbiAgICBmb3IgKHZhciBpID0gbmV3RWRnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgICB2YXIgc3JjID0gZWRnZVsxXTtcbiAgICAgIHZhciB0Z3QgPSBlZGdlWzJdO1xuXG4gICAgICBpZiAobm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMiB8fCBub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICAgIG5ld0VkZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9IC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmV3RWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2VkZ2UgPSBuZXdFZGdlc1tfaV07XG5cbiAgICAgIGlmIChfZWRnZVsxXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAvLyBDaGVjayBzb3VyY2VcbiAgICAgICAgbmV3RWRnZXNbX2ldID0gX2VkZ2Uuc2xpY2UoKTsgLy8gY29weVxuXG4gICAgICAgIG5ld0VkZ2VzW19pXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgICB9IGVsc2UgaWYgKF9lZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgIC8vIENoZWNrIHRhcmdldFxuICAgICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgICAgbmV3RWRnZXNbX2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICAgIH1cbiAgICB9IC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG5cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVNYXAubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG5vZGVNYXBbX2kyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICBub2RlTWFwW19pMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdFZGdlcztcbiAgfTsgLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG5cblxuICB2YXIgY29udHJhY3RVbnRpbCA9IGZ1bmN0aW9uIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzLCBzaXplLCBzaXplTGltaXQpIHtcbiAgICB3aGlsZSAoc2l6ZSA+IHNpemVMaW1pdCkge1xuICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpOyAvLyBDb2xsYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG5cbiAgICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgICAgc2l6ZS0tO1xuICAgIH1cblxuICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgfTtcblxuICB2YXIgZWxlc2ZuJHAgPSB7XG4gICAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAgICBrYXJnZXJTdGVpbjogZnVuY3Rpb24ga2FyZ2VyU3RlaW4oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBzcXJ0Mik7XG5cbiAgICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgZXJyb3IoJ0F0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXItU3RlaW4gYWxnb3JpdGhtJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG5cblxuICAgICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBub2Rlcy5pbmRleE9mKGUuc291cmNlKCkpLCBub2Rlcy5pbmRleE9mKGUudGFyZ2V0KCkpXSk7XG4gICAgICB9IC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcblxuXG4gICAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkN1dEVkZ2VJbmRleGVzID0gW107XG4gICAgICB2YXIgbWluQ3V0Tm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7IC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuXG4gICAgICB2YXIgbWV0YU5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgdmFyIG1ldGFOb2RlTWFwMiA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG5cbiAgICAgIHZhciBjb3B5Tm9kZXNNYXAgPSBmdW5jdGlvbiBjb3B5Tm9kZXNNYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgICAgdG9bX2kzXSA9IGZyb21bX2kzXTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gTWFpbiBsb29wXG5cblxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIFJlc2V0IG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICAgICAgbWV0YU5vZGVNYXBbX2k0XSA9IF9pNDtcbiAgICAgICAgfSAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcblxuXG4gICAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMuc2xpY2UoKSwgbnVtTm9kZXMsIHN0b3BTaXplKTtcbiAgICAgICAgdmFyIGVkZ2VzU3RhdGUyID0gZWRnZXNTdGF0ZS5zbGljZSgpOyAvLyBjb3B5XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG5cbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtZXRhTm9kZU1hcDIpOyAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG5cbiAgICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUyLCBzdG9wU2l6ZSwgMik7IC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG5cbiAgICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczE7XG4gICAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMyO1xuICAgICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcDIsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcbiAgICAgIC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgICB2YXIgY3V0ID0gdGhpcy5zcGF3bihtaW5DdXRFZGdlSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzW2VbMF1dO1xuICAgICAgfSkpO1xuICAgICAgdmFyIHBhcnRpdGlvbjEgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgcGFydGl0aW9uMiA9IHRoaXMuc3Bhd24oKTsgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG5cbiAgICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dE5vZGVNYXBbMF07XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG1pbkN1dE5vZGVNYXAubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgcGFydGl0aW9uSWQgPSBtaW5DdXROb2RlTWFwW19pNV07XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbX2k1XTtcblxuICAgICAgICBpZiAocGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uKSB7XG4gICAgICAgICAgcGFydGl0aW9uMS5tZXJnZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0aXRpb24yLm1lcmdlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvbnN0cnVjdCBjb21wb25lbnRzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBkaXNqb2ludCBzdWJzZXQgb2Ygbm9kZXNcblxuXG4gICAgICB2YXIgY29uc3RydWN0Q29tcG9uZW50ID0gZnVuY3Rpb24gY29uc3RydWN0Q29tcG9uZW50KHN1YnNldCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuc3Bhd24oKTtcblxuICAgICAgICBzdWJzZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGVkZ2UgaXMgd2l0aGluIGNhbGxpbmcgY29sbGVjdGlvbiBhbmQgZWRnZSBpcyBub3QgaW4gY3V0XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29udGFpbnMoZWRnZSkgJiYgIWN1dC5jb250YWlucyhlZGdlKSkge1xuICAgICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgfTtcblxuICAgICAgdmFyIGNvbXBvbmVudHMgPSBbY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjEpLCBjb25zdHJ1Y3RDb21wb25lbnQocGFydGl0aW9uMildO1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgY3V0OiBjdXQsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAgIC8vIG4uYi4gcGFydGl0aW9ucyBhcmUgaW5jbHVkZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBvbGQgYXBpIHNwZWNcbiAgICAgICAgLy8gKGNvdWxkIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbilcbiAgICAgICAgcGFydGl0aW9uMTogcGFydGl0aW9uMSxcbiAgICAgICAgcGFydGl0aW9uMjogcGFydGl0aW9uMlxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9OyAvLyBlbGVzZm5cblxuICB2YXIgY29weVBvc2l0aW9uID0gZnVuY3Rpb24gY29weVBvc2l0aW9uKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54LFxuICAgICAgeTogcC55XG4gICAgfTtcbiAgfTtcbiAgdmFyIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgIHk6IHAueSAqIHpvb20gKyBwYW4ueVxuICAgIH07XG4gIH07XG4gIHZhciByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAocC54IC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHk6IChwLnkgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgfTtcbiAgdmFyIGFycmF5MnBvaW50ID0gZnVuY3Rpb24gYXJyYXkycG9pbnQoYXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGFyclswXSxcbiAgICAgIHk6IGFyclsxXVxuICAgIH07XG4gIH07XG4gIHZhciBtaW4gPSBmdW5jdGlvbiBtaW4oYXJyKSB7XG4gICAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9O1xuICB2YXIgbWF4ID0gZnVuY3Rpb24gbWF4KGFycikge1xuICAgIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgodmFsLCBtYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH07XG4gIHZhciBtZWFuID0gZnVuY3Rpb24gbWVhbihhcnIpIHtcbiAgICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBuID0gMDtcblxuICAgIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgICB0b3RhbCArPSB2YWw7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWwgLyBuO1xuICB9O1xuICB2YXIgbWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICAgIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICAgIHZhciBjb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIHZhciBzb3J0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgIHZhciBpbmNsdWRlSG9sZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG5cbiAgICBpZiAoY29weSkge1xuICAgICAgYXJyID0gYXJyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5kIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBhcnIuc3BsaWNlKGVuZCwgYXJyLmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiZWdpbiA+IDApIHtcbiAgICAgICAgYXJyLnNwbGljZSgwLCBiZWdpbik7XG4gICAgICB9XG4gICAgfSAvLyBhbGwgbm9uIGZpbml0ZSAoZS5nLiBJbmZpbml0eSwgTmFOKSBlbGVtZW50cyBtdXN0IGJlIC1JbmZpbml0eSBzbyB0aGV5IGdvIHRvIHRoZSBzdGFydFxuXG5cbiAgICB2YXIgb2ZmID0gMDsgLy8gb2Zmc2V0IGZyb20gbm9uLWZpbml0ZSB2YWx1ZXNcblxuICAgIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB2ID0gYXJyW2ldO1xuXG4gICAgICBpZiAoaW5jbHVkZUhvbGVzKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUodikpIHtcbiAgICAgICAgICBhcnJbaV0gPSAtSW5maW5pdHk7XG4gICAgICAgICAgb2ZmKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGp1c3QgcmVtb3ZlIGl0IGlmIHdlIGRvbid0IHdhbnQgdG8gY29uc2lkZXIgaG9sZXNcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSk7IC8vIHJlcXVpcmVzIGNvcHkgPSB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb3JpZ1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuXG4gICAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICAgIHJldHVybiBhcnJbbWlkICsgMSArIG9mZl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYXJyW21pZCAtIDEgKyBvZmZdICsgYXJyW21pZCArIG9mZl0pIC8gMjtcbiAgICB9XG4gIH07XG4gIHZhciBkZWcycmFkID0gZnVuY3Rpb24gZGVnMnJhZChkZWcpIHtcbiAgICByZXR1cm4gTWF0aC5QSSAqIGRlZyAvIDE4MDtcbiAgfTtcbiAgdmFyIGdldEFuZ2xlRnJvbURpc3AgPSBmdW5jdGlvbiBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKGRpc3BZLCBkaXNwWCkgLSBNYXRoLlBJIC8gMjtcbiAgfTtcbiAgdmFyIGxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTWF0aC5sb2cobikgLyBNYXRoLmxvZygyKTtcbiAgfTtcbiAgdmFyIHNpZ251bSA9IGZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gICAgaWYgKHggPiAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRpc3QgPSBmdW5jdGlvbiBkaXN0KHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoc3FkaXN0KHAxLCBwMikpO1xuICB9O1xuICB2YXIgc3FkaXN0ID0gZnVuY3Rpb24gc3FkaXN0KHAxLCBwMikge1xuICAgIHZhciBkeCA9IHAyLnggLSBwMS54O1xuICAgIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfTtcbiAgdmFyIGluUGxhY2VTdW1Ob3JtYWxpemUgPSBmdW5jdGlvbiBpblBsYWNlU3VtTm9ybWFsaXplKHYpIHtcbiAgICB2YXIgbGVuZ3RoID0gdi5sZW5ndGg7IC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuXG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IHZbaV07XG4gICAgfSAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICAgIHZbX2ldID0gdltfaV0gLyB0b3RhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcWJlemllckF0ID0gZnVuY3Rpb24gcWJlemllckF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbiAgfTtcbiAgdmFyIHFiZXppZXJQdEF0ID0gZnVuY3Rpb24gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBxYmV6aWVyQXQocDAueCwgcDEueCwgcDIueCwgdCksXG4gICAgICB5OiBxYmV6aWVyQXQocDAueSwgcDEueSwgcDIueSwgdClcbiAgICB9O1xuICB9O1xuICB2YXIgbGluZUF0ID0gZnVuY3Rpb24gbGluZUF0KHAwLCBwMSwgdCwgZCkge1xuICAgIHZhciB2ZWMgPSB7XG4gICAgICB4OiBwMS54IC0gcDAueCxcbiAgICAgIHk6IHAxLnkgLSBwMC55XG4gICAgfTtcbiAgICB2YXIgdmVjRGlzdCA9IGRpc3QocDAsIHAxKTtcbiAgICB2YXIgbm9ybVZlYyA9IHtcbiAgICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICAgIHk6IHZlYy55IC8gdmVjRGlzdFxuICAgIH07XG4gICAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuICAgIGQgPSBkICE9IG51bGwgPyBkIDogdCAqIHZlY0Rpc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgICAgeTogcDAueSArIG5vcm1WZWMueSAqIGRcbiAgICB9O1xuICB9O1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiBib3VuZChtaW4sIHZhbCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWwpKTtcbiAgfTsgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcblxuICB2YXIgbWFrZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gbWFrZUJvdW5kaW5nQm94KGJiKSB7XG4gICAgaWYgKGJiID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgICB4MjogLUluZmluaXR5LFxuICAgICAgICB5MjogLUluZmluaXR5LFxuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsKSB7XG4gICAgICBpZiAoYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICB4MjogYmIueDIsXG4gICAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogYmIueDEsXG4gICAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgICB3OiBiYi53LFxuICAgICAgICAgIGg6IGJiLmhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBjb3B5Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjb3B5Qm91bmRpbmdCb3goYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGJiLngxLFxuICAgICAgeDI6IGJiLngyLFxuICAgICAgdzogYmIudyxcbiAgICAgIHkxOiBiYi55MSxcbiAgICAgIHkyOiBiYi55MixcbiAgICAgIGg6IGJiLmhcbiAgICB9O1xuICB9O1xuICB2YXIgY2xlYXJCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNsZWFyQm91bmRpbmdCb3goYmIpIHtcbiAgICBiYi54MSA9IEluZmluaXR5O1xuICAgIGJiLnkxID0gSW5maW5pdHk7XG4gICAgYmIueDIgPSAtSW5maW5pdHk7XG4gICAgYmIueTIgPSAtSW5maW5pdHk7XG4gICAgYmIudyA9IDA7XG4gICAgYmIuaCA9IDA7XG4gIH07XG4gIHZhciB1cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gICAgLy8gdXBkYXRlIGJiMSB3aXRoIGJiMiBib3VuZHNcbiAgICBiYjEueDEgPSBNYXRoLm1pbihiYjEueDEsIGJiMi54MSk7XG4gICAgYmIxLngyID0gTWF0aC5tYXgoYmIxLngyLCBiYjIueDIpO1xuICAgIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICAgIGJiMS55MSA9IE1hdGgubWluKGJiMS55MSwgYmIyLnkxKTtcbiAgICBiYjEueTIgPSBNYXRoLm1heChiYjEueTIsIGJiMi55Mik7XG4gICAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG4gIH07XG4gIHZhciBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHgsIHkpIHtcbiAgICBiYi54MSA9IE1hdGgubWluKGJiLngxLCB4KTtcbiAgICBiYi54MiA9IE1hdGgubWF4KGJiLngyLCB4KTtcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi55MSA9IE1hdGgubWluKGJiLnkxLCB5KTtcbiAgICBiYi55MiA9IE1hdGgubWF4KGJiLnkyLCB5KTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgfTtcbiAgdmFyIGV4cGFuZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3goYmIpIHtcbiAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBiYi54MSAtPSBwYWRkaW5nO1xuICAgIGJiLngyICs9IHBhZGRpbmc7XG4gICAgYmIueTEgLT0gcGFkZGluZztcbiAgICBiYi55MiArPSBwYWRkaW5nO1xuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIHJldHVybiBiYjtcbiAgfTtcbiAgdmFyIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiKSB7XG4gICAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFswXTtcbiAgICB2YXIgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0O1xuXG4gICAgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICB0b3AgPSByaWdodCA9IGJvdHRvbSA9IGxlZnQgPSBwYWRkaW5nWzBdO1xuICAgIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRvcCA9IGJvdHRvbSA9IHBhZGRpbmdbMF07XG4gICAgICBsZWZ0ID0gcmlnaHQgPSBwYWRkaW5nWzFdO1xuICAgIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBfcGFkZGluZyA9IF9zbGljZWRUb0FycmF5KHBhZGRpbmcsIDQpO1xuXG4gICAgICB0b3AgPSBfcGFkZGluZ1swXTtcbiAgICAgIHJpZ2h0ID0gX3BhZGRpbmdbMV07XG4gICAgICBib3R0b20gPSBfcGFkZGluZ1syXTtcbiAgICAgIGxlZnQgPSBfcGFkZGluZ1szXTtcbiAgICB9XG5cbiAgICBiYi54MSAtPSBsZWZ0O1xuICAgIGJiLngyICs9IHJpZ2h0O1xuICAgIGJiLnkxIC09IHRvcDtcbiAgICBiYi55MiArPSBib3R0b207XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgcmV0dXJuIGJiO1xuICB9O1xuXG4gIHZhciBhc3NpZ25Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gICAgYmIxLngxID0gYmIyLngxO1xuICAgIGJiMS55MSA9IGJiMi55MTtcbiAgICBiYjEueDIgPSBiYjIueDI7XG4gICAgYmIxLnkyID0gYmIyLnkyO1xuICAgIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICAgIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xuICB9O1xuICB2YXIgYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIxLCBiYjIpIHtcbiAgICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgICBpZiAoYmIxLngxID4gYmIyLngyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGJiMi54MSA+IGJiMS54Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcblxuXG4gICAgaWYgKGJiMS54MiA8IGJiMi54MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChiYjIueDIgPCBiYjEueDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuXG5cbiAgICBpZiAoYmIxLnkyIDwgYmIyLnkxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGJiMi55MiA8IGJiMS55MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG5cblxuICAgIGlmIChiYjEueTEgPiBiYjIueTIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYmIyLnkxID4gYmIxLnkyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciBpbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkge1xuICAgIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xuICB9O1xuICB2YXIgcG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gcG9pbnRJbkJvdW5kaW5nQm94KGJiLCBwdCkge1xuICAgIHJldHVybiBpbkJvdW5kaW5nQm94KGJiLCBwdC54LCBwdC55KTtcbiAgfTtcbiAgdmFyIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICAgIHJldHVybiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngxLCBiYjIueTEpICYmIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDIsIGJiMi55Mik7XG4gIH07XG4gIHZhciByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyOyAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuXG4gICAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7IC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG5cbiAgICB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcblxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9IC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICAgIHtcbiAgICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlKTtcblxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9IC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG5cbiAgICB7XG4gICAgICB2YXIgYm90dG9tU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHZhciBib3R0b21FbmRZID0gYm90dG9tU3RhcnRZO1xuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcblxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9IC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuXG4gICAge1xuICAgICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuXG4gICAgdmFyIGFyY0ludGVyc2VjdGlvbnM7IC8vIFRvcCBMZWZ0XG5cbiAgICB7XG4gICAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgdG9wTGVmdENlbnRlclgsIHRvcExlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcExlZnRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfSAvLyBUb3AgUmlnaHRcblxuICAgIHtcbiAgICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9IC8vIEJvdHRvbSBSaWdodFxuXG4gICAge1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH0gLy8gQm90dG9tIExlZnRcblxuICAgIHtcbiAgICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21MZWZ0Q2VudGVyWCwgYm90dG9tTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tTGVmdENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG4gIH07XG4gIHZhciBpbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uIGluTGluZVZpY2luaXR5KHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKSB7XG4gICAgdmFyIHQgPSB0b2xlcmFuY2U7XG4gICAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICAgIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gICAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuICAgIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdCAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbiAgfTtcbiAgdmFyIGluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbiBpbkJlemllclZpY2luaXR5KHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuICAgIHZhciBiYiA9IHtcbiAgICAgIHgxOiBNYXRoLm1pbih4MSwgeDMsIHgyKSAtIHRvbGVyYW5jZSxcbiAgICAgIHgyOiBNYXRoLm1heCh4MSwgeDMsIHgyKSArIHRvbGVyYW5jZSxcbiAgICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICAgIHkyOiBNYXRoLm1heCh5MSwgeTMsIHkyKSArIHRvbGVyYW5jZVxuICAgIH07IC8vIGlmIG91dHNpZGUgdGhlIHJvdWdoIGJvdW5kaW5nIGJveCBmb3IgdGhlIGJlemllciwgdGhlbiBpdCBjYW4ndCBiZSBhIGhpdFxuXG4gICAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHNvbHZlUXVhZHJhdGljID0gZnVuY3Rpb24gc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgdmFsKSB7XG4gICAgYyAtPSB2YWw7XG4gICAgdmFyIHIgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChyIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzcXJ0UiA9IE1hdGguc3FydChyKTtcbiAgICB2YXIgZGVub20gPSAyICogYTtcbiAgICB2YXIgcm9vdDEgPSAoLWIgKyBzcXJ0UikgLyBkZW5vbTtcbiAgICB2YXIgcm9vdDIgPSAoLWIgLSBzcXJ0UikgLyBkZW5vbTtcbiAgICByZXR1cm4gW3Jvb3QxLCByb290Ml07XG4gIH07XG4gIHZhciBzb2x2ZUN1YmljID0gZnVuY3Rpb24gc29sdmVDdWJpYyhhLCBiLCBjLCBkLCByZXN1bHQpIHtcbiAgICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAgIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG4gICAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcbiAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDE7IC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hpbGUga2VlcGluZyB0aGUgb3ZlcmFsbCBleHByZXNzaW9uIGNsb3NlIGluIHZhbHVlXG5cbiAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgYSA9IGVwc2lsb247XG4gICAgfVxuXG4gICAgYiAvPSBhO1xuICAgIGMgLz0gYTtcbiAgICBkIC89IGE7XG4gICAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcbiAgICBxID0gKDMuMCAqIGMgLSBiICogYikgLyA5LjA7XG4gICAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gICAgciAvPSA1NC4wO1xuICAgIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgdGVybTEgPSBiIC8gMy4wO1xuXG4gICAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgICBzID0gcyA8IDAgPyAtTWF0aC5wb3coLXMsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhzLCAxLjAgLyAzLjApO1xuICAgICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHQgPSB0IDwgMCA/IC1NYXRoLnBvdygtdCwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHQsIDEuMCAvIDMuMCk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcblxuICAgIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICAgIHIxMyA9IHIgPCAwID8gLU1hdGgucG93KC1yLCAxLjAgLyAzLjApIDogTWF0aC5wb3cociwgMS4wIC8gMy4wKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHEgPSAtcTtcbiAgICBkdW0xID0gcSAqIHEgKiBxO1xuICAgIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gICAgcjEzID0gMi4wICogTWF0aC5zcXJ0KHEpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKGR1bTEgLyAzLjApO1xuICAgIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICAgIHJlc3VsdFs0XSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgNC4wICogTWF0aC5QSSkgLyAzLjApO1xuICAgIHJldHVybjtcbiAgfTtcbiAgdmFyIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24gc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gICAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAgIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgICB2YXIgYSA9IDEuMCAqIHgxICogeDEgLSA0ICogeDEgKiB4MiArIDIgKiB4MSAqIHgzICsgNCAqIHgyICogeDIgLSA0ICogeDIgKiB4MyArIHgzICogeDMgKyB5MSAqIHkxIC0gNCAqIHkxICogeTIgKyAyICogeTEgKiB5MyArIDQgKiB5MiAqIHkyIC0gNCAqIHkyICogeTMgKyB5MyAqIHkzO1xuICAgIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG4gICAgdmFyIGMgPSAxLjAgKiAzICogeDEgKiB4MSAtIDYgKiB4MSAqIHgyICsgeDEgKiB4MyAtIHgxICogeCArIDIgKiB4MiAqIHgyICsgMiAqIHgyICogeCAtIHgzICogeCArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuICAgIHZhciBkID0gMS4wICogeDEgKiB4MiAtIHgxICogeDEgKyB4MSAqIHggLSB4MiAqIHggKyB5MSAqIHkyIC0geTEgKiB5MSArIHkxICogeSAtIHkyICogeTsgLy8gZGVidWcoXCJjb2VmZmljaWVudHM6IFwiICsgYSAvIGEgKyBcIiwgXCIgKyBiIC8gYSArIFwiLCBcIiArIGMgLyBhICsgXCIsIFwiICsgZCAvIGEpO1xuXG4gICAgdmFyIHJvb3RzID0gW107IC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cblxuICAgIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICAgIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyKSB7XG4gICAgICBpZiAoTWF0aC5hYnMocm9vdHNbaW5kZXggKyAxXSkgPCB6ZXJvVGhyZXNob2xkICYmIHJvb3RzW2luZGV4XSA+PSAwICYmIHJvb3RzW2luZGV4XSA8PSAxLjApIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJhbXMucHVzaCgxLjApO1xuICAgIHBhcmFtcy5wdXNoKDAuMCk7XG4gICAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICAgIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDEgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MiArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuICAgICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MSArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeTM7XG4gICAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTsgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG5cbiAgICAgIGlmIChtaW5EaXN0YW5jZVNxdWFyZWQgPj0gMCkge1xuICAgICAgICBpZiAoZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbiAgfTtcbiAgdmFyIHNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uIHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICAgIHZhciBsaW5lID0gW3gyIC0geDEsIHkyIC0geTFdO1xuICAgIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gICAgaWYgKGRvdFByb2R1Y3QgPCAwKSB7XG4gICAgICByZXR1cm4gaHlwU3E7XG4gICAgfVxuXG4gICAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgICByZXR1cm4gKHggLSB4MikgKiAoeCAtIHgyKSArICh5IC0geTIpICogKHkgLSB5Mik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG4gIH07XG4gIHZhciBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSB7XG4gICAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICAgIHZhciB5MzsgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuXG4gICAgdmFyIHVwID0gMDsgLy8gbGV0IGRvd24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSA7IGVsc2UgaWYgKHgxID49IHggJiYgeCA+PSB4MiB8fCB4MSA8PSB4ICYmIHggPD0geDIpIHtcbiAgICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgICB1cCsrO1xuICAgICAgICB9IC8vIGlmKCB5MyA8IHkgKXtcbiAgICAgICAgLy8gZG93bisrO1xuICAgICAgICAvLyB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB2YXIgcG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7IC8vIEdpdmVzIG5lZ2F0aXZlIGFuZ2xlXG5cbiAgICB2YXIgYW5nbGU7XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdICE9IG51bGwpIHtcbiAgICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb25bMF0gPCAwKSB7XG4gICAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpOyAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gd2lkdGggLyAyICogKGJhc2VQb2ludHNbaSAqIDJdICogY29zIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cblxuICAgIHZhciBwb2ludHM7XG5cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICB9O1xuICB2YXIgcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGN1dFBvbHlnb25Qb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHNxdWFyZWRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgKiBjb3JuZXJSYWRpdXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlVXYgPSB2b2lkIDAsXG4gICAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBzb3VyY2VVdiA9IGJhc2VQb2ludHMubGVuZ3RoIC0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgICAgfVxuXG4gICAgICBkZXN0VXYgPSBpICogNCArIDI7XG4gICAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICAgIHZhciBweSA9IGNlbnRlclkgKyBoYWxmSCAqIGJhc2VQb2ludHNbaSAqIDQgKyAxXTtcbiAgICAgIHZhciBjb3NUaGV0YSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XSAqIGJhc2VQb2ludHNbZGVzdFV2XSAtIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDRdID0gY3AweDtcbiAgICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAxXSA9IGNwMHk7XG4gICAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMl0gPSBjcDF4O1xuICAgICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDNdID0gY3AxeTtcbiAgICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICAgIHZhciBvcnRoeSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICAgIHZhciBjb3NBbHBoYSA9IG9ydGh4ICogYmFzZVBvaW50c1tkZXN0VXZdICsgb3J0aHkgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICAgIG9ydGh4ICo9IC0xO1xuICAgICAgICBvcnRoeSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN4ID0gY3AweCArIG9ydGh4ICogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGN5ID0gY3AweSArIG9ydGh5ICogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGN4IC0geCwgMikgKyBNYXRoLnBvdyhjeSAtIHksIDIpO1xuXG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IHNxdWFyZWRDb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRQb2x5Z29uUG9pbnRzKTtcbiAgfTtcbiAgdmFyIGpvaW5MaW5lcyA9IGZ1bmN0aW9uIGpvaW5MaW5lcyhsaW5lU2V0KSB7XG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gICAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gICAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbaSAqIDRdO1xuICAgICAgY3VycmVudExpbmVTdGFydFkgPSBsaW5lU2V0W2kgKiA0ICsgMV07XG4gICAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0W2kgKiA0ICsgM107XG5cbiAgICAgIGlmIChpIDwgbGluZVNldC5sZW5ndGggLyA0IC0gMSkge1xuICAgICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsoaSArIDEpICogNCArIDJdO1xuICAgICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbMF07XG4gICAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsyXTtcbiAgICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFszXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksIHRydWUpO1xuICAgICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVydGljZXM7XG4gIH07XG4gIHZhciBleHBhbmRQb2x5Z29uID0gZnVuY3Rpb24gZXhwYW5kUG9seWdvbihwb2ludHMsIHBhZCkge1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgICB9IC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcblxuXG4gICAgICB2YXIgb2Zmc2V0WCA9IG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZO1xuICAgICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTsgLy8gTm9ybWFsaXplXG5cbiAgICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNF0gPSBjdXJyZW50UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgM10gPSBuZXh0UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbiAgfTtcbiAgdmFyIGludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gICAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gICAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gICAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gICAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gICAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gICAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG5cbiAgICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICAgIHJldHVybiBbKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHldO1xuICB9O1xuICB2YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgeCAtPSBjZW50ZXJYO1xuICAgIHkgLT0gY2VudGVyWTtcbiAgICB4IC89IHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgeSAvPSBoZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xuICB9OyAvLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxuXG4gIHZhciBpbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUNpcmNsZSh4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcblxuICAgIHZhciBmID0gW3gxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZXTtcbiAgICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gICAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICAgIHZhciBjID0gZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSAtIHJhZGl1cyAqIHJhZGl1cztcbiAgICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gICAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICAgIHZhciBpblJhbmdlUGFyYW1zID0gW107XG5cbiAgICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICAgIH1cblxuICAgIGlmICh0TWF4ID49IDAgJiYgdE1heCA8PSAxKSB7XG4gICAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gICAgfVxuXG4gICAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gICAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblksIGZhckludGVyc2VjdGlvblgsIGZhckludGVyc2VjdGlvblldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICB9O1xuICB2YXIgbWlkT2ZUaHJlZSA9IGZ1bmN0aW9uIG1pZE9mVGhyZWUoYSwgYiwgYykge1xuICAgIGlmIChiIDw9IGEgJiYgYSA8PSBjIHx8IGMgPD0gYSAmJiBhIDw9IGIpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH0gZWxzZSBpZiAoYSA8PSBiICYmIGIgPD0gYyB8fCBjIDw9IGIgJiYgYiA8PSBhKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9OyAvLyAoeDEseTEpPT4oeDIseTIpIGludGVyc2VjdCB3aXRoICh4Myx5Myk9Pih4NCx5NClcblxuICB2YXIgZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiBmaW5pdGVMaW5lc0ludGVyc2VjdCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcbiAgICB2YXIgZHgxMyA9IHgxIC0geDM7XG4gICAgdmFyIGR4MjEgPSB4MiAtIHgxO1xuICAgIHZhciBkeDQzID0geDQgLSB4MztcbiAgICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gICAgdmFyIGR5MjEgPSB5MiAtIHkxO1xuICAgIHZhciBkeTQzID0geTQgLSB5MztcbiAgICB2YXIgdWFfdCA9IGR4NDMgKiBkeTEzIC0gZHk0MyAqIGR4MTM7XG4gICAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICAgIHZhciB1X2IgPSBkeTQzICogZHgyMSAtIGR4NDMgKiBkeTIxO1xuXG4gICAgaWYgKHVfYiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG4gICAgICB2YXIgZmxwdFRocmVzaG9sZCA9IDAuMDAxO1xuXG4gICAgICB2YXIgX21pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuXG4gICAgICB2YXIgX21heCA9IDEgKyBmbHB0VGhyZXNob2xkO1xuXG4gICAgICBpZiAoX21pbiA8PSB1YSAmJiB1YSA8PSBfbWF4ICYmIF9taW4gPD0gdWIgJiYgdWIgPD0gX21heCkge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcbiAgICAgICAgLy8gUGFyYWxsZWwsIGNvaW5jaWRlbnQgbGluZXMuIENoZWNrIGlmIG92ZXJsYXBcbiAgICAgICAgLy8gQ2hlY2sgZW5kcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4NCkgPT09IHg0KSB7XG4gICAgICAgICAgcmV0dXJuIFt4NCwgeTRdO1xuICAgICAgICB9IC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG5cblxuICAgICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHgzKSA9PT0geDMpIHtcbiAgICAgICAgICByZXR1cm4gW3gzLCB5M107XG4gICAgICAgIH0gLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuXG5cbiAgICAgICAgaWYgKG1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgICAgcmV0dXJuIFt4MiwgeTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKVxuICAvLyBpbnRlcnNlY3QgYSBub2RlIHBvbHlnb24gKHB0cyB0cmFuc2Zvcm1lZClcbiAgLy9cbiAgLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSApXG4gIC8vIGludGVyc2VjdCB0aGUgcG9pbnRzIChubyB0cmFuc2Zvcm0pXG5cbiAgdmFyIHBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgdmFyIGludGVyc2VjdGlvbjtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICAgIHZhciBkb1RyYW5zZm9ybSA9IHRydWU7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgZG9UcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzO1xuXG4gICAgaWYgKGRvVHJhbnNmb3JtKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSBiYXNlUG9pbnRzW2kgKiAyXSAqIHdpZHRoICsgY2VudGVyWDtcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSBiYXNlUG9pbnRzO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvaW50cy5sZW5ndGggLyAyOyBfaTIrKykge1xuICAgICAgY3VycmVudFggPSBwb2ludHNbX2kyICogMl07XG4gICAgICBjdXJyZW50WSA9IHBvaW50c1tfaTIgKiAyICsgMV07XG5cbiAgICAgIGlmIChfaTIgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFggPSBwb2ludHNbKF9pMiArIDEpICogMl07XG4gICAgICAgIG5leHRZID0gcG9pbnRzWyhfaTIgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFkpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuICB2YXIgcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgdmFyIGludGVyc2VjdGlvbjtcbiAgICB2YXIgbGluZXMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlVXYgPSB2b2lkIDAsXG4gICAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBzb3VyY2VVdiA9IGJhc2VQb2ludHMubGVuZ3RoIC0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgICAgfVxuXG4gICAgICBkZXN0VXYgPSBpICogNCArIDI7XG4gICAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICAgIHZhciBweSA9IGNlbnRlclkgKyBoYWxmSCAqIGJhc2VQb2ludHNbaSAqIDQgKyAxXTtcbiAgICAgIHZhciBjb3NUaGV0YSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XSAqIGJhc2VQb2ludHNbZGVzdFV2XSAtIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgbGluZXNbYmFzZVBvaW50cy5sZW5ndGggLSAyXSA9IGNwMHg7XG4gICAgICAgIGxpbmVzW2Jhc2VQb2ludHMubGVuZ3RoIC0gMV0gPSBjcDB5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZXNbaSAqIDQgLSAyXSA9IGNwMHg7XG4gICAgICAgIGxpbmVzW2kgKiA0IC0gMV0gPSBjcDB5O1xuICAgICAgfVxuXG4gICAgICBsaW5lc1tpICogNF0gPSBjcDF4O1xuICAgICAgbGluZXNbaSAqIDQgKyAxXSA9IGNwMXk7XG4gICAgICB2YXIgb3J0aHggPSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgICB2YXIgY29zQWxwaGEgPSBvcnRoeCAqIGJhc2VQb2ludHNbZGVzdFV2XSArIG9ydGh5ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgICAgaWYgKGNvc0FscGhhIDwgMCkge1xuICAgICAgICBvcnRoeCAqPSAtMTtcbiAgICAgICAgb3J0aHkgKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBjeSA9IGNwMHkgKyBvcnRoeSAqIGNvcm5lclJhZGl1cztcbiAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY3gsIGN5LCBjb3JuZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpbmVzLmxlbmd0aCAvIDQ7IF9pMysrKSB7XG4gICAgICBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBsaW5lc1tfaTMgKiA0XSwgbGluZXNbX2kzICogNCArIDFdLCBsaW5lc1tfaTMgKiA0ICsgMl0sIGxpbmVzW19pMyAqIDQgKyAzXSwgZmFsc2UpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhciBsb3dlc3RJbnRlcnNlY3Rpb24gPSBbaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB2YXIgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzBdIC0geCwgMikgKyBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMV0gLSB5LCAyKTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgaW50ZXJzZWN0aW9ucy5sZW5ndGggLyAyOyBfaTQrKykge1xuICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3coaW50ZXJzZWN0aW9uc1tfaTQgKiAyXSAtIHgsIDIpICsgTWF0aC5wb3coaW50ZXJzZWN0aW9uc1tfaTQgKiAyICsgMV0gLSB5LCAyKTtcblxuICAgICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IGxvd2VzdFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICAgIGxvd2VzdEludGVyc2VjdGlvblswXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMl07XG4gICAgICAgICAgbG93ZXN0SW50ZXJzZWN0aW9uWzFdID0gaW50ZXJzZWN0aW9uc1tfaTQgKiAyICsgMV07XG4gICAgICAgICAgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb3dlc3RJbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIHZhciBzaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gICAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gICAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgICBpZiAobGVuUmF0aW8gPCAwKSB7XG4gICAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvZmZzZXRbMF0gKyBsZW5SYXRpbyAqIGRpc3BbMF0sIG9mZnNldFsxXSArIGxlblJhdGlvICogZGlzcFsxXV07XG4gIH07XG4gIHZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIHZhciBwb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICAgIHBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG4gIHZhciBmaXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbiBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKSB7XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHNpZGVzID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICB4ID0gcG9pbnRzWzIgKiBpXTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICB9IC8vIHN0cmV0Y2ggZmFjdG9yc1xuXG5cbiAgICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNpZGVzOyBfaTUrKykge1xuICAgICAgeCA9IHBvaW50c1syICogX2k1XSA9IHBvaW50c1syICogX2k1XSAqIHN4O1xuICAgICAgeSA9IHBvaW50c1syICogX2k1ICsgMV0gPSBwb2ludHNbMiAqIF9pNSArIDFdICogc3k7XG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgfVxuXG4gICAgaWYgKG1pblkgPCAtMSkge1xuICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgc2lkZXM7IF9pNisrKSB7XG4gICAgICAgIHkgPSBwb2ludHNbMiAqIF9pNiArIDFdID0gcG9pbnRzWzIgKiBfaTYgKyAxXSArICgtMSAtIG1pblkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG4gIHZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG4gICAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaWRlcyAlIDIgPT09IDAgPyBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG4gICAgdmFyIGN1cnJlbnRBbmdsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgICBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsgLy8geFxuXG4gICAgICBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOyAvLyB5XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTsgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1cywgdW5sZXNzIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBkZWZhdWx0XG5cbiAgdmFyIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xuICB9OyAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzXG5cbiAgdmFyIGdldFJvdW5kUG9seWdvblJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gMTAsIGhlaWdodCAvIDEwLCA4KTtcbiAgfTtcbiAgdmFyIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCA9IGZ1bmN0aW9uIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIHtcbiAgICByZXR1cm4gODtcbiAgfTtcbiAgdmFyIGJlemllclB0c1RvUXVhZENvZWZmID0gZnVuY3Rpb24gYmV6aWVyUHRzVG9RdWFkQ29lZmYocDAsIHAxLCBwMikge1xuICAgIHJldHVybiBbcDAgLSAyICogcDEgKyBwMiwgMiAqIChwMSAtIHAwKSwgcDBdO1xuICB9OyAvLyBnZXQgY3VydmUgd2lkdGgsIGhlaWdodCwgYW5kIGNvbnRyb2wgcG9pbnQgcG9zaXRpb24gb2Zmc2V0cyBhcyBhIHBlcmNlbnRhZ2Ugb2Ygbm9kZSBoZWlnaHQgLyB3aWR0aFxuXG4gIHZhciBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGZ1bmN0aW9uIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0T2Zmc2V0OiBNYXRoLm1pbigxNSwgMC4wNSAqIGhlaWdodCksXG4gICAgICB3aWR0aE9mZnNldDogTWF0aC5taW4oMTAwLCAwLjI1ICogd2lkdGgpLFxuICAgICAgY3RybFB0T2Zmc2V0UGN0OiAwLjA1XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcGFnZVJhbmtEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIGRhbXBpbmdGYWN0b3I6IDAuOCxcbiAgICBwcmVjaXNpb246IDAuMDAwMDAxLFxuICAgIGl0ZXJhdGlvbnM6IDIwMCxcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZWxlc2ZuJG8gPSB7XG4gICAgcGFnZVJhbms6IGZ1bmN0aW9uIHBhZ2VSYW5rKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfcGFnZVJhbmtEZWZhdWx0cyA9IHBhZ2VSYW5rRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgZGFtcGluZ0ZhY3RvciA9IF9wYWdlUmFua0RlZmF1bHRzLmRhbXBpbmdGYWN0b3IsXG4gICAgICAgICAgcHJlY2lzaW9uID0gX3BhZ2VSYW5rRGVmYXVsdHMucHJlY2lzaW9uLFxuICAgICAgICAgIGl0ZXJhdGlvbnMgPSBfcGFnZVJhbmtEZWZhdWx0cy5pdGVyYXRpb25zLFxuICAgICAgICAgIHdlaWdodCA9IF9wYWdlUmFua0RlZmF1bHRzLndlaWdodDtcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtTm9kZXNTcWQgPSBudW1Ob2RlcyAqIG51bU5vZGVzO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoOyAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuXG4gICAgICB2YXIgbWF0cml4ID0gbmV3IEFycmF5KG51bU5vZGVzU3FkKTtcbiAgICAgIHZhciBjb2x1bW5TdW0gPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzOyAvLyBDcmVhdGUgbnVsbCBtYXRyaXhcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIHZhciBuID0gaSAqIG51bU5vZGVzICsgajtcbiAgICAgICAgICBtYXRyaXhbbl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uU3VtW2ldID0gMDtcbiAgICAgIH0gLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUVkZ2VzOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgICB2YXIgdGd0SWQgPSBlZGdlLmRhdGEoJ3RhcmdldCcpOyAvLyBEb24ndCBpbmNsdWRlIGxvb3BzIGluIHRoZSBtYXRyaXhcblxuICAgICAgICBpZiAoc3JjSWQgPT09IHRndElkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcyA9IG5vZGVzLmluZGV4T2ZJZChzcmNJZCk7XG4gICAgICAgIHZhciB0ID0gbm9kZXMuaW5kZXhPZklkKHRndElkKTtcbiAgICAgICAgdmFyIHcgPSB3ZWlnaHQoZWRnZSk7XG5cbiAgICAgICAgdmFyIF9uID0gdCAqIG51bU5vZGVzICsgczsgLy8gVXBkYXRlIG1hdHJpeFxuXG5cbiAgICAgICAgbWF0cml4W19uXSArPSB3OyAvLyBVcGRhdGUgY29sdW1uIHN1bVxuXG4gICAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgICAgfSAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuXG5cbiAgICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG51bU5vZGVzOyBfaisrKSB7XG4gICAgICAgIGlmIChjb2x1bW5TdW1bX2pdID09PSAwKSB7XG4gICAgICAgICAgLy8gTm8gJ2xpbmtzJyBvdXQgZnJvbSBub2RlIGp0aCwgYXNzdW1lIGVxdWFsIHByb2JhYmlsaXR5IGZvciBlYWNoIHBvc3NpYmxlIG5vZGVcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBudW1Ob2RlczsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBfbjIgPSBfaTIgKiBudW1Ob2RlcyArIF9qO1xuXG4gICAgICAgICAgICBtYXRyaXhbX24yXSA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIF9uMyA9IF9pMyAqIG51bU5vZGVzICsgX2o7XG5cbiAgICAgICAgICAgIG1hdHJpeFtfbjNdID0gbWF0cml4W19uM10gLyBjb2x1bW5TdW1bX2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG5cblxuICAgICAgdmFyIGVpZ2VudmVjdG9yID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIHZhciB0ZW1wID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIHZhciBwcmV2aW91czsgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgZWlnZW52ZWN0b3JbX2k0XSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAgIC8vIFRlbXAgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bU5vZGVzOyBfaTUrKykge1xuICAgICAgICAgIHRlbXBbX2k1XSA9IDA7XG4gICAgICAgIH0gLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG5cblxuICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBudW1Ob2RlczsgX2k2KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBudW1Ob2RlczsgX2oyKyspIHtcbiAgICAgICAgICAgIHZhciBfbjQgPSBfaTYgKiBudW1Ob2RlcyArIF9qMjtcblxuICAgICAgICAgICAgdGVtcFtfaTZdICs9IG1hdHJpeFtfbjRdICogZWlnZW52ZWN0b3JbX2oyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpblBsYWNlU3VtTm9ybWFsaXplKHRlbXApO1xuICAgICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG4gICAgICAgIHRlbXAgPSBwcmV2aW91cztcbiAgICAgICAgdmFyIGRpZmYgPSAwOyAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcblxuICAgICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBudW1Ob2RlczsgX2k3KyspIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBwcmV2aW91c1tfaTddIC0gZWlnZW52ZWN0b3JbX2k3XTtcbiAgICAgICAgICBkaWZmICs9IGRlbHRhICogZGVsdGE7XG4gICAgICAgIH0gLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuXG5cbiAgICAgICAgaWYgKGRpZmYgPCBwcmVjaXNpb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBDb25zdHJ1Y3QgcmVzdWx0XG5cblxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgcmFuazogZnVuY3Rpb24gcmFuayhub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IGN5LmNvbGxlY3Rpb24obm9kZSlbMF07XG4gICAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW25vZGVzLmluZGV4T2Yobm9kZSldO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIHBhZ2VSYW5rXG5cbiAgfTsgLy8gZWxlc2ZuXG5cbiAgdmFyIGRlZmF1bHRzJGYgPSBkZWZhdWx0cyRnKHtcbiAgICByb290OiBudWxsLFxuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgIGFscGhhOiAwXG4gIH0pO1xuICB2YXIgZWxlc2ZuJG4gPSB7XG4gICAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyRmKG9wdGlvbnMpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cbiAgICAgICAgICBvcHRpb25zLnJvb3QgPSBub2RlO1xuICAgICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKG1heERlZ3JlZSA8IGN1cnJEZWdyZWUuZGVncmVlKSB7XG4gICAgICAgICAgICBtYXhEZWdyZWUgPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVncmVlOiBmdW5jdGlvbiBkZWdyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG1heERlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhEZWdyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICAgICAgICB2YXIgaWQgPSBfbm9kZS5pZCgpOyAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcblxuXG4gICAgICAgICAgb3B0aW9ucy5yb290ID0gX25vZGU7XG5cbiAgICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPCBfY3VyckRlZ3JlZS5pbmRlZ3JlZSkgbWF4SW5kZWdyZWUgPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgICBpZiAobWF4T3V0ZGVncmVlIDwgX2N1cnJEZWdyZWUub3V0ZGVncmVlKSBtYXhPdXRkZWdyZWUgPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgICAgaW5kZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICAgIG91dGRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRlZ3JlZTogZnVuY3Rpb24gaW5kZWdyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG1heEluZGVncmVlID09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG91dGRlZ3JlZTogZnVuY3Rpb24gb3V0ZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlc1tub2RlLmlkKCldIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gICAgLy8gXCJOb2RlIGNlbnRyYWxpdHkgaW4gd2VpZ2h0ZWQgbmV0d29ya3M6IEdlbmVyYWxpemluZyBkZWdyZWUgYW5kIHNob3J0ZXN0IHBhdGhzXCJcbiAgICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyRmKG9wdGlvbnMpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcbiAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICAgICAgd2VpZ2h0ID0gX29wdGlvbnMud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX29wdGlvbnMuZGlyZWN0ZWQsXG4gICAgICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdO1xuXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgICAgdmFyIGsgPSBjb25uRWRnZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcyA9IDA7IC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcyArPSB3ZWlnaHQoY29ubkVkZ2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICAgIHZhciBpbmNvbWluZyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG91dGdvaW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgICB2YXIgc19pbiA9IDA7XG4gICAgICAgIHZhciBzX291dCA9IDA7IC8vIE5vdywgc3VtIGluY29taW5nIGVkZ2Ugd2VpZ2h0c1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY29taW5nLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBzX2luICs9IHdlaWdodChpbmNvbWluZ1tfaTJdKTtcbiAgICAgICAgfSAvLyBOb3csIHN1bSBvdXRnb2luZyBlZGdlIHdlaWdodHNcblxuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICBzX291dCArPSB3ZWlnaHQob3V0Z29pbmdbX2kzXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVncmVlOiBNYXRoLnBvdyhrX2luLCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19pbiwgYWxwaGEpLFxuICAgICAgICAgIG91dGRlZ3JlZTogTWF0aC5wb3coa19vdXQsIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX291dCwgYWxwaGEpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyBkZWdyZWVDZW50cmFsaXR5XG5cbiAgfTsgLy8gZWxlc2ZuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuXG4gIGVsZXNmbiRuLmRjID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eTtcbiAgZWxlc2ZuJG4uZGNuID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxuICB2YXIgZGVmYXVsdHMkZSA9IGRlZmF1bHRzJGcoe1xuICAgIGhhcm1vbmljOiB0cnVlLFxuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgcm9vdDogbnVsbFxuICB9KTtcbiAgdmFyIGVsZXNmbiRtID0ge1xuICAgIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkZShvcHRpb25zKSxcbiAgICAgICAgICBoYXJtb25pYyA9IF9kZWZhdWx0cy5oYXJtb25pYyxcbiAgICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICAgIHZhciBtYXhDbG9zZW5lc3MgPSAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHtcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgICAgfSk7IC8vIENvbXB1dGUgY2xvc2VuZXNzIGZvciBldmVyeSBub2RlIGFuZCBmaW5kIHRoZSBtYXhpbXVtIGNsb3NlbmVzc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgICAgdmFyIG5vZGVfaSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZShub2RlX2ksIG5vZGVzW2pdKTtcblxuICAgICAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gMSAvIGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXJtb25pYykge1xuICAgICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKSB7XG4gICAgICAgICAgbWF4Q2xvc2VuZXNzID0gY3VyckNsb3NlbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb3NlbmVzc2VzW25vZGVfaS5pZCgpXSA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3NlbmVzczogZnVuY3Rpb24gY2xvc2VuZXNzKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgICB2YXIgX2RlZmF1bHRzMiA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICAgICAgcm9vdCA9IF9kZWZhdWx0czIucm9vdCxcbiAgICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMyLndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0czIuZGlyZWN0ZWQsXG4gICAgICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMyLmhhcm1vbmljO1xuXG4gICAgICByb290ID0gdGhpcy5maWx0ZXIocm9vdClbMF07IC8vIHdlIG5lZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gZXZlcnkgb3RoZXIgbm9kZVxuXG4gICAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgICAgfSk7XG4gICAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgICBpZiAoIW4uc2FtZShyb290KSkge1xuICAgICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhuKTtcblxuICAgICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gICAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbiAgfTsgLy8gZWxlc2ZuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuXG4gIGVsZXNmbiRtLmNjID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbiAgZWxlc2ZuJG0uY2NuID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxuICB2YXIgZGVmYXVsdHMkZCA9IGRlZmF1bHRzJGcoe1xuICAgIHdlaWdodDogbnVsbCxcbiAgICBkaXJlY3RlZDogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kbCA9IHtcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gdGhlIHBhcGVyIFwiT24gVmFyaWFudHMgb2YgU2hvcnRlc3QtUGF0aCBCZXR3ZWVubmVzcyBDZW50cmFsaXR5IGFuZCB0aGVpciBHZW5lcmljIENvbXB1dGF0aW9uXCIgYnkgVWxyaWsgQnJhbmRlc1xuICAgIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRkKG9wdGlvbnMpLFxuICAgICAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICAgIHZhciB3ZWlnaHRlZCA9IHdlaWdodCAhPSBudWxsO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBzdGFydGluZ1xuXG4gICAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBBID0ge307XG4gICAgICB2YXIgX0MgPSB7fTtcbiAgICAgIHZhciBtYXggPSAwO1xuICAgICAgdmFyIEMgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICAgICAgX0Nba2V5XSA9IHZhbDtcblxuICAgICAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcblxuICAgICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgICBBW3ZpZF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBW3ZpZF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIEMuc2V0KHZpZCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHMpIHtcbiAgICAgICAgdmFyIHNpZCA9IFZbc10uaWQoKTtcbiAgICAgICAgdmFyIFMgPSBbXTsgLy8gc3RhY2tcblxuICAgICAgICB2YXIgUCA9IHt9O1xuICAgICAgICB2YXIgZyA9IHt9O1xuICAgICAgICB2YXIgZCA9IHt9O1xuICAgICAgICB2YXIgUSA9IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGRbYV0gLSBkW2JdO1xuICAgICAgICB9KTsgLy8gcXVldWVcbiAgICAgICAgLy8gaW5pdCBkaWN0aW9uYXJpZXNcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgVi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3ZpZCA9IFZbX2ldLmlkKCk7XG5cbiAgICAgICAgICBQW192aWRdID0gW107XG4gICAgICAgICAgZ1tfdmlkXSA9IDA7XG4gICAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZ1tzaWRdID0gMTsgLy8gc2lnbWFcblxuICAgICAgICBkW3NpZF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgICAgUS5wdXNoKHNpZCk7XG5cbiAgICAgICAgd2hpbGUgKCFRLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuXG4gICAgICAgICAgUy5wdXNoKF92KTtcblxuICAgICAgICAgIGlmICh3ZWlnaHRlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBBW192XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgdyA9IEFbX3ZdW2pdO1xuICAgICAgICAgICAgICB2YXIgdkVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKF92KTtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgaWYgKHZFbGUuZWRnZXNUbyh3KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZWRnZSA9IHZFbGUuZWRnZXNUbyh3KVswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGdlID0gdy5lZGdlc1RvKHZFbGUpWzBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICAgIHcgPSB3LmlkKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGRbd10gPiBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkW3ddID0gZFtfdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKFEubm9kZXMuaW5kZXhPZih3KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vaWYgdyBpcyBub3QgaW4gUVxuICAgICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ1t3XSA9IDA7XG4gICAgICAgICAgICAgICAgUFt3XSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRbd10gPT0gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW192XTtcbiAgICAgICAgICAgICAgICBQW3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBBW192XS5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgdmFyIF93ID0gQVtfdl1bX2pdLmlkKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGRbX3ddID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgUS5wdXNoKF93KTtcbiAgICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkW193XSA9PSBkW192XSArIDEpIHtcbiAgICAgICAgICAgICAgICBnW193XSA9IGdbX3ddICsgZ1tfdl07XG5cbiAgICAgICAgICAgICAgICBQW193XS5wdXNoKF92KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgVi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgZVtWW19pMl0uaWQoKV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBfdzIgPSBTLnBvcCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICAgIHZhciBfdjIgPSBQW193Ml1bX2oyXTtcbiAgICAgICAgICAgIGVbX3YyXSA9IGVbX3YyXSArIGdbX3YyXSAvIGdbX3cyXSAqICgxICsgZVtfdzJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3cyICE9IFZbc10uaWQoKSkge1xuICAgICAgICAgICAgQy5zZXQoX3cyLCBDLmdldChfdzIpICsgZVtfdzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgICBfbG9vcChzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uIGJldHdlZW5uZXNzKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBjeS5jb2xsZWN0aW9uKG5vZGUpLmlkKCk7XG4gICAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkOiBmdW5jdGlvbiBiZXR3ZWVubmVzc05vcm1hbGl6ZWQobm9kZSkge1xuICAgICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICAgIHJldHVybiBDLmdldChpZCkgLyBtYXg7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGFsaWFzXG5cbiAgICAgIHJldC5iZXR3ZWVubmVzc05vcm1hbGlzZWQgPSByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpemVkO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG4gIH07IC8vIGVsZXNmblxuICAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuICBlbGVzZm4kbC5iYyA9IGVsZXNmbiRsLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcblxuICAvLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICB2YXIgZGVmYXVsdHMkYyA9IGRlZmF1bHRzJGcoe1xuICAgIGV4cGFuZEZhY3RvcjogMixcbiAgICAvLyBhZmZlY3RzIHRpbWUgb2YgY29tcHV0YXRpb24gYW5kIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgdG8gc29tZSBleHRlbnQ6IE0gKiBNXG4gICAgaW5mbGF0ZUZhY3RvcjogMixcbiAgICAvLyBhZmZlY3RzIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgKHRoZSBncmVhdGVyIHRoZSB2YWx1ZSwgdGhlIG1vcmUgY2x1c3RlcnMpOiBNKGksaikgLyBFKGopXG4gICAgbXVsdEZhY3RvcjogMSxcbiAgICAvLyBvcHRpb25hbCBzZWxmIGxvb3BzIGZvciBlYWNoIG5vZGUuIFVzZSBhIG5ldXRyYWwgdmFsdWUgdG8gaW1wcm92ZSBjbHVzdGVyIGNvbXB1dGF0aW9ucy5cbiAgICBtYXhJdGVyYXRpb25zOiAyMCxcbiAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIG9mIHRoZSBNQ0wgYWxnb3JpdGhtIGluIGEgc2luZ2xlIHJ1blxuICAgIGF0dHJpYnV0ZXM6IFsvLyBhdHRyaWJ1dGVzL2ZlYXR1cmVzIHVzZWQgdG8gZ3JvdXAgbm9kZXMsIGllLiBzaW1pbGFyaXR5IHZhbHVlcyBiZXR3ZWVuIG5vZGVzXG4gICAgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1dXG4gIH0pO1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgdmFyIHNldE9wdGlvbnMkMyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBkZWZhdWx0cyRjKG9wdGlvbnMpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICB2YXIgZ2V0U2ltaWxhcml0eSQxID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eShlZGdlLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWwgKz0gYXR0cmlidXRlc1tpXShlZGdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH07XG5cbiAgdmFyIGFkZExvb3BzID0gZnVuY3Rpb24gYWRkTG9vcHMoTSwgbiwgdmFsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIE1baSAqIG4gKyBpXSA9IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShNLCBuKSB7XG4gICAgdmFyIHN1bTtcblxuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG47IGNvbCsrKSB7XG4gICAgICBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuOyByb3crKykge1xuICAgICAgICBzdW0gKz0gTVtyb3cgKiBuICsgY29sXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JvdyA9IDA7IF9yb3cgPCBuOyBfcm93KyspIHtcbiAgICAgICAgTVtfcm93ICogbiArIGNvbF0gPSBNW19yb3cgKiBuICsgY29sXSAvIHN1bTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRPRE86IGJsb2NrZWQgbWF0cml4IG11bHRpcGxpY2F0aW9uP1xuXG5cbiAgdmFyIG1tdWx0ID0gZnVuY3Rpb24gbW11bHQoQSwgQiwgbikge1xuICAgIHZhciBDID0gbmV3IEFycmF5KG4gKiBuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBDW2kgKiBuICsgal0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICAgIENbaSAqIG4gKyBfal0gKz0gQVtpICogbiArIGtdICogQltrICogbiArIF9qXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDO1xuICB9O1xuXG4gIHZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoTSwgbiwgZXhwYW5kRmFjdG9yXG4gIC8qKiBwb3dlciAqKi9cbiAgKSB7XG4gICAgdmFyIF9NID0gTS5zbGljZSgwKTtcblxuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgZXhwYW5kRmFjdG9yOyBwKyspIHtcbiAgICAgIE0gPSBtbXVsdChNLCBfTSwgbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE07XG4gIH07XG5cbiAgdmFyIGluZmxhdGUgPSBmdW5jdGlvbiBpbmZsYXRlKE0sIG4sIGluZmxhdGVGYWN0b3JcbiAgLyoqIHIgKiovXG4gICkge1xuICAgIHZhciBfTSA9IG5ldyBBcnJheShuICogbik7IC8vIE0oaSxqKSBeIGluZmxhdGVQb3dlclxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gKiBuOyBpKyspIHtcbiAgICAgIF9NW2ldID0gTWF0aC5wb3coTVtpXSwgaW5mbGF0ZUZhY3Rvcik7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKF9NLCBuKTtcbiAgICByZXR1cm4gX007XG4gIH07XG5cbiAgdmFyIGhhc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIHJvdW5kRmFjdG9yKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCBib3RoIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgKGksailcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4yOyBpKyspIHtcbiAgICAgIHZhciB2MSA9IE1hdGgucm91bmQoTVtpXSAqIE1hdGgucG93KDEwLCByb3VuZEZhY3RvcikpIC8gTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKTsgLy8gdHJ1bmNhdGUgdG8gJ3JvdW5kRmFjdG9yJyBkZWNpbWFsIHBsYWNlc1xuXG4gICAgICB2YXIgdjIgPSBNYXRoLnJvdW5kKF9NW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpO1xuXG4gICAgICBpZiAodjEgIT09IHYyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgYXNzaWduJDIgPSBmdW5jdGlvbiBhc3NpZ24oTSwgbiwgbm9kZXMsIGN5KSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGNsdXN0ZXIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgLy8gUm93LXdpc2UgYXR0cmFjdG9ycyBhbmQgZWxlbWVudHMgdGhhdCB0aGV5IGF0dHJhY3QgYmVsb25nIGluIHNhbWUgY2x1c3RlclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChNW2kgKiBuICsgal0gKiAxMDAwKSAvIDEwMDAgPiAwKSB7XG4gICAgICAgICAgY2x1c3Rlci5wdXNoKG5vZGVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY2x1c3RlcnMucHVzaChjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGlzRHVwbGljYXRlID0gZnVuY3Rpb24gaXNEdXBsaWNhdGUoYzEsIGMyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjMltpXSB8fCBjMVtpXS5pZCgpICE9PSBjMltpXS5pZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGogJiYgaXNEdXBsaWNhdGUoY2x1c3RlcnNbaV0sIGNsdXN0ZXJzW2pdKSkge1xuICAgICAgICAgIGNsdXN0ZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgbWFya292Q2x1c3RlcmluZyA9IGZ1bmN0aW9uIG1hcmtvdkNsdXN0ZXJpbmcob3B0aW9ucykge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06XG5cbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMyhvcHRpb25zKTsgLy8gTWFwIGVhY2ggbm9kZSB0byBpdHMgcG9zaXRpb24gaW4gbm9kZSBhcnJheVxuXG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfSAvLyBHZW5lcmF0ZSBzdG9jaGFzdGljIG1hdHJpeCBNIGZyb20gaW5wdXQgZ3JhcGggRyAoc2hvdWxkIGJlIHN5bW1ldHJpYy91bmRpcmVjdGVkKVxuXG5cbiAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbjIgPSBuICogbjtcblxuICAgIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICAgICAgX007XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICAgIE1bX2ldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgICAgdmFyIF9pMiA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgICB2YXIgaiA9IGlkMnBvc2l0aW9uW2VkZ2UudGFyZ2V0KCkuaWQoKV07XG4gICAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eSQxKGVkZ2UsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICBNW19pMiAqIG4gKyBqXSArPSBzaW07IC8vIEcgc2hvdWxkIGJlIHN5bW1ldHJpYyBhbmQgdW5kaXJlY3RlZFxuXG4gICAgICBNW2ogKiBuICsgX2kyXSArPSBzaW07XG4gICAgfSAvLyBCZWdpbiBNYXJrb3YgY2x1c3RlciBhbGdvcml0aG1cbiAgICAvLyBTdGVwIDE6IEFkZCBzZWxmIGxvb3BzIHRvIGVhY2ggbm9kZSwgaWUuIGFkZCBtdWx0RmFjdG9yIHRvIG1hdHJpeCBkaWFnb25hbFxuXG5cbiAgICBhZGRMb29wcyhNLCBuLCBvcHRzLm11bHRGYWN0b3IpOyAvLyBTdGVwIDI6IE0gPSBub3JtYWxpemUoIE0gKTtcblxuICAgIG5vcm1hbGl6ZShNLCBuKTtcbiAgICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlOyAvLyBTdGVwIDM6XG5cbiAgICAgIF9NID0gZXhwYW5kKE0sIG4sIG9wdHMuZXhwYW5kRmFjdG9yKTsgLy8gU3RlcCA0OlxuXG4gICAgICBNID0gaW5mbGF0ZShfTSwgbiwgb3B0cy5pbmZsYXRlRmFjdG9yKTsgLy8gU3RlcCA1OiBjaGVjayB0byBzZWUgaWYgfnN0ZWFkeSBzdGF0ZSBoYXMgYmVlbiByZWFjaGVkXG5cbiAgICAgIGlmICghaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgNCkpIHtcbiAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9IC8vIEJ1aWxkIGNsdXN0ZXJzIGZyb20gbWF0cml4XG5cblxuICAgIHZhciBjbHVzdGVycyA9IGFzc2lnbiQyKE0sIG4sIG5vZGVzLCBjeSk7IC8vIFJlbW92ZSBkdXBsaWNhdGUgY2x1c3RlcnMgZHVlIHRvIHN5bW1ldHJ5IG9mIGdyYXBoIGFuZCBNIG1hdHJpeFxuXG4gICAgY2x1c3RlcnMgPSByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKTtcbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIG1hcmtvdkNsdXN0ZXJpbmckMSA9IHtcbiAgICBtYXJrb3ZDbHVzdGVyaW5nOiBtYXJrb3ZDbHVzdGVyaW5nLFxuICAgIG1jbDogbWFya292Q2x1c3RlcmluZ1xuICB9O1xuXG4gIC8vIENvbW1vbiBkaXN0YW5jZSBtZXRyaWNzIGZvciBjbHVzdGVyaW5nIGFsZ29yaXRobXNcblxuICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgdmFyIGFic0RpZmYgPSBmdW5jdGlvbiBhYnNEaWZmKHAsIHEpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMocSAtIHApO1xuICB9O1xuXG4gIHZhciBhZGRBYnNEaWZmID0gZnVuY3Rpb24gYWRkQWJzRGlmZih0b3RhbCwgcCwgcSkge1xuICAgIHJldHVybiB0b3RhbCArIGFic0RpZmYocCwgcSk7XG4gIH07XG5cbiAgdmFyIGFkZFNxdWFyZWREaWZmID0gZnVuY3Rpb24gYWRkU3F1YXJlZERpZmYodG90YWwsIHAsIHEpIHtcbiAgICByZXR1cm4gdG90YWwgKyBNYXRoLnBvdyhxIC0gcCwgMik7XG4gIH07XG5cbiAgdmFyIHNxcnQgPSBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgpO1xuICB9O1xuXG4gIHZhciBtYXhBYnNEaWZmID0gZnVuY3Rpb24gbWF4QWJzRGlmZihjdXJyZW50TWF4LCBwLCBxKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRNYXgsIGFic0RpZmYocCwgcSkpO1xuICB9O1xuXG4gIHZhciBnZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgaW5pdCwgdmlzaXQpIHtcbiAgICB2YXIgcG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogaWRlbnRpdHk7XG4gICAgdmFyIHJldCA9IGluaXQ7XG4gICAgdmFyIHAsIHE7XG5cbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBsZW5ndGg7IGRpbSsrKSB7XG4gICAgICBwID0gZ2V0UChkaW0pO1xuICAgICAgcSA9IGdldFEoZGltKTtcbiAgICAgIHJldCA9IHZpc2l0KHJldCwgcCwgcSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3QocmV0KTtcbiAgfTtcblxuICB2YXIgZGlzdGFuY2VzID0ge1xuICAgIGV1Y2xpZGVhbjogZnVuY3Rpb24gZXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmLCBzcXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZvciBzaW5nbGUgYXR0ciBjYXNlLCBtb3JlIGVmZmljaWVudCB0byBhdm9pZCBzcXJ0XG4gICAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3F1YXJlZEV1Y2xpZGVhbjogZnVuY3Rpb24gc3F1YXJlZEV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmKTtcbiAgICB9LFxuICAgIG1hbmhhdHRhbjogZnVuY3Rpb24gbWFuaGF0dGFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gICAgfSxcbiAgICBtYXg6IGZ1bmN0aW9uIG1heChsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIC1JbmZpbml0eSwgbWF4QWJzRGlmZik7XG4gICAgfVxuICB9OyAvLyBpbiBjYXNlIHRoZSB1c2VyIGFjY2lkZW50YWxseSBkb2Vzbid0IHVzZSBjYW1lbCBjYXNlXG5cbiAgZGlzdGFuY2VzWydzcXVhcmVkLWV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG4gIGRpc3RhbmNlc1snc3F1YXJlZGV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG4gIGZ1bmN0aW9uIGNsdXN0ZXJpbmdEaXN0YW5jZSAobWV0aG9kLCBsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSkge1xuICAgIHZhciBpbXBsO1xuXG4gICAgaWYgKGZuJDYobWV0aG9kKSkge1xuICAgICAgaW1wbCA9IG1ldGhvZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbCA9IGRpc3RhbmNlc1ttZXRob2RdIHx8IGRpc3RhbmNlcy5ldWNsaWRlYW47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbiQ2KG1ldGhvZCkpIHtcbiAgICAgIHJldHVybiBpbXBsKG5vZGVQLCBub2RlUSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbXBsKGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdHMkYiA9IGRlZmF1bHRzJGcoe1xuICAgIGs6IDIsXG4gICAgbTogMixcbiAgICBzZW5zaXRpdml0eVRocmVzaG9sZDogMC4wMDAxLFxuICAgIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgICBtYXhJdGVyYXRpb25zOiAxMCxcbiAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICB0ZXN0TW9kZTogZmFsc2UsXG4gICAgdGVzdENlbnRyb2lkczogbnVsbFxuICB9KTtcblxuICB2YXIgc2V0T3B0aW9ucyQyID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzJGIob3B0aW9ucyk7XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuXG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdCh0eXBlLCBub2RlLCBjZW50cm9pZCwgYXR0cmlidXRlcywgbW9kZSkge1xuICAgIHZhciBub05vZGVQID0gbW9kZSAhPT0gJ2tNZWRvaWRzJztcbiAgICB2YXIgZ2V0UCA9IG5vTm9kZVAgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNlbnRyb2lkW2ldO1xuICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0oY2VudHJvaWQpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0USA9IGZ1bmN0aW9uIGdldFEoaSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBub2RlUCA9IGNlbnRyb2lkO1xuICAgIHZhciBub2RlUSA9IG5vZGU7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgfTtcblxuICB2YXIgcmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBrLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIG5kaW0gPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICB2YXIgbWluID0gbmV3IEFycmF5KG5kaW0pO1xuICAgIHZhciBtYXggPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgdmFyIGNlbnRyb2lkcyA9IG5ldyBBcnJheShrKTtcbiAgICB2YXIgY2VudHJvaWQgPSBudWxsOyAvLyBGaW5kIG1pbiwgbWF4IHZhbHVlcyBmb3IgZWFjaCBhdHRyaWJ1dGUgZGltZW5zaW9uXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5kaW07IGkrKykge1xuICAgICAgbWluW2ldID0gbm9kZXMubWluKGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICAgICAgbWF4W2ldID0gbm9kZXMubWF4KGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICAgIH0gLy8gQnVpbGQgayBjZW50cm9pZHMsIGVhY2ggcmVwcmVzZW50ZWQgYXMgYW4gbi1kaW0gZmVhdHVyZSB2ZWN0b3JcblxuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICAgIGNlbnRyb2lkID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZGltOyBfaSsrKSB7XG4gICAgICAgIGNlbnRyb2lkW19pXSA9IE1hdGgucmFuZG9tKCkgKiAobWF4W19pXSAtIG1pbltfaV0pICsgbWluW19pXTsgLy8gcmFuZG9tIGluaXRpYWwgdmFsdWVcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzW2NdID0gY2VudHJvaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRyb2lkcztcbiAgfTtcblxuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIGRpc3RhbmNlLCBhdHRyaWJ1dGVzLCB0eXBlKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpc3QgPSBnZXREaXN0KGRpc3RhbmNlLCBub2RlLCBjZW50cm9pZHNbaV0sIGF0dHJpYnV0ZXMsIHR5cGUpO1xuXG4gICAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkaXN0O1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIHZhciBidWlsZENsdXN0ZXIgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXIoY2VudHJvaWQsIG5vZGVzLCBhc3NpZ25tZW50KSB7XG4gICAgdmFyIGNsdXN0ZXIgPSBbXTtcbiAgICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG5cbiAgICAgIGlmIChhc3NpZ25tZW50W25vZGUuaWQoKV0gPT09IGNlbnRyb2lkKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOb2RlIFwiICsgbm9kZS5pZCgpICsgXCIgaXMgYXNzb2NpYXRlZCB3aXRoIG1lZG9pZCAjOiBcIiArIG0pO1xuICAgICAgICBjbHVzdGVyLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXI7XG4gIH07XG5cbiAgdmFyIGhhdmVWYWx1ZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlVmFsdWVzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModjIgLSB2MSkgPD0gc2Vuc2l0aXZpdHlUaHJlc2hvbGQ7XG4gIH07XG5cbiAgdmFyIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2MVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHYxW2ldW2pdIC0gdjJbaV1bal0pO1xuXG4gICAgICAgIGlmIChkaWZmID4gc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgc2VlbkJlZm9yZSA9IGZ1bmN0aW9uIHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAobm9kZSA9PT0gbWVkb2lkc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciByYW5kb21NZWRvaWRzID0gZnVuY3Rpb24gcmFuZG9tTWVkb2lkcyhub2Rlcywgaykge1xuICAgIHZhciBtZWRvaWRzID0gbmV3IEFycmF5KGspOyAvLyBGb3Igc21hbGwgZGF0YSBzZXRzLCB0aGUgcHJvYmFiaWxpdHkgb2YgbWVkb2lkIGNvbmZsaWN0IGlzIGdyZWF0ZXIsXG4gICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBzZWVuIG9yIGNob3NlIHRoaXMgbm9kZSBiZWZvcmUuXG5cbiAgICBpZiAobm9kZXMubGVuZ3RoIDwgNTApIHtcbiAgICAgIC8vIFJhbmRvbWx5IHNlbGVjdCBrIG1lZG9pZHMgZnJvbSB0aGUgbiBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTsgLy8gSWYgd2UndmUgYWxyZWFkeSBjaG9zZW4gdGhpcyBub2RlIHRvIGJlIGEgbWVkb2lkLCBkb24ndCBjaG9vc2UgaXQgYWdhaW4gKGZvciBzbWFsbCBkYXRhIHNldHMpLlxuICAgICAgICAvLyBJbnN0ZWFkIGNob29zZSBhIGRpZmZlcmVudCByYW5kb20gbm9kZS5cblxuICAgICAgICB3aGlsZSAoc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBpKSkge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lZG9pZHNbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWxhdGl2ZWx5IGxhcmdlIGRhdGEgc2V0LCBzbyBwcmV0dHkgc2FmZSB0byBub3QgY2hlY2sgYW5kIGp1c3Qgc2VsZWN0IHJhbmRvbSBub2Rlc1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgazsgX2kyKyspIHtcbiAgICAgICAgbWVkb2lkc1tfaTJdID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lZG9pZHM7XG4gIH07XG5cbiAgdmFyIGZpbmRDb3N0ID0gZnVuY3Rpb24gZmluZENvc3QocG90ZW50aWFsTmV3TWVkb2lkLCBjbHVzdGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGNvc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVyLmxlbmd0aDsgbisrKSB7XG4gICAgICBjb3N0ICs9IGdldERpc3QoJ21hbmhhdHRhbicsIGNsdXN0ZXJbbl0sIHBvdGVudGlhbE5ld01lZG9pZCwgYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvc3Q7XG4gIH07XG5cbiAgdmFyIGtNZWFucyA9IGZ1bmN0aW9uIGtNZWFucyhvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbm9kZSA9IG51bGw7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogIyBvZiBjbHVzdGVycywgZGlzdGFuY2UgbWV0cmljLCBldGMuXG5cbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTsgLy8gQmVnaW4gay1tZWFucyBhbGdvcml0aG1cblxuICAgIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICAgIHZhciBhc3NpZ25tZW50ID0ge307XG4gICAgdmFyIGNlbnRyb2lkczsgLy8gU3RlcCAxOiBJbml0aWFsaXplIGNlbnRyb2lkIHBvc2l0aW9uc1xuXG4gICAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBzZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICAgIG9wdHMudGVzdENlbnRyb2lkcztcbiAgICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2VudHJvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBjZW50cm9pZFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbl07IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuXG4gICAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lYW5zJyk7XG4gICAgICB9IC8vIFN0ZXAgMzogRm9yIGVhY2ggb2YgdGhlIGsgY2x1c3RlcnMsIHVwZGF0ZSBpdHMgY2VudHJvaWRcblxuXG4gICAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3B0cy5rOyBjKyspIHtcbiAgICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGNsdXN0ZXJcbiAgICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIoYywgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gVXBkYXRlIGNlbnRyb2lkcyBieSBjYWxjdWxhdGluZyBhdmcgb2YgYWxsIG5vZGVzIHdpdGhpbiB0aGUgY2x1c3Rlci5cblxuXG4gICAgICAgIHZhciBuZGltID0gb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2NdOyAvLyBbIGRpbV8xLCBkaW1fMiwgZGltXzMsIC4uLiAsIGRpbV9uIF1cblxuICAgICAgICB2YXIgbmV3Q2VudHJvaWQgPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgICAgIHZhciBzdW0gPSBuZXcgQXJyYXkobmRpbSk7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBuZGltOyBkKyspIHtcbiAgICAgICAgICBzdW1bZF0gPSAwLjA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBjbHVzdGVyW2ldO1xuICAgICAgICAgICAgc3VtW2RdICs9IG9wdHMuYXR0cmlidXRlc1tkXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdDZW50cm9pZFtkXSA9IHN1bVtkXSAvIGNsdXN0ZXIubGVuZ3RoOyAvLyBDaGVjayB0byBzZWUgaWYgYWxnb3JpdGhtIGhhcyBjb252ZXJnZWQsIGkuZS4gd2hlbiBjZW50cm9pZHMgbm8gbG9uZ2VyIGNoYW5nZVxuXG4gICAgICAgICAgaWYgKCFoYXZlVmFsdWVzQ29udmVyZ2VkKG5ld0NlbnRyb2lkW2RdLCBjZW50cm9pZFtkXSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkc1tjXSA9IG5ld0NlbnRyb2lkO1xuICAgICAgICBjbHVzdGVyc1tjXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGtNZWRvaWRzID0gZnVuY3Rpb24ga01lZG9pZHMob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG5vZGUgPSBudWxsO1xuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpOyAvLyBCZWdpbiBrLW1lZG9pZHMgYWxnb3JpdGhtXG5cbiAgICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgICB2YXIgbWVkb2lkcztcbiAgICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICAgIHZhciBjdXJDb3N0O1xuICAgIHZhciBtaW5Db3N0cyA9IG5ldyBBcnJheShvcHRzLmspOyAvLyBtaW5pbXVtIGNvc3QgY29uZmlndXJhdGlvbiBmb3IgZWFjaCBjbHVzdGVyXG4gICAgLy8gU3RlcCAxOiBJbml0aWFsaXplIGsgbWVkb2lkc1xuXG4gICAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykgOyBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1lZG9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IG1lZG9pZFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbl07IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuXG4gICAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIG1lZG9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAzOiBGb3IgZWFjaCBtZWRvaWQgbSwgYW5kIGZvciBlYWNoIG5vZGUgYXNzb2NpYXRlZCB3aXRoIG1lZGlvZCBtLFxuICAgICAgLy8gc2VsZWN0IHRoZSBub2RlIHdpdGggdGhlIGxvd2VzdCBjb25maWd1cmF0aW9uIGNvc3QgYXMgbmV3IG1lZG9pZC5cblxuICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBtZWRvaWRzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBtZWRvaWRcbiAgICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIobSwgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5Db3N0c1ttXSA9IGZpbmRDb3N0KG1lZG9pZHNbbV0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7IC8vIG9yaWdpbmFsIGNvc3RcbiAgICAgICAgLy8gU2VsZWN0IGRpZmZlcmVudCBtZWRvaWQgaWYgaXRzIGNvbmZpZ3VyYXRpb24gaGFzIHRoZSBsb3dlc3QgY29zdFxuXG4gICAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyLmxlbmd0aDsgX24rKykge1xuICAgICAgICAgIGN1ckNvc3QgPSBmaW5kQ29zdChjbHVzdGVyW19uXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgIGlmIChjdXJDb3N0IDwgbWluQ29zdHNbbV0pIHtcbiAgICAgICAgICAgIG1pbkNvc3RzW21dID0gY3VyQ29zdDtcbiAgICAgICAgICAgIG1lZG9pZHNbbV0gPSBjbHVzdGVyW19uXTtcbiAgICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJzW21dID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9ucysrO1xuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgdXBkYXRlQ2VudHJvaWRzID0gZnVuY3Rpb24gdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cykge1xuICAgIHZhciBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgd2VpZ2h0W25dW2NdID0gTWF0aC5wb3coVVtuXVtjXSwgb3B0cy5tKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgY2VudHJvaWRzLmxlbmd0aDsgX2MrKykge1xuICAgICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDsgZGltKyspIHtcbiAgICAgICAgbnVtZXJhdG9yID0gMDtcbiAgICAgICAgZGVub21pbmF0b3IgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG5vZGVzLmxlbmd0aDsgX24yKyspIHtcbiAgICAgICAgICBudW1lcmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdICogb3B0cy5hdHRyaWJ1dGVzW2RpbV0obm9kZXNbX24yXSk7XG4gICAgICAgICAgZGVub21pbmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdO1xuICAgICAgICB9XG5cbiAgICAgICAgY2VudHJvaWRzW19jXVtkaW1dID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVNZW1iZXJzaGlwID0gZnVuY3Rpb24gdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cykge1xuICAgIC8vIFNhdmUgcHJldmlvdXMgc3RlcFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVS5sZW5ndGg7IGkrKykge1xuICAgICAgX1VbaV0gPSBVW2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHN1bSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcbiAgICB2YXIgcG93ID0gMiAvIChvcHRzLm0gLSAxKTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHN1bSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjZW50cm9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAvLyBhZ2FpbnN0IGFsbCBvdGhlciBjZW50cm9pZHNcbiAgICAgICAgICBudW1lcmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNbY10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICAgIGRlbm9taW5hdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2tdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgICBzdW0gKz0gTWF0aC5wb3cobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHBvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBVW25dW2NdID0gMSAvIHN1bTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGFzc2lnbiQxID0gZnVuY3Rpb24gYXNzaWduKG5vZGVzLCBVLCBvcHRzLCBjeSkge1xuICAgIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgY2x1c3RlcnNbY10gPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWF4O1xuICAgIHZhciBpbmRleDtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgVS5sZW5ndGg7IG4rKykge1xuICAgICAgLy8gZm9yIGVhY2ggbm9kZSAoVSBpcyBOIHggQyBtYXRyaXgpXG4gICAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgICBpbmRleCA9IC0xOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGUgbm9kZSBpcyBtb3N0IGxpa2VseSB0byBiZWxvbmcgaW5cblxuICAgICAgZm9yICh2YXIgX2MyID0gMDsgX2MyIDwgVVswXS5sZW5ndGg7IF9jMisrKSB7XG4gICAgICAgIGlmIChVW25dW19jMl0gPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBVW25dW19jMl07XG4gICAgICAgICAgaW5kZXggPSBfYzI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2x1c3RlcnNbaW5kZXhdLnB1c2gobm9kZXNbbl0pO1xuICAgIH0gLy8gVHVybiBldmVyeSBhcnJheSBpbnRvIGEgY29sbGVjdGlvbiBvZiBub2Rlc1xuXG5cbiAgICBmb3IgKHZhciBfYzMgPSAwOyBfYzMgPCBjbHVzdGVycy5sZW5ndGg7IF9jMysrKSB7XG4gICAgICBjbHVzdGVyc1tfYzNdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tfYzNdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGZ1enp5Q01lYW5zID0gZnVuY3Rpb24gZnV6enlDTWVhbnMob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7IC8vIEJlZ2luIGZ1enp5IGMtbWVhbnMgYWxnb3JpdGhtXG5cbiAgICB2YXIgY2x1c3RlcnM7XG4gICAgdmFyIGNlbnRyb2lkcztcbiAgICB2YXIgVTtcblxuICAgIHZhciBfVTtcblxuICAgIHZhciB3ZWlnaHQ7IC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBsZXRpYWJsZXMuXG5cbiAgICBfVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTiB4IEMgbWF0cml4XG4gICAgICBfVVtpXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICAgIH1cblxuICAgIFUgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIC8vIE4geCBDIG1hdHJpeFxuICAgICAgVVtfaTNdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHRzLms7IGorKykge1xuICAgICAgICBVW19pNF1bal0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0b3RhbCArPSBVW19pNF1bal07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBvcHRzLms7IF9qKyspIHtcbiAgICAgICAgVVtfaTRdW19qXSA9IFVbX2k0XVtfal0gLyB0b3RhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZW50cm9pZHMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG9wdHMuazsgX2k1KyspIHtcbiAgICAgIGNlbnRyb2lkc1tfaTVdID0gbmV3IEFycmF5KG9wdHMuYXR0cmlidXRlcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHdlaWdodCA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbm9kZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgLy8gTiB4IEMgbWF0cml4XG4gICAgICB3ZWlnaHRbX2k2XSA9IG5ldyBBcnJheShvcHRzLmspO1xuICAgIH0gLy8gZW5kIGluaXQgRkNNXG5cblxuICAgIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMjogQ2FsY3VsYXRlIHRoZSBjZW50cm9pZHMgZm9yIGVhY2ggc3RlcC5cblxuICAgICAgdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cyk7IC8vIFN0ZXAgMzogVXBkYXRlIHRoZSBwYXJ0aXRpb24gbWF0cml4IFUuXG5cbiAgICAgIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpOyAvLyBTdGVwIDQ6IENoZWNrIGZvciBjb252ZXJnZW5jZS5cblxuICAgICAgaWYgKCFoYXZlTWF0cmljZXNDb252ZXJnZWQoVSwgX1UsIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfSAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnMgd2l0aCBoaWdoZXN0IHByb2JhYmlsaXR5LlxuXG5cbiAgICBjbHVzdGVycyA9IGFzc2lnbiQxKG5vZGVzLCBVLCBvcHRzLCBjeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycyxcbiAgICAgIGRlZ3JlZU9mTWVtYmVyc2hpcDogVVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGtDbHVzdGVyaW5nID0ge1xuICAgIGtNZWFuczoga01lYW5zLFxuICAgIGtNZWRvaWRzOiBrTWVkb2lkcyxcbiAgICBmdXp6eUNNZWFuczogZnV6enlDTWVhbnMsXG4gICAgZmNtOiBmdXp6eUNNZWFuc1xuICB9O1xuXG4gIC8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuICB2YXIgZGVmYXVsdHMkYSA9IGRlZmF1bHRzJGcoe1xuICAgIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBub2Rlc1xuICAgIGxpbmthZ2U6ICdtaW4nLFxuICAgIC8vIGxpbmthZ2UgY3JpdGVyaW9uIDogaG93IHRvIGRldGVybWluZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjbHVzdGVycyBvZiBub2Rlc1xuICAgIG1vZGU6ICd0aHJlc2hvbGQnLFxuICAgIC8vIG1vZGU6J3RocmVzaG9sZCcgPT4gY2x1c3RlcnMgbXVzdCBiZSB0aHJlc2hvbGQgZGlzdGFuY2UgYXBhcnRcbiAgICB0aHJlc2hvbGQ6IEluZmluaXR5LFxuICAgIC8vIHRoZSBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgICAvLyBtb2RlOidkZW5kcm9ncmFtJyA9PiB0aGUgbm9kZXMgYXJlIG9yZ2FuaXNlZCBhcyBsZWF2ZXMgaW4gYSB0cmVlIChzaWJsaW5ncyBhcmUgY2xvc2UpLCBtZXJnaW5nIG1ha2VzIGNsdXN0ZXJzXG4gICAgYWRkRGVuZHJvZ3JhbTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byBhZGQgdGhlIGRlbmRyb2dyYW0gdG8gdGhlIGdyYXBoIGZvciB2aXpcbiAgICBkZW5kcm9ncmFtRGVwdGg6IDAsXG4gICAgLy8gZGVwdGggYXQgd2hpY2ggZGVuZHJvZ3JhbSBicmFuY2hlcyBhcmUgbWVyZ2VkIGludG8gdGhlIHJldHVybmVkIGNsdXN0ZXJzXG4gICAgYXR0cmlidXRlczogW10gLy8gYXJyYXkgb2YgYXR0ciBmdW5jdGlvbnNcblxuICB9KTtcbiAgdmFyIGxpbmthZ2VBbGlhc2VzID0ge1xuICAgICdzaW5nbGUnOiAnbWluJyxcbiAgICAnY29tcGxldGUnOiAnbWF4J1xuICB9O1xuXG4gIHZhciBzZXRPcHRpb25zJDEgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IGRlZmF1bHRzJGEob3B0aW9ucyk7XG4gICAgdmFyIHByZWZlcnJlZEFsaWFzID0gbGlua2FnZUFsaWFzZXNbb3B0cy5saW5rYWdlXTtcblxuICAgIGlmIChwcmVmZXJyZWRBbGlhcyAhPSBudWxsKSB7XG4gICAgICBvcHRzLmxpbmthZ2UgPSBwcmVmZXJyZWRBbGlhcztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0cztcbiAgfTtcblxuICB2YXIgbWVyZ2VDbG9zZXN0ID0gZnVuY3Rpb24gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpIHtcbiAgICAvLyBGaW5kIHR3byBjbG9zZXN0IGNsdXN0ZXJzIGZyb20gY2FjaGVkIG1pbnNcbiAgICB2YXIgbWluS2V5ID0gMDtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIGRpc3Q7XG4gICAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuXG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgICAgfSwgbjEsIG4yKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGNsdXN0ZXJzW2ldLmtleTtcbiAgICAgIHZhciBfZGlzdCA9IGRpc3RzW2tleV1bbWluc1trZXldXTtcblxuICAgICAgaWYgKF9kaXN0IDwgbWluKSB7XG4gICAgICAgIG1pbktleSA9IGtleTtcbiAgICAgICAgbWluID0gX2Rpc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubW9kZSA9PT0gJ3RocmVzaG9sZCcgJiYgbWluID49IG9wdHMudGhyZXNob2xkIHx8IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nICYmIGNsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjMSA9IGluZGV4W21pbktleV07XG4gICAgdmFyIGMyID0gaW5kZXhbbWluc1ttaW5LZXldXTtcbiAgICB2YXIgbWVyZ2VkOyAvLyBNZXJnZSB0d28gY2xvc2VzdCBjbHVzdGVyc1xuXG4gICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgICBtZXJnZWQgPSB7XG4gICAgICAgIGxlZnQ6IGMxLFxuICAgICAgICByaWdodDogYzIsXG4gICAgICAgIGtleTogYzEua2V5XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWQgPSB7XG4gICAgICAgIHZhbHVlOiBjMS52YWx1ZS5jb25jYXQoYzIudmFsdWUpLFxuICAgICAgICBrZXk6IGMxLmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjbHVzdGVyc1tjMS5pbmRleF0gPSBtZXJnZWQ7XG4gICAgY2x1c3RlcnMuc3BsaWNlKGMyLmluZGV4LCAxKTtcbiAgICBpbmRleFtjMS5rZXldID0gbWVyZ2VkOyAvLyBVcGRhdGUgZGlzdGFuY2VzIHdpdGggbmV3IG1lcmdlZCBjbHVzdGVyXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY2x1c3RlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY3VyID0gY2x1c3RlcnNbX2ldO1xuXG4gICAgICBpZiAoYzEua2V5ID09PSBjdXIua2V5KSB7XG4gICAgICAgIGRpc3QgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWluJykge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcblxuICAgICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA+IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtYXgnKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuXG4gICAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldIDwgZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21lYW4nKSB7XG4gICAgICAgIGRpc3QgPSAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSAqIGMxLnNpemUgKyBkaXN0c1tjMi5rZXldW2N1ci5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWUsIGMxLnZhbHVlKTtlbHNlIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZVswXSwgYzEudmFsdWVbMF0pO1xuICAgICAgfVxuXG4gICAgICBkaXN0c1tjMS5rZXldW2N1ci5rZXldID0gZGlzdHNbY3VyLmtleV1bYzEua2V5XSA9IGRpc3Q7IC8vIGRpc3RhbmNlIG1hdHJpeCBpcyBzeW1tZXRyaWNcbiAgICB9IC8vIFVwZGF0ZSBjYWNoZWQgbWluc1xuXG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjbHVzdGVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIga2V5MSA9IGNsdXN0ZXJzW19pMl0ua2V5O1xuXG4gICAgICBpZiAobWluc1trZXkxXSA9PT0gYzEua2V5IHx8IG1pbnNba2V5MV0gPT09IGMyLmtleSkge1xuICAgICAgICB2YXIgX21pbiA9IGtleTE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBrZXkyID0gY2x1c3RlcnNbal0ua2V5O1xuXG4gICAgICAgICAgaWYgKGRpc3RzW2tleTFdW2tleTJdIDwgZGlzdHNba2V5MV1bX21pbl0pIHtcbiAgICAgICAgICAgIF9taW4gPSBrZXkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1pbnNba2V5MV0gPSBfbWluO1xuICAgICAgfVxuXG4gICAgICBjbHVzdGVyc1tfaTJdLmluZGV4ID0gX2kyO1xuICAgIH0gLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcblxuXG4gICAgYzEua2V5ID0gYzIua2V5ID0gYzEuaW5kZXggPSBjMi5pbmRleCA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIGdldEFsbENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4ocm9vdCwgYXJyLCBjeSkge1xuICAgIGlmICghcm9vdCkgcmV0dXJuO1xuXG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIGFyci5wdXNoKHJvb3QudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGFycik7XG4gICAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgYXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWxkRGVuZHJvZ3JhbSA9IGZ1bmN0aW9uIGJ1aWxkRGVuZHJvZ3JhbShyb290LCBjeSkge1xuICAgIGlmICghcm9vdCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHJvb3QubGVmdCAmJiByb290LnJpZ2h0KSB7XG4gICAgICB2YXIgbGVmdFN0ciA9IGJ1aWxkRGVuZHJvZ3JhbShyb290LmxlZnQsIGN5KTtcbiAgICAgIHZhciByaWdodFN0ciA9IGJ1aWxkRGVuZHJvZ3JhbShyb290LnJpZ2h0LCBjeSk7XG4gICAgICB2YXIgbm9kZSA9IGN5LmFkZCh7XG4gICAgICAgIGdyb3VwOiAnbm9kZXMnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGxlZnRTdHIgKyAnLCcgKyByaWdodFN0clxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN5LmFkZCh7XG4gICAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBsZWZ0U3RyLFxuICAgICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3kuYWRkKHtcbiAgICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzb3VyY2U6IHJpZ2h0U3RyLFxuICAgICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgICB9IGVsc2UgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIHJldHVybiByb290LnZhbHVlLmlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBidWlsZENsdXN0ZXJzRnJvbVRyZWUgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdCwgaywgY3kpIHtcbiAgICBpZiAoIXJvb3QpIHJldHVybiBbXTtcbiAgICB2YXIgbGVmdCA9IFtdLFxuICAgICAgICByaWdodCA9IFtdLFxuICAgICAgICBsZWF2ZXMgPSBbXTtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICAvLyBkb24ndCBjdXQgdHJlZSwgc2ltcGx5IHJldHVybiBhbGwgbm9kZXMgYXMgMSBzaW5nbGUgY2x1c3RlclxuICAgICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgICBsZWF2ZXMgPSBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVhdmVzKV07XG4gICAgfSBlbHNlIGlmIChrID09PSAxKSB7XG4gICAgICAvLyBjdXQgYXQgcm9vdFxuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgLy8gbGVhZiBub2RlXG4gICAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgICAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVmdCksIGN5LmNvbGxlY3Rpb24ocmlnaHQpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyb290LmxlZnQpIGxlZnQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5sZWZ0LCBrIC0gMSwgY3kpO1xuICAgICAgICBpZiAocm9vdC5yaWdodCkgcmlnaHQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5yaWdodCwgayAtIDEsIGN5KTtcbiAgICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuXG4gIHZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24gaGllcmFyY2hpY2FsQ2x1c3RlcmluZyhvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiBsaW5rYWdlIHR5cGUsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuXG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDEob3B0aW9ucyk7XG4gICAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuXG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgICAgfSwgbjEsIG4yKTtcbiAgICB9OyAvLyBCZWdpbiBoaWVyYXJjaGljYWwgYWxnb3JpdGhtXG5cblxuICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgIHZhciBkaXN0cyA9IFtdOyAvLyBkaXN0YW5jZXMgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcblxuICAgIHZhciBtaW5zID0gW107IC8vIGNsb3Nlc3QgY2x1c3RlciBmb3IgZWFjaCBjbHVzdGVyXG5cbiAgICB2YXIgaW5kZXggPSBbXTsgLy8gaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG4gICAgLy8gSW4gYWdnbG9tZXJhdGl2ZSAoYm90dG9tLXVwKSBjbHVzdGVyaW5nLCBlYWNoIG5vZGUgc3RhcnRzIGFzIGl0cyBvd24gY2x1c3RlclxuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICAgIHZhbHVlOiBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyA/IG5vZGVzW25dIDogW25vZGVzW25dXSxcbiAgICAgICAga2V5OiBuLFxuICAgICAgICBpbmRleDogblxuICAgICAgfTtcbiAgICAgIGNsdXN0ZXJzW25dID0gY2x1c3RlcjtcbiAgICAgIGluZGV4W25dID0gY2x1c3RlcjtcbiAgICAgIGRpc3RzW25dID0gW107XG4gICAgICBtaW5zW25dID0gMDtcbiAgICB9IC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICAgIHZhciBkaXN0ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgICAgIC8vIG1vZGVzIHN0b3JlIGNsdXN0ZXIgdmFsdWVzIGRpZmZlcmVudGx5XG4gICAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWUsIGNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZVswXSwgY2x1c3RlcnNbal0udmFsdWVbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzdHNbaV1bal0gPSBkaXN0O1xuICAgICAgICBkaXN0c1tqXVtpXSA9IGRpc3Q7XG5cbiAgICAgICAgaWYgKGRpc3QgPCBkaXN0c1tpXVttaW5zW2ldXSkge1xuICAgICAgICAgIG1pbnNbaV0gPSBqOyAvLyBDYWNoZSBtaW5zOiBjbG9zZXN0IGNsdXN0ZXIgdG8gY2x1c3RlciBpIGlzIGNsdXN0ZXIgalxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBGaW5kIHRoZSBjbG9zZXN0IHBhaXIgb2YgY2x1c3RlcnMgYW5kIG1lcmdlIHRoZW0gaW50byBhIHNpbmdsZSBjbHVzdGVyLlxuICAgIC8vIFVwZGF0ZSBkaXN0YW5jZXMgYmV0d2VlbiBuZXcgY2x1c3RlciBhbmQgZWFjaCBvZiB0aGUgb2xkIGNsdXN0ZXJzLCBhbmQgbG9vcCB1bnRpbCB0aHJlc2hvbGQgcmVhY2hlZC5cblxuXG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcblxuICAgIHdoaWxlIChtZXJnZWQpIHtcbiAgICAgIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0Q2x1c3RlcnM7IC8vIERlbmRyb2dyYW0gbW9kZSBidWlsZHMgdGhlIGhpZXJhcmNoeSBhbmQgYWRkcyBpbnRlcm1lZGlhcnkgbm9kZXMgKyBlZGdlc1xuICAgIC8vIGluIGFkZGl0aW9uIHRvIHJldHVybmluZyB0aGUgY2x1c3RlcnMuXG5cbiAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgIHJldENsdXN0ZXJzID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKGNsdXN0ZXJzWzBdLCBvcHRzLmRlbmRyb2dyYW1EZXB0aCwgY3kpO1xuICAgICAgaWYgKG9wdHMuYWRkRGVuZHJvZ3JhbSkgYnVpbGREZW5kcm9ncmFtKGNsdXN0ZXJzWzBdLCBjeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXIgbW9kZSBzaW1wbHkgcmV0dXJucyB0aGUgY2x1c3RlcnNcbiAgICAgIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGNsdXN0ZXJzLmxlbmd0aCk7XG4gICAgICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBpKSB7XG4gICAgICAgIC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gICAgICAgIGNsdXN0ZXIua2V5ID0gY2x1c3Rlci5pbmRleCA9IG51bGw7XG4gICAgICAgIHJldENsdXN0ZXJzW2ldID0gY3kuY29sbGVjdGlvbihjbHVzdGVyLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXRDbHVzdGVycztcbiAgfTtcblxuICB2YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxID0ge1xuICAgIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmc6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcsXG4gICAgaGNhOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nXG4gIH07XG5cbiAgLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4gIHZhciBkZWZhdWx0cyQ5ID0gZGVmYXVsdHMkZyh7XG4gICAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAgIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIGF0dHJpYnV0ZXMgYmV0d2VlbiB0d28gbm9kZXNcbiAgICBwcmVmZXJlbmNlOiAnbWVkaWFuJyxcbiAgICAvLyBzdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgICBkYW1waW5nOiAwLjgsXG4gICAgLy8gZGFtcGluZyBmYWN0b3IgYmV0d2VlbiBbMC41LCAxKVxuICAgIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgLy8gbWF4IG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1blxuICAgIG1pbkl0ZXJhdGlvbnM6IDEwMCxcbiAgICAvLyBtaW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuIGluIG9yZGVyIGZvciBjbHVzdGVyaW5nIHRvIHN0b3BcbiAgICBhdHRyaWJ1dGVzOiBbLy8gZnVuY3Rpb25zIHRvIHF1YW50aWZ5IHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gYW55IHR3byBwb2ludHNcbiAgICAgIC8vIGUuZy4gbm9kZSA9PiBub2RlLmRhdGEoJ3dlaWdodCcpXG4gICAgXVxuICB9KTtcblxuICB2YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBkbXAgPSBvcHRpb25zLmRhbXBpbmc7XG4gICAgdmFyIHByZWYgPSBvcHRpb25zLnByZWZlcmVuY2U7XG5cbiAgICBpZiAoISgwLjUgPD0gZG1wICYmIGRtcCA8IDEpKSB7XG4gICAgICBlcnJvcihcIkRhbXBpbmcgbXVzdCByYW5nZSBvbiBbMC41LCAxKS4gIEdvdDogXCIuY29uY2F0KGRtcCkpO1xuICAgIH1cblxuICAgIHZhciB2YWxpZFByZWZzID0gWydtZWRpYW4nLCAnbWVhbicsICdtaW4nLCAnbWF4J107XG5cbiAgICBpZiAoISh2YWxpZFByZWZzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSBwcmVmO1xuICAgIH0pIHx8IG51bWJlciQxKHByZWYpKSkge1xuICAgICAgZXJyb3IoXCJQcmVmZXJlbmNlIG11c3QgYmUgb25lIG9mIFtcIi5jb25jYXQodmFsaWRQcmVmcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIFwiJ1wiLmNvbmNhdChwLCBcIidcIik7XG4gICAgICB9KS5qb2luKCcsICcpLCBcIl0gb3IgYSBudW1iZXIuICBHb3Q6IFwiKS5jb25jYXQocHJlZikpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0cyQ5KG9wdGlvbnMpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICB2YXIgZ2V0U2ltaWxhcml0eSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkodHlwZSwgbjEsIG4yLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG4sIGkpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG4pO1xuICAgIH07IC8vIG5iIG5lZ2F0aXZlIGJlY2F1c2Ugc2ltaWxhcml0eSBzaG91bGQgaGF2ZSBhbiBpbnZlcnNlIHJlbGF0aW9uc2hpcCB0byBkaXN0YW5jZVxuXG5cbiAgICByZXR1cm4gLWNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyKG4xLCBpKTtcbiAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHIobjIsIGkpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG5cbiAgdmFyIGdldFByZWZlcmVuY2UgPSBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlKFMsIHByZWZlcmVuY2UpIHtcbiAgICAvLyBsYXJnZXIgcHJlZmVyZW5jZSA9IGdyZWF0ZXIgIyBvZiBjbHVzdGVyc1xuICAgIHZhciBwID0gbnVsbDtcblxuICAgIGlmIChwcmVmZXJlbmNlID09PSAnbWVkaWFuJykge1xuICAgICAgcCA9IG1lZGlhbihTKTtcbiAgICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtZWFuJykge1xuICAgICAgcCA9IG1lYW4oUyk7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWluJykge1xuICAgICAgcCA9IG1pbihTKTtcbiAgICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtYXgnKSB7XG4gICAgICBwID0gbWF4KFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDdXN0b20gcHJlZmVyZW5jZSBudW1iZXIsIGFzIHNldCBieSB1c2VyXG4gICAgICBwID0gcHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgZmluZEV4ZW1wbGFycyA9IGZ1bmN0aW9uIGZpbmRFeGVtcGxhcnMobiwgUiwgQSkge1xuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKFJbaSAqIG4gKyBpXSArIEFbaSAqIG4gKyBpXSA+IDApIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9O1xuXG4gIHZhciBhc3NpZ25DbHVzdGVycyA9IGZ1bmN0aW9uIGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycykge1xuICAgIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICAgICAgdmFyIGUgPSBleGVtcGxhcnNbZWldO1xuXG4gICAgICAgIGlmIChTW2kgKiBuICsgZV0gPiBtYXgpIHtcbiAgICAgICAgICBpbmRleCA9IGU7XG4gICAgICAgICAgbWF4ID0gU1tpICogbiArIGVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgY2x1c3RlcnMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2VpID0gMDsgX2VpIDwgZXhlbXBsYXJzLmxlbmd0aDsgX2VpKyspIHtcbiAgICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc1tfZWldXSA9IGV4ZW1wbGFyc1tfZWldO1xuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKG4sIFMsIGV4ZW1wbGFycykge1xuICAgIHZhciBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG5cbiAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgdmFyIGlpID0gW107XG5cbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgaWYgKGNsdXN0ZXJzW2NdID09PSBleGVtcGxhcnNbZWldKSB7XG4gICAgICAgICAgaWkucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4SSA9IC0xO1xuICAgICAgdmFyIG1heFN1bSA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc3VtICs9IFNbaWlbal0gKiBuICsgaWlbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1bSA+IG1heFN1bSkge1xuICAgICAgICAgIG1heEkgPSBpO1xuICAgICAgICAgIG1heFN1bSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleGVtcGxhcnNbZWldID0gaWlbbWF4SV07XG4gICAgfVxuXG4gICAgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIGFmZmluaXR5UHJvcGFnYXRpb24ob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICB9IC8vIEJlZ2luIGFmZmluaXR5IHByb3BhZ2F0aW9uIGFsZ29yaXRobVxuXG5cbiAgICB2YXIgbjsgLy8gbnVtYmVyIG9mIGRhdGEgcG9pbnRzXG5cbiAgICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcblxuICAgIHZhciBTOyAvLyBzaW1pbGFyaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgICB2YXIgcDsgLy8gcHJlZmVyZW5jZS9zdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcblxuICAgIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gICAgdmFyIEE7IC8vIGF2YWlsYWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gICAgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBuMiA9IG4gKiBuOyAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG5cbiAgICBTID0gbmV3IEFycmF5KG4yKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgICAgU1tfaV0gPSAtSW5maW5pdHk7IC8vIGZvciBjYXNlcyB3aGVyZSB0d28gZGF0YSBwb2ludHMgc2hvdWxkbid0IGJlIGxpbmtlZCB0b2dldGhlclxuICAgIH1cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG47IF9pMisrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoX2kyICE9PSBqKSB7XG4gICAgICAgICAgU1tfaTIgKiBuICsgal0gPSBnZXRTaW1pbGFyaXR5KG9wdHMuZGlzdGFuY2UsIG5vZGVzW19pMl0sIG5vZGVzW2pdLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBQbGFjZSBwcmVmZXJlbmNlcyBvbiB0aGUgZGlhZ29uYWwgb2YgU1xuXG5cbiAgICBwID0gZ2V0UHJlZmVyZW5jZShTLCBvcHRzLnByZWZlcmVuY2UpO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbjsgX2kzKyspIHtcbiAgICAgIFNbX2kzICogbiArIF9pM10gPSBwO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuXG5cbiAgICBSID0gbmV3IEFycmF5KG4yKTtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG4yOyBfaTQrKykge1xuICAgICAgUltfaTRdID0gMC4wO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcblxuXG4gICAgQSA9IG5ldyBBcnJheShuMik7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuMjsgX2k1KyspIHtcbiAgICAgIEFbX2k1XSA9IDAuMDtcbiAgICB9XG5cbiAgICB2YXIgb2xkID0gbmV3IEFycmF5KG4pO1xuICAgIHZhciBScCA9IG5ldyBBcnJheShuKTtcbiAgICB2YXIgc2UgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBuOyBfaTYrKykge1xuICAgICAgb2xkW19pNl0gPSAwLjA7XG4gICAgICBScFtfaTZdID0gMC4wO1xuICAgICAgc2VbX2k2XSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQXJyYXkobiAqIG9wdHMubWluSXRlcmF0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgIGVbX2k3XSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXI7XG5cbiAgICBmb3IgKGl0ZXIgPSAwOyBpdGVyIDwgb3B0cy5tYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAgIC8vIG1haW4gYWxnb3JpdGhtaWMgbG9vcFxuICAgICAgLy8gVXBkYXRlIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBuOyBfaTgrKykge1xuICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgICAgbWF4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgIG1heEkgPSAtMSxcbiAgICAgICAgICAgIEFTID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgICAgb2xkW19qXSA9IFJbX2k4ICogbiArIF9qXTtcbiAgICAgICAgICBBUyA9IEFbX2k4ICogbiArIF9qXSArIFNbX2k4ICogbiArIF9qXTtcblxuICAgICAgICAgIGlmIChBUyA+PSBtYXgpIHtcbiAgICAgICAgICAgIG1heDIgPSBtYXg7XG4gICAgICAgICAgICBtYXggPSBBUztcbiAgICAgICAgICAgIG1heEkgPSBfajtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFTID4gbWF4Mikge1xuICAgICAgICAgICAgbWF4MiA9IEFTO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG47IF9qMisrKSB7XG4gICAgICAgICAgUltfaTggKiBuICsgX2oyXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBfajJdIC0gbWF4KSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajJdO1xuICAgICAgICB9XG5cbiAgICAgICAgUltfaTggKiBuICsgbWF4SV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgbWF4SV0gLSBtYXgyKSArIG9wdHMuZGFtcGluZyAqIG9sZFttYXhJXTtcbiAgICAgIH0gLy8gVXBkYXRlIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuXG5cbiAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG47IF9pOSsrKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG47IF9qMysrKSB7XG4gICAgICAgICAgb2xkW19qM10gPSBBW19qMyAqIG4gKyBfaTldO1xuICAgICAgICAgIFJwW19qM10gPSBNYXRoLm1heCgwLCBSW19qMyAqIG4gKyBfaTldKTtcbiAgICAgICAgICBzdW0gKz0gUnBbX2ozXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSAtPSBScFtfaTldO1xuICAgICAgICBScFtfaTldID0gUltfaTkgKiBuICsgX2k5XTtcbiAgICAgICAgc3VtICs9IFJwW19pOV07XG5cbiAgICAgICAgZm9yICh2YXIgX2o0ID0gMDsgX2o0IDwgbjsgX2o0KyspIHtcbiAgICAgICAgICBBW19qNCAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogTWF0aC5taW4oMCwgc3VtIC0gUnBbX2o0XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2o0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFbX2k5ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoc3VtIC0gUnBbX2k5XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2k5XTtcbiAgICAgIH0gLy8gQ2hlY2sgZm9yIGNvbnZlcmdlbmNlXG5cblxuICAgICAgdmFyIEsgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG47IF9pMTArKykge1xuICAgICAgICB2YXIgRSA9IEFbX2kxMCAqIG4gKyBfaTEwXSArIFJbX2kxMCAqIG4gKyBfaTEwXSA+IDAgPyAxIDogMDtcbiAgICAgICAgZVtpdGVyICUgb3B0cy5taW5JdGVyYXRpb25zICogbiArIF9pMTBdID0gRTtcbiAgICAgICAgSyArPSBFO1xuICAgICAgfVxuXG4gICAgICBpZiAoSyA+IDAgJiYgKGl0ZXIgPj0gb3B0cy5taW5JdGVyYXRpb25zIC0gMSB8fCBpdGVyID09IG9wdHMubWF4SXRlcmF0aW9ucyAtIDEpKSB7XG4gICAgICAgIHZhciBfc3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG47IF9pMTErKykge1xuICAgICAgICAgIHNlW19pMTFdID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IG9wdHMubWluSXRlcmF0aW9uczsgX2o1KyspIHtcbiAgICAgICAgICAgIHNlW19pMTFdICs9IGVbX2o1ICogbiArIF9pMTFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZVtfaTExXSA9PT0gMCB8fCBzZVtfaTExXSA9PT0gb3B0cy5taW5JdGVyYXRpb25zKSB7XG4gICAgICAgICAgICBfc3VtKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9zdW0gPT09IG4pIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGhhdmUgY29udmVyZ2VuY2VcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSWRlbnRpZnkgZXhlbXBsYXJzIChjbHVzdGVyIGNlbnRlcnMpXG5cblxuICAgIHZhciBleGVtcGxhcnNJbmRpY2VzID0gZmluZEV4ZW1wbGFycyhuLCBSLCBBKTsgLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzXG5cbiAgICB2YXIgY2x1c3RlckluZGljZXMgPSBhc3NpZ24obiwgUywgZXhlbXBsYXJzSW5kaWNlcyk7XG4gICAgdmFyIGNsdXN0ZXJzID0ge307XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbY11dID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2Rlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgdmFyIHBvcyA9IGlkMnBvc2l0aW9uW25vZGVzW19pMTJdLmlkKCldO1xuXG4gICAgICB2YXIgY2x1c3RlckluZGV4ID0gY2x1c3RlckluZGljZXNbcG9zXTtcblxuICAgICAgaWYgKGNsdXN0ZXJJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIC8vIHRoZSBub2RlIG1heSBoYXZlIG5vdCBiZWVuIGFzc2lnbmVkIGEgY2x1c3RlciBpZiBubyB2YWxpZCBhdHRyaWJ1dGVzIHdlcmUgc3BlY2lmaWVkXG4gICAgICAgIGNsdXN0ZXJzW2NsdXN0ZXJJbmRleF0ucHVzaChub2Rlc1tfaTEyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIF9jID0gMDsgX2MgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgX2MrKykge1xuICAgICAgcmV0Q2x1c3RlcnNbX2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW19jXV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXRDbHVzdGVycztcbiAgfTtcblxuICB2YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiQxID0ge1xuICAgIGFmZmluaXR5UHJvcGFnYXRpb246IGFmZmluaXR5UHJvcGFnYXRpb24sXG4gICAgYXA6IGFmZmluaXR5UHJvcGFnYXRpb25cbiAgfTtcblxuICB2YXIgaGllcmhvbHplckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgcm9vdDogdW5kZWZpbmVkLFxuICAgIGRpcmVjdGVkOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiRrID0ge1xuICAgIGhpZXJob2x6ZXI6IGZ1bmN0aW9uIGhpZXJob2x6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICAgIGRpcmVjdGVkOiBhcmdzWzFdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBfaGllcmhvbHplckRlZmF1bHRzID0gaGllcmhvbHplckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIHJvb3QgPSBfaGllcmhvbHplckRlZmF1bHRzLnJvb3QsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfaGllcmhvbHplckRlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgZGZsYWcgPSBmYWxzZTtcbiAgICAgIHZhciBvZGRJbjtcbiAgICAgIHZhciBvZGRPdXQ7XG4gICAgICB2YXIgc3RhcnRWZXJ0ZXg7XG4gICAgICBpZiAocm9vdCkgc3RhcnRWZXJ0ZXggPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXS5pZCgpIDogcm9vdFswXS5pZCgpO1xuICAgICAgdmFyIG5vZGVzID0ge307XG4gICAgICB2YXIgZWRnZXMgPSB7fTtcblxuICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgaW5kID0gZWxlLmluZGVncmVlKHRydWUpO1xuICAgICAgICAgICAgdmFyIG91dGQgPSBlbGUub3V0ZGVncmVlKHRydWUpO1xuICAgICAgICAgICAgdmFyIGQxID0gaW5kIC0gb3V0ZDtcbiAgICAgICAgICAgIHZhciBkMiA9IG91dGQgLSBpbmQ7XG5cbiAgICAgICAgICAgIGlmIChkMSA9PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvZGRJbikgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkSW4gPSBpZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPT0gMSkge1xuICAgICAgICAgICAgICBpZiAob2RkT3V0KSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRPdXQgPSBpZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPiAxIHx8IGQxID4gMSkge1xuICAgICAgICAgICAgICBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgICAgZWxlLm91dGdvZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoZS5pc0VkZ2UoKSkgbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGdlc1tpZF0gPSBbdW5kZWZpbmVkLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGVsZS5kZWdyZWUodHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChkICUgMikge1xuICAgICAgICAgICAgICBpZiAoIW9kZEluKSBvZGRJbiA9IGlkO2Vsc2UgaWYgKCFvZGRPdXQpIG9kZE91dCA9IGlkO2Vsc2UgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXNbaWRdID0gW2VsZS5zb3VyY2UoKS5pZCgpLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgICB0cmFpbDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgaWYgKGRmbGFnKSByZXR1cm4gcmVzdWx0O2Vsc2UgaWYgKG9kZE91dCAmJiBvZGRJbikge1xuICAgICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXggJiYgb2RkSW4gIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzdGFydFZlcnRleCkgc3RhcnRWZXJ0ZXggPSBlbGVzWzBdLmlkKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gd2Fsayh2KSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHY7XG4gICAgICAgIHZhciBzdWJ0b3VyID0gW3ZdO1xuICAgICAgICB2YXIgYWRqLCBhZGpUYWlsLCBhZGpIZWFkO1xuXG4gICAgICAgIHdoaWxlIChub2Rlc1tjdXJyZW50Tm9kZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgYWRqID0gbm9kZXNbY3VycmVudE5vZGVdLnNoaWZ0KCk7XG4gICAgICAgICAgYWRqVGFpbCA9IGVkZ2VzW2Fkal1bMF07XG4gICAgICAgICAgYWRqSGVhZCA9IGVkZ2VzW2Fkal1bMV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gYWRqSGVhZCkge1xuICAgICAgICAgICAgbm9kZXNbYWRqSGVhZF0gPSBub2Rlc1thZGpIZWFkXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkakhlYWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghZGlyZWN0ZWQgJiYgY3VycmVudE5vZGUgIT0gYWRqVGFpbCkge1xuICAgICAgICAgICAgbm9kZXNbYWRqVGFpbF0gPSBub2Rlc1thZGpUYWlsXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkalRhaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VidG91ci51bnNoaWZ0KGFkaik7XG4gICAgICAgICAgc3VidG91ci51bnNoaWZ0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJ0b3VyO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRyYWlsID0gW107XG4gICAgICB2YXIgc3VidG91ciA9IFtdO1xuICAgICAgc3VidG91ciA9IHdhbGsoc3RhcnRWZXJ0ZXgpO1xuXG4gICAgICB3aGlsZSAoc3VidG91ci5sZW5ndGggIT0gMSkge1xuICAgICAgICBpZiAobm9kZXNbc3VidG91clswXV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YnRvdXIgPSB3YWxrKHN1YnRvdXIuc2hpZnQoKSkuY29uY2F0KHN1YnRvdXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTsgLy8gZmluYWwgbm9kZVxuXG4gICAgICBmb3IgKHZhciBkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlc1tkXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5mb3VuZCA9IHRydWU7XG4gICAgICByZXN1bHQudHJhaWwgPSB0aGlzLnNwYXduKHRyYWlsLCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkID0gZnVuY3Rpb24gaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCgpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGlkID0gMDtcbiAgICB2YXIgZWRnZUNvdW50ID0gMDtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciB2aXNpdGVkRWRnZXMgPSB7fTtcblxuICAgIHZhciBidWlsZENvbXBvbmVudCA9IGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50KHgsIHkpIHtcbiAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjdXRzZXQgPSBbXTtcbiAgICAgIHZhciBjb21wb25lbnQgPSBlbGVzLnNwYXduKCk7XG5cbiAgICAgIHdoaWxlIChzdGFja1tpXS54ICE9IHggfHwgc3RhY2tbaV0ueSAhPSB5KSB7XG4gICAgICAgIGN1dHNldC5wdXNoKHN0YWNrLnBvcCgpLmVkZ2UpO1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIGN1dHNldC5wdXNoKHN0YWNrLnBvcCgpLmVkZ2UpO1xuICAgICAgY3V0c2V0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gZWRnZS5jb25uZWN0ZWROb2RlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKGVkZ2UpO1xuICAgICAgICBjb25uZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcblxuICAgICAgICAgIGlmICghbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShjb25uZWN0ZWRFZGdlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShjb25uZWN0ZWRFZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgfTtcblxuICAgIHZhciBiaWNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIGJpY29ubmVjdGVkU2VhcmNoKHJvb3QsIGN1cnJlbnROb2RlLCBwYXJlbnQpIHtcbiAgICAgIGlmIChyb290ID09PSBwYXJlbnQpIGVkZ2VDb3VudCArPSAxO1xuICAgICAgbm9kZXNbY3VycmVudE5vZGVdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGxvdzogaWQrKyxcbiAgICAgICAgY3V0VmVydGV4OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZ2V0RWxlbWVudEJ5SWQoY3VycmVudE5vZGUpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuXG4gICAgICBpZiAoZWRnZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChlbGVzLnNwYXduKGVsZXMuZ2V0RWxlbWVudEJ5SWQoY3VycmVudE5vZGUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlSWQsIHRhcmdldElkLCBvdGhlck5vZGVJZCwgZWRnZUlkO1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgc291cmNlSWQgPSBlZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICAgICAgdGFyZ2V0SWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICAgICAgb3RoZXJOb2RlSWQgPSBzb3VyY2VJZCA9PT0gY3VycmVudE5vZGUgPyB0YXJnZXRJZCA6IHNvdXJjZUlkO1xuXG4gICAgICAgICAgaWYgKG90aGVyTm9kZUlkICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGVkZ2VJZCA9IGVkZ2UuaWQoKTtcblxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkRWRnZXNbZWRnZUlkXSkge1xuICAgICAgICAgICAgICB2aXNpdGVkRWRnZXNbZWRnZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHk6IG90aGVyTm9kZUlkLFxuICAgICAgICAgICAgICAgIGVkZ2U6IGVkZ2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKG90aGVyTm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgICAgICBiaWNvbm5lY3RlZFNlYXJjaChyb290LCBvdGhlck5vZGVJZCwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0ubG93ID0gTWF0aC5taW4obm9kZXNbY3VycmVudE5vZGVdLmxvdywgbm9kZXNbb3RoZXJOb2RlSWRdLmxvdyk7XG5cbiAgICAgICAgICAgICAgaWYgKG5vZGVzW2N1cnJlbnROb2RlXS5pZCA8PSBub2Rlc1tvdGhlck5vZGVJZF0ubG93KSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmN1dFZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnVpbGRDb21wb25lbnQoY3VycmVudE5vZGUsIG90aGVyTm9kZUlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmICghKG5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICBlZGdlQ291bnQgPSAwO1xuICAgICAgICAgIGJpY29ubmVjdGVkU2VhcmNoKG5vZGVJZCwgbm9kZUlkKTtcbiAgICAgICAgICBub2Rlc1tub2RlSWRdLmN1dFZlcnRleCA9IGVkZ2VDb3VudCA+IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgY3V0VmVydGljZXMgPSBPYmplY3Qua2V5cyhub2RlcykuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIG5vZGVzW2lkXS5jdXRWZXJ0ZXg7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGVsZXMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjdXQ6IGVsZXMuc3Bhd24oY3V0VmVydGljZXMpLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSA9IHtcbiAgICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICAgIGh0YmM6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gICAgaHRiOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICAgIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRDb21wb25lbnRzOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkXG4gIH07XG5cbiAgdmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkID0gZnVuY3Rpb24gdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQoKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgY3V0ID0gZWxlcy5zcGF3bihlbGVzKTtcblxuICAgIHZhciBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKHNvdXJjZU5vZGVJZCkge1xuICAgICAgc3RhY2sucHVzaChzb3VyY2VOb2RlSWQpO1xuICAgICAgbm9kZXNbc291cmNlTm9kZUlkXSA9IHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsb3c6IGluZGV4KyssXG4gICAgICAgIGV4cGxvcmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IGVsZXMuZ2V0RWxlbWVudEJ5SWQoc291cmNlTm9kZUlkKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICAgIGNvbm5lY3RlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGVJZCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZUlkICE9PSBzb3VyY2VOb2RlSWQpIHtcbiAgICAgICAgICBpZiAoISh0YXJnZXROb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgICBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaCh0YXJnZXROb2RlSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbm9kZXNbdGFyZ2V0Tm9kZUlkXS5leHBsb3JlZCkge1xuICAgICAgICAgICAgbm9kZXNbc291cmNlTm9kZUlkXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdywgbm9kZXNbdGFyZ2V0Tm9kZUlkXS5sb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChub2Rlc1tzb3VyY2VOb2RlSWRdLmluZGV4ID09PSBub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdykge1xuICAgICAgICB2YXIgY29tcG9uZW50Tm9kZXMgPSBlbGVzLnNwYXduKCk7XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBjb21wb25lbnROb2Rlcy5tZXJnZShlbGVzLmdldEVsZW1lbnRCeUlkKG5vZGVJZCkpO1xuICAgICAgICAgIG5vZGVzW25vZGVJZF0ubG93ID0gbm9kZXNbc291cmNlTm9kZUlkXS5pbmRleDtcbiAgICAgICAgICBub2Rlc1tub2RlSWRdLmV4cGxvcmVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChub2RlSWQgPT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudEVkZ2VzID0gY29tcG9uZW50Tm9kZXMuZWRnZXNXaXRoKGNvbXBvbmVudE5vZGVzKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudE5vZGVzLm1lcmdlKGNvbXBvbmVudEVkZ2VzKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIGN1dCA9IGN1dC5kaWZmZXJlbmNlKGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjdXQ6IGN1dCxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICB9O1xuICB9O1xuXG4gIHZhciB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCQxID0ge1xuICAgIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgICB0c2M6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICAgIHRzY2M6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICAgIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50czogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRcbiAgfTtcblxuICB2YXIgZWxlc2ZuJGogPSB7fTtcbiAgW2VsZXNmbiR2LCBlbGVzZm4kdSwgZWxlc2ZuJHQsIGVsZXNmbiRzLCBlbGVzZm4kciwgZWxlc2ZuJHEsIGVsZXNmbiRwLCBlbGVzZm4kbywgZWxlc2ZuJG4sIGVsZXNmbiRtLCBlbGVzZm4kbCwgbWFya292Q2x1c3RlcmluZyQxLCBrQ2x1c3RlcmluZywgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxLCBhZmZpbml0eVByb3BhZ2F0aW9uJDEsIGVsZXNmbiRrLCBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEsIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKGVsZXNmbiRqLCBwcm9wcyk7XG4gIH0pO1xuXG4gIC8qIVxuICBFbWJlZGRhYmxlIE1pbmltdW0gU3RyaWN0bHktQ29tcGxpYW50IFByb21pc2VzL0ErIDEuMS4xIFRoZW5hYmxlXG4gIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG4gIExpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAgKi9cblxuICAvKiAgcHJvbWlzZSBzdGF0ZXMgW1Byb21pc2VzL0ErIDIuMV0gICovXG4gIHZhciBTVEFURV9QRU5ESU5HID0gMDtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG5cbiAgdmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xuXG4gIHZhciBTVEFURV9SRUpFQ1RFRCA9IDI7XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG4gIC8qICBwcm9taXNlIG9iamVjdCBjb25zdHJ1Y3RvciAgKi9cblxuICB2YXIgYXBpID0gZnVuY3Rpb24gYXBpKGV4ZWN1dG9yKSB7XG4gICAgLyogIG9wdGlvbmFsbHkgc3VwcG9ydCBub24tY29uc3RydWN0b3IvcGxhaW4tZnVuY3Rpb24gY2FsbCAgKi9cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSkgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuICAgIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cblxuICAgIHRoaXMuaWQgPSAnVGhlbmFibGUvMS4wLjcnO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QRU5ESU5HO1xuICAgIC8qICBpbml0aWFsIHN0YXRlICAqL1xuXG4gICAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyogIGluaXRpYWwgdmFsdWUgICovXG5cbiAgICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG5cbiAgICB0aGlzLnJlamVjdFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgICAvKiAgaW5pdGlhbCByZWFzb24gKi9cblxuICAgIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cblxuICAgIHRoaXMub25GdWxmaWxsZWQgPSBbXTtcbiAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAgIHRoaXMub25SZWplY3RlZCA9IFtdO1xuICAgIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gICAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuXG4gICAgdGhpcy5wcm94eSA9IHtcbiAgICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cblxuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09ICdmdW5jdGlvbicpIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xuICB9O1xuICAvKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cblxuXG4gIGFwaS5wcm90b3R5cGUgPSB7XG4gICAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gICAgZnVsZmlsbDogZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfRlVMRklMTEVELCAnZnVsZmlsbFZhbHVlJywgdmFsdWUpO1xuICAgIH0sXG4gICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX1JFSkVDVEVELCAncmVqZWN0UmVhc29uJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgICAgdmFyIG5leHQgPSBuZXcgYXBpKCk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cblxuICAgICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKHJlc29sdmVyKG9uRnVsZmlsbGVkLCBuZXh0LCAnZnVsZmlsbCcpKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuXG4gICAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChyZXNvbHZlcihvblJlamVjdGVkLCBuZXh0LCAncmVqZWN0JykpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG5cbiAgICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgICByZXR1cm4gbmV4dC5wcm94eTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gICAgfVxuICB9O1xuICAvKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG5cbiAgdmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiBkZWxpdmVyKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgICBjdXJyLnN0YXRlID0gc3RhdGU7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuXG4gICAgICBjdXJyW25hbWVdID0gdmFsdWU7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuXG4gICAgICBleGVjdXRlKGN1cnIpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyO1xuICB9O1xuICAvKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG5cblxuICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoY3Vycikge1xuICAgIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUpO2Vsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvblJlamVjdGVkJywgY3Vyci5yZWplY3RSZWFzb24pO1xuICB9O1xuICAvKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cblxuXG4gIHZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAgIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cblxuICAgIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICAgIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG5cbiAgICB2YXIgaGFuZGxlcnMgPSBjdXJyW25hbWVdO1xuICAgIGN1cnJbbmFtZV0gPSBbXTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjMsIDIuMi4zLjNdICAqL1xuXG4gICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYW5kbGVyc1tpXSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi41XSAgKi9cblxuICAgIH07XG4gICAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqL1xuXG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cblxuXG4gICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHNldEltbWVkaWF0ZShmdW5jKTtlbHNlIHNldFRpbWVvdXQoZnVuYywgMCk7XG4gIH07XG4gIC8qICBnZW5lcmF0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uICAqL1xuXG5cbiAgdmFyIHJlc29sdmVyID0gZnVuY3Rpb24gcmVzb2x2ZXIoY2IsIG5leHQsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGNiKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHQucmVqZWN0KGUpO1xuICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMl0gICovXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKG5leHQsIHJlc3VsdCk7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cblxuXG4gIHZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB4KSB7XG4gICAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovXG5cbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG5cblxuICAgIHZhciB0aGVuO1xuXG4gICAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4gPSB4LnRoZW47XG4gICAgICB9XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgICBhbmQgc2ltaWxhciBcInRoZW5hYmxlc1wiIFtQcm9taXNlcy9BKyAyLjMuM10gICovXG5cblxuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi9cblxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgICB0aGVuLmNhbGwoeCxcbiAgICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqL1xuXG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuXG4gICAgICAgICAgaWYgKHkgPT09IHgpXG4gICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdjaXJjdWxhciB0aGVuYWJsZSBjaGFpbicpKTtlbHNlIHJlc29sdmUocHJvbWlzZSwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qICByZWplY3RQcm9taXNlICAqL1xuXG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4yXSAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qICBoYW5kbGUgb3RoZXIgdmFsdWVzICAqL1xuXG5cbiAgICBwcm9taXNlLmZ1bGZpbGwoeCk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG4gIH07IC8vIHNvIHdlIGFsd2F5cyBoYXZlIFByb21pc2UuYWxsKClcblxuXG4gIGFwaS5hbGwgPSBmdW5jdGlvbiAocHMpIHtcbiAgICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZUFsbCwgcmVqZWN0QWxsKSB7XG4gICAgICB2YXIgdmFscyA9IG5ldyBBcnJheShwcy5sZW5ndGgpO1xuICAgICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24gZnVsZmlsbChpLCB2YWwpIHtcbiAgICAgICAgdmFsc1tpXSA9IHZhbDtcbiAgICAgICAgZG9uZUNvdW50Kys7XG5cbiAgICAgICAgaWYgKGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzb2x2ZUFsbCh2YWxzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICAgIHZhciBpc1Byb21pc2UgPSBwICE9IG51bGwgJiYgcC50aGVuICE9IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdEFsbChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgYXBpLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVzb2x2ZSh2YWwpO1xuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KHZhbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFByb21pc2UkMSA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gQW5pbWF0aW9uKHRhcmdldCwgb3B0cywgb3B0czIpIHtcbiAgICB2YXIgaXNDb3JlID0gY29yZSh0YXJnZXQpO1xuICAgIHZhciBpc0VsZSA9ICFpc0NvcmU7XG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAxMDAwXG4gICAgfSwgb3B0cywgb3B0czIpO1xuXG4gICAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIF9wLnN0eWxlID0gX3Auc3R5bGUgfHwgX3AuY3NzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3AuaG9va2VkID0gZmFsc2U7XG4gICAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICBfcC5wcm9ncmVzcyA9IDA7XG4gICAgX3AuY29tcGxldGVzID0gW107XG4gICAgX3AuZnJhbWVzID0gW107XG5cbiAgICBpZiAoX3AuY29tcGxldGUgJiYgZm4kNihfcC5jb21wbGV0ZSkpIHtcbiAgICAgIF9wLmNvbXBsZXRlcy5wdXNoKF9wLmNvbXBsZXRlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNFbGUpIHtcbiAgICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICAgIF9wLnN0YXJ0UG9zaXRpb24gPSBfcC5zdGFydFBvc2l0aW9uIHx8IHtcbiAgICAgICAgeDogcG9zLngsXG4gICAgICAgIHk6IHBvcy55XG4gICAgICB9O1xuICAgICAgX3Auc3RhcnRTdHlsZSA9IF9wLnN0YXJ0U3R5bGUgfHwgdGFyZ2V0LmN5KCkuc3R5bGUoKS5nZXRBbmltYXRpb25TdGFydFN0eWxlKHRhcmdldCwgX3Auc3R5bGUpO1xuICAgIH1cblxuICAgIGlmIChpc0NvcmUpIHtcbiAgICAgIHZhciBwYW4gPSB0YXJnZXQucGFuKCk7XG4gICAgICBfcC5zdGFydFBhbiA9IHtcbiAgICAgICAgeDogcGFuLngsXG4gICAgICAgIHk6IHBhbi55XG4gICAgICB9O1xuICAgICAgX3Auc3RhcnRab29tID0gdGFyZ2V0Lnpvb20oKTtcbiAgICB9IC8vIGZvciBmdXR1cmUgdGltZWxpbmUvYW5pbWF0aW9ucyBpbXBsXG5cblxuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB0aGlzWzBdID0gdGhpcztcbiAgfTtcblxuICB2YXIgYW5pZm4gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuICBleHRlbmQoYW5pZm4sIHtcbiAgICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gICAgfSxcbiAgICBob29rOiBmdW5jdGlvbiBob29rKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFfcC5ob29rZWQpIHtcbiAgICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgICB2YXIgcTtcbiAgICAgICAgdmFyIHRBbmkgPSBfcC50YXJnZXQuX3ByaXZhdGUuYW5pbWF0aW9uO1xuXG4gICAgICAgIGlmIChfcC5xdWV1ZSkge1xuICAgICAgICAgIHEgPSB0QW5pLnF1ZXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEgPSB0QW5pLmN1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBxLnB1c2godGhpcyk7IC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuXG4gICAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKF9wLnRhcmdldCkpIHtcbiAgICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woX3AudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7IC8vIGF1dG9yZXdpbmRcblxuICAgICAgaWYgKF9wLnByb2dyZXNzID09PSAxKSB7XG4gICAgICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICAgIH1cblxuICAgICAgX3AucGxheWluZyA9IHRydWU7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcblxuICAgICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ob29rKCk7IC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIHN0YXJ0IHRoZSBhbmltYXRpb24uLi5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwbGF5aW5nOiBmdW5jdGlvbiBwbGF5aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGxheWluZztcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcblxuICAgICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ob29rKCk7IC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGFwcGx5IHRoZSBhbmltYXRpb24gYXQgdGhpcyBwcm9ncmVzc1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFwcGx5aW5nOiBmdW5jdGlvbiBhcHBseWluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZXdpbmQ6IGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDApO1xuICAgIH0sXG4gICAgZmFzdGZvcndhcmQ6IGZ1bmN0aW9uIGZhc3Rmb3J3YXJkKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMSk7XG4gICAgfSxcbiAgICB0aW1lOiBmdW5jdGlvbiB0aW1lKHQpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9wLnByb2dyZXNzICogX3AuZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyh0IC8gX3AuZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHApIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9wLnByb2dyZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY29tcGxldGVkOiBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wcm9ncmVzcyA9PT0gMTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYSwgYikge1xuICAgICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgICAgaWYgKF9wYSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BbYV0gPSBfcFtiXTtcbiAgICAgICAgX3BbYl0gPSBfcGE7XG4gICAgICB9O1xuXG4gICAgICBzd2FwKCd6b29tJywgJ3N0YXJ0Wm9vbScpO1xuICAgICAgc3dhcCgncGFuJywgJ3N0YXJ0UGFuJyk7XG4gICAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7IC8vIHN3YXAgc3R5bGVzXG5cbiAgICAgIGlmIChfcC5zdHlsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9wLnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfcC5zdHlsZVtpXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICB2YXIgc3RhcnRTdHlsZVByb3AgPSBfcC5zdGFydFN0eWxlW25hbWVdO1xuICAgICAgICAgIF9wLnN0YXJ0U3R5bGVbbmFtZV0gPSBwcm9wO1xuICAgICAgICAgIF9wLnN0eWxlW2ldID0gc3RhcnRTdHlsZVByb3A7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGFycjtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgICBhcnIgPSBfcC5mcmFtZXM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgIGFyciA9IF9wLmNvbXBsZXRlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhcnIucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuICBhbmlmbi5ydW4gPSBhbmlmbi5wbGF5O1xuICBhbmlmbi5ydW5uaW5nID0gYW5pZm4ucGxheWluZztcblxuICB2YXIgZGVmaW5lJDMgPSB7XG4gICAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVkSW1wbCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gYW5pbWF0ZWRcbiAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBjbGVhclF1ZXVlXG4gICAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGRlbGF5XG4gICAgZGVsYXlBbmltYXRpb246IGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uKHtcbiAgICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gZGVsYXlcbiAgICBhbmltYXRpb246IGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRpb25JbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgICB2YXIgaXNDb3JlID0gIXNlbGZJc0FycmF5TGlrZTtcbiAgICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXNFbXB0eSA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAocHJvcGVydGllcy5kdXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVzKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VsZXMgJiYgcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbik7XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuXG5cbiAgICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcblxuXG4gICAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcblxuICAgICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbihjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tKTtcblxuICAgICAgICAgIGlmIChjZW50ZXJQYW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuXG5cbiAgICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICAgIHZhciBmaXRWcCA9IGN5LmdldEZpdFZpZXdwb3J0KGZpdC5lbGVzIHx8IGZpdC5ib3VuZGluZ0JveCwgZml0LnBhZGRpbmcpO1xuXG4gICAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuO1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgem9vbSAoJiBwb3RlbnRpYWxseSBwYW4pIHcvIHpvb20gb2JqIGlmIHNldFxuXG5cbiAgICAgICAgaWYgKGlzQ29yZSAmJiBwbGFpbk9iamVjdChwcm9wZXJ0aWVzLnpvb20pKSB7XG4gICAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcblxuICAgICAgICAgIGlmICh2cCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodnAuem9vbWVkKSB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IHZwLnpvb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB2cC5wYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IG51bGw7IC8vIGFuIGluYXZhbGlkIHpvb20gKGUuZy4gbm8gZGVsdGEpIGdldHMgYXV0b21hdGljYWxseSBkZXN0cm95ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihhbGxbMF0sIHByb3BlcnRpZXMpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGFuaW1hdGVcbiAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgICB9IC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG5cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcbiAgICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbihwcm9wZXJ0aWVzLCBxdWV1ZSA/IHtcbiAgICAgICAgICAgIHF1ZXVlOiB0cnVlXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGFuaW1hdGVcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKGNsZWFyUXVldWUsIGp1bXBUb0VuZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGFuaSA9IGFuaXNbal07XG4gICAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICAgIGlmIChqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgICAgLy8gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBsb29wLCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcblxuXG4gICAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghanVtcFRvRW5kKSB7XG4gICAgICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB3ZSBoYXZlIHRvIG5vdGlmeSAodGhlIGFuaW1hdGlvbiBsb29wIGRvZXNuJ3QgZG8gaXQgZm9yIHVzIG9uIGBzdG9wYClcblxuXG4gICAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSAvLyBzdG9wXG5cbiAgfTsgLy8gZGVmaW5lXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIHZhciBpc0FycmF5XzEgPSBpc0FycmF5O1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gIH1cblxuICB2YXIgX2lzS2V5ID0gaXNLZXk7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gIH1cblxuICB2YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gIHZhciBjb3JlSnNEYXRhID0gX3Jvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gIHZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGEgJiYgX2NvcmVKc0RhdGEua2V5cyAmJiBfY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICB9XG5cbiAgdmFyIF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgdmFyIGZ1bmNUb1N0cmluZyQxID0gZnVuY1Byb3RvJDEudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmckMS5jYWxsKGZ1bmMpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBfdG9Tb3VyY2UgPSB0b1NvdXJjZTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5JDMpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgKTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpIHx8IF9pc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uXzEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZSh2YWx1ZSkpO1xuICB9XG5cbiAgdmFyIF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIHZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBfZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICB2YXIgbmF0aXZlQ3JlYXRlID0gX2dldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICB2YXIgX25hdGl2ZUNyZWF0ZSA9IG5hdGl2ZUNyZWF0ZTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gX25hdGl2ZUNyZWF0ZSA/IF9uYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG5cbiAgdmFyIF9oYXNoQ2xlYXIgPSBoYXNoQ2xlYXI7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCQxID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkMiA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBnZXRcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChfbmF0aXZlQ3JlYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQkMSA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5JDIuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIF9oYXNoR2V0ID0gaGFzaEdldDtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQxLmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGhhc1xuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkMS5jYWxsKGRhdGEsIGtleSk7XG4gIH1cblxuICB2YXIgX2hhc2hIYXMgPSBoYXNoSGFzO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgZGF0YVtrZXldID0gKF9uYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIF9oYXNoU2V0ID0gaGFzaFNldDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IF9oYXNoQ2xlYXI7XG4gIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IF9oYXNoRGVsZXRlO1xuICBIYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcbiAgSGFzaC5wcm90b3R5cGUuaGFzID0gX2hhc2hIYXM7XG4gIEhhc2gucHJvdG90eXBlLnNldCA9IF9oYXNoU2V0O1xuXG4gIHZhciBfSGFzaCA9IEhhc2g7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG5cbiAgdmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhXG4gICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICpcbiAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5lcSgnYScsICdhJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5lcShOYU4sIE5hTik7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICB9XG5cbiAgdmFyIGVxXzEgPSBlcTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgZGF0YS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgIH1cbiAgICAtLXRoaXMuc2l6ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBfbGlzdENhY2hlRGVsZXRlID0gbGlzdENhY2hlRGVsZXRlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICB9XG5cbiAgdmFyIF9saXN0Q2FjaGVHZXQgPSBsaXN0Q2FjaGVHZXQ7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICByZXR1cm4gX2Fzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gIH1cblxuICB2YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuICAvKipcbiAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgKyt0aGlzLnNpemU7XG4gICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX2xpc3RDYWNoZVNldCA9IGxpc3RDYWNoZVNldDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbGlzdENhY2hlQ2xlYXI7XG4gIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2xpc3RDYWNoZURlbGV0ZTtcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9saXN0Q2FjaGVIYXM7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gX2xpc3RDYWNoZVNldDtcblxuICB2YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gIHZhciBNYXAkMSA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxuICB2YXIgX01hcCA9IE1hcCQxO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAnaGFzaCc6IG5ldyBfSGFzaCxcbiAgICAgICdtYXAnOiBuZXcgKF9NYXAgfHwgX0xpc3RDYWNoZSksXG4gICAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gICAgfTtcbiAgfVxuXG4gIHZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgfVxuXG4gIHZhciBfaXNLZXlhYmxlID0gaXNLZXlhYmxlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgcmV0dXJuIF9pc0tleWFibGUoa2V5KVxuICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgIDogZGF0YS5tYXA7XG4gIH1cblxuICB2YXIgX2dldE1hcERhdGEgPSBnZXRNYXBEYXRhO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gX2dldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gIH1cblxuICB2YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICByZXR1cm4gX2dldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgfVxuXG4gIHZhciBfbWFwQ2FjaGVIYXMgPSBtYXBDYWNoZUhhcztcblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gX2dldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIF9tYXBDYWNoZVNldCA9IG1hcENhY2hlU2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gX21hcENhY2hlQ2xlYXI7XG4gIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbWFwQ2FjaGVEZWxldGU7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbWFwQ2FjaGVIYXM7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbWFwQ2FjaGVTZXQ7XG5cbiAgdmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAqXG4gICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIHZhbHVlcyhvdGhlcik7XG4gICAqIC8vID0+IFszLCA0XVxuICAgKlxuICAgKiBvYmplY3QuYSA9IDI7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsnYScsICdiJ11cbiAgICpcbiAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICovXG4gIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICB9XG4gICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgX01hcENhY2hlKTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gIH1cblxuICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgbWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxuICB2YXIgbWVtb2l6ZV8xID0gbWVtb2l6ZTtcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZV8xKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG5cbiAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfbWVtb2l6ZUNhcHBlZCA9IG1lbW9pemVDYXBwZWQ7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqL1xuICB2YXIgc3RyaW5nVG9QYXRoID0gX21lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgIH1cbiAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgdmFyIF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGg7XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9hcnJheU1hcCA9IGFycmF5TWFwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkkMSA9IDEgLyAwO1xuXG4gIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICB2YXIgc3ltYm9sUHJvdG8gPSBfU3ltYm9sID8gX1N5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgcmV0dXJuIF9hcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2Jhc2VUb1N0cmluZyA9IGJhc2VUb1N0cmluZztcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAqIC8vID0+ICcnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoLTApO1xuICAgKiAvLyA9PiAnLTAnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gJzEsMiwzJ1xuICAgKi9cbiAgZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBfYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIHZhciB0b1N0cmluZ18xID0gdG9TdHJpbmckMTtcblxuICAvKipcbiAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gX2lzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IF9zdHJpbmdUb1BhdGgodG9TdHJpbmdfMSh2YWx1ZSkpO1xuICB9XG5cbiAgdmFyIF9jYXN0UGF0aCA9IGNhc3RQYXRoO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG5cbiAgdmFyIF90b0tleSA9IHRvS2V5O1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W190b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgfVxuICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBfYmFzZUdldCA9IGJhc2VHZXQ7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjcuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAqL1xuICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBfYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgfVxuXG4gIHZhciBnZXRfMSA9IGdldDtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmdW5jID0gX2dldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgKiB2YWx1ZSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBfZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9iYXNlQXNzaWduVmFsdWUgPSBiYXNlQXNzaWduVmFsdWU7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAqL1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcV8xKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICBfYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9hc3NpZ25WYWx1ZSA9IGFzc2lnblZhbHVlO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBfaXNJbmRleCA9IGlzSW5kZXg7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gX3RvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdF8xKG9ialZhbHVlKVxuICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgOiAoX2lzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIF9iYXNlU2V0ID0gYmFzZVNldDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjcuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICpcbiAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICogLy8gPT4gNFxuICAgKlxuICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICogLy8gPT4gNVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBfYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgfVxuXG4gIHZhciBzZXRfMSA9IHNldDtcblxuICAvKipcbiAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHZhciBfY29weUFycmF5ID0gY29weUFycmF5O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgKlxuICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICovXG4gIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gX2FycmF5TWFwKHZhbHVlLCBfdG9LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gaXNTeW1ib2xfMSh2YWx1ZSkgPyBbdmFsdWVdIDogX2NvcHlBcnJheShfc3RyaW5nVG9QYXRoKHRvU3RyaW5nXzEodmFsdWUpKSk7XG4gIH1cblxuICB2YXIgdG9QYXRoXzEgPSB0b1BhdGg7XG5cbiAgdmFyIGRlZmluZSQyID0ge1xuICAgIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YShwYXJhbXMpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgICAgaW1tdXRhYmxlS2V5czoge30sXG4gICAgICAgIC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICAgIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KHNlbGYpIHt9LFxuICAgICAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChzZWxmLCBvYmopIHt9LFxuICAgICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICAgIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7IC8vIC5kYXRhKCdmb28nLCAuLi4pXG5cbiAgICAgICAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgICAgIC8vIHNldCBvciBnZXQgcHJvcGVydHlcbiAgICAgICAgICB2YXIgaXNQYXRoTGlrZSA9IG5hbWUuaW5kZXhPZignLicpICE9PSAtMTsgLy8gdGhlcmUgbWlnaHQgYmUgYSBub3JtYWwgZmllbGQgd2l0aCBhIGRvdCBcblxuICAgICAgICAgIHZhciBwYXRoID0gaXNQYXRoTGlrZSAmJiB0b1BhdGhfMShuYW1lKTsgLy8gLmRhdGEoJ2ZvbycpXG5cbiAgICAgICAgICBpZiAocC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0XG4gICAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7IC8vIGNoZWNrIGlmIGl0J3MgcGF0aCBhbmQgYSBmaWVsZCB3aXRoIHRoZSBzYW1lIG5hbWUgZG9lc24ndCBleGlzdFxuXG4gICAgICAgICAgICAgIGlmIChwYXRoICYmIHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZ2V0XzEoc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdLCBwYXRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDsgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgY2hhbmdlKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KGVsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXRoICYmIHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF8xKGVsZS5fcHJpdmF0ZVtwLmZpZWxkXSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcblxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgLy8gZXh0ZW5kXG4gICAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgICAgdmFyIGssIHY7XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIG9iaik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGsgPSBrZXlzW19pXTtcbiAgICAgICAgICAgIHYgPSBvYmpba107XG5cbiAgICAgICAgICAgIHZhciBfdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tdO1xuXG4gICAgICAgICAgICBpZiAoX3ZhbGlkKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbGUgPSBhbGxbal07XG5cbiAgICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoX2VsZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcblxuXG4gICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgICB9IC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcblxuXG4gICAgICAgICAgcC5vblNldChzZWxmKTtcblxuICAgICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICAgIH0gLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG5cbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93QmluZGluZyAmJiBmbiQ2KG5hbWUpKSB7XG4gICAgICAgICAgLy8gYmluZCB0byBldmVudFxuICAgICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4pOyAvLyAuZGF0YSgpXG4gICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICAgIHZhciBfcmV0O1xuXG4gICAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTtcbiAgICAgICAgICAgIF9yZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sXG4gICAgLy8gZGF0YVxuICAgIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShwYXJhbXMpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcblxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwobmFtZXMpIHtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuXG4gICAgICAgIGlmIChzdHJpbmcobmFtZXMpKSB7XG4gICAgICAgICAgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmIChlbXB0eVN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcblxuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKyspIHtcbiAgICAgICAgICAgICAgICBhbGxbaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgICAgfSAvLyAucmVtb3ZlRGF0YSgpXG5cbiAgICAgICAgfSBlbHNlIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcbiAgICAgICAgICBmb3IgKHZhciBfaV9hID0gMCwgX2xfYSA9IGFsbC5sZW5ndGg7IF9pX2EgPCBfbF9hOyBfaV9hKyspIHtcbiAgICAgICAgICAgIHZhciBfcHJpdmF0ZUZpZWxkcyA9IGFsbFtfaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXTtcblxuICAgICAgICAgICAgdmFyIF9rZXlzID0gT2JqZWN0LmtleXMoX3ByaXZhdGVGaWVsZHMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfa2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgIHZhciBfa2V5ID0gX2tleXNbX2kyXTtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzW19rZXldO1xuXG4gICAgICAgICAgICAgIGlmICh2YWxpZEtleVRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbX2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSAvLyByZW1vdmVEYXRhXG5cbiAgfTsgLy8gZGVmaW5lXG5cbiAgdmFyIGRlZmluZSQxID0ge1xuICAgIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiBldmVudEFsaWFzZXNPbihwcm90bykge1xuICAgICAgdmFyIHAgPSBwcm90bztcbiAgICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgICBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZiA9IHAucmVtb3ZlTGlzdGVuZXI7XG4gICAgICBwLnRyaWdnZXIgPSBwLmVtaXQ7IC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcblxuICAgICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uIChldmVudHMsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZSkge1xuICAgICAgICAgICAgc2VsZi5vZmYuYXBwbHkoc2VsZiwgb2ZmQXJncyk7XG4gICAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgICAgdmFyIG9mZkFyZ3MgPSBvbkFyZ3MuY29uY2F0KFtdKTtcbiAgICAgICAgICBzZWxmLm9uLmFwcGx5KHNlbGYsIG9uQXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07IC8vIGRlZmluZVxuXG4gIC8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxuICB2YXIgZGVmaW5lID0ge307XG4gIFtkZWZpbmUkMywgZGVmaW5lJDIsIGRlZmluZSQxXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgZXh0ZW5kKGRlZmluZSwgbSk7XG4gIH0pO1xuXG4gIHZhciBlbGVzZm4kaSA9IHtcbiAgICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICAgIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICAgIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gICAgc3RvcDogZGVmaW5lLnN0b3AoKVxuICB9O1xuXG4gIHZhciBlbGVzZm4kaCA9IHtcbiAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKF9jbGFzc2VzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChfY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICBzZWxmWzBdLl9wcml2YXRlLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgICAgcmV0dXJuIHJldC5wdXNoKGNscyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9IGVsc2UgaWYgKCFhcnJheShfY2xhc3NlcykpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICAgIHZhciBjbGFzc2VzU2V0ID0gbmV3IFNldCQxKF9jbGFzc2VzKTsgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbal07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGVsZUNsYXNzZXMgPSBfcC5jbGFzc2VzO1xuICAgICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlOyAvLyBjaGVjayBpZiBlbGUgaGFzIGFsbCBvZiB0aGUgcGFzc2VkIGNsYXNzZXNcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNscyA9IF9jbGFzc2VzW2ldO1xuICAgICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG5cbiAgICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcblxuXG4gICAgICAgIGlmICghY2hhbmdlZEVsZSkge1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSBlbGVDbGFzc2VzLnNpemUgIT09IF9jbGFzc2VzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkRWxlKSB7XG4gICAgICAgICAgX3AuY2xhc3NlcyA9IGNsYXNzZXNTZXQ7XG4gICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHJldHVybiBlbGUgIT0gbnVsbCAmJiBlbGUuX3ByaXZhdGUuY2xhc3Nlcy5oYXMoY2xhc3NOYW1lKTtcbiAgICB9LFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhjbGFzc2VzLCB0b2dnbGUpIHtcbiAgICAgIGlmICghYXJyYXkoY2xhc3NlcykpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG9nZ2xlVW5kZWZkID0gdG9nZ2xlID09PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgICAgdmFyIGVsZUNsYXNzZXMgPSBlbGUuX3ByaXZhdGUuY2xhc3NlcztcbiAgICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkTm93ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodG9nZ2xlIHx8IHRvZ2dsZVVuZGVmZCAmJiAhaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmIGhhc0NsYXNzKSB7XG4gICAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNoYW5nZWRFbGUgJiYgY2hhbmdlZE5vdykge1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuXG4gICAgICB9IC8vIGZvciBpIGVsZXNcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuXG5cbiAgICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uIGZsYXNoQ2xhc3MoY2xhc3NlcywgZHVyYXRpb24pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBub3RoaW5nIHRvIGRvIHJlYWxseVxuICAgICAgfVxuXG4gICAgICBzZWxmLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG4gIGVsZXNmbiRoLmNsYXNzTmFtZSA9IGVsZXNmbiRoLmNsYXNzTmFtZXMgPSBlbGVzZm4kaC5jbGFzc2VzO1xuXG4gIHZhciB0b2tlbnMgPSB7XG4gICAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLFxuICAgIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIGxldCBuYW1lcywgZXRjXG4gICAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JyxcbiAgICAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICBib29sT3A6ICdcXFxcP3xcXFxcIXxcXFxcXicsXG4gICAgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pKlwiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSonXCIsXG4gICAgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsXG4gICAgLy8gYWxsb3dlZCBtZXRhZGF0YSBmaWVsZHMgKGkuZS4gYWxsb3dlZCBmdW5jdGlvbnMgdG8gdXNlIGZyb20gQ29sbGVjdGlvbilcbiAgICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJyxcbiAgICAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICAgIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICAgIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gICAgc3ViamVjdDogJ1xcXFwkJyxcbiAgICBncm91cDogJ25vZGV8ZWRnZXxcXFxcKicsXG4gICAgZGlyZWN0ZWRFZGdlOiAnXFxcXHMrLT5cXFxccysnLFxuICAgIHVuZGlyZWN0ZWRFZGdlOiAnXFxcXHMrPC0+XFxcXHMrJ1xuICB9O1xuICB0b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LS5dfCg/OlxcXFxcXFxcJyArIHRva2Vucy5tZXRhQ2hhciArICcpKSsnOyAvLyBhIHZhcmlhYmxlIG5hbWUgY2FuIGhhdmUgbGV0dGVycywgbnVtYmVycywgZGFzaGVzLCBhbmQgcGVyaW9kc1xuXG4gIHRva2Vucy5jbGFzc05hbWUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgY2xhc3MgbmFtZSBoYXMgdGhlIHNhbWUgcnVsZXMgYXMgYSB2YXJpYWJsZSBleGNlcHQgaXQgY2FuJ3QgaGF2ZSBhICcuJyBpbiB0aGUgbmFtZVxuXG4gIHRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcblxuICB0b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3BzLCBvcCwgaTsgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG5cbiAgICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcCA9IG9wc1tpXTtcbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgIH0gLy8gYWRkICEgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG5cblxuICAgIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9wID0gb3BzW2ldO1xuXG4gICAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcblxuXG4gICAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gc2tpcCA9IGIvYyAhPSBpcyBleHBsaWNpdGx5IGRlZmluZWRcblxuXG4gICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgbmV3IHF1ZXJ5IG9iamVjdFxuICAgKlxuICAgKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICAgKiBAcHJvcCBjaGVja3MgTGlzdCBvZiBjaGVja3MgdG8gbWFrZSBhZ2FpbnN0IGFuIGVsZSB0byB0ZXN0IGZvciBhIG1hdGNoXG4gICAqL1xuICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tzOiBbXVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAgICogVGhlIG9yZGVyaW5nIGRvZXMgbm90IG1hdHRlciBhcyBsb25nIGFzIHRoZSBpbnRzIGFyZSB1bmlxdWUuXG4gICAqL1xuICB2YXIgVHlwZSA9IHtcbiAgICAvKiogRS5nLiBub2RlICovXG4gICAgR1JPVVA6IDAsXG5cbiAgICAvKiogQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzICovXG4gICAgQ09MTEVDVElPTjogMSxcblxuICAgIC8qKiBBIGZpbHRlcihlbGUpIGZ1bmN0aW9uICovXG4gICAgRklMVEVSOiAyLFxuXG4gICAgLyoqIEUuZy4gW2ZvbyA+IDFdICovXG4gICAgREFUQV9DT01QQVJFOiAzLFxuXG4gICAgLyoqIEUuZy4gW2Zvb10gKi9cbiAgICBEQVRBX0VYSVNUOiA0LFxuXG4gICAgLyoqIEUuZy4gWz9mb29dICovXG4gICAgREFUQV9CT09MOiA1LFxuXG4gICAgLyoqIEUuZy4gW1tkZWdyZWUgPiAyXV0gKi9cbiAgICBNRVRBX0NPTVBBUkU6IDYsXG5cbiAgICAvKiogRS5nLiA6c2VsZWN0ZWQgKi9cbiAgICBTVEFURTogNyxcblxuICAgIC8qKiBFLmcuICNmb28gKi9cbiAgICBJRDogOCxcblxuICAgIC8qKiBFLmcuIC5mb28gKi9cbiAgICBDTEFTUzogOSxcblxuICAgIC8qKiBFLmcuICNmb28gPC0+ICNiYXIgKi9cbiAgICBVTkRJUkVDVEVEX0VER0U6IDEwLFxuXG4gICAgLyoqIEUuZy4gI2ZvbyAtPiAjYmFyICovXG4gICAgRElSRUNURURfRURHRTogMTEsXG5cbiAgICAvKiogRS5nLiAkI2ZvbyAtPiAjYmFyICovXG4gICAgTk9ERV9TT1VSQ0U6IDEyLFxuXG4gICAgLyoqIEUuZy4gI2ZvbyAtPiAkI2JhciAqL1xuICAgIE5PREVfVEFSR0VUOiAxMyxcblxuICAgIC8qKiBFLmcuICQjZm9vIDwtPiAjYmFyICovXG4gICAgTk9ERV9ORUlHSEJPUjogMTQsXG5cbiAgICAvKiogRS5nLiAjZm9vID4gI2JhciAqL1xuICAgIENISUxEOiAxNSxcblxuICAgIC8qKiBFLmcuICNmb28gI2JhciAqL1xuICAgIERFU0NFTkRBTlQ6IDE2LFxuXG4gICAgLyoqIEUuZy4gJCNmb28gPiAjYmFyICovXG4gICAgUEFSRU5UOiAxNyxcblxuICAgIC8qKiBFLmcuICQjZm9vICNiYXIgKi9cbiAgICBBTkNFU1RPUjogMTgsXG5cbiAgICAvKiogRS5nLiAjZm9vID4gJGJhciA+ICNiYXogKi9cbiAgICBDT01QT1VORF9TUExJVDogMTksXG5cbiAgICAvKiogQWx3YXlzIG1hdGNoZXMsIHVzZWZ1bCBwbGFjZWhvbGRlciBmb3Igc3ViamVjdCBpbiBgQ09NUE9VTkRfU1BMSVRgICovXG4gICAgVFJVRTogMjBcbiAgfTtcblxuICB2YXIgc3RhdGVTZWxlY3RvcnMgPSBbe1xuICAgIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnVuc2VsZWN0ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5zZWxlY3RlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnNlbGVjdGFibGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5zZWxlY3RhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6bG9ja2VkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5sb2NrZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp1bmxvY2tlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnZpc2libGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpoaWRkZW4nLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dHJhbnNwYXJlbnQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuZ3JhYmJlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmZyZWUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5ncmFiYmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6cmVtb3ZlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLnJlbW92ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpncmFiYmFibGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmdyYWJiYWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnVuZ3JhYmJhYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmFuaW1hdGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dW5hbmltYXRlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmFuaW1hdGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6cGFyZW50JyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNDaGlsZGxlc3MoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpjaGlsZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOm9ycGhhbicsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpjb21wb3VuZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmxvb3AnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnNpbXBsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNTaW1wbGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzphY3RpdmUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmFjdGl2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmluYWN0aXZlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuYWN0aXZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6YmFja2dyb3VuZGluZycsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOm5vbmJhY2tncm91bmRpbmcnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgfVxuICB9XS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gbi5iLiBzZWxlY3RvcnMgdGhhdCBhcmUgc3RhcnRpbmcgc3Vic3RyaW5ncyBvZiBvdGhlcnMgbXVzdCBoYXZlIHRoZSBsb25nZXIgb25lcyBmaXJzdFxuICAgIHJldHVybiBkZXNjZW5kaW5nKGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IpO1xuICB9KTtcblxuICB2YXIgbG9va3VwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxUb0ZuID0ge307XG4gICAgdmFyIHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzID0gc3RhdGVTZWxlY3RvcnNbaV07XG4gICAgICBzZWxUb0ZuW3Muc2VsZWN0b3JdID0gcy5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxUb0ZuO1xuICB9KCk7XG5cbiAgdmFyIHN0YXRlU2VsZWN0b3JNYXRjaGVzID0gZnVuY3Rpb24gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc2VsLCBlbGUpIHtcbiAgICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbiAgfTtcbiAgdmFyIHN0YXRlU2VsZWN0b3JSZWdleCA9ICcoJyArIHN0YXRlU2VsZWN0b3JzLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNlbGVjdG9yO1xuICB9KS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLy8gc28gdGhhdCB2YWx1ZXMgZ2V0IGNvbXBhcmVkIHByb3Blcmx5IGluIFNlbGVjdG9yLmZpbHRlcigpXG5cbiAgdmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24gY2xlYW5NZXRhQ2hhcnMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgICAgIHJldHVybiAkMTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZUxhc3RRdWVyeSA9IGZ1bmN0aW9uIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGV4YW1pbmluZ1F1ZXJ5LCByZXBsYWNlbWVudFF1ZXJ5KSB7XG4gICAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPSByZXBsYWNlbWVudFF1ZXJ5O1xuICB9OyAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4gIC8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuICAvLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxlY3RvcltpXVxuICAvLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIG1hdGNoKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuXG5cbiAgdmFyIGV4cHJzID0gW3tcbiAgICBuYW1lOiAnZ3JvdXAnLFxuICAgIC8vIGp1c3QgdXNlZCBmb3IgaWRlbnRpZnlpbmcgd2hlbiBkZWJ1Z2dpbmdcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgIGdyb3VwID0gX3JlZjJbMF07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5HUk9VUCxcbiAgICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnc3RhdGUnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjMpIHtcbiAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgICAgICBzdGF0ZSA9IF9yZWY0WzBdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuU1RBVEUsXG4gICAgICAgIHZhbHVlOiBzdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2lkJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjUpIHtcbiAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAxKSxcbiAgICAgICAgICBpZCA9IF9yZWY2WzBdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuSUQsXG4gICAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhpZClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdjbGFzc05hbWUnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjcpIHtcbiAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAxKSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNMQVNTLFxuICAgICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2RhdGFFeGlzdHMnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY5KSB7XG4gICAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDEpLFxuICAgICAgICAgIHZhcmlhYmxlID0gX3JlZjEwWzBdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuREFUQV9FWElTVCxcbiAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFsdWUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTEpIHtcbiAgICAgIHZhciBfcmVmMTIgPSBfc2xpY2VkVG9BcnJheShfcmVmMTEsIDMpLFxuICAgICAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxMlsxXSxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYxMlsyXTtcblxuICAgICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRBVEFfQ09NUEFSRSxcbiAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGF0YUJvb2wnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy5ib29sT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjEzKSB7XG4gICAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgICBib29sT3AgPSBfcmVmMTRbMF0sXG4gICAgICAgICAgdmFyaWFibGUgPSBfcmVmMTRbMV07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5EQVRBX0JPT0wsXG4gICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdtZXRhQ29tcGFyZScsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxNSkge1xuICAgICAgdmFyIF9yZWYxNiA9IF9zbGljZWRUb0FycmF5KF9yZWYxNSwgMyksXG4gICAgICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTZbMV0sXG4gICAgICAgICAgbnVtYmVyID0gX3JlZjE2WzJdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTUVUQV9DT01QQVJFLFxuICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMobWV0YSksXG4gICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICduZXh0UXVlcnknLFxuICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICAgIHZhciBlZGdlQ291bnQgPSBzZWxlY3Rvci5lZGdlQ291bnQ7XG4gICAgICB2YXIgY29tcG91bmRDb3VudCA9IHNlbGVjdG9yLmNvbXBvdW5kQ291bnQ7XG4gICAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgbGFzdFEuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuICAgICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGxhc3RRLmVkZ2VDb3VudCA9IGVkZ2VDb3VudDtcbiAgICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBjb21wb3VuZENvdW50O1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50ID0gMDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQgPSAwOyAvLyBnbyBvbiB0byBuZXh0IHF1ZXJ5XG5cbiAgICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgICAgcmV0dXJuIG5leHRRdWVyeTsgLy8gdGhpcyBpcyB0aGUgbmV3IHF1ZXJ5IHRvIGJlIGZpbGxlZCBieSB0aGUgZm9sbG93aW5nIGV4cHJzXG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2RpcmVjdGVkRWRnZScsXG4gICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMuZGlyZWN0ZWRFZGdlLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkRJUkVDVEVEX0VER0UsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2UvdGFyZ2V0XG4gICAgICAgIHZhciBzcmNUZ3RRID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcblxuICAgICAgICB2YXIgX3RhcmdldCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgc3JjVGd0US5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5OT0RFX1NPVVJDRSxcbiAgICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiBfdGFyZ2V0XG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBzcmNUZ3RRKTtcbiAgICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7XG4gICAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICd1bmRpcmVjdGVkRWRnZScsXG4gICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuVU5ESVJFQ1RFRF9FREdFLFxuICAgICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGVkZ2VRdWVyeSk7XG4gICAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmVpZ2hib3VyaG9vZFxuICAgICAgICB2YXIgbmhvb2RRID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWVyeTtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gbmV3UXVlcnkoKTtcbiAgICAgICAgbmhvb2RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLk5PREVfTkVJR0hCT1IsXG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBuZWlnaGJvcjogbmVpZ2hib3JcbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICAgIHJldHVybiBuZWlnaGJvcjsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIG5laWdoYm9yIHdpdGggZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2NoaWxkJyxcbiAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgICAvLyBkZWZhdWx0OiBjaGlsZCBxdWVyeVxuICAgICAgICB2YXIgcGFyZW50Q2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgICAgcGFyZW50Q2hpbGRRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBjaGlsZDogY2hpbGRcbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIHBhcmVudENoaWxkUXVlcnkpO1xuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfY2hpbGQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gbmV3UXVlcnkoKTsgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcblxuXG4gICAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgICAgfSk7IC8vIHBvcHVsYXRlIHRoZSBzdWJqZWN0IGFuZCByZXBsYWNlIHRoZSBxIGF0IHRoZSBvbGQgc3BvdCAod2l0aGluIGxlZnQpIHdpdGggVFJVRVxuXG4gICAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuXG4gICAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcbiAgICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgICAgX3BhcmVudC5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICAgIH0pOyAvLyBwYXJlbnQgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG5cblxuICAgICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICAgIHBhcmVudDogX3BhcmVudCxcbiAgICAgICAgICBjaGlsZDogX2NoaWxkIC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpOyAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG5cbiAgICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICAgIHJldHVybiBfY2hpbGQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSByaWdodCBzaWRlJ3MgY2hpbGRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBxdWVyeVxuICAgICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgICAgdmFyIF9wYXJlbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX2NoaWxkMiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIHBjUUNoZWNrcyA9IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgICAgcGFyZW50OiBfcGFyZW50MixcbiAgICAgICAgICBjaGlsZDogX2NoaWxkMlxuICAgICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgICAgX3BhcmVudDIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICAgIHF1ZXJ5LmNoZWNrcyA9IHBjUUNoZWNrczsgLy8gcGMgcXVlcnkgdGFrZXMgb3ZlclxuXG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgICAgcmV0dXJuIF9jaGlsZDI7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy5kZXNjZW5kYW50LFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAgIC8vIGRlZmF1bHQ6IGRlc2NlbmRhbnQgcXVlcnlcbiAgICAgICAgdmFyIGFuY0NoUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgICBhbmNDaFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgICAgYW5jZXN0b3I6IGFuY2VzdG9yLFxuICAgICAgICAgIGRlc2NlbmRhbnQ6IGRlc2NlbmRhbnRcbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGFuY0NoUXVlcnkpO1xuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX2Rlc2NlbmRhbnQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfYW5jZXN0b3IgPSBuZXdRdWVyeSgpOyAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuXG5cbiAgICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQ09NUE9VTkRfU1BMSVQsXG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgc3ViamVjdDogc3ViamVjdFxuICAgICAgICB9KTsgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG5cbiAgICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcblxuICAgICAgICBfYW5jZXN0b3IuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgICB9KTsgLy8gYW5jZXN0b3IgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG5cblxuICAgICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcixcbiAgICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudCAvLyBlbXB0eSBmb3Igbm93XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTsgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuXG4gICAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgICByZXR1cm4gX2Rlc2NlbmRhbnQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSByaWdodCBzaWRlJ3MgZGVzY2VuZGFudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jZXN0b3IgcXVlcnlcbiAgICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICAgIHZhciBfYW5jZXN0b3IyID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX2Rlc2NlbmRhbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgYWRRQ2hlY2tzID0gW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IyLFxuICAgICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50MlxuICAgICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgICAgX2FuY2VzdG9yMi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG5cbiAgICAgICAgcXVlcnkuY2hlY2tzID0gYWRRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgICByZXR1cm4gX2Rlc2NlbmRhbnQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnc3ViamVjdCcsXG4gICAgbW9kaWZpZXI6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgICB3YXJuKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yLnRvU3RyaW5nKCkgKyAnYCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gcXVlcnk7XG4gICAgICB2YXIgdG9wUSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHRvcENoayA9IHRvcFEuY2hlY2tzWzBdO1xuICAgICAgdmFyIHRvcFR5cGUgPSB0b3BDaGsgPT0gbnVsbCA/IG51bGwgOiB0b3BDaGsudHlwZTtcblxuICAgICAgaWYgKHRvcFR5cGUgPT09IFR5cGUuRElSRUNURURfRURHRSkge1xuICAgICAgICAvLyBkaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIGNoYW5nZSB0byB0YXJnZXQgbm9kZSBjaGVja1xuICAgICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9UQVJHRVQ7XG4gICAgICB9IGVsc2UgaWYgKHRvcFR5cGUgPT09IFR5cGUuVU5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZSB3aXRoIHN1YmplY3Qgb24gdGhlIHNlY29uZCBub2RlXG4gICAgICAgIC8vIGNoYW5nZSB0byBuZWlnaGJvciBjaGVja1xuICAgICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgICAgdG9wQ2hrLm5vZGUgPSB0b3BDaGsubm9kZXNbMV07IC8vIHNlY29uZCBub2RlIGlzIHN1YmplY3RcblxuICAgICAgICB0b3BDaGsubmVpZ2hib3IgPSB0b3BDaGsubm9kZXNbMF07IC8vIGNsZWFuIHVwIHVudXNlZCBmaWVsZHMgZm9yIG5ldyB0eXBlXG5cbiAgICAgICAgdG9wQ2hrLm5vZGVzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dO1xuICBleHBycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUucmVnZXhPYmogPSBuZXcgUmVnRXhwKCdeJyArIGUucmVnZXgpO1xuICB9KTtcblxuICAvKipcbiAgICogT2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgKiBAcmV0dXJucyBUaGUgbWF0Y2hlZCBleHByZXNzaW9uIGFuZCB0aGUgbmV3bHkgcmVtYWluaW5nIHRleHQgYHsgZXhwciwgbWF0Y2gsIG5hbWUsIHJlbWFpbmluZyB9YFxuICAgKi9cblxuICB2YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgICB2YXIgZXhwcjtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZSA9IGV4cHJzW2pdO1xuICAgICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChlLnJlZ2V4T2JqKTtcblxuICAgICAgaWYgKG0gIT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IG07XG4gICAgICAgIGV4cHIgPSBlO1xuICAgICAgICBuYW1lID0gbjtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICAgICAgICBicmVhazsgLy8gd2UndmUgY29uc3VtZWQgb25lIGV4cHIsIHNvIHdlIGNhbiByZXR1cm4gbm93XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHI6IGV4cHIsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQ29uc3VtZSBhbGwgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSB0ZXh0IHRvIGNvbnN1bWVcbiAgICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWRcbiAgICovXG5cblxuICB2YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiBjb25zdW1lV2hpdGVzcGFjZShyZW1haW5pbmcpIHtcbiAgICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBjb25zdW1lZCA9IG1hdGNoWzBdO1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1haW5pbmc7XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBzdG9yZSB0aGUgcGFyc2VkIHJlcHJlc2VudGF0aW9uIGluIHRoZSBTZWxlY3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciBzdHJpbmdcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzZWxlY3RvciB3YXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG5cblxuICB2YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVtYWluaW5nID0gc2VsZi5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuICAgIHJlbWFpbmluZyA9IGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZyk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZXhwckluZm8gPSBjb25zdW1lRXhwcihyZW1haW5pbmcpO1xuXG4gICAgICBpZiAoZXhwckluZm8uZXhwciA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2BpcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmdzID0gZXhwckluZm8ubWF0Y2guc2xpY2UoMSk7IC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCBpbiBjdXJyZW50UXVlcnlcblxuICAgICAgICB2YXIgcmV0ID0gZXhwckluZm8uZXhwci5wb3B1bGF0ZShzZWxmLCBjdXJyZW50UXVlcnksIGFyZ3MpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UXVlcnkgPSByZXQ7IC8vIGNoYW5nZSB0aGUgY3VycmVudCBxdWVyeSB0byBiZSBmaWxsZWQgaWYgdGhlIGV4cHIgc3BlY2lmaWVzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nID0gZXhwckluZm8ucmVtYWluaW5nOyAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcblxuICAgICAgaWYgKHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RRID0gc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHNlbGYuY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgICAgbGFzdFEuc3ViamVjdCA9IHNlbGYuY3VycmVudFN1YmplY3Q7XG4gICAgfVxuXG4gICAgbGFzdFEuZWRnZUNvdW50ID0gc2VsZi5lZGdlQ291bnQ7XG4gICAgbGFzdFEuY29tcG91bmRDb3VudCA9IHNlbGYuY29tcG91bmRDb3VudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHEgPSBzZWxmW2ldOyAvLyBpbiBmdXR1cmUsIHRoaXMgY291bGQgcG90ZW50aWFsbHkgYmUgYWxsb3dlZCBpZiB0aGVyZSB3ZXJlIG9wZXJhdG9yIHByZWNlZGVuY2UgYW5kIGRldGVjdGlvbiBvZiBpbnZhbGlkIGNvbWJpbmF0aW9uc1xuXG4gICAgICBpZiAocS5jb21wb3VuZENvdW50ID4gMCAmJiBxLmVkZ2VDb3VudCA+IDApIHtcbiAgICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBib3RoIGEgY29tcG91bmQgc2VsZWN0b3IgYW5kIGFuIGVkZ2Ugc2VsZWN0b3InKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocS5lZGdlQ291bnQgPiAxKSB7XG4gICAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgbXVsdGlwbGUgZWRnZSBzZWxlY3RvcnMnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChxLmVkZ2VDb3VudCA9PT0gMSkge1xuICAgICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGRlcHJlY2F0ZWQuICBFZGdlIHNlbGVjdG9ycyBkbyBub3QgdGFrZSBlZmZlY3Qgb24gY2hhbmdlcyB0byBzb3VyY2UgYW5kIHRhcmdldCBub2RlcyBhZnRlciBhbiBlZGdlIGlzIGFkZGVkLCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIFVzZSBhIGNsYXNzIG9yIGRhdGEgc2VsZWN0b3Igb24gZWRnZXMgaW5zdGVhZCwgdXBkYXRpbmcgdGhlIGNsYXNzIG9yIGRhdGEgb2YgYW4gZWRnZSB3aGVuIHlvdXIgYXBwIGRldGVjdHMgYSBjaGFuZ2UgaW4gc291cmNlIG9yIHRhcmdldCBub2Rlcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gc3VjY2Vzc1xuICB9O1xuICAvKipcbiAgICogR2V0IHRoZSBzZWxlY3RvciByZXByZXNlbnRlZCBhcyBhIHN0cmluZy4gIFRoaXMgdmFsdWUgdXNlcyBkZWZhdWx0IGZvcm1hdHRpbmcsXG4gICAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZWxlY3RvciBzdHJpbmdcbiAgICovXG5cblxuICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy50b1N0cmluZ0NhY2hlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nQ2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIGNsZWFuID0gZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNsZWFuVmFsID0gZnVuY3Rpb24gY2xlYW5WYWwodmFsKSB7XG4gICAgICBpZiAoc3RyaW5nKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuKHZhbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHZhbCkge1xuICAgICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgICB2YXIgdHlwZSA9IGNoZWNrLnR5cGUsXG4gICAgICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZS5HUk9VUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBjbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgZmllbGQgKyBzcGFjZShjbGVhbihvcGVyYXRvcikpICsgY2xlYW5WYWwodmFsdWUpICsgJ10nO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuREFUQV9CT09MOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBjbGVhbihfb3BlcmF0b3IpICsgX2ZpZWxkICsgJ10nO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuREFUQV9FWElTVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2ZpZWxkMiA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIF9maWVsZDIgKyAnXSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5NRVRBX0NPTVBBUkU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9vcGVyYXRvcjIgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBfZmllbGQzID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuU1RBVEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuSUQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICcjJyArIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuQ0xBU1M6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuUEFSRU5UOlxuICAgICAgICBjYXNlIFR5cGUuQ0hJTEQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2sucGFyZW50LCBzdWJqZWN0KSArIHNwYWNlKCc+JykgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmNoaWxkLCBzdWJqZWN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkFOQ0VTVE9SOlxuICAgICAgICBjYXNlIFR5cGUuREVTQ0VOREFOVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5hbmNlc3Rvciwgc3ViamVjdCkgKyAnICcgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmRlc2NlbmRhbnQsIHN1YmplY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGxocyA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2subGVmdCwgc3ViamVjdCk7XG4gICAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICAgIHZhciByaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnJpZ2h0LCBzdWJqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBsaHMgKyAobGhzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyBzdWIgKyByaHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5UUlVFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24gcXVlcnlUb1N0cmluZyhxdWVyeSwgc3ViamVjdCkge1xuICAgICAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgY2hrLCBpKSB7XG4gICAgICAgIHJldHVybiBzdHIgKyAoc3ViamVjdCA9PT0gcXVlcnkgJiYgaSA9PT0gMCA/ICckJyA6ICcnKSArIGNoZWNrVG9TdHJpbmcoY2hrLCBzdWJqZWN0KTtcbiAgICAgIH0sICcnKTtcbiAgICB9O1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcocXVlcnksIHF1ZXJ5LnN1YmplY3QpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmIGkgPCB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3RyICs9ICcsICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50b1N0cmluZ0NhY2hlID0gc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIHZhciBwYXJzZSQxID0ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcblxuICB2YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICB2YXIgbWF0Y2hlcztcbiAgICB2YXIgaXNGaWVsZFN0ciA9IHN0cmluZyhmaWVsZFZhbCk7XG4gICAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIkMShmaWVsZFZhbCk7XG4gICAgdmFyIGlzVmFsU3RyID0gc3RyaW5nKHZhbHVlKTtcbiAgICB2YXIgZmllbGRTdHIsIHZhbFN0cjtcbiAgICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG5cbiAgICBpZiAob3BlcmF0b3IuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnIScsICcnKTtcbiAgICAgIG5vdEV4cHIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRvci5pbmRleE9mKCdAJykgPj0gMCkge1xuICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGaWVsZFN0ciB8fCBpc1ZhbFN0ciB8fCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgIGZpZWxkU3RyID0gIWlzRmllbGRTdHIgJiYgIWlzRmllbGROdW0gPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICB2YWxTdHIgPSAnJyArIHZhbHVlO1xuICAgIH0gLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAgIC8vIGV2ZW4gaWYgd2UncmUgY29tcGFyaW5nIG51bWJlcnNcblxuXG4gICAgaWYgKGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgZmllbGRWYWwgPSBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IHZhbFN0ciA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA+PSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJD0nOlxuICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIsIGZpZWxkU3RyLmxlbmd0aCAtIHZhbFN0ci5sZW5ndGgpID49IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdePSc6XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPT09IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH0gLy8gYXBwbHkgdGhlIG5vdCBvcCwgYnV0IG51bGwgdmFscyBmb3IgaW5lcXVhbGl0aWVzIHNob3VsZCBhbHdheXMgc3RheSBub24tbWF0Y2hpbmdcblxuXG4gICAgaWYgKG5vdEV4cHIgJiYgKGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCkpIHtcbiAgICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcbiAgdmFyIGJvb2xDbXAgPSBmdW5jdGlvbiBib29sQ21wKGZpZWxkVmFsLCBvcGVyYXRvcikge1xuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJz8nOlxuICAgICAgICByZXR1cm4gZmllbGRWYWwgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICByZXR1cm4gZmllbGRWYWwgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICByZXR1cm4gZmllbGRWYWwgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIHZhciBleGlzdENtcCA9IGZ1bmN0aW9uIGV4aXN0Q21wKGZpZWxkVmFsKSB7XG4gICAgcmV0dXJuIGZpZWxkVmFsICE9PSB1bmRlZmluZWQ7XG4gIH07XG4gIHZhciBkYXRhJDEgPSBmdW5jdGlvbiBkYXRhKGVsZSwgZmllbGQpIHtcbiAgICByZXR1cm4gZWxlLmRhdGEoZmllbGQpO1xuICB9O1xuICB2YXIgbWV0YSA9IGZ1bmN0aW9uIG1ldGEoZWxlLCBmaWVsZCkge1xuICAgIHJldHVybiBlbGVbZmllbGRdKCk7XG4gIH07XG5cbiAgLyoqIEEgbG9va3VwIG9mIGBtYXRjaChjaGVjaywgZWxlKWAgZnVuY3Rpb25zIGJ5IGBUeXBlYCBpbnQgKi9cblxuICB2YXIgbWF0Y2ggPSBbXTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBmb3IgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIHF1ZXJ5IFRoZSBgeyB0eXBlLCB2YWx1ZSwgLi4uIH1gIHF1ZXJ5IG9iamVjdFxuICAgKiBAcGFyYW0gZWxlIFRoZSBlbGVtZW50IHRvIGNvbXBhcmUgYWdhaW5zdFxuICAqL1xuXG4gIHZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgICByZXR1cm4gcXVlcnkuY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGspIHtcbiAgICAgIHJldHVybiBtYXRjaFtjaGsudHlwZV0oY2hrLCBlbGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuR1JPVVBdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gZ3JvdXAgPT09ICcqJyB8fCBncm91cCA9PT0gZWxlLmdyb3VwKCk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5TVEFURV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBzdGF0ZVNlbGVjdG9yID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIHN0YXRlU2VsZWN0b3JNYXRjaGVzKHN0YXRlU2VsZWN0b3IsIGVsZSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5JRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBpZCA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5DTEFTU10gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBjbHMgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gZWxlLmhhc0NsYXNzKGNscyk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5NRVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gdmFsQ21wKG1ldGEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5EQVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gdmFsQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkRBVEFfQk9PTF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICAgIHJldHVybiBib29sQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuREFUQV9FWElTVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgICAgICBjaGVjay5vcGVyYXRvcjtcbiAgICByZXR1cm4gZXhpc3RDbXAoZGF0YSQxKGVsZSwgZmllbGQpKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLlVORElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBxQSA9IGNoZWNrLm5vZGVzWzBdO1xuICAgIHZhciBxQiA9IGNoZWNrLm5vZGVzWzFdO1xuICAgIHZhciBzcmMgPSBlbGUuc291cmNlKCk7XG4gICAgdmFyIHRndCA9IGVsZS50YXJnZXQoKTtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKHFBLCBzcmMpICYmIG1hdGNoZXMkMShxQiwgdGd0KSB8fCBtYXRjaGVzJDEocUIsIHNyYykgJiYgbWF0Y2hlcyQxKHFBLCB0Z3QpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuTk9ERV9ORUlHSEJPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2subm9kZSwgZWxlKSAmJiBlbGUubmVpZ2hib3Job29kKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLm5laWdoYm9yLCBuKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgZWxlLnNvdXJjZSgpKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBlbGUudGFyZ2V0KCkpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuTk9ERV9TT1VSQ0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgZWxlKSAmJiBlbGUub3V0Z29lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBuKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLk5PREVfVEFSR0VUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIGVsZSkgJiYgZWxlLmluY29tZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgbik7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5DSElMRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suY2hpbGQsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnBhcmVudCwgZWxlLnBhcmVudCgpKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLlBBUkVOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUpICYmIGVsZS5jaGlsZHJlbigpLnNvbWUoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suY2hpbGQsIGMpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuREVTQ0VOREFOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZWxlKSAmJiBlbGUuYW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5hbmNlc3RvciwgYSk7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5BTkNFU1RPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGVsZSkgJiYgZWxlLmRlc2NlbmRhbnRzKCkuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5kZXNjZW5kYW50LCBkKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkNPTVBPVU5EX1NQTElUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zdWJqZWN0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5yaWdodCwgZWxlKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLlRSVUVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuQ09MTEVDVElPTl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGVsZSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5GSUxURVJdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZmlsdGVyID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIGZpbHRlcihlbGUpO1xuICB9O1xuXG4gIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gZm9yIDEgaWQgI2ZvbyBxdWVyaWVzLCBqdXN0IGdldCB0aGUgZWxlbWVudFxuXG4gICAgaWYgKHNlbGYubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrc1swXS50eXBlID09PSBUeXBlLklEKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5nZXRFbGVtZW50QnlJZChzZWxmWzBdLmNoZWNrc1swXS52YWx1ZSkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaWYgKHNlbGYudGV4dCgpID09IG51bGwpIHtcbiAgICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKHNlbGVjdG9yRnVuY3Rpb24pO1xuICB9OyAvLyBmaWx0ZXJcbiAgLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xuXG5cbiAgdmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07IC8vIG1hdGNoZXNcblxuXG4gIHZhciBtYXRjaGluZyA9IHtcbiAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgIGZpbHRlcjogZmlsdGVyXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0gZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB0aGlzLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICAgIHRoaXMuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgIHRoaXMuY29tcG91bmRDb3VudCA9IDA7XG4gICAgdGhpcy5lZGdlQ291bnQgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pKSA7IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgICAgY2hlY2tzOiBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQ09MTEVDVElPTixcbiAgICAgICAgICB2YWx1ZTogc2VsZWN0b3IuY29sbGVjdGlvbigpXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGZuJDYoc2VsZWN0b3IpKSB7XG4gICAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgICAgY2hlY2tzOiBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuRklMVEVSLFxuICAgICAgICAgIHZhbHVlOiBzZWxlY3RvclxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICBpZiAoIXRoaXMucGFyc2Uoc2VsZWN0b3IpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuICBbcGFyc2UkMSwgbWF0Y2hpbmddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHNlbGZuLCBwKTtcbiAgfSk7XG5cbiAgc2VsZm4udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFRleHQ7XG4gIH07XG5cbiAgc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgc2VsZm4uZXEgPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiB0aGlzW2ldO1xuICB9O1xuXG4gIHNlbGZuLnNhbWVUZXh0ID0gZnVuY3Rpb24gKG90aGVyU2VsKSB7XG4gICAgcmV0dXJuICF0aGlzLmludmFsaWQgJiYgIW90aGVyU2VsLmludmFsaWQgJiYgdGhpcy50ZXh0KCkgPT09IG90aGVyU2VsLnRleHQoKTtcbiAgfTtcblxuICBzZWxmbi5hZGRRdWVyeSA9IGZ1bmN0aW9uIChxKSB7XG4gICAgdGhpc1t0aGlzLmxlbmd0aCsrXSA9IHE7XG4gIH07XG5cbiAgc2VsZm4uc2VsZWN0b3IgPSBzZWxmbi50b1N0cmluZztcblxuICB2YXIgZWxlc2ZuJGcgPSB7XG4gICAgYWxsQXJlOiBmdW5jdGlvbiBhbGxBcmUoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuXG4gICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2FtZTogZnVuY3Rpb24gc2FtZShjb2xsZWN0aW9uKSB7XG4gICAgICAvLyBjaGVhcCBjb2xsZWN0aW9uIHJlZiBjaGVja1xuICAgICAgaWYgKHRoaXMgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICAgIHZhciB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICB2YXIgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoOyAvLyBjaGVhcCBsZW5ndGggY2hlY2tcblxuICAgICAgaWYgKHRoaXNMZW5ndGggIT09IGNvbGxlY3Rpb25MZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjaGVhcCBlbGVtZW50IHJlZiBjaGVja1xuXG5cbiAgICAgIGlmICh0aGlzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID09PSBjb2xsZWN0aW9uWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhbnlTYW1lOiBmdW5jdGlvbiBhbnlTYW1lKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiBhbGxBcmVOZWlnaGJvcnMoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIG5ob29kID0gdGhpcy5uZWlnaGJvcmhvb2QoKTtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ob29kLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbiRnLmFsbEFyZU5laWdoYm9ycztcbiAgZWxlc2ZuJGcuaGFzID0gZWxlc2ZuJGcuY29udGFpbnM7XG4gIGVsZXNmbiRnLmVxdWFsID0gZWxlc2ZuJGcuZXF1YWxzID0gZWxlc2ZuJGcuc2FtZTtcblxuICB2YXIgY2FjaGUgPSBmdW5jdGlvbiBjYWNoZShmbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZShhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICB2YXIgc2VsZWN0b3JPckVsZXMgPSBhcmcxO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgaWYgKHNlbGVjdG9yT3JFbGVzID09IG51bGwpIHtcbiAgICAgICAga2V5ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3JPckVsZXMpICYmIHNlbGVjdG9yT3JFbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBrZXkgPSBzZWxlY3Rvck9yRWxlcy5pZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlcy5sZW5ndGggPT09IDEgJiYga2V5KSB7XG4gICAgICAgIHZhciBfcCA9IGVsZXNbMF0uX3ByaXZhdGU7XG4gICAgICAgIHZhciB0Y2ggPSBfcC50cmF2ZXJzYWxDYWNoZSA9IF9wLnRyYXZlcnNhbENhY2hlIHx8IHt9O1xuICAgICAgICB2YXIgY2ggPSB0Y2hbbmFtZV0gPSB0Y2hbbmFtZV0gfHwgW107XG4gICAgICAgIHZhciBoYXNoID0gaGFzaFN0cmluZyhrZXkpO1xuICAgICAgICB2YXIgY2FjaGVIaXQgPSBjaFtoYXNoXTtcblxuICAgICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVIaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoW2hhc2hdID0gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZWxlc2ZuJGYgPSB7XG4gICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBwYXJlbnRzID0gW107IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIGVsZSBjYWxsXG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpc1swXS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgX3BhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKF9wYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG5cbiAgICAgIHdoaWxlIChlbGVzLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24gY29tbW9uQW5jZXN0b3JzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QocGFyZW50cyk7IC8vIGN1cnJlbnQgbGlzdCBtdXN0IGJlIGNvbW1vbiB3aXRoIGN1cnJlbnQgZWxlIHBhcmVudHMgc2V0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIG9ycGhhbnM6IGZ1bmN0aW9uIG9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBub25vcnBoYW5zOiBmdW5jdGlvbiBub25vcnBoYW5zKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBjaGlsZHJlbjogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgZWxlQ2hpbGRyZW4gPSBlbGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goZWxlQ2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGNoaWxkcmVuLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sICdjaGlsZHJlbicpLFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQ2hpbGRsZXNzOiBmdW5jdGlvbiBpc0NoaWxkbGVzcygpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzT3JwaGFuOiBmdW5jdGlvbiBpc09ycGhhbigpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCA9PSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkKGVsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuXG4gICAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGFkZChlbGUuY2hpbGRyZW4oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZCh0aGlzLmNoaWxkcmVuKCkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZvckVhY2hDb21wb3VuZChlbGVzLCBmbiwgaW5jbHVkZVNlbGYsIHJlY3Vyc2l2ZVN0ZXApIHtcbiAgICB2YXIgcSA9IFtdO1xuICAgIHZhciBkaWQgPSBuZXcgU2V0JDEoKTtcbiAgICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgICBxLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfZWxlID0gcS5zaGlmdCgpO1xuXG4gICAgICBmbihfZWxlKTtcbiAgICAgIGRpZC5hZGQoX2VsZS5pZCgpKTtcblxuICAgICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgX2VsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZXM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICAgIHEucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdmVyeSBlZmZpY2llbnQgdmVyc2lvbiBvZiBlbGVzLmFkZCggZWxlcy5kZXNjZW5kYW50cygpICkuZm9yRWFjaCgpXG4gIC8vIGZvciBpbnRlcm5hbCB1c2VcblxuXG4gIGVsZXNmbiRmLmZvckVhY2hEb3duID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRDaGlsZHJlbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkUGFyZW50KHEsIGRpZCwgZWxlKSB7XG4gICAgaWYgKGVsZS5pc0NoaWxkKCkpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICBpZiAoIWRpZC5oYXMocGFyZW50LmlkKCkpKSB7XG4gICAgICAgIHEucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsZXNmbiRmLmZvckVhY2hVcCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGRQYXJlbnRBbmRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICAgIGFkZFBhcmVudChxLCBkaWQsIGVsZSk7XG4gICAgYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpO1xuICB9XG5cbiAgZWxlc2ZuJGYuZm9yRWFjaFVwQW5kRG93biA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50QW5kQ2hpbGRyZW4pO1xuICB9OyAvLyBhbGlhc2VzXG5cblxuICBlbGVzZm4kZi5hbmNlc3RvcnMgPSBlbGVzZm4kZi5wYXJlbnRzO1xuXG4gIHZhciBmbiQ1LCBlbGVzZm4kZTtcbiAgZm4kNSA9IGVsZXNmbiRlID0ge1xuICAgIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICBzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgcnNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuICAgIHJlbW92ZVJzY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2VcbiAgICB9KSxcbiAgICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgZm4kNS5hdHRyID0gZm4kNS5kYXRhO1xuICBmbiQ1LnJlbW92ZUF0dHIgPSBmbiQ1LnJlbW92ZURhdGE7XG4gIHZhciBkYXRhID0gZWxlc2ZuJGU7XG5cbiAgdmFyIGVsZXNmbiRkID0ge307XG5cbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGZbMF07XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbaV07XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVMb29wcyAmJiBlZGdlLmlzTG9vcCgpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWdyZWUgKz0gY2FsbGJhY2sobm9kZSwgZWRnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVncmVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBleHRlbmQoZWxlc2ZuJGQsIHtcbiAgICBkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSksXG4gICAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgICBpZiAoZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSksXG4gICAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgICAgaWYgKGVkZ2Uuc291cmNlKCkuc2FtZShub2RlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oaW5jbHVkZUxvb3BzKTtcblxuICAgICAgICBpZiAoZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkpIHtcbiAgICAgICAgICByZXQgPSBkZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kKGVsZXNmbiRkLCB7XG4gICAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuICAgIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KSxcbiAgICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuICAgIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG4gICAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuICAgIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KVxuICB9KTtcbiAgZXh0ZW5kKGVsZXNmbiRkLCB7XG4gICAgdG90YWxEZWdyZWU6IGZ1bmN0aW9uIHRvdGFsRGVncmVlKGluY2x1ZGVMb29wcykge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoaW5jbHVkZUxvb3BzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGZuJDQsIGVsZXNmbiRjO1xuXG4gIHZhciBiZWZvcmVQb3NpdGlvblNldCA9IGZ1bmN0aW9uIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1Bvcywgc2lsZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUubG9ja2VkKCkpIHtcbiAgICAgICAgdmFyIG9sZFBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgIHg6IG5ld1Bvcy54ICE9IG51bGwgPyBuZXdQb3MueCAtIG9sZFBvcy54IDogMCxcbiAgICAgICAgICB5OiBuZXdQb3MueSAhPSBudWxsID8gbmV3UG9zLnkgLSBvbGRQb3MueSA6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgICAgZWxlLmNoaWxkcmVuKCkuc2hpZnQoZGVsdGEsIHNpbGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb3NpdGlvbkRlZiA9IHtcbiAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ2VtaXRBbmROb3RpZnknLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gICAgYmVmb3JlR2V0OiBmdW5jdGlvbiBiZWZvcmVHZXQoZWxlKSB7XG4gICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB9LFxuICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KGVsZXMsIG5ld1Bvcykge1xuICAgICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgfVxuICB9O1xuICBmbiQ0ID0gZWxlc2ZuJGMgPSB7XG4gICAgcG9zaXRpb246IGRlZmluZS5kYXRhKHBvc2l0aW9uRGVmKSxcbiAgICAvLyBwb3NpdGlvbiBidXQgbm8gbm90aWZpY2F0aW9uIHRvIHJlbmRlcmVyXG4gICAgc2lsZW50UG9zaXRpb246IGRlZmluZS5kYXRhKGV4dGVuZCh7fSwgcG9zaXRpb25EZWYsIHtcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICAgIH1cbiAgICB9KSksXG4gICAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMocG9zLCBzaWxlbnQpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChwb3MpKSB7XG4gICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICB0aGlzLnNpbGVudFBvc2l0aW9uKHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZuJDYocG9zKSkge1xuICAgICAgICB2YXIgX2ZuID0gcG9zO1xuICAgICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIHZhciBfcG9zID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKF9wb3MgPSBfZm4oZWxlLCBpKSkge1xuICAgICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGUucG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uIHNpbGVudFBvc2l0aW9ucyhwb3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICAgIH0sXG4gICAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KGRpbSwgdmFsLCBzaWxlbnQpIHtcbiAgICAgIHZhciBkZWx0YTtcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KGRpbSkpIHtcbiAgICAgICAgZGVsdGEgPSB7XG4gICAgICAgICAgeDogbnVtYmVyJDEoZGltLngpID8gZGltLnggOiAwLFxuICAgICAgICAgIHk6IG51bWJlciQxKGRpbS55KSA/IGRpbS55IDogMFxuICAgICAgICB9O1xuICAgICAgICBzaWxlbnQgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgZGVsdGEgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGRlbHRhW2RpbV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldOyAvLyBleGNsdWRlIGFueSBub2RlIHRoYXQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBjYWxsaW5nIGNvbGxlY3Rpb25cblxuICAgICAgICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkgJiYgZWxlLmlzQ2hpbGQoKSAmJiBlbGUuYW5jZXN0b3JzKCkuYW55U2FtZSh0aGlzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICAgIHZhciBuZXdQb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCArIGRlbHRhLngsXG4gICAgICAgICAgICB5OiBwb3MueSArIGRlbHRhLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2lsZW50U2hpZnQ6IGZ1bmN0aW9uIHNpbGVudFNoaWZ0KGRpbSwgdmFsKSB7XG4gICAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgICB0aGlzLnNoaWZ0KGRpbSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgdGhpcy5zaGlmdChkaW0sIHZhbCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gICAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24gcmVuZGVyZWRQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciBycG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuXG4gICAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2VsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgICBfZWxlLnBvc2l0aW9uKGRpbSwgKHZhbCAtIHBhbltkaW1dKSAvIHpvb20pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChycG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICAgIF9lbGUucG9zaXRpb24ocmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgICAgcnBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHBvcywgem9vbSwgcGFuKTtcblxuICAgICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zW2RpbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gICAgcmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gcmVsYXRpdmVQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgcHBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2VsZTIgPSB0aGlzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBfZWxlMi5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oZGltLCB2YWwgKyBvcmlnaW5bZGltXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcblxuICAgICAgICAgIHZhciBfaGFzUGFyZW50ID0gX3BhcmVudCAmJiBfcGFyZW50Lmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuXG4gICAgICAgICAgaWYgKF9oYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIF9wYXJlbnQgPSBfcGFyZW50WzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfb3JpZ2luID0gX3JlbGF0aXZlVG9QYXJlbnQgPyBfcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBwcG9zID0ge1xuICAgICAgICAgICAgeDogcG9zLnggLSBfb3JpZ2luLngsXG4gICAgICAgICAgICB5OiBwb3MueSAtIF9vcmlnaW4ueVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcHBvc1tkaW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfTsgLy8gYWxpYXNlc1xuXG4gIGZuJDQubW9kZWxQb3NpdGlvbiA9IGZuJDQucG9pbnQgPSBmbiQ0LnBvc2l0aW9uO1xuICBmbiQ0Lm1vZGVsUG9zaXRpb25zID0gZm4kNC5wb2ludHMgPSBmbiQ0LnBvc2l0aW9ucztcbiAgZm4kNC5yZW5kZXJlZFBvaW50ID0gZm4kNC5yZW5kZXJlZFBvc2l0aW9uO1xuICBmbiQ0LnJlbGF0aXZlUG9pbnQgPSBmbiQ0LnJlbGF0aXZlUG9zaXRpb247XG4gIHZhciBwb3NpdGlvbiA9IGVsZXNmbiRjO1xuXG4gIHZhciBmbiQzLCBlbGVzZm4kYjtcbiAgZm4kMyA9IGVsZXNmbiRiID0ge307XG5cbiAgZWxlc2ZuJGIucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveChvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4MTogeDEsXG4gICAgICB4MjogeDIsXG4gICAgICB5MTogeTEsXG4gICAgICB5MjogeTIsXG4gICAgICB3OiB4MiAtIHgxLFxuICAgICAgaDogeTIgLSB5MVxuICAgIH07XG4gIH07XG5cbiAgZWxlc2ZuJGIuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaWxlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5mb3JFYWNoVXAoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IGZhbHNlO1xuICAgICAgICBfcC5iYkNhY2hlID0gbnVsbDtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGVsZXNmbiRiLnVwZGF0ZUNvbXBvdW5kQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBub3QgcG9zc2libGUgdG8gZG8gb24gbm9uLWNvbXBvdW5kIGdyYXBocyBvciB3aXRoIHRoZSBzdHlsZSBkaXNhYmxlZFxuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gYmF0Y2hpbmcgLS0gYnV0IGJvdW5kcyB3aWxsIGJlIHN0YWxlIChvciBub3QgZXhpc3QgeWV0KVxuXG5cbiAgICBpZiAoIWZvcmNlICYmIGN5LmJhdGNoaW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZShwYXJlbnQpIHtcbiAgICAgIGlmICghcGFyZW50LmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gcGFyZW50LnBzdHlsZSgnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnKS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgICAgdmFyIG1pbiA9IHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgICAgbGVmdDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtbGVmdCcpLFxuICAgICAgICAgIHJpZ2h0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1yaWdodCcpXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodCcpLnBmVmFsdWUsXG4gICAgICAgICAgdG9wOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtdG9wJyksXG4gICAgICAgICAgYm90dG9tOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KHtcbiAgICAgICAgaW5jbHVkZUxhYmVsczogaW5jbHVkZUxhYmVscyxcbiAgICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcbiAgICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgICAgLy8gY2FjaGUgY3ljbGUgKGkuZS4gYmVmb3JlIGZpcmVkIGV2ZW50cylcbiAgICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjsgLy8gaWYgY2hpbGRyZW4gdGFrZSB1cCB6ZXJvIGFyZWEgdGhlbiBrZWVwIHBvc2l0aW9uIGFuZCBmYWxsIGJhY2sgb24gc3R5bGVzaGVldCB3L2hcblxuICAgICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgICBiYiA9IHtcbiAgICAgICAgICB3OiBwYXJlbnQucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgICAgaDogcGFyZW50LnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICBiYi54MSA9IHBvcy54IC0gYmIudyAvIDI7XG4gICAgICAgIGJiLngyID0gcG9zLnggKyBiYi53IC8gMjtcbiAgICAgICAgYmIueTEgPSBwb3MueSAtIGJiLmggLyAyO1xuICAgICAgICBiYi55MiA9IHBvcy55ICsgYmIuaCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVCaWFzVmFsdWVzKHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50KSB7XG4gICAgICAgIHZhciBiaWFzRGlmZiA9IDA7XG4gICAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHByb3BEaWZmID4gMCAmJiBiaWFzVG90YWwgPiAwKSB7XG4gICAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICAgIGJpYXNDb21wbGVtZW50RGlmZiA9IHByb3BCaWFzQ29tcGxlbWVudCAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiaWFzRGlmZjogYmlhc0RpZmYsXG4gICAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVBhZGRpbmdWYWx1ZXMod2lkdGgsIGhlaWdodCwgcGFkZGluZ09iamVjdCwgcmVsYXRpdmVUbykge1xuICAgICAgICAvLyBBc3N1bWluZyBwZXJjZW50YWdlIGlzIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgICBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJyUnKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG5cbiAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcblxuICAgICAgICAgICAgY2FzZSAnYXZlcmFnZSc6XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqICh3aWR0aCArIGhlaWdodCkgLyAyIDogMDtcblxuICAgICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG5cbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJ3B4Jykge1xuICAgICAgICAgIHJldHVybiBwYWRkaW5nT2JqZWN0LnBmVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnRWYWwgPSBtaW4ud2lkdGgubGVmdC52YWx1ZTtcblxuICAgICAgaWYgKG1pbi53aWR0aC5sZWZ0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICAgIGxlZnRWYWwgPSBsZWZ0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0VmFsID0gbWluLndpZHRoLnJpZ2h0LnZhbHVlO1xuXG4gICAgICBpZiAobWluLndpZHRoLnJpZ2h0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICAgIHJpZ2h0VmFsID0gcmlnaHRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG5cbiAgICAgIGlmIChtaW4uaGVpZ2h0LnRvcC51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgICAgdG9wVmFsID0gdG9wVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3R0b21WYWwgPSBtaW4uaGVpZ2h0LmJvdHRvbS52YWx1ZTtcblxuICAgICAgaWYgKG1pbi5oZWlnaHQuYm90dG9tLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgICBib3R0b21WYWwgPSBib3R0b21WYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoQmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLndpZHRoLnZhbCAtIGJiLncsIGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICAgIHZhciBoZWlnaHRCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsKTtcbiAgICAgIHZhciBkaWZmVG9wID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgICAgdmFyIGRpZmZCb3R0b20gPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgICAgX3AuYXV0b1BhZGRpbmcgPSBjb21wdXRlUGFkZGluZ1ZhbHVlcyhiYi53LCBiYi5oLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nJyksIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmctcmVsYXRpdmUtdG8nKS52YWx1ZSk7XG4gICAgICBfcC5hdXRvV2lkdGggPSBNYXRoLm1heChiYi53LCBtaW4ud2lkdGgudmFsKTtcbiAgICAgIHBvcy54ID0gKC1kaWZmTGVmdCArIGJiLngxICsgYmIueDIgKyBkaWZmUmlnaHQpIC8gMjtcbiAgICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgICBwb3MueSA9ICgtZGlmZlRvcCArIGJiLnkxICsgYmIueTIgKyBkaWZmQm90dG9tKSAvIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFfcC5jb21wb3VuZEJvdW5kc0NsZWFuIHx8IGZvcmNlKSB7XG4gICAgICAgIHVwZGF0ZShlbGUpO1xuXG4gICAgICAgIGlmICghY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIG5vbmluZiA9IGZ1bmN0aW9uIG5vbmluZih4KSB7XG4gICAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kcyhiLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICAgIGlmICh4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGRvbid0IHVwZGF0ZSB3aXRoIG51bGwgZGltXG5cblxuICAgIGlmICh4MSA9PSBudWxsIHx8IHkxID09IG51bGwgfHwgeDIgPT0gbnVsbCB8fCB5MiA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYi54MSA9IHgxIDwgYi54MSA/IHgxIDogYi54MTtcbiAgICBiLngyID0geDIgPiBiLngyID8geDIgOiBiLngyO1xuICAgIGIueTEgPSB5MSA8IGIueTEgPyB5MSA6IGIueTE7XG4gICAgYi55MiA9IHkyID4gYi55MiA/IHkyIDogYi55MjtcbiAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICBiLmggPSBiLnkyIC0gYi55MTtcbiAgfTtcblxuICB2YXIgdXBkYXRlQm91bmRzRnJvbUJveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYiwgYjIpIHtcbiAgICBpZiAoYjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUJvdW5kcyhiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55Mik7XG4gIH07XG5cbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBwcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCkge1xuICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gICAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgaGFsZkFyVyA9IHJzdHlsZS5hcnJvd1dpZHRoIC8gMjtcbiAgICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG5cbiAgICBpZiAoYXJyb3dUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIGlmIChwcmVmaXggPT09ICdzb3VyY2UnKSB7XG4gICAgICAgIHggPSByc3R5bGUuc3JjWDtcbiAgICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHggPSByc3R5bGUudGd0WDtcbiAgICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHJzdHlsZS5taWRYO1xuICAgICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgaW5kaXZpZHVhbCBhcnJvdyBib3VuZHNcblxuXG4gICAgICB2YXIgYmJzID0gX3AuYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcyB8fCB7fTtcbiAgICAgIHZhciBiYiA9IGJic1twcmVmaXhdID0gYmJzW3ByZWZpeF0gfHwge307XG4gICAgICBiYi54MSA9IHggLSBoYWxmQXJXO1xuICAgICAgYmIueTEgPSB5IC0gaGFsZkFyVztcbiAgICAgIGJiLngyID0geCArIGhhbGZBclc7XG4gICAgICBiYi55MiA9IHkgKyBoYWxmQXJXO1xuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiLCAxKTtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJiLngxLCBiYi55MSwgYmIueDIsIGJiLnkyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gICAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJlZml4RGFzaDtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS5zdHJWYWx1ZTtcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJyk7XG4gICAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKTtcbiAgICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICAgIHZhciBsYWJlbEhlaWdodCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxhYmVsWCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICAgIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgICB2YXIgb3V0bGluZVdpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgICB2YXIgcGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcbiAgICAgIHZhciBtYXJnaW5PZkVycm9yID0gMjsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgICB2YXIgbGggPSBsYWJlbEhlaWdodDtcbiAgICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICAgIHZhciBsaF8yID0gbGggLyAyO1xuICAgICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcblxuICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGx4MSA9IGxhYmVsWDtcbiAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaDtcbiAgICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBzaGlmdCBieSBtYXJnaW4gYW5kIGV4cGFuZCBieSBvdXRsaW5lIGFuZCBib3JkZXJcblxuXG4gICAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgICAgbHgyICs9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nICsgbWFyZ2luT2ZFcnJvcjtcbiAgICAgIGx5MSArPSBtYXJnaW5ZIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZyAtIG1hcmdpbk9mRXJyb3I7XG4gICAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmcgKyBtYXJnaW5PZkVycm9yOyAvLyBhbHdheXMgc3RvcmUgdGhlIHVucm90YXRlZCBsYWJlbCBib3VuZHMgc2VwYXJhdGVseVxuXG4gICAgICB2YXIgYmJQcmVmaXggPSBwcmVmaXggfHwgJ21haW4nO1xuICAgICAgdmFyIGJicyA9IF9wLmxhYmVsQm91bmRzO1xuICAgICAgdmFyIGJiID0gYmJzW2JiUHJlZml4XSA9IGJic1tiYlByZWZpeF0gfHwge307XG4gICAgICBiYi54MSA9IGx4MTtcbiAgICAgIGJiLnkxID0gbHkxO1xuICAgICAgYmIueDIgPSBseDI7XG4gICAgICBiYi55MiA9IGx5MjtcbiAgICAgIGJiLncgPSBseDIgLSBseDE7XG4gICAgICBiYi5oID0gbHkyIC0gbHkxO1xuICAgICAgdmFyIGlzQXV0b3JvdGF0ZSA9IGlzRWRnZSAmJiByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnO1xuICAgICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuXG4gICAgICBpZiAoaXNBdXRvcm90YXRlIHx8IGlzUGZWYWx1ZSkge1xuICAgICAgICB2YXIgdGhldGEgPSBpc0F1dG9yb3RhdGUgPyBwcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpIDogcm90YXRpb24ucGZWYWx1ZTtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTsgLy8gcm90YXRpb24gcG9pbnQgKGRlZmF1bHQgdmFsdWUgZm9yIGNlbnRlci1jZW50ZXIpXG5cbiAgICAgICAgdmFyIHhvID0gKGx4MSArIGx4MikgLyAyO1xuICAgICAgICB2YXIgeW8gPSAobHkxICsgbHkyKSAvIDI7XG5cbiAgICAgICAgaWYgKCFpc0VkZ2UpIHtcbiAgICAgICAgICBzd2l0Y2ggKGhhbGlnbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgIHhvID0gbHgyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICB4byA9IGx4MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgIHlvID0gbHkyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgeW8gPSBseTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICAgIHggPSB4IC0geG87XG4gICAgICAgICAgeSA9IHkgLSB5bztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyB4byxcbiAgICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgeW9cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICAgIGx4MSA9IE1hdGgubWluKHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgICBseDIgPSBNYXRoLm1heChweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgICAgbHkxID0gTWF0aC5taW4ocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgICAgIGx5MiA9IE1hdGgubWF4KHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmJQcmVmaXhSb3QgPSBiYlByZWZpeCArICdSb3QnO1xuICAgICAgdmFyIGJiUm90ID0gYmJzW2JiUHJlZml4Um90XSA9IGJic1tiYlByZWZpeFJvdF0gfHwge307XG4gICAgICBiYlJvdC54MSA9IGx4MTtcbiAgICAgIGJiUm90LnkxID0gbHkxO1xuICAgICAgYmJSb3QueDIgPSBseDI7XG4gICAgICBiYlJvdC55MiA9IGx5MjtcbiAgICAgIGJiUm90LncgPSBseDIgLSBseDE7XG4gICAgICBiYlJvdC5oID0gbHkyIC0gbHkxO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgICAgIHVwZGF0ZUJvdW5kcyhfcC5sYWJlbEJvdW5kcy5hbGwsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTsgLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG5cblxuICB2YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0aW9ucykge1xuICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gICAgdmFyIGhlYWRsZXNzID0gY3kuaGVhZGxlc3MoKTtcbiAgICB2YXIgYm91bmRzID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyOyAvLyBleHRyZW1hIG9mIGJvZHkgLyBsaW5lc1xuXG4gICAgdmFyIHgsIHk7IC8vIG5vZGUgcG9zXG5cbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBtYW51YWxFeHBhbnNpb24gPSBpc05vZGUgJiYgc3R5bGVFbmFibGVkID8gZWxlLnBzdHlsZSgnYm91bmRzLWV4cGFuc2lvbicpLnBmVmFsdWUgOiBbMF07IC8vIG11c3QgdXNlIGBkaXNwbGF5YCBwcm9wIG9ubHksIGFzIHJlYWRpbmcgYGNvbXBvdW5kLndpZHRoKClgIGNhdXNlcyByZWN1cnNpb25cbiAgICAvLyAob3RoZXIgZmFjdG9ycyBsaWtlIHdpZHRoIHZhbHVlcyB3aWxsIGJlIGNvbnNpZGVyZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbiBhbnl3YXkpXG5cbiAgICB2YXIgaXNEaXNwbGF5ZWQgPSBmdW5jdGlvbiBpc0Rpc3BsYXllZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgIT09ICdub25lJztcbiAgICB9O1xuXG4gICAgdmFyIGRpc3BsYXllZCA9ICFzdHlsZUVuYWJsZWQgfHwgaXNEaXNwbGF5ZWQoZWxlKSAvLyBtdXN0IHRha2UgaW50byBhY2NvdW50IGNvbm5lY3RlZCBub2RlcyBiL2Mgb2YgaW1wbGljaXQgZWRnZSBoaWRpbmcgb24gZGlzcGxheTpub25lIG5vZGVcbiAgICAmJiAoIWlzRWRnZSB8fCBpc0Rpc3BsYXllZChlbGUuc291cmNlKCkpICYmIGlzRGlzcGxheWVkKGVsZS50YXJnZXQoKSkpO1xuXG4gICAgaWYgKGRpc3BsYXllZCkge1xuICAgICAgLy8gZGlzcGxheWVkIHN1ZmZpY2VzLCBzaW5jZSB3ZSB3aWxsIGZpbmQgemVybyBhcmVhIGVsZXMgYW55d2F5XG4gICAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSAwO1xuICAgICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gMDtcblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdmVybGF5cykge1xuICAgICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICAgIGlmIChvdmVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICAgIG92ZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuZGVybGF5T3BhY2l0eSA9IDA7XG4gICAgICB2YXIgdW5kZXJsYXlQYWRkaW5nID0gMDtcblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVVbmRlcmxheXMpIHtcbiAgICAgICAgdW5kZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgndW5kZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICAgIGlmICh1bmRlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgICB1bmRlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhZGRpbmcgPSBNYXRoLm1heChvdmVybGF5UGFkZGluZywgdW5kZXJsYXlQYWRkaW5nKTtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHZhciB3SGFsZiA9IDA7XG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTm9kZSAmJiBvcHRpb25zLmluY2x1ZGVOb2Rlcykge1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHggPSBwb3MueDtcbiAgICAgICAgeSA9IHBvcy55O1xuXG4gICAgICAgIHZhciBfdyA9IGVsZS5vdXRlcldpZHRoKCk7XG5cbiAgICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgICB2YXIgaCA9IGVsZS5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgaGFsZkggPSBoIC8gMjsgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgICAgZXkyID0geSArIGhhbGZIO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiAhaGVhZGxlc3MpIHtcbiAgICAgICAgICB2YXIgY3VydmVTdHlsZSA9IGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykuc3RyVmFsdWU7IC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICBleDEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgICBleDIgPSBNYXRoLm1heChyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgICBleTEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcbiAgICAgICAgICBleTIgPSBNYXRoLm1heChyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTsgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuXG4gICAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgICAgZXkyICs9IHdIYWxmO1xuICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7IC8vIHByZWNpc2UgZWRnZXNcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgICAgIGlmIChocHRzICYmIGhwdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGV4MSA9IGhwdHNbMF0ueDtcbiAgICAgICAgICAgICAgZXkxID0gaHB0c1swXS55O1xuICAgICAgICAgICAgICBleDIgPSBocHRzWzFdLng7XG4gICAgICAgICAgICAgIGV5MiA9IGhwdHNbMV0ueTtcblxuICAgICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90ZW1wID0gZXkxO1xuICAgICAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgICAgICBleTIgPSBfdGVtcDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHdIYWxmLCBleTEgLSB3SGFsZiwgZXgyICsgd0hhbGYsIGV5MiArIHdIYWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnZlU3R5bGUgPT09ICdiZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICAgICAgdmFyIHB0cztcblxuICAgICAgICAgICAgc3dpdGNoIChjdXJ2ZVN0eWxlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICAgIGNhc2UgJ3VuYnVuZGxlZC1iZXppZXInOlxuICAgICAgICAgICAgICAgIHB0cyA9IHJzdHlsZS5iZXppZXJQdHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICAgICAgICBjYXNlICd0YXhpJzpcbiAgICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHB0ID0gcHRzW2pdO1xuICAgICAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgICAgICAgZXkxID0gcHQueSAtIHdIYWxmO1xuICAgICAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcbiAgICAgICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBiZXppZXItbGlrZSBvciBzZWdtZW50LWxpa2UgZWRnZVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcbiAgICAgICAgICAvLyBmYWxsYmFjayBvbiBzb3VyY2UgYW5kIHRhcmdldCBwb3NpdGlvbnNcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgICAgdmFyIG4xcG9zID0gbjEucG9zaXRpb24oKTtcbiAgICAgICAgICB2YXIgbjIgPSBlbGUudGFyZ2V0KCk7XG4gICAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgICBleDEgPSBuMXBvcy54O1xuICAgICAgICAgIGV4MiA9IG4ycG9zLng7XG4gICAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgICBleTIgPSBuMnBvcy55O1xuXG4gICAgICAgICAgaWYgKGV4MSA+IGV4Mikge1xuICAgICAgICAgICAgdmFyIF90ZW1wMiA9IGV4MTtcbiAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgIGV4MiA9IF90ZW1wMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgICB2YXIgX3RlbXAzID0gZXkxO1xuICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgZXkyID0gX3RlbXAzO1xuICAgICAgICAgIH0gLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuXG5cbiAgICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgfSAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuXG4gICAgICB9IC8vIGVkZ2VzXG4gICAgICAvLyBoYW5kbGUgZWRnZSBhcnJvdyBzaXplXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyAmJiBpc0VkZ2UpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXNvdXJjZScpO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jyk7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgIH0gLy8gZ2hvc3RcbiAgICAgIC8vLy8vLy8vXG5cblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB2YXIgZ2hvc3QgPSBlbGUucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcblxuICAgICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgICB2YXIgZ3ggPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgICAgICAgdmFyIGd5ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJvdW5kcy54MSArIGd4LCBib3VuZHMueTEgKyBneSwgYm91bmRzLngyICsgZ3gsIGJvdW5kcy55MiArIGd5KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbHdheXMgc3RvcmUgdGhlIGJvZHkgYm91bmRzIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGFiZWxzXG5cblxuICAgICAgdmFyIGJiQm9keSA9IF9wLmJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzIHx8IHt9O1xuICAgICAgYXNzaWduQm91bmRpbmdCb3goYmJCb2R5LCBib3VuZHMpO1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYkJvZHksIG1hbnVhbEV4cGFuc2lvbik7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveChiYkJvZHksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgICAvLyBvdmVybGF5XG4gICAgICAvLy8vLy8vLy8vXG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgZXgxID0gYm91bmRzLngxO1xuICAgICAgICBleDIgPSBib3VuZHMueDI7XG4gICAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgICAgZXkyID0gYm91bmRzLnkyO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSBwYWRkaW5nLCBleTEgLSBwYWRkaW5nLCBleDIgKyBwYWRkaW5nLCBleTIgKyBwYWRkaW5nKTtcbiAgICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuXG5cbiAgICAgIHZhciBiYk92ZXJsYXkgPSBfcC5vdmVybGF5Qm91bmRzID0gX3Aub3ZlcmxheUJvdW5kcyB8fCB7fTtcbiAgICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiT3ZlcmxheSwgYm91bmRzKTtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJPdmVybGF5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3goYmJPdmVybGF5LCAxKTsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuICAgICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIHZhciBiYkxhYmVscyA9IF9wLmxhYmVsQm91bmRzID0gX3AubGFiZWxCb3VuZHMgfHwge307XG5cbiAgICAgIGlmIChiYkxhYmVscy5hbGwgIT0gbnVsbCkge1xuICAgICAgICBjbGVhckJvdW5kaW5nQm94KGJiTGFiZWxzLmFsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYkxhYmVscy5hbGwgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3RhcmdldCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzdHlsZSBlbmFibGVkIGZvciBsYWJlbHNcblxuICAgIH0gLy8gaWYgZGlzcGxheWVkXG5cblxuICAgIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICAgIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICAgIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICAgIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICAgIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gICAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcblxuICAgIGlmIChib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCkge1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhib3VuZHMsIG1hbnVhbEV4cGFuc2lvbik7IC8vIGV4cGFuZCBib3VuZHMgYnkgMSBiZWNhdXNlIGFudGlhbGlhc2luZyBjYW4gaW5jcmVhc2UgdGhlIHZpc3VhbC9lZmZlY3RpdmUgc2l6ZSBieSAxIG9uIGFsbCBzaWRlc1xuXG4gICAgICBleHBhbmRCb3VuZGluZ0JveChib3VuZHMsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZHM7XG4gIH07XG5cbiAgdmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShvcHRzKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHRmID0gZnVuY3Rpb24gdGYodmFsKSB7XG4gICAgICByZXR1cm4gKHZhbCA/IDEgOiAwKSA8PCBpKys7XG4gICAgfTtcblxuICAgIHZhciBrZXkgPSAwO1xuICAgIGtleSArPSB0ZihvcHRzLmluY3VkZU5vZGVzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlRWRnZXMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVMYWJlbHMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVNYWluTGFiZWxzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3ZlcmxheXMpO1xuICAgIHJldHVybiBrZXk7XG4gIH07XG5cbiAgdmFyIGdldEJvdW5kaW5nQm94UG9zS2V5ID0gZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHAxID0gZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgcDIgPSBlbGUudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICAgICAgdmFyIHIgPSBmdW5jdGlvbiByKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaGFzaEludHNBcnJheShbcihwMS54KSwgcihwMS55KSwgcihwMi54KSwgcihwMi55KV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGJiO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGtleSA9IG9wdHMgPT0gbnVsbCA/IGRlZkJiT3B0c0tleSA6IGdldEtleShvcHRzKTtcbiAgICB2YXIgdXNpbmdEZWZPcHRzID0ga2V5ID09PSBkZWZCYk9wdHNLZXk7XG4gICAgdmFyIGN1cnJQb3NLZXkgPSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICAgIHZhciBpc1Bvc0tleVNhbWUgPSBfcC5iYkNhY2hlUG9zS2V5ID09PSBjdXJyUG9zS2V5O1xuICAgIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lO1xuXG4gICAgdmFyIGlzRGlydHkgPSBmdW5jdGlvbiBpc0RpcnR5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYkNhY2hlID09IG51bGwgfHwgZWxlLl9wcml2YXRlLnN0eWxlRGlydHk7XG4gICAgfTtcblxuICAgIHZhciBuZWVkUmVjYWxjID0gIXVzZUNhY2hlIHx8IGlzRGlydHkoZWxlKSB8fCBpc0VkZ2UgJiYgaXNEaXJ0eShlbGUuc291cmNlKCkpIHx8IGlzRGlydHkoZWxlLnRhcmdldCgpKTtcblxuICAgIGlmIChuZWVkUmVjYWxjKSB7XG4gICAgICBpZiAoIWlzUG9zS2V5U2FtZSkge1xuICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICAgIH1cblxuICAgICAgYmIgPSBib3VuZGluZ0JveEltcGwoZWxlLCBkZWZCYk9wdHMpO1xuICAgICAgX3AuYmJDYWNoZSA9IGJiO1xuICAgICAgX3AuYmJDYWNoZVBvc0tleSA9IGN1cnJQb3NLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJiID0gX3AuYmJDYWNoZTtcbiAgICB9IC8vIG5vdCB1c2luZyBkZWYgb3B0cyA9PiBuZWVkIHRvIGJ1aWxkIHVwIGJiIGZyb20gY29tYmluYXRpb24gb2Ygc3ViIGJic1xuXG5cbiAgICBpZiAoIXVzaW5nRGVmT3B0cykge1xuICAgICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgIGlmIChvcHRzLmluY2x1ZGVOb2RlcyAmJiBpc05vZGUgfHwgb3B0cy5pbmNsdWRlRWRnZXMgJiYgIWlzTm9kZSkge1xuICAgICAgICBpZiAob3B0cy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5vdmVybGF5Qm91bmRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5ib2R5Qm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzICYmICghaXNFZGdlIHx8IG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyAmJiBvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuYWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMubWFpblJvdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuc291cmNlUm90KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIH1cblxuICAgIHJldHVybiBiYjtcbiAgfTtcblxuICB2YXIgZGVmQmJPcHRzID0ge1xuICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICBpbmNsdWRlRWRnZXM6IHRydWUsXG4gICAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgICBpbmNsdWRlTWFpbkxhYmVsczogdHJ1ZSxcbiAgICBpbmNsdWRlU291cmNlTGFiZWxzOiB0cnVlLFxuICAgIGluY2x1ZGVUYXJnZXRMYWJlbHM6IHRydWUsXG4gICAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICAgIGluY2x1ZGVVbmRlcmxheXM6IHRydWUsXG4gICAgdXNlQ2FjaGU6IHRydWVcbiAgfTtcbiAgdmFyIGRlZkJiT3B0c0tleSA9IGdldEtleShkZWZCYk9wdHMpO1xuICB2YXIgZmlsbGVkQmJPcHRzID0gZGVmYXVsdHMkZyhkZWZCYk9wdHMpO1xuXG4gIGVsZXNmbiRiLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYm91bmRzOyAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgICAvLyBzcGVjaWZpZWQgcy50LiB0aGUgY2FjaGUgaXMgdXNlZCwgc28gY2hlY2sgZm9yIHRoaXMgY2FzZSB0byBtYWtlIGl0IGZhc3RlciBieVxuICAgIC8vIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLl9wcml2YXRlLmJiQ2FjaGUgIT0gbnVsbCAmJiAhdGhpc1swXS5fcHJpdmF0ZS5zdHlsZURpcnR5ICYmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHRydWUpKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gZmlsbGVkQmJPcHRzKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBib3VuZHMgPSBjYWNoZWRCb3VuZGluZ0JveEltcGwodGhpc1swXSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmQmJPcHRzO1xuICAgICAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgICAgICAgICB2YXIgaXNQb3NLZXlTYW1lID0gX3AuYmJDYWNoZVBvc0tleSA9PT0gY3VyclBvc0tleTtcbiAgICAgICAgICB2YXIgdXNlQ2FjaGUgPSBvcHRzLnVzZUNhY2hlICYmIGlzUG9zS2V5U2FtZSAmJiAhX3Auc3R5bGVEaXJ0eTtcbiAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCFvcHRpb25zLnVzZUNhY2hlKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfZWxlID0gZWxlc1tfaV07XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYm91bmRzLCBjYWNoZWRCb3VuZGluZ0JveEltcGwoX2VsZSwgb3B0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICAgIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICAgIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICAgIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICAgIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gICAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9O1xuXG4gIGVsZXNmbiRiLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcCA9IHRoaXNbaV0uX3ByaXZhdGU7XG4gICAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICAgIF9wLmJiQ2FjaGVQb3NLZXkgPSBudWxsO1xuICAgICAgX3AuYm9keUJvdW5kcyA9IG51bGw7XG4gICAgICBfcC5vdmVybGF5Qm91bmRzID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLmFsbCA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLm1haW4gPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMuc291cmNlUm90ID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy5tYWluUm90ID0gbnVsbDtcbiAgICAgIF9wLmFycm93Qm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgICBfcC5hcnJvd0JvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgICAgX3AuYXJyb3dCb3VuZHNbJ21pZC1zb3VyY2UnXSA9IG51bGw7XG4gICAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXRhcmdldCddID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBwcml2YXRlIGhlbHBlciB0byBnZXQgYm91bmRpbmcgYm94IGZvciBjdXN0b20gbm9kZSBwb3NpdGlvbnNcbiAgLy8gLSBnb29kIGZvciBwZXJmIGluIGNlcnRhaW4gY2FzZXMgYnV0IGN1cnJlbnRseSByZXF1aXJlcyBkaXJ0eWluZyB0aGUgcmVuZGVyZWQgc3R5bGVcbiAgLy8gLSB3b3VsZCBiZSBiZXR0ZXIgdG8gbm90IG1vZGlmeSB0aGUgbm9kZXMgYnV0IHRoZSBub2RlcyBhcmUgcmVhZCBkaXJlY3RseSBldmVyeXdoZXJlIGluIHRoZSByZW5kZXJlci4uLlxuICAvLyAtIHRyeSB0byB1c2UgZm9yIG9ubHkgdGhpbmdzIGxpa2UgZGlzY3JldGUgbGF5b3V0cyB3aGVyZSB0aGUgbm9kZSBwb3NpdGlvbiB3b3VsZCBjaGFuZ2UgYW55d2F5XG5cblxuICBlbGVzZm4kYi5ib3VuZGluZ0JveEF0ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgcGFyZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICBwYXJlbnRzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlzUGFyZW50KCk7XG4gICAgICB9KTtcbiAgICAgIG5vZGVzID0gbm9kZXMubm90KHBhcmVudHMpO1xuICAgIH1cblxuICAgIGlmIChwbGFpbk9iamVjdChmbikpIHtcbiAgICAgIHZhciBvYmogPSBmbjtcblxuICAgICAgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlT2xkUG9zID0gZnVuY3Rpb24gc3RvcmVPbGRQb3Mobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuYmJBdE9sZFBvcyA9IGZuKG5vZGUsIGkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0T2xkUG9zID0gZnVuY3Rpb24gZ2V0T2xkUG9zKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3M7XG4gICAgfTtcblxuICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICBub2Rlcy5mb3JFYWNoKHN0b3JlT2xkUG9zKS5zaWxlbnRQb3NpdGlvbnMoZm4pO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICBwYXJlbnRzLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICAgIH1cblxuICAgIHZhciBiYiA9IGNvcHlCb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KHtcbiAgICAgIHVzZUNhY2hlOiBmYWxzZVxuICAgIH0pKTtcbiAgICBub2Rlcy5zaWxlbnRQb3NpdGlvbnMoZ2V0T2xkUG9zKTtcblxuICAgIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgIHBhcmVudHMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgICB9XG5cbiAgICBjeS5lbmRCYXRjaCgpO1xuICAgIHJldHVybiBiYjtcbiAgfTtcblxuICBmbiQzLmJvdW5kaW5nYm94ID0gZm4kMy5iYiA9IGZuJDMuYm91bmRpbmdCb3g7XG4gIGZuJDMucmVuZGVyZWRCb3VuZGluZ2JveCA9IGZuJDMucmVuZGVyZWRCb3VuZGluZ0JveDtcbiAgdmFyIGJvdW5kcyA9IGVsZXNmbiRiO1xuXG4gIHZhciBmbiQyLCBlbGVzZm4kYTtcbiAgZm4kMiA9IGVsZXNmbiRhID0ge307XG5cbiAgdmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gICAgb3B0cy51cHBlcmNhc2VOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm5hbWUpO1xuICAgIG9wdHMuYXV0b05hbWUgPSAnYXV0bycgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gICAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICAgIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgICBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSA9IGNhcGl0YWxpemUob3B0cy5vdXRlck5hbWUpO1xuXG4gICAgZm4kMltvcHRzLm5hbWVdID0gZnVuY3Rpb24gZGltSW1wbCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGQgPSBlbGUucHN0eWxlKG9wdHMubmFtZSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGQuc3RyVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZC5wZlZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmbiQyWydvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICAgIHZhciBkaW0gPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgICAgIHZhciBib3JkZXIgPSBlbGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlOyAvLyBuLmIuIDEvMiBlYWNoIHNpZGVcblxuICAgICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIGRpbSArIGJvcmRlciArIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4kMlsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkRGltSW1wbCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHZhciBkID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgcmV0dXJuIGQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmbiQyWydyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZE91dGVyRGltSW1wbCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHZhciBvZCA9IGVsZVtvcHRzLm91dGVyTmFtZV0oKTtcbiAgICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGRlZmluZURpbUZucyh7XG4gICAgbmFtZTogJ3dpZHRoJ1xuICB9KTtcbiAgZGVmaW5lRGltRm5zKHtcbiAgICBuYW1lOiAnaGVpZ2h0J1xuICB9KTtcblxuICBlbGVzZm4kYS5wYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG5cbiAgICAgIGlmIChfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcC5hdXRvUGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm4kYS5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5oZWlnaHQoKSArIDIgKiBlbGUucGFkZGluZygpO1xuICB9O1xuXG4gIGVsZXNmbiRhLnBhZGRlZFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUud2lkdGgoKSArIDIgKiBlbGUucGFkZGluZygpO1xuICB9O1xuXG4gIHZhciB3aWR0aEhlaWdodCA9IGVsZXNmbiRhO1xuXG4gIHZhciBpZkVkZ2UgPSBmdW5jdGlvbiBpZkVkZ2UoZWxlLCBnZXRWYWx1ZSkge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHJldHVybiBnZXRWYWx1ZShlbGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaWZFZGdlUmVuZGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24oZWxlLCBnZXRQb2ludCkge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKGdldFBvaW50KGVsZSksIGN5Lnpvb20oKSwgY3kucGFuKCkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMgPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyhlbGUsIGdldFBvaW50cykge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICByZXR1cm4gZ2V0UG9pbnRzKGVsZSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb250cm9sUG9pbnRzID0gZnVuY3Rpb24gY29udHJvbFBvaW50cyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0Q29udHJvbFBvaW50cyhlbGUpO1xuICB9O1xuXG4gIHZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U2VnbWVudFBvaW50cyhlbGUpO1xuICB9O1xuXG4gIHZhciBzb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KGVsZSkge1xuICAgIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRTb3VyY2VFbmRwb2ludChlbGUpO1xuICB9O1xuXG4gIHZhciB0YXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIHRhcmdldEVuZHBvaW50KGVsZSkge1xuICAgIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRUYXJnZXRFbmRwb2ludChlbGUpO1xuICB9O1xuXG4gIHZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICAgIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRFZGdlTWlkcG9pbnQoZWxlKTtcbiAgfTtcblxuICB2YXIgcHRzID0ge1xuICAgIGNvbnRyb2xQb2ludHM6IHtcbiAgICAgIGdldDogY29udHJvbFBvaW50cyxcbiAgICAgIG11bHQ6IHRydWVcbiAgICB9LFxuICAgIHNlZ21lbnRQb2ludHM6IHtcbiAgICAgIGdldDogc2VnbWVudFBvaW50cyxcbiAgICAgIG11bHQ6IHRydWVcbiAgICB9LFxuICAgIHNvdXJjZUVuZHBvaW50OiB7XG4gICAgICBnZXQ6IHNvdXJjZUVuZHBvaW50XG4gICAgfSxcbiAgICB0YXJnZXRFbmRwb2ludDoge1xuICAgICAgZ2V0OiB0YXJnZXRFbmRwb2ludFxuICAgIH0sXG4gICAgbWlkcG9pbnQ6IHtcbiAgICAgIGdldDogbWlkcG9pbnRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbmRlcmVkTmFtZSA9IGZ1bmN0aW9uIHJlbmRlcmVkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuICdyZW5kZXJlZCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgfTtcblxuICB2YXIgZWRnZVBvaW50cyA9IE9iamVjdC5rZXlzKHB0cykucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICB2YXIgc3BlYyA9IHB0c1tuYW1lXTtcbiAgICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG5cbiAgICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuXG4gICAgaWYgKHNwZWMubXVsdCkge1xuICAgICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xuXG4gIHZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbiAgLyohXG4gIEV2ZW50IG9iamVjdCBiYXNlZCBvbiBqUXVlcnkgZXZlbnRzLCBNSVQgbGljZW5zZVxuXG4gIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuICBodHRwczovL3RsZHJsZWdhbC5jb20vbGljZW5zZS9taXQtbGljZW5zZVxuICBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgKi9cbiAgdmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoc3JjLCBwcm9wcykge1xuICAgIHRoaXMucmVjeWNsZShzcmMsIHByb3BzKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXG5cbiAgRXZlbnQucHJvdG90eXBlID0ge1xuICAgIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnZXZlbnQnO1xuICAgIH0sXG4gICAgcmVjeWNsZTogZnVuY3Rpb24gcmVjeWNsZShzcmMsIHByb3BzKSB7XG4gICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgLy8gQnJvd3NlciBFdmVudCBvYmplY3RcbiAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7IC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsICYmIHNyYy50eXBlKSB7XG4gICAgICAgIC8vIFBsYWluIG9iamVjdCBjb250YWluaW5nIGFsbCBldmVudCBkZXRhaWxzXG4gICAgICAgIHByb3BzID0gc3JjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXZlbnQgc3RyaW5nXG4gICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcblxuXG4gICAgICBpZiAocHJvcHMgIT0gbnVsbCkge1xuICAgICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gcHJvcHMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPSBudWxsID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICAgICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICAgIHZhciBwYW4gPSB0aGlzLmN5LnBhbigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblxuXG4gICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gICAgfSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblxuXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIGlmICghZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2VcbiAgfTtcblxuICB2YXIgZXZlbnRSZWdleCA9IC9eKFteLl0rKShcXC4oPzpbXi5dKykpPyQvOyAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuXG4gIHZhciB1bml2ZXJzYWxOYW1lc3BhY2UgPSAnLionOyAvLyBtYXRjaGVzIGFzIGlmIG5vIG5hbWVzcGFjZSBzcGVjaWZpZWQgYW5kIHByZXZlbnRzIHVzZXJzIGZyb20gdW5iaW5kaW5nIGFjY2lkZW50YWxseVxuXG4gIHZhciBkZWZhdWx0cyQ4ID0ge1xuICAgIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUocTEsIHEyKSB7XG4gICAgICByZXR1cm4gcTEgPT09IHEyO1xuICAgIH0sXG4gICAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvblxuICAgICAgLypjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICAgIGV2ZW50TWF0Y2hlcygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uXG4gICAgICAvKmNvbnRleHQsIGV2dCovXG4gICAgYWRkRXZlbnRGaWVsZHMoKSB7fSxcbiAgICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjb250ZXh0XG4gICAgLyosIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICAgKSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9LFxuICAgIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uXG4gICAgICAvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgICBiZWZvcmVFbWl0KCkge30sXG4gICAgYWZ0ZXJFbWl0OiBmdW5jdGlvblxuICAgICAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gICAgYWZ0ZXJFbWl0KCkge30sXG4gICAgYnViYmxlOiBmdW5jdGlvblxuICAgICAgLypjb250ZXh0Ki9cbiAgICBidWJibGUoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uXG4gICAgICAvKmNvbnRleHQqL1xuICAgIHBhcmVudCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgY29udGV4dDogbnVsbFxuICB9O1xuICB2YXIgZGVmYXVsdHNLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMkOCk7XG4gIHZhciBlbXB0eU9wdHMgPSB7fTtcblxuICBmdW5jdGlvbiBFbWl0dGVyKCkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbXB0eU9wdHM7XG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIG1pY3JvLW9wdGltaXNhdGlvbiB2cyBPYmplY3QuYXNzaWduKCkgLS0gcmVkdWNlcyBFbGVtZW50IGluc3RhbnRpYXRpb24gdGltZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmYXVsdHNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZGVmYXVsdHNLZXlzW2ldO1xuICAgICAgdGhpc1trZXldID0gb3B0c1trZXldIHx8IGRlZmF1bHRzJDhba2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuZW1pdHRpbmcgPSAwO1xuICB9XG5cbiAgdmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcblxuICB2YXIgZm9yRWFjaEV2ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50KHNlbGYsIGhhbmRsZXIsIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICAgIGlmIChmbiQ2KHF1YWxpZmllcikpIHtcbiAgICAgIGNhbGxiYWNrID0gcXVhbGlmaWVyO1xuICAgICAgcXVhbGlmaWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29uZk92ZXJyaWRlcykge1xuICAgICAgaWYgKGNvbmYgPT0gbnVsbCkge1xuICAgICAgICBjb25mID0gY29uZk92ZXJyaWRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmYgPSBleHRlbmQoe30sIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcblxuICAgICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBhbGxvdyBleGl0aW5nIGVhcmx5XG5cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG1ha2VFdmVudE9iaiA9IGZ1bmN0aW9uIG1ha2VFdmVudE9iaihzZWxmLCBvYmopIHtcbiAgICBzZWxmLmFkZEV2ZW50RmllbGRzKHNlbGYuY29udGV4dCwgb2JqKTtcbiAgICByZXR1cm4gbmV3IEV2ZW50KG9iai50eXBlLCBvYmopO1xuICB9O1xuXG4gIHZhciBmb3JFYWNoRXZlbnRPYmogPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnRPYmooc2VsZiwgaGFuZGxlciwgZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50KGV2ZW50cykpIHtcbiAgICAgIGhhbmRsZXIoc2VsZiwgZXZlbnRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGV2ZW50cykpIHtcbiAgICAgIGhhbmRsZXIoc2VsZiwgbWFrZUV2ZW50T2JqKHNlbGYsIGV2ZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcblxuICAgICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgICB2YXIgZXZlbnRPYmogPSBtYWtlRXZlbnRPYmooc2VsZiwge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgdGFyZ2V0OiBzZWxmLmNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIoc2VsZiwgZXZlbnRPYmopO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwLm9uID0gcC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgICBmb3JFYWNoRXZlbnQodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICAgIGlmIChmbiQ2KGNhbGxiYWNrKSkge1xuICAgICAgICBzZWxmLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgLy8gZnVsbCBldmVudCBzdHJpbmdcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICAgIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgICAgcXVhbGlmaWVyOiBxdWFsaWZpZXIsXG4gICAgICAgICAgLy8gYSByZXN0cmljdGlvbiBvbiB3aGV0aGVyIHRvIG1hdGNoIHRoaXMgZW1pdHRlclxuICAgICAgICAgIGNvbmY6IGNvbmYgLy8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLm9uZSA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIHtcbiAgICAgIG9uZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIHAucmVtb3ZlTGlzdGVuZXIgPSBwLm9mZiA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZW1pdHRpbmcgIT09IDApIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gY29weUFycmF5JDEodGhpcy5saXN0ZW5lcnMpO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGZvckVhY2hFdmVudChfdGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2tcbiAgICAgIC8qLCBjb25mKi9cbiAgICAgICkge1xuICAgICAgICBpZiAoKGxpc3RlbmVyLnR5cGUgPT09IHR5cGUgfHwgZXZlbnRzID09PSAnKicpICYmICghbmFtZXNwYWNlICYmIGxpc3RlbmVyLm5hbWVzcGFjZSAhPT0gJy4qJyB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkgJiYgKCFxdWFsaWZpZXIgfHwgc2VsZi5xdWFsaWZpZXJDb21wYXJlKGxpc3RlbmVyLnF1YWxpZmllciwgcXVhbGlmaWVyKSkgJiYgKCFjYWxsYmFjayB8fCBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2spKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIF9sb29wKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKCcqJyk7XG4gIH07XG5cbiAgcC5lbWl0ID0gcC50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50cywgZXh0cmFQYXJhbXMsIG1hbnVhbENhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICAgIHZhciBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB0aGlzLmVtaXR0aW5nKys7XG5cbiAgICBpZiAoIWFycmF5KGV4dHJhUGFyYW1zKSkge1xuICAgICAgZXh0cmFQYXJhbXMgPSBbZXh0cmFQYXJhbXNdO1xuICAgIH1cblxuICAgIGZvckVhY2hFdmVudE9iaih0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnRPYmopIHtcbiAgICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IFt7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50T2JqLmV2ZW50LFxuICAgICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgICAgbmFtZXNwYWNlOiBldmVudE9iai5uYW1lc3BhY2UsXG4gICAgICAgICAgY2FsbGJhY2s6IG1hbnVhbENhbGxiYWNrXG4gICAgICAgIH1dO1xuICAgICAgICBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihpKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICBpZiAobGlzdGVuZXIudHlwZSA9PT0gZXZlbnRPYmoudHlwZSAmJiAoIWxpc3RlbmVyLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IGV2ZW50T2JqLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IHVuaXZlcnNhbE5hbWVzcGFjZSkgJiYgc2VsZi5ldmVudE1hdGNoZXMoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbZXZlbnRPYmpdO1xuXG4gICAgICAgICAgaWYgKGV4dHJhUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHB1c2goYXJncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuYmVmb3JlRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG5cbiAgICAgICAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uZSkge1xuICAgICAgICAgICAgc2VsZi5saXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBzZWxmLmNhbGxiYWNrQ29udGV4dChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG4gICAgICAgICAgdmFyIHJldCA9IGxpc3RlbmVyLmNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudE9iai5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50T2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcblxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0OyBpKyspIHtcbiAgICAgICAgX2xvb3AyKGkpO1xuICAgICAgfSAvLyBmb3IgbGlzdGVuZXJcblxuXG4gICAgICBpZiAoc2VsZi5idWJibGUoc2VsZi5jb250ZXh0KSAmJiAhZXZlbnRPYmouaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBzZWxmLnBhcmVudChzZWxmLmNvbnRleHQpLmVtaXQoZXZlbnRPYmosIGV4dHJhUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9LCBldmVudHMpO1xuICAgIHRoaXMuZW1pdHRpbmctLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZW1pdHRlck9wdGlvbnMkMSA9IHtcbiAgICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVsZSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGVsZSwgZXZ0KSB7XG4gICAgICBldnQuY3kgPSBlbGUuY3koKTtcbiAgICAgIGV2dC50YXJnZXQgPSBlbGU7XG4gICAgfSxcbiAgICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogZWxlO1xuICAgIH0sXG4gICAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdChjb250ZXh0LCBsaXN0ZW5lclxuICAgIC8qLCBldmVudE9iaiovXG4gICAgKSB7XG4gICAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uY2UpIHtcbiAgICAgICAgbGlzdGVuZXIuY29uZi5vbmNlQ29sbGVjdGlvbi5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIucXVhbGlmaWVyLCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXJnU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICAgIGlmIChzdHJpbmcoYXJnKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZWxlc2ZuJDkgPSB7XG4gICAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucyQxLCBlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2ssIHtcbiAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgIG9uY2VDb2xsZWN0aW9uOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgICAgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG5cblxuICAgICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgICB0aGlzLmVtaXQoZXZlbnQsIGV4dHJhUGFyYW1zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKGVsZXNmbiQ5KTtcblxuICB2YXIgZWxlc2ZuJDggPSB7XG4gICAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICAvLyBpbnRlcm5hbCBoZWxwZXIgdG8gZ2V0IG5vZGVzIGFuZCBlZGdlcyBhcyBzZXBhcmF0ZSBjb2xsZWN0aW9ucyB3aXRoIHNpbmdsZSBpdGVyYXRpb24gb3ZlciBlbGVtZW50c1xuICAgIGJ5R3JvdXA6IGZ1bmN0aW9uIGJ5R3JvdXAoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLnNwYXduKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGVkZ2VzOiBlZGdlc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKF9maWx0ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcoX2ZpbHRlcikgfHwgZWxlbWVudE9yQ29sbGVjdGlvbihfZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoZm4kNihfZmlsdGVyKSkge1xuICAgICAgICB2YXIgZmlsdGVyRWxlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBpbmNsdWRlID0gdGhpc0FyZyA/IF9maWx0ZXIuYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogX2ZpbHRlcihlbGUsIGksIGVsZXMpO1xuXG4gICAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICAgIGZpbHRlckVsZXMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJFbGVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bigpOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIodG9SZW1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmVtb3ZlID0gdG9SZW1vdmUuaGFzKGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKCFyZW1vdmUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbiBhYnNvbHV0ZUNvbXBsZW1lbnQoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICByZXR1cm4gY3kubXV0YWJsZUVsZW1lbnRzKCkubm90KHRoaXMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgICAgdmFyIGNvbFMgPSBjb2wxU21hbGxlciA/IGNvbDEgOiBjb2wyO1xuICAgICAgdmFyIGNvbEwgPSBjb2wxU21hbGxlciA/IGNvbDIgOiBjb2wxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFNbaV07XG5cbiAgICAgICAgaWYgKGNvbEwuaGFzKGVsZSkpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgeG9yOiBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICAgIGlmICghaW5PdGhlcikge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYWRkKGNvbDEsIGNvbDIpO1xuICAgICAgYWRkKGNvbDIsIGNvbDEpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgZGlmZjogZnVuY3Rpb24gZGlmZihvdGhlcikge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgYm90aCA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICAgIGlmIChpbk90aGVyKSB7XG4gICAgICAgICAgICBib3RoLm1lcmdlKGVsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEVsZXMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYWRkKGNvbDEsIGNvbDIsIGxlZnQpO1xuICAgICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgYm90aDogYm90aFxuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKHRvQWRkKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiAoIXRvQWRkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaW5nKHRvQWRkKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduU2VsZigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0b0FkZFtpXTtcbiAgICAgICAgdmFyIGFkZCA9ICF0aGlzLmhhcyhlbGUpO1xuXG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGN5ID0gX3AuY3k7XG5cbiAgICAgIGlmICghdG9BZGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b0FkZCAmJiBzdHJpbmcodG9BZGQpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXAgPSBfcC5tYXA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICAgIHZhciBpZCA9IHRvQWRkRWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBhZGQgPSAhbWFwLmhhcyhpZCk7XG5cbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgdGhpc1tpbmRleF0gPSB0b0FkZEVsZTtcbiAgICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICB1bm1lcmdlQXQ6IGZ1bmN0aW9uIHVubWVyZ2VBdChpKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBtYXAgPSBfcC5tYXA7IC8vIHJlbW92ZSBlbGVcblxuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIG1hcFtcImRlbGV0ZVwiXShpZCk7XG4gICAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxOyAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSkge1xuICAgICAgICB2YXIgbGFzdEVsZUkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICAgIHZhciBsYXN0RWxlSWQgPSBsYXN0RWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHRoaXNbbGFzdEVsZUldID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgICAgbWFwLnNldChsYXN0RWxlSWQsIHtcbiAgICAgICAgICBlbGU6IGxhc3RFbGUsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG5cblxuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgdW5tZXJnZU9uZTogZnVuY3Rpb24gdW5tZXJnZU9uZShlbGUpIHtcbiAgICAgIGVsZSA9IGVsZVswXTtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBtYXAgPSBfcC5tYXA7XG4gICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcblxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBlbnRyeS5pbmRleDtcbiAgICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICB1bm1lcmdlOiBmdW5jdGlvbiB1bm1lcmdlKHRvUmVtb3ZlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9SZW1vdmUgJiYgc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgICAgdG9SZW1vdmUgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudW5tZXJnZU9uZSh0b1JlbW92ZVtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgdW5tZXJnZUJ5OiBmdW5jdGlvbiB1bm1lcmdlQnkodG9SbUZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAodG9SbUZuKGVsZSkpIHtcbiAgICAgICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcEZuLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBtYXBGbihlbGUsIGksIGVsZXMpO1xuICAgICAgICBhcnIucHVzaChyZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIHZhbCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbCA9IGZuKHZhbCwgZWxlc1tpXSwgaSwgZWxlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBtYXg6IGZ1bmN0aW9uIG1heCh2YWxGbiwgdGhpc0FyZykge1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhFbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuXG4gICAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtYXgsXG4gICAgICAgIGVsZTogbWF4RWxlXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWluOiBmdW5jdGlvbiBtaW4odmFsRm4sIHRoaXNBcmcpIHtcbiAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5FbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuXG4gICAgICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtaW4sXG4gICAgICAgIGVsZTogbWluRWxlXG4gICAgICB9O1xuICAgIH1cbiAgfTsgLy8gYWxpYXNlc1xuXG4gIHZhciBmbiQxID0gZWxlc2ZuJDg7XG4gIGZuJDFbJ3UnXSA9IGZuJDFbJ3wnXSA9IGZuJDFbJysnXSA9IGZuJDEudW5pb24gPSBmbiQxLm9yID0gZm4kMS5hZGQ7XG4gIGZuJDFbJ1xcXFwnXSA9IGZuJDFbJyEnXSA9IGZuJDFbJy0nXSA9IGZuJDEuZGlmZmVyZW5jZSA9IGZuJDEucmVsYXRpdmVDb21wbGVtZW50ID0gZm4kMS5zdWJ0cmFjdCA9IGZuJDEubm90O1xuICBmbiQxWyduJ10gPSBmbiQxWycmJ10gPSBmbiQxWycuJ10gPSBmbiQxLmFuZCA9IGZuJDEuaW50ZXJzZWN0aW9uID0gZm4kMS5pbnRlcnNlY3Q7XG4gIGZuJDFbJ14nXSA9IGZuJDFbJygrKSddID0gZm4kMVsnKC0pJ10gPSBmbiQxLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBmbiQxLnN5bWRpZmYgPSBmbiQxLnhvcjtcbiAgZm4kMS5mbkZpbHRlciA9IGZuJDEuZmlsdGVyRm4gPSBmbiQxLnN0ZEZpbHRlciA9IGZuJDEuZmlsdGVyO1xuICBmbiQxLmNvbXBsZW1lbnQgPSBmbiQxLmFic2NvbXAgPSBmbiQxLmFic29sdXRlQ29tcGxlbWVudDtcblxuICB2YXIgZWxlc2ZuJDcgPSB7XG4gICAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICAgIH0sXG4gICAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICAgIH0sXG4gICAgaXNMb29wOiBmdW5jdGlvbiBpc0xvb3AoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdID09PSB0aGlzLnRhcmdldCgpWzBdO1xuICAgIH0sXG4gICAgaXNTaW1wbGU6IGZ1bmN0aW9uIGlzU2ltcGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSAhPT0gdGhpcy50YXJnZXQoKVswXTtcbiAgICB9LFxuICAgIGdyb3VwOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAgRWxlbWVudHMgYXJlIGRyYXduIGluIGEgc3BlY2lmaWMgb3JkZXIgYmFzZWQgb24gY29tcG91bmQgZGVwdGggKGxvdyB0byBoaWdoKSwgdGhlIGVsZW1lbnQgdHlwZSAobm9kZXMgYWJvdmUgZWRnZXMpLFxuICAgKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAgICpcbiAgICogIHotY29tcG91bmQtZGVwdGg6IE1heSBiZSBgYm90dG9tIHwgb3JwaGFuIHwgYXV0byB8IHRvcGAuICBUaGUgZmlyc3QgZHJhd24gaXMgYGJvdHRvbWAsIHRoZW4gYG9ycGhhbmAgd2hpY2ggaXMgdGhlXG4gICAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gICAqICAgICAgcm9vdCB0byBsZWF2ZXMgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLiAgVGhlIGxhc3QgZHJhd24gaXMgYHRvcGAuXG4gICAqICB6LWluZGV4LWNvbXBhcmU6IE1heSBiZSBgYXV0byB8IG1hbnVhbGAuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgYXV0b2Agd2hpY2ggYWx3YXlzIGRyYXdzIGVkZ2VzIHVuZGVyIG5vZGVzLlxuICAgKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gICAqICB6LWluZGV4OiBBbiBpbnRlZ2VyIHZhbHVlIHRoYXQgYWZmZWN0cyB0aGUgcmVsYXRpdmUgZHJhdyBvcmRlciBvZiBlbGVtZW50cy4gIEluIGdlbmVyYWwsIGFuIGVsZW1lbnQgd2l0aCBhIGhpZ2hlclxuICAgKiAgICAgIGB6LWluZGV4YCB3aWxsIGJlIGRyYXduIG9uIHRvcCBvZiBhbiBlbGVtZW50IHdpdGggYSBsb3dlciBgei1pbmRleGAuXG4gICAqL1xuXG4gIHZhciB6SW5kZXhTb3J0ID0gZnVuY3Rpb24gekluZGV4U29ydChhLCBiKSB7XG4gICAgdmFyIGN5ID0gYS5jeSgpO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJyk7XG5cbiAgICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnpEZXB0aCgpIDogMDtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUudmFsdWUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUudmFsdWUgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiBNQVhfSU5UJDE7XG4gICAgICB9IC8vICdvcnBoYW4nXG5cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoRGlmZiA9IGdldERlcHRoKGEpIC0gZ2V0RGVwdGgoYik7XG5cbiAgICBpZiAoZGVwdGhEaWZmICE9PSAwKSB7XG4gICAgICByZXR1cm4gZGVwdGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsZURlcHRoKGVsZSkge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1pbmRleC1jb21wYXJlJyk7XG5cbiAgICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgPyAxIDogMDtcbiAgICAgIH0gLy8gJ21hbnVhbCdcblxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG5cbiAgICBpZiAoZWxlRGlmZiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGVsZURpZmY7XG4gICAgfVxuXG4gICAgdmFyIHpEaWZmID0gYS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSAtIGIucHN0eWxlKCd6LWluZGV4JykudmFsdWU7XG5cbiAgICBpZiAoekRpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiB6RGlmZjtcbiAgICB9IC8vIGNvbXBhcmUgaW5kaWNlcyBpbiB0aGUgY29yZSAob3JkZXIgYWRkZWQgdG8gZ3JhcGggdy8gbGFzdCBvbiB0b3ApXG5cblxuICAgIHJldHVybiBhLnBvb2xJbmRleCgpIC0gYi5wb29sSW5kZXgoKTtcbiAgfTtcblxuICB2YXIgZWxlc2ZuJDYgPSB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgICAgaWYgKGZuJDYoZm4pKSB7XG4gICAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIHRoaXNdKSA6IGZuKGVsZSwgaSwgdGhpcyk7XG5cbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gdGhpc1NpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IHRoaXNTaXplICsgc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCA9IHRoaXNTaXplICsgZW5kO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGFycmF5KTtcbiAgICB9LFxuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24gZXEoaSkge1xuICAgICAgcmV0dXJuIHRoaXNbaV0gfHwgdGhpcy5zcGF3bigpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICAgIH0sXG4gICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gfHwgdGhpcy5zcGF3bigpO1xuICAgIH0sXG4gICAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH0sXG4gICAgbm9uZW1wdHk6IGZ1bmN0aW9uIG5vbmVtcHR5KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KHNvcnRGbikge1xuICAgICAgaWYgKCFmbiQ2KHNvcnRGbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KHNvcnRGbik7XG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihzb3J0ZWQpO1xuICAgIH0sXG4gICAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbiBzb3J0QnlaSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0KHpJbmRleFNvcnQpO1xuICAgIH0sXG4gICAgekRlcHRoOiBmdW5jdGlvbiB6RGVwdGgoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKCFlbGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gbGV0IGN5ID0gZWxlLmN5KCk7XG5cblxuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcblxuICAgICAgICBpZiAoIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgcmV0dXJuIE1BWF9JTlQkMSAtIDE7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICAgIHZhciB0Z3REZXB0aCA9IHRndC56RGVwdGgoKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBlbGVzZm4kNi5lYWNoID0gZWxlc2ZuJDYuZm9yRWFjaDtcblxuICB2YXIgZGVmaW5lU3ltYm9sSXRlcmF0b3IgPSBmdW5jdGlvbiBkZWZpbmVTeW1ib2xJdGVyYXRvcigpIHtcbiAgICB2YXIgdHlwZW9mVW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcbiAgICB2YXIgaXNJdGVyYXRvclN1cHBvcnRlZCA9ICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU3ltYm9sKSkgIT0gdHlwZW9mVW5kZWYgJiYgX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpICE9IHR5cGVvZlVuZGVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpZiAoaXNJdGVyYXRvclN1cHBvcnRlZCkge1xuICAgICAgZWxlc2ZuJDZbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5JDEoe1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBlbnRyeS52YWx1ZSA9IF90aGlzW2krK107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFN5bWJvbC5pdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBkZWZpbmVTeW1ib2xJdGVyYXRvcigpO1xuXG4gIHZhciBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zID0gZGVmYXVsdHMkZyh7XG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiQ1ID0ge1xuICAgIC8vIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgbm9kZSBkaW1lbnNpb25zIHsgeCwgeSB9IGJhc2VkIG9uIG9wdGlvbnMgZ2l2ZW5cbiAgICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGRpbXM7XG5cbiAgICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgICBkaW1zID0ge1xuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogMFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscykge1xuICAgICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIGRpbXMgPSB7XG4gICAgICAgICAgdzogYmJEaW0udyxcbiAgICAgICAgICBoOiBiYkRpbS5oXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaW1zID0ge1xuICAgICAgICAgIHc6IHRoaXMub3V0ZXJXaWR0aCgpLFxuICAgICAgICAgIGg6IHRoaXMub3V0ZXJIZWlnaHQoKVxuICAgICAgICB9O1xuICAgICAgfSAvLyBzYW5pdGlzZSB0aGUgZGltZW5zaW9ucyBmb3IgZXh0ZXJuYWwgbGF5b3V0cyAoYXZvaWQgZGl2aXNpb24gYnkgemVybylcblxuXG4gICAgICBpZiAoZGltcy53ID09PSAwIHx8IGRpbXMuaCA9PT0gMCkge1xuICAgICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuICAgIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uIGxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGZuKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAhbi5pc1BhcmVudCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgbGF5b3V0RWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gbm9kZXMgJiBlZGdlc1xuXG4gICAgICB2YXIgZ2V0TWVtb2l6ZUtleSA9IGZ1bmN0aW9uIGdldE1lbW9pemVLZXkobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pZCgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZuTWVtID0gbWVtb2l6ZSQxKGZuLCBnZXRNZW1vaXplS2V5KTsgLy8gbWVtb2l6ZWQgdmVyc2lvbiBvZiBwb3NpdGlvbiBmdW5jdGlvblxuXG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG5cbiAgICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgICB4OiBub2Rlc0JiLngxICsgbm9kZXNCYi53IC8gMixcbiAgICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3BhY2luZ1ZlY3RvciA9IHtcbiAgICAgICAgICAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgICAgeDogKHBvcy54IC0gY2VudGVyLngpICogc3BhY2luZyxcbiAgICAgICAgICB5OiAocG9zLnkgLSBjZW50ZXIueSkgKiBzcGFjaW5nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyBzcGFjaW5nVmVjdG9yLngsXG4gICAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB1c2VTcGFjaW5nRmFjdG9yID0gb3B0aW9ucy5zcGFjaW5nRmFjdG9yICYmIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAhPT0gMTtcblxuICAgICAgdmFyIHNwYWNpbmdCYiA9IGZ1bmN0aW9uIHNwYWNpbmdCYigpIHtcbiAgICAgICAgaWYgKCF1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgcG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICAgICAgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCBwb3MueCwgcG9zLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJiO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJiID0gc3BhY2luZ0JiKCk7XG4gICAgICB2YXIgZ2V0RmluYWxQb3MgPSBtZW1vaXplJDEoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGZuTWVtKG5vZGUsIGkpO1xuXG4gICAgICAgIGlmICh1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICAgIG5ld1BvcyA9IGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgYmIsIG5ld1Bvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgICAgICAgIG5ld1BvcyA9IG9wdGlvbnMudHJhbnNmb3JtKG5vZGUsIG5ld1Bvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UG9zO1xuICAgICAgfSwgZ2V0TWVtb2l6ZUtleSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIG5ld1BvcyA9IGdldEZpbmFsUG9zKG5vZGUsIGkpO1xuICAgICAgICAgIHZhciBhbmltYXRlTm9kZSA9IG9wdGlvbnMuYW5pbWF0ZUZpbHRlciA9PSBudWxsIHx8IG9wdGlvbnMuYW5pbWF0ZUZpbHRlcihub2RlLCBpKTtcblxuICAgICAgICAgIGlmIChhbmltYXRlTm9kZSkge1xuICAgICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaChhbmkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgICAgdmFyIGZpdEFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgICBmaXQ6IHtcbiAgICAgICAgICAgICAgYm91bmRpbmdCb3g6IGxheW91dEVsZXMuYm91bmRpbmdCb3hBdChnZXRGaW5hbFBvcyksXG4gICAgICAgICAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goZml0QW5pKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHpvb21QYW5BbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgICAgem9vbTogb3B0aW9ucy56b29tLFxuICAgICAgICAgICAgcGFuOiBvcHRpb25zLnBhbixcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goem9vbVBhbkFuaSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmkpIHtcbiAgICAgICAgICByZXR1cm4gYW5pLnBsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgICBQcm9taXNlJDEuYWxsKGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaS5wcm9taXNlKCk7XG4gICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyhnZXRGaW5hbFBvcyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgICAgY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnpvb20gIT0gbnVsbCkge1xuICAgICAgICAgIGN5Lnpvb20ob3B0aW9ucy56b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBhbikge1xuICAgICAgICAgIGN5LnBhbihvcHRpb25zLnBhbik7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGVsZXM6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07IC8vIGFsaWFzZXM6XG5cbiAgZWxlc2ZuJDUuY3JlYXRlTGF5b3V0ID0gZWxlc2ZuJDUubWFrZUxheW91dCA9IGVsZXNmbiQ1LmxheW91dDtcblxuICBmdW5jdGlvbiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5zdHlsZUNhY2hlID0gX3Auc3R5bGVDYWNoZSB8fCBbXTtcbiAgICB2YXIgdmFsO1xuXG4gICAgaWYgKCh2YWwgPSBjYWNoZVtrZXldKSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBjYWNoZVtrZXldID0gZm4oZWxlKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAgICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFN0eWxlRnVuY3Rpb24oZWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICAgIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcblxuICAgIHZhciBzZWxmRm4gPSBmdW5jdGlvbiBzZWxmRm4oZWxlKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbChlbGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkUHJvdG90eXBlU3R5bGVGdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgc2VsZkZuLCBlbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZWxlc2ZuJDQgPSB7XG4gICAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICAgIGlmIChyZW5kZXJlciAmJiBzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHRoaXMsIHVzZUNhY2hlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkaXJ0eVN0eWxlQ2FjaGU6IGZ1bmN0aW9uIGRpcnR5U3R5bGVDYWNoZSgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgdmFyIGRpcnR5ID0gZnVuY3Rpb24gZGlydHkoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICAgIHZhciBlbGVzO1xuICAgICAgICBlbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICAgICAgZWxlcy5tZXJnZShlbGVzLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICBlbGVzLmZvckVhY2goZGlydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBkaXJ0eShlbGUpO1xuICAgICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZGlydHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gICAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcbiAgICAgICAgYkVsZXMubWVyZ2UodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzO1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAgIC8vIHRoZW4gYWRkIGV2ZXJ5dGhpbmcgdXAgYW5kIGRvd24gZm9yIGNvbXBvdW5kIHNlbGVjdG9yIGNoZWNrc1xuICAgICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICB9IC8vIGxldCBjaGFuZ2VkRWxlcyA9IHN0eWxlLmFwcGx5KCB1cGRhdGVkRWxlcyApO1xuXG5cbiAgICAgIHZhciBjaGFuZ2VkRWxlcyA9IHVwZGF0ZWRFbGVzO1xuXG4gICAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgICAgY2hhbmdlZEVsZXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuXG4gICAgICB1cGRhdGVkRWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICAvLyBwcml2YXRlOiBjbGVhcnMgZGlydHkgZmxhZyBhbmQgcmVjYWxjdWxhdGVzIHN0eWxlXG4gICAgY2xlYW5TdHlsZTogZnVuY3Rpb24gY2xlYW5TdHlsZSgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAoZWxlLl9wcml2YXRlLnN0eWxlRGlydHkpIHtcbiAgICAgICAgICAvLyBuLmIuIHRoaXMgZmxhZyBzaG91bGQgYmUgc2V0IGJlZm9yZSBhcHBseSgpIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgICBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgIGN5LnN0eWxlKCkuYXBwbHkoZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgcGFyc2VkU3R5bGU6IGZ1bmN0aW9uIHBhcnNlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgaW5jbHVkZU5vbkRlZmF1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB0aGlzLmNsZWFuU3R5bGUoKTtcbiAgICAgICAgdmFyIG92ZXJyaWRkZW5TdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtwcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKG92ZXJyaWRkZW5TdHlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5TdHlsZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlTm9uRGVmYXVsdCkge1xuICAgICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG51bWVyaWNTdHlsZTogZnVuY3Rpb24gbnVtZXJpY1N0eWxlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpO1xuICAgICAgICByZXR1cm4gcHN0eWxlLnBmVmFsdWUgIT09IHVuZGVmaW5lZCA/IHBzdHlsZS5wZlZhbHVlIDogcHN0eWxlLnZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVtZXJpY1N0eWxlVW5pdHM6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZVVuaXRzKHByb3BlcnR5KSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUocHJvcGVydHkpLnVuaXRzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgY3NzIHByb3BlcnR5IGFzIGEgcmVuZGVyZWQgdmFsdWUgKGkuZS4gb24tc2NyZWVuIHZhbHVlKVxuICAgIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gICAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKGVsZSwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIC8vIHRoZW4gZXh0ZW5kIHRoZSBieXBhc3NcbiAgICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIGdldCB0aGUgcHJvcGVydHkgZnJvbSB0aGUgc3R5bGVcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZS5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9lbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmIChfZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKF9lbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHJlbW92ZVN0eWxlOiBmdW5jdGlvbiByZW1vdmVTdHlsZShuYW1lcykge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUyID0gZWxlc1tfaV07XG4gICAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdlbGVtZW50Jyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGVmZmVjdGl2ZU9wYWNpdHk6IGZ1bmN0aW9uIGVmZmVjdGl2ZU9wYWNpdHkoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcblxuICAgICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc3BhcmVudDogZnVuY3Rpb24gdHJhbnNwYXJlbnQoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICAgIHJldHVybiBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uIGJhY2tncm91bmRpbmcoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBwYXJlbnRzID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcblxuICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG5cbiAgICAgICAgaWYgKCFwYXJlbnRPayhwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICAgIHZhciBvayA9IHNwZWNzLm9rO1xuICAgIHZhciBlZGdlT2tWaWFOb2RlID0gc3BlY3MuZWRnZU9rVmlhTm9kZSB8fCBzcGVjcy5vaztcbiAgICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgICBpZiAoIW9rKGVsZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgICAgIHJldHVybiBlZGdlT2tWaWFOb2RlKHNyYykgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoc3JjLCBlZGdlT2tWaWFOb2RlKSkgJiYgKHNyYyA9PT0gdGd0IHx8IGVkZ2VPa1ZpYU5vZGUodGd0KSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZCh0Z3QsIGVkZ2VPa1ZpYU5vZGUpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGVsZVRha2VzVXBTcGFjZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlVGFrZXNVcFNwYWNlJywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG4gIH0pO1xuICBlbGVzZm4kNC50YWtlc1VwU3BhY2UgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Rha2VzVXBTcGFjZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgICBvazogZWxlVGFrZXNVcFNwYWNlXG4gIH0pKTtcbiAgdmFyIGVsZUludGVyYWN0aXZlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVJbnRlcmFjdGl2ZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xuICB9KTtcbiAgdmFyIHBhcmVudEludGVyYWN0aXZlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdwYXJlbnRJbnRlcmFjdGl2ZScsIGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG4gIH0pO1xuICBlbGVzZm4kNC5pbnRlcmFjdGl2ZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbignaW50ZXJhY3RpdmUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gICAgb2s6IGVsZUludGVyYWN0aXZlLFxuICAgIHBhcmVudE9rOiBwYXJlbnRJbnRlcmFjdGl2ZSxcbiAgICBlZGdlT2tWaWFOb2RlOiBlbGVUYWtlc1VwU3BhY2VcbiAgfSkpO1xuXG4gIGVsZXNmbiQ0Lm5vbmludGVyYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZVZpc2libGUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVZpc2libGUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZS5wc3R5bGUoJ29wYWNpdHknKS5wZlZhbHVlICE9PSAwICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xuICB9KTtcbiAgdmFyIGVkZ2VWaXNpYmxlVmlhTm9kZSA9IGVsZVRha2VzVXBTcGFjZTtcbiAgZWxlc2ZuJDQudmlzaWJsZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndmlzaWJsZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgICBvazogZWxlVmlzaWJsZSxcbiAgICBlZGdlT2tWaWFOb2RlOiBlZGdlVmlzaWJsZVZpYU5vZGVcbiAgfSkpO1xuXG4gIGVsZXNmbiQ0LmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuJDQuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMucmVtb3ZlZCgpICYmIHRoaXMucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJyAmJiB0aGlzLnRha2VzVXBTcGFjZSgpO1xuICB9KTtcbiAgZWxlc2ZuJDQuYnlwYXNzID0gZWxlc2ZuJDQuY3NzID0gZWxlc2ZuJDQuc3R5bGU7XG4gIGVsZXNmbiQ0LnJlbmRlcmVkQ3NzID0gZWxlc2ZuJDQucmVuZGVyZWRTdHlsZTtcbiAgZWxlc2ZuJDQucmVtb3ZlQnlwYXNzID0gZWxlc2ZuJDQucmVtb3ZlQ3NzID0gZWxlc2ZuJDQucmVtb3ZlU3R5bGU7XG4gIGVsZXNmbiQ0LnBzdHlsZSA9IGVsZXNmbiQ0LnBhcnNlZFN0eWxlO1xuXG4gIHZhciBlbGVzZm4kMyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRlZmluZVN3aXRjaEZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBjaGFuZ2VkRWxlcyA9IFtdOyAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBkYXRhLCBoYW5kbGVyIClcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlcik7XG4gICAgICB9IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgZm4kNihhcmdzWzBdKSkge1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgX2hhbmRsZXIpO1xuICAgICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KClcbiAgICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCBhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcnJheShhcmdzWzBdKSkge1xuICAgICAgICB2YXIgYWRkbEV2ZW50cyA9IGFyZ3MubGVuZ3RoID09PSAxID8gYXJnc1swXSA6IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSAhPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgICAgaWYgKCFvdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFibGUpIHtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdID0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWRDb2xsID0gdGhpcy5zcGF3bihjaGFuZ2VkRWxlcyk7XG4gICAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcblxuICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG5cbiAgICAgICAgaWYgKGFkZGxFdmVudHMpIHtcbiAgICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KGFkZGxFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gICAgZWxlc2ZuJDNbcGFyYW1zLmZpZWxkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVGaWVsZCkge1xuICAgICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZChlbGUpO1xuXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlc2ZuJDNbcGFyYW1zLm9uXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICAgIGV2ZW50OiBwYXJhbXMub24sXG4gICAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBlbGVzZm4kM1twYXJhbXMub2ZmXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2xvY2tlZCcsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnbG9jaycsXG4gICAgb2ZmOiAndW5sb2NrJ1xuICB9KTtcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgfHwgZWxlLnBhbm5hYmxlKCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnZ3JhYmlmeScsXG4gICAgb2ZmOiAndW5ncmFiaWZ5J1xuICB9KTtcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgICBhYmxlRmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uIG92ZXJyaWRlQWJsZShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3QnLFxuICAgIG9mZjogJ3Vuc2VsZWN0J1xuICB9KTtcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnc2VsZWN0aWZ5JyxcbiAgICBvZmY6ICd1bnNlbGVjdGlmeSdcbiAgfSk7XG4gIGVsZXNmbiQzLmRlc2VsZWN0ID0gZWxlc2ZuJDMudW5zZWxlY3Q7XG5cbiAgZWxlc2ZuJDMuZ3JhYmJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2FjdGl2ZScsXG4gICAgb246ICdhY3RpdmF0ZScsXG4gICAgb2ZmOiAndW5hY3RpdmF0ZSdcbiAgfSk7XG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdwYW5uYWJsZScsXG4gICAgb246ICdwYW5pZnknLFxuICAgIG9mZjogJ3VucGFuaWZ5J1xuICB9KTtcblxuICBlbGVzZm4kMy5pbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZXNmbiQyID0ge307IC8vIERBRyBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHZhciBkZWZpbmVEYWdFeHRyZW1pdHkgPSBmdW5jdGlvbiBkZWZpbmVEYWdFeHRyZW1pdHkocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzcXVhbGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5ub0luY29taW5nRWRnZXMgJiYgdGd0ID09PSBlbGUgJiYgc3JjICE9PSBlbGUgfHwgcGFyYW1zLm5vT3V0Z29pbmdFZGdlcyAmJiBzcmMgPT09IGVsZSAmJiB0Z3QgIT09IGVsZSkge1xuICAgICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlzcXVhbGlmaWVkKSB7XG4gICAgICAgICAgcmV0LnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihyZXQsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVmaW5lRGFnT25lSG9wID0gZnVuY3Rpb24gZGVmaW5lRGFnT25lSG9wKHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5vdXRnb2luZyAmJiBzcmMgPT09IGVsZSkge1xuICAgICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIG9FbGVzLnB1c2godGd0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5pbmNvbWluZyAmJiB0Z3QgPT09IGVsZSkge1xuICAgICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ob0VsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVmaW5lRGFnQWxsSG9wcyA9IGZ1bmN0aW9uIGRlZmluZURhZ0FsbEhvcHMocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHNFbGVzID0gW107XG4gICAgICB2YXIgc0VsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgbmV4dCA9IHBhcmFtcy5vdXRnb2luZyA/IGVsZXMub3V0Z29lcnMoKSA6IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgICBpZiAobmV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG5cbiAgICAgICAgdmFyIG5ld05leHQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbiA9IG5leHRbaV07XG4gICAgICAgICAgdmFyIG5pZCA9IG4uaWQoKTtcblxuICAgICAgICAgIGlmICghc0VsZXNJZHNbbmlkXSkge1xuICAgICAgICAgICAgc0VsZXNJZHNbbmlkXSA9IHRydWU7XG4gICAgICAgICAgICBzRWxlcy5wdXNoKG4pO1xuICAgICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cblxuICAgICAgICBlbGVzID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oc0VsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfTtcbiAgfTtcblxuICBlbGVzZm4kMi5jbGVhclRyYXZlcnNhbENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tpXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gICAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgICBub0luY29taW5nRWRnZXM6IHRydWVcbiAgICB9KSxcbiAgICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICAgIGxlYXZlczogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICAgIG5vT3V0Z29pbmdFZGdlczogdHJ1ZVxuICAgIH0pLFxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICAgIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgICAgb3V0Z29pbmc6IHRydWVcbiAgICB9KSwgJ291dGdvZXJzJyksXG4gICAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICAgIHN1Y2Nlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgICAgb3V0Z29pbmc6IHRydWVcbiAgICB9KSxcbiAgICAvLyBub3JtYWxseSBjYWxsZWQgcGFyZW50cyBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICAgIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgICAgaW5jb21pbmc6IHRydWVcbiAgICB9KSwgJ2luY29tZXJzJyksXG4gICAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgICBwcmVkZWNlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgICAgaW5jb21pbmc6IHRydWVcbiAgICB9KVxuICB9KTsgLy8gTmVpZ2hib3VyaG9vZCBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICBuZWlnaGJvcmhvb2Q6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7IC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYzsgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcblxuICAgICAgICAgIGlmIChvdGhlck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChvdGhlck5vZGVbMF0pOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgICAgfSAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcblxuXG4gICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LCAnbmVpZ2hib3Job29kJyksXG4gICAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbiBjbG9zZWROZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24gb3Blbk5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKHNlbGVjdG9yKTtcbiAgICB9XG4gIH0pOyAvLyBhbGlhc2VzXG5cbiAgZWxlc2ZuJDIubmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLm5laWdoYm9yaG9vZDtcbiAgZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLmNsb3NlZE5laWdoYm9yaG9vZDtcbiAgZWxlc2ZuJDIub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5vcGVuTmVpZ2hib3Job29kOyAvLyBFZGdlIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgc3JjO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlcihzZWxlY3RvcikgOiBzcmM7XG4gICAgfSwgJ3NvdXJjZScpLFxuICAgIHRhcmdldDogY2FjaGUoZnVuY3Rpb24gdGFyZ2V0SW1wbChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgdGd0O1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlcihzZWxlY3RvcikgOiB0Z3Q7XG4gICAgfSwgJ3RhcmdldCcpLFxuICAgIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICdzb3VyY2UnXG4gICAgfSksXG4gICAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgICAgYXR0cjogJ3RhcmdldCdcbiAgICB9KVxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlW3BhcmFtcy5hdHRyXTtcblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgc291cmNlcy5wdXNoKHNyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oc291cmNlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgZWRnZXNXaXRoOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLCAnZWRnZXNXaXRoJyksXG4gICAgZWRnZXNUbzogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgICAgdGhpc0lzU3JjOiB0cnVlXG4gICAgfSksICdlZGdlc1RvJylcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwob3RoZXJOb2Rlcykge1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHAgPSBwYXJhbXMgfHwge307IC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuXG4gICAgICBpZiAoc3RyaW5nKG90aGVyTm9kZXMpKSB7XG4gICAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgICAgdmFyIG90aGVyVG9UaGlzID0gb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgICAgaWYgKCFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwLnRoaXNJc1NyYyB8fCBwLnRoaXNJc1RndCkge1xuICAgICAgICAgICAgaWYgKHAudGhpc0lzU3JjICYmICF0aGlzVG9PdGhlcikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAudGhpc0lzVGd0ICYmICFvdGhlclRvVGhpcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKTtcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcblxuICAgICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSwgJ2Nvbm5lY3RlZEVkZ2VzJyksXG4gICAgY29ubmVjdGVkTm9kZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcblxuICAgICAgICBpZiAoIWVkZ2UuaXNFZGdlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldEVsZXMucHVzaChlZGdlLnNvdXJjZSgpWzBdKTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UudGFyZ2V0KClbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sICdjb25uZWN0ZWROb2RlcycpLFxuICAgIHBhcmFsbGVsRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycpLFxuICAgIGNvZGlyZWN0ZWRFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgICB9KSwgJ2NvZGlyZWN0ZWRFZGdlcycpXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGFyYWxsZWxFZGdlc0ltcGwoc2VsZWN0b3IpIHtcbiAgICAgIC8vIG1pY3JvLW9wdGltaXNlZCBmb3IgcmVuZGVyZXJcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgICAgdmFyIHAgPSBwYXJhbXM7IC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZWRnZTFfcCA9IGVkZ2UxLl9wcml2YXRlO1xuICAgICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgICB2YXIgc3JjaWQxID0gc3JjMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgdGd0aWQxID0gZWRnZTFfcC5kYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7IC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlZGdlMiA9IHNyY0VkZ2VzMVtqXTtcbiAgICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgICB2YXIgc3JjaWQyID0gZWRnZTJkYXRhLnNvdXJjZTtcbiAgICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICAgIHZhciBvcHBkaXJlY3RlZCA9IHNyY2lkMSA9PT0gdGd0aWQyICYmIHRndGlkMSA9PT0gc3JjaWQyO1xuXG4gICAgICAgICAgaWYgKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkIHx8ICFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfTtcbiAgfSAvLyBNaXNjIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHZhciB1bnZpc2l0ZWQgPSByb290ID09IG51bGwgPyBzZWxmLm5vZGVzKCkgOiByb290Lm5vZGVzKCk7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBpZiAocm9vdCAhPSBudWxsICYmIHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIHJvb3QgbWF5IGNvbnRhaW4gb25seSBlZGdlc1xuICAgICAgICB1bnZpc2l0ZWQgPSByb290LnNvdXJjZXMoKTsgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggbm9kZSB0byB1c2UgKHVuZGlyZWN0ZWQpLCBzbyBqdXN0IHVzZSB0aGUgc291cmNlIHNpZGVzXG4gICAgICB9XG5cbiAgICAgIHZhciB2aXNpdEluQ29tcG9uZW50ID0gZnVuY3Rpb24gdmlzaXRJbkNvbXBvbmVudChub2RlLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmlzaXRlZC5tZXJnZShub2RlKTtcbiAgICAgICAgdW52aXNpdGVkLnVubWVyZ2Uobm9kZSk7XG4gICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zcGF3bigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgLy8gZWFjaCBpdGVyYXRpb24geWllbGRzIGEgY29tcG9uZW50XG4gICAgICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgICB2aXNpdEluQ29tcG9uZW50KHJvb3QsIGNtcHQpO1xuICAgICAgICBzZWxmLmJmcyh7XG4gICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHJvb3RzOiByb290LFxuICAgICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRJbkNvbXBvbmVudCh2LCBjbXB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzKGUpICYmIGNtcHQuaGFzKGUuc291cmNlKCkpICYmIGNtcHQuaGFzKGUudGFyZ2V0KCkpKSB7XG4gICAgICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZG8ge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfSB3aGlsZSAodW52aXNpdGVkLmxlbmd0aCA+IDApO1xuXG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuICAgIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICByZXR1cm4gZWxlLmN5KCkubXV0YWJsZUVsZW1lbnRzKCkuY29tcG9uZW50cyhlbGUpWzBdO1xuICAgIH1cbiAgfSk7XG4gIGVsZXNmbiQyLmNvbXBvbmVudHNPZiA9IGVsZXNmbiQyLmNvbXBvbmVudHM7XG5cbiAgdmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cykge1xuICAgIHZhciB1bmlxdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciByZW1vdmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgIGlmIChjeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXAgPSBuZXcgTWFwJDIoKTtcbiAgICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG5cbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBwbGFpbk9iamVjdChlbGVtZW50c1swXSkgJiYgIWVsZW1lbnQoZWxlbWVudHNbMF0pKSB7XG4gICAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlOyAvLyBtYWtlIGVsZW1lbnRzIGZyb20ganNvbiBhbmQgcmVzdG9yZSBhbGwgYXQgb25jZSBsYXRlclxuXG4gICAgICB2YXIgZWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXNJZHMgPSBuZXcgU2V0JDEoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgICBpZiAoanNvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZGF0YSA9IGpzb24uZGF0YTsgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcblxuICAgICAgICBpZiAoX2RhdGEuaWQgPT0gbnVsbCkge1xuICAgICAgICAgIF9kYXRhLmlkID0gdXVpZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEuaWQpIHx8IGVsZXNJZHMuaGFzKF9kYXRhLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7XG4gICAgICAgIGVsZXMucHVzaChlbGUpO1xuICAgICAgICBlbGVzSWRzLmFkZChfZGF0YS5pZCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzID0gZWxlcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9sID0gZWxlbWVudHMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCQxID0gZWxlbWVudHNbX2ldWzBdOyAvLyBbMF0gaW4gY2FzZSBlbGVtZW50cyBpcyBhbiBhcnJheSBvZiBjb2xsZWN0aW9ucywgcmF0aGVyIHRoYW4gYXJyYXkgb2YgZWxlbWVudHNcblxuICAgICAgaWYgKGVsZW1lbnQkMSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSBlbGVtZW50JDEuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgICAgaWYgKCF1bmlxdWUgfHwgIW1hcC5oYXMoaWQpKSB7XG4gICAgICAgIGlmICh1bmlxdWUpIHtcbiAgICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgICBpbmRleDogdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICBlbGU6IGVsZW1lbnQkMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1t0aGlzLmxlbmd0aF0gPSBlbGVtZW50JDE7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGVsZXM6IHRoaXMsXG4gICAgICBjeTogY3ksXG5cbiAgICAgIGdldCBtYXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhenlNYXAgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVidWlsZE1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eU1hcDtcbiAgICAgIH0sXG5cbiAgICAgIHNldCBtYXAobSkge1xuICAgICAgICB0aGlzLmxhenlNYXAgPSBtO1xuICAgICAgfSxcblxuICAgICAgcmVidWlsZE1hcDogZnVuY3Rpb24gcmVidWlsZE1hcCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxhenlNYXAgPSBuZXcgTWFwJDIoKTtcbiAgICAgICAgdmFyIGVsZXMgPSB0aGlzLmVsZXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9lbGUgPSBlbGVzW19pMl07XG4gICAgICAgICAgbS5zZXQoX2VsZS5pZCgpLCB7XG4gICAgICAgICAgICBpbmRleDogX2kyLFxuICAgICAgICAgICAgZWxlOiBfZWxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHVuaXF1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5tYXAgPSBtYXA7XG4gICAgfSAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG5cblxuICAgIGlmIChjcmVhdGVkRWxlbWVudHMgJiYgIXJlbW92ZWQpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgfTsgLy8gRnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8ga2VlcCB0aGUgcHJvdG90eXBlcyBpbiBzeW5jIChhbiBlbGVtZW50IGhhcyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgYSBjb2xsZWN0aW9uKVxuICAvLyBhbmQgdXNlIGVsZWZuIGFuZCBlbGVzZm4gYXMgc2hvcnRoYW5kcyB0byB0aGUgcHJvdG90eXBlc1xuXG5cbiAgdmFyIGVsZXNmbiQxID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcblxuICBlbGVzZm4kMS5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xuICB9O1xuXG4gIGVsZXNmbiQxLnNwYXduID0gZnVuY3Rpb24gKGVsZXMsIHVuaXF1ZSkge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXMsIHVuaXF1ZSk7XG4gIH07XG5cbiAgZWxlc2ZuJDEuc3Bhd25TZWxmID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNwYXduKHRoaXMpO1xuICB9O1xuXG4gIGVsZXNmbiQxLmN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICB9O1xuXG4gIGVsZXNmbiQxLnJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5LnJlbmRlcmVyKCk7XG4gIH07XG5cbiAgZWxlc2ZuJDEuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfTtcblxuICBlbGVzZm4kMS5jb2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb2xsZWN0aW9uKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW4gZWxlbWVudFxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiQxLnVuaXF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgdHJ1ZSk7XG4gIH07XG5cbiAgZWxlc2ZuJDEuaGFzRWxlbWVudFdpdGhJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5oYXMoaWQpO1xuICB9O1xuXG4gIGVsZXNmbiQxLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCk7XG5cbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeS5lbGUgOiBuZXcgQ29sbGVjdGlvbihjeSk7IC8vIGdldCBlbGUgb3IgZW1wdHkgY29sbGVjdGlvblxuICB9O1xuXG4gIGVsZXNmbiQxLiRpZCA9IGVsZXNmbiQxLmdldEVsZW1lbnRCeUlkO1xuXG4gIGVsZXNmbiQxLnBvb2xJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgdmFyIGlkID0gdGhpc1swXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIHJldHVybiBlbGVzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xuICB9O1xuXG4gIGVsZXNmbiQxLmluZGV4T2YgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGlkID0gZWxlWzBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG4gIH07XG5cbiAgZWxlc2ZuJDEuaW5kZXhPZklkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG4gIH07XG5cbiAgZWxlc2ZuJDEuanNvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYgKGVsZSA9PSBudWxsICYmIG9iaikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBjYW4ndCBzZXQgdG8gbm8gZWxlc1xuXG5cbiAgICBpZiAoZWxlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBjYW4ndCBnZXQgZnJvbSBubyBlbGVzXG5cblxuICAgIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIC8vIHNldFxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgICAgZWxlLmRhdGEob2JqLmRhdGEpO1xuICAgICAgICB2YXIgX2RhdGEyID0gcC5kYXRhO1xuXG4gICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAvLyBzb3VyY2UgYW5kIHRhcmdldCBhcmUgaW1tdXRhYmxlIHZpYSBkYXRhKClcbiAgICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICAgIHZhciBzcGVjID0ge307XG4gICAgICAgICAgdmFyIHNyYyA9IG9iai5kYXRhLnNvdXJjZTtcbiAgICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYyAhPSBfZGF0YTIuc291cmNlKSB7XG4gICAgICAgICAgICBzcGVjLnNvdXJjZSA9ICcnICsgc3JjOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGd0ICE9IG51bGwgJiYgdGd0ICE9IF9kYXRhMi50YXJnZXQpIHtcbiAgICAgICAgICAgIHNwZWMudGFyZ2V0ID0gJycgKyB0Z3Q7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgICAgdmFyIG5ld1BhcmVudFZhbFNwZWNkID0gKCdwYXJlbnQnIGluIG9iai5kYXRhKTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmRhdGEucGFyZW50O1xuXG4gICAgICAgICAgaWYgKG5ld1BhcmVudFZhbFNwZWNkICYmIChwYXJlbnQgIT0gbnVsbCB8fCBfZGF0YTIucGFyZW50ICE9IG51bGwpICYmIHBhcmVudCAhPSBfZGF0YTIucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IHVuZGVmaW5lZCBpbXBlcmF0aXZlbHksIHNvIHVzZSBudWxsXG4gICAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSAnJyArIHBhcmVudDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlID0gZWxlLm1vdmUoe1xuICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoucG9zaXRpb24pIHtcbiAgICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgICB9IC8vIGlnbm9yZSBncm91cCAtLSBpbW11dGFibGVcblxuXG4gICAgICB2YXIgY2hlY2tTd2l0Y2ggPSBmdW5jdGlvbiBjaGVja1N3aXRjaChrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSkge1xuICAgICAgICB2YXIgb2JqX2sgPSBvYmpba107XG5cbiAgICAgICAgaWYgKG9ial9rICE9IG51bGwgJiYgb2JqX2sgIT09IHBba10pIHtcbiAgICAgICAgICBpZiAob2JqX2spIHtcbiAgICAgICAgICAgIGVsZVt0cnVlRm5OYW1lXSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVbZmFsc2VGbk5hbWVdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjaGVja1N3aXRjaCgncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScpO1xuICAgICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGVkJywgJ3NlbGVjdCcsICd1bnNlbGVjdCcpO1xuICAgICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5Jyk7XG4gICAgICBjaGVja1N3aXRjaCgnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyk7XG4gICAgICBjaGVja1N3aXRjaCgnZ3JhYmJhYmxlJywgJ2dyYWJpZnknLCAndW5ncmFiaWZ5Jyk7XG4gICAgICBjaGVja1N3aXRjaCgncGFubmFibGUnLCAncGFuaWZ5JywgJ3VucGFuaWZ5Jyk7XG5cbiAgICAgIGlmIChvYmouY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIGVsZS5jbGFzc2VzKG9iai5jbGFzc2VzKTtcbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGdldFxuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIGRhdGE6IGNvcHkocC5kYXRhKSxcbiAgICAgICAgcG9zaXRpb246IGNvcHkocC5wb3NpdGlvbiksXG4gICAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgICBzZWxlY3RhYmxlOiBwLnNlbGVjdGFibGUsXG4gICAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICAgIHBhbm5hYmxlOiBwLnBhbm5hYmxlLFxuICAgICAgICBjbGFzc2VzOiBudWxsXG4gICAgICB9O1xuICAgICAganNvbi5jbGFzc2VzID0gJyc7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBwLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiBqc29uLmNsYXNzZXMgKz0gaSsrID09PSAwID8gY2xzIDogJyAnICsgY2xzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuJDEuanNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGpzb25zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgICAganNvbnMucHVzaChqc29uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbnM7XG4gIH07XG5cbiAgZWxlc2ZuJDEuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBlbGVzQXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgICAgdmFyIGNsb25lID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgICBlbGVzQXJyLnB1c2goY2xvbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlc0Fycik7XG4gIH07XG5cbiAgZWxlc2ZuJDEuY29weSA9IGVsZXNmbiQxLmNsb25lO1xuXG4gIGVsZXNmbiQxLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdGlmeVJlbmRlcmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHZhciBhZGRUb1Bvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlOyAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAgIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG5cbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICB2YXIgZWxlbWVudHM7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwLCBsID0gc2VsZi5sZW5ndGg7IF9pMyA8IGw7IF9pMysrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltfaTNdO1xuXG4gICAgICBpZiAoYWRkVG9Qb29sICYmICFlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gaGFuZGxlIHRoaXMgZWxlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcblxuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoZWRnZXMpO1xuICAgIHZhciBpO1xuXG4gICAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21FbGVtZW50cygpIHtcbiAgICAgIGVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICB9OyAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9lbGUyID0gZWxlbWVudHNbaV07XG4gICAgICB2YXIgX3ByaXZhdGUgPSBfZWxlMi5fcHJpdmF0ZTtcbiAgICAgIHZhciBfZGF0YTMgPSBfcHJpdmF0ZS5kYXRhOyAvLyB0aGUgdHJhdmVyc2FsIGNhY2hlIHNob3VsZCBzdGFydCBmcmVzaCB3aGVuIGVsZSBpcyBhZGRlZFxuXG4gICAgICBfZWxlMi5jbGVhclRyYXZlcnNhbENhY2hlKCk7IC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcblxuXG4gICAgICBpZiAoIWFkZFRvUG9vbCAmJiAhX3ByaXZhdGUucmVtb3ZlZCkgOyBlbHNlIGlmIChfZGF0YTMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfZGF0YTMuaWQgPSB1dWlkKCk7XG4gICAgICB9IGVsc2UgaWYgKG51bWJlciQxKF9kYXRhMy5pZCkpIHtcbiAgICAgICAgX2RhdGEzLmlkID0gJycgKyBfZGF0YTMuaWQ7IC8vIG5vdyBpdCdzIGEgc3RyaW5nXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5U3RyaW5nKF9kYXRhMy5pZCkgfHwgIXN0cmluZyhfZGF0YTMuaWQpKSB7XG4gICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlbGVtZW50IHdpdGggaW52YWxpZCBzdHJpbmcgSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcblxuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEzLmlkKSkge1xuICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIF9kYXRhMy5pZCArICdgJyk7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIG9uZSBhbHJlYWR5IGhhcyB0aGF0IGlkXG5cbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSBfZGF0YTMuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgICAgaWYgKF9lbGUyLmlzTm9kZSgpKSB7XG4gICAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3Igbm9kZXNcbiAgICAgICAgdmFyIHBvcyA9IF9wcml2YXRlLnBvc2l0aW9uOyAvLyBtYWtlIHN1cmUgdGhlIG5vZGVzIGhhdmUgYSBkZWZpbmVkIHBvc2l0aW9uXG5cbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIHBvcy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoX2VsZTIuaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuICAgICAgICB2YXIgZWRnZSA9IF9lbGUyO1xuICAgICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICAgIHZhciB2YWwgPSBfZGF0YTNbZmllbGRdO1xuXG4gICAgICAgICAgaWYgKG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IF9kYXRhM1tmaWVsZF0gPSAnJyArIF9kYXRhM1tmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSAnJykge1xuICAgICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghY3kuaGFzRWxlbWVudFdpdGhJZCh2YWwpKSB7XG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYWRTb3VyY2VPclRhcmdldCkge1xuICAgICAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cblxuICAgICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoX2RhdGEzLnNvdXJjZSk7XG4gICAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMudGFyZ2V0KTsgLy8gb25seSBvbmUgZWRnZSBpbiBub2RlIGlmIGxvb3BcblxuICAgICAgICBpZiAoc3JjLnNhbWUodGd0KSkge1xuICAgICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICAgICAgdGd0Ll9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgICAgZWRnZS5fcHJpdmF0ZS50YXJnZXQgPSB0Z3Q7XG4gICAgICB9IC8vIGlmIGlzIGVkZ2VcbiAgICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG5cblxuICAgICAgX3ByaXZhdGUubWFwID0gbmV3IE1hcCQyKCk7XG5cbiAgICAgIF9wcml2YXRlLm1hcC5zZXQoaWQsIHtcbiAgICAgICAgZWxlOiBfZWxlMixcbiAgICAgICAgaW5kZXg6IDBcbiAgICAgIH0pO1xuXG4gICAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgICAgY3kuYWRkVG9Qb29sKF9lbGUyKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcbiAgICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcblxuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgLy8gZWFjaCBub2RlXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW19pNF07XG4gICAgICB2YXIgX2RhdGE0ID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICBpZiAobnVtYmVyJDEoX2RhdGE0LnBhcmVudCkpIHtcbiAgICAgICAgLy8gdGhlbiBhdXRvbWFrZSBzdHJpbmdcbiAgICAgICAgX2RhdGE0LnBhcmVudCA9ICcnICsgX2RhdGE0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudElkID0gX2RhdGE0LnBhcmVudDtcbiAgICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgICBpZiAoc3BlY2lmaWVkUGFyZW50IHx8IG5vZGUuX3ByaXZhdGUucGFyZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLl9wcml2YXRlLnBhcmVudCA/IGN5LmNvbGxlY3Rpb24oKS5tZXJnZShub2RlLl9wcml2YXRlLnBhcmVudCkgOiBjeS5nZXRFbGVtZW50QnlJZChwYXJlbnRJZCk7XG5cbiAgICAgICAgaWYgKHBhcmVudC5lbXB0eSgpKSB7XG4gICAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudFswXS5yZW1vdmVkKCkpIHtcbiAgICAgICAgICB3YXJuKCdOb2RlIGFkZGVkIHdpdGggbWlzc2luZyBwYXJlbnQsIHJlZmVyZW5jZSB0byBwYXJlbnQgcmVtb3ZlZCcpO1xuICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG5cbiAgICAgICAgICB3aGlsZSAoIWFuY2VzdG9yLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnNhbWUoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXNlbGZBc1BhcmVudCkge1xuICAgICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07IC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuXG4gICAgICAgICAgICBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbHNlXG5cbiAgICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuXG4gICAgfSAvLyBmb3IgZWFjaCBub2RlXG5cblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgcmVzdG9yZWQgPSBlbGVtZW50cy5sZW5ndGggPT09IHNlbGYubGVuZ3RoID8gc2VsZiA6IG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHJlc3RvcmVkLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIF9lbGUzID0gcmVzdG9yZWRbX2k1XTtcblxuICAgICAgICBpZiAoX2VsZTMuaXNOb2RlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG5cblxuICAgICAgICBfZWxlMy5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG5cblxuICAgICAgICBfZWxlMy5zb3VyY2UoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAgICAgX2VsZTMudGFyZ2V0KCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9VcGRhdGVTdHlsZTtcblxuICAgICAgaWYgKGN5X3AuaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQ7XG4gICAgICB9XG5cbiAgICAgIHRvVXBkYXRlU3R5bGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCkuZGlydHlCb3VuZGluZ0JveENhY2hlKCkudXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpO1xuXG4gICAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgICB9IGVsc2UgaWYgKGFkZFRvUG9vbCkge1xuICAgICAgICByZXN0b3JlZC5lbWl0KCdhZGQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjsgLy8gY2hhaW5hYmlsaXR5XG4gIH07XG5cbiAgZWxlc2ZuJDEucmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xuICB9O1xuXG4gIGVsZXNmbiQxLmluc2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICBlbGVzZm4kMS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdGlmeVJlbmRlcmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHZhciByZW1vdmVGcm9tUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHZhciBlbGVzVG9SZW1vdmVJZHMgPSB7fTtcbiAgICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5OyAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG5cbiAgICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFkZChlZGdlc1tpXSk7XG4gICAgICB9XG4gICAgfSAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuXG5cbiAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFkZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKGVsZSkge1xuICAgICAgdmFyIGFscmVhZHlBZGRlZCA9IGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV07XG5cbiAgICAgIGlmIChyZW1vdmVGcm9tUG9vbCAmJiBlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoZWxlKTtcbiAgICAgICAgYWRkQ2hpbGRyZW4oZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KGVsZSk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgICB9XG4gICAgfSAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAgIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICBhZGQoZWxlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2UpIHtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICByZW1vdmVGcm9tQXJyYXkoY29ubmVjdGVkRWRnZXMsIGVkZ2UpOyAvLyByZW1vdmluZyBhbiBlZGdlcyBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciBpdHMgbm9kZXNcblxuICAgICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSkge1xuICAgICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgICBwbGxFZGdlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKSB7XG4gICAgICBlbGUgPSBlbGVbMF07XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgICByZW1vdmVGcm9tQXJyYXkoY2hpbGRyZW4sIGVsZSk7IC8vIHJlbW92ZSBwYXJlbnQgPT4gY2hpbGQgcmVmXG5cbiAgICAgIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPSBudWxsOyAvLyByZW1vdmUgY2hpbGQgPT4gcGFyZW50IHJlZlxuXG4gICAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1twaWRdID0gdHJ1ZTtcbiAgICAgICAgYWx0ZXJlZFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgIGN5LnJlbW92ZUZyb21Qb29sKGVsZXNUb1JlbW92ZSk7IC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICAgIH1cblxuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNisrKSB7XG4gICAgICB2YXIgX2VsZTQgPSBlbGVzVG9SZW1vdmVbX2k2XTtcblxuICAgICAgaWYgKF9lbGU0LmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICAgIHZhciBzcmMgPSBfZWxlNC5zb3VyY2UoKVswXTtcblxuICAgICAgICB2YXIgdGd0ID0gX2VsZTQudGFyZ2V0KClbMF07XG5cbiAgICAgICAgcmVtb3ZlRWRnZVJlZihzcmMsIF9lbGU0KTtcbiAgICAgICAgcmVtb3ZlRWRnZVJlZih0Z3QsIF9lbGU0KTtcblxuICAgICAgICB2YXIgcGxsRWRnZXMgPSBfZWxlNC5wYXJhbGxlbEVkZ2VzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGxFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBwbGxFZGdlID0gcGxsRWRnZXNbal07XG4gICAgICAgICAgcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSk7XG5cbiAgICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICAgIHZhciBwYXJlbnQgPSBfZWxlNC5wYXJlbnQoKTtcblxuICAgICAgICBpZiAocGFyZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgX2VsZTQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgICAgX2VsZTQuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuXG5cbiAgICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgIHZhciBfZWxlNSA9IGVsZXNTdGlsbEluc2lkZVtfaTddO1xuXG4gICAgICBpZiAoX2VsZTUuaXNQYXJlbnQoKSkge1xuICAgICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlc1RvUmVtb3ZlKTtcblxuICAgIGlmIChyZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCkge1xuICAgICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG4gICAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXRBbmROb3RpZnkoJ3JlbW92ZScpO1xuICAgICAgfSBlbHNlIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgICByZW1vdmVkRWxlbWVudHMuZW1pdCgncmVtb3ZlJyk7XG4gICAgICB9XG4gICAgfSAvLyB0aGUgcGFyZW50cyB3aG8gd2VyZSBtb2RpZmllZCBieSB0aGUgcmVtb3ZhbCBuZWVkIHRoZWlyIHN0eWxlIHVwZGF0ZWRcblxuXG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgYWx0ZXJlZFBhcmVudHMubGVuZ3RoOyBfaTgrKykge1xuICAgICAgdmFyIF9lbGU2ID0gYWx0ZXJlZFBhcmVudHNbX2k4XTtcblxuICAgICAgaWYgKCFyZW1vdmVGcm9tUG9vbCB8fCAhX2VsZTYucmVtb3ZlZCgpKSB7XG4gICAgICAgIF9lbGU2LnVwZGF0ZVN0eWxlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZWRFbGVtZW50cztcbiAgfTtcblxuICBlbGVzZm4kMS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVsZXMgPSB0aGlzOyAvLyBqdXN0IGNsZWFuIHVwIHJlZnMsIGNhY2hlcywgZXRjLiBpbiB0aGUgc2FtZSB3YXkgYXMgd2hlbiByZW1vdmluZyBhbmQgdGhlbiByZXN0b3JpbmdcbiAgICAvLyAob3VyIGNhbGxzIHRvIHJlbW92ZS9yZXN0b3JlIGRvIG5vdCByZW1vdmUgZnJvbSB0aGUgZ3JhcGggb3IgbWFrZSBldmVudHMpXG5cbiAgICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBmYWxzZTtcbiAgICB2YXIgbW9kaWZ5UG9vbCA9IGZhbHNlO1xuXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoaWQpIHtcbiAgICAgIHJldHVybiBpZCA9PSBudWxsID8gaWQgOiAnJyArIGlkO1xuICAgIH07IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cblxuICAgIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc3JjSWQgPSB0b1N0cmluZyhzdHJ1Y3Quc291cmNlKTtcbiAgICAgIHZhciB0Z3RJZCA9IHRvU3RyaW5nKHN0cnVjdC50YXJnZXQpO1xuICAgICAgdmFyIHNyY0V4aXN0cyA9IHNyY0lkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZChzcmNJZCk7XG4gICAgICB2YXIgdGd0RXhpc3RzID0gdGd0SWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHRndElkKTtcblxuICAgICAgaWYgKHNyY0V4aXN0cyB8fCB0Z3RFeGlzdHMpIHtcbiAgICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgICAgZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cblxuICAgICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIHZhciBfZGF0YTUgPSBlbGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgICBpZiAoc3JjRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRndEV4aXN0cykge1xuICAgICAgICAgICAgICAgIF9kYXRhNS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZXMucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnRJZCA9IHRvU3RyaW5nKHN0cnVjdC5wYXJlbnQpO1xuICAgICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5Lmhhc0VsZW1lbnRXaXRoSWQocGFyZW50SWQpO1xuXG4gICAgICBpZiAocGFyZW50RXhpc3RzKSB7XG4gICAgICAgIHZhciBwaWRUb0Fzc2lnbiA9IHBhcmVudElkID09PSBudWxsID8gdW5kZWZpbmVkIDogcGFyZW50SWQ7XG4gICAgICAgIGN5LmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICAgIHZhciB1cGRhdGVkID0gZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cblxuICAgICAgICAgIHVwZGF0ZWQuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIHZhciBfZGF0YTYgPSBlbGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgICBfZGF0YTYucGFyZW50ID0gcGlkVG9Bc3NpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlZC5yZXN0b3JlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gbWFrZSBuZXcgcmVmcywgc3R5bGUsIGV0Yy5cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFtlbGVzZm4kaiwgZWxlc2ZuJGksIGVsZXNmbiRoLCBlbGVzZm4kZywgZWxlc2ZuJGYsIGRhdGEsIGVsZXNmbiRkLCBkaW1lbnNpb25zLCBlbGVzZm4kOSwgZWxlc2ZuJDgsIGVsZXNmbiQ3LCBlbGVzZm4kNiwgZWxlc2ZuJDUsIGVsZXNmbiQ0LCBlbGVzZm4kMywgZWxlc2ZuJDJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKGVsZXNmbiQxLCBwcm9wcyk7XG4gIH0pO1xuXG4gIHZhciBjb3JlZm4kOSA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChvcHRzKSB7XG4gICAgICB2YXIgZWxlbWVudHM7XG4gICAgICB2YXIgY3kgPSB0aGlzOyAvLyBhZGQgdGhlIGVsZW1lbnRzXG5cbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICAgIHZhciBlbGVzID0gb3B0cztcblxuICAgICAgICBpZiAoZWxlcy5fcHJpdmF0ZS5jeSA9PT0gY3kpIHtcbiAgICAgICAgICAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIGpzb25zLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgICAgZWxzZSBpZiAoYXJyYXkob3B0cykpIHtcbiAgICAgICAgdmFyIF9qc29ucyA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29ucyk7XG4gICAgICB9IC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICAgIGVsc2UgaWYgKHBsYWluT2JqZWN0KG9wdHMpICYmIChhcnJheShvcHRzLm5vZGVzKSB8fCBhcnJheShvcHRzLmVkZ2VzKSkpIHtcbiAgICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgICAgdmFyIF9qc29uczIgPSBbXTtcbiAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgX2kgPCBpbDsgX2krKykge1xuICAgICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcblxuICAgICAgICAgIGlmIChhcnJheShlbGVzQXJyYXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICB2YXIganNvbiA9IGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICAgIH0sIGVsZXNBcnJheVtqXSk7XG5cbiAgICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29uczIpO1xuICAgICAgfSAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9qc29uID0gb3B0cztcbiAgICAgICAgZWxlbWVudHMgPSBuZXcgRWxlbWVudChjeSwgX2pzb24pLmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikpIDsgZWxzZSBpZiAoc3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xuXG4gIC8qISBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuICAgICAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG4gICAgICAgIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMSxcbiAgICAgICAgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcbiAgICAgICAga1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuICAgICAgICBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCksXG4gICAgICAgIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuICAgIC8qIE11c3QgY29udGFpbiBmb3VyIGFyZ3VtZW50cy4gKi9cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogWCB2YWx1ZXMgbXVzdCBiZSBpbiB0aGUgWzAsIDFdIHJhbmdlLiAqL1xuXG5cbiAgICBtWDEgPSBNYXRoLm1pbihtWDEsIDEpO1xuICAgIG1YMiA9IE1hdGgubWluKG1YMiwgMSk7XG4gICAgbVgxID0gTWF0aC5tYXgobVgxLCAwKTtcbiAgICBtWDIgPSBNYXRoLm1heChtWDIsIDApO1xuICAgIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICAgIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDKGFBMSkge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytfaSkge1xuICAgICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuXG4gICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGtTcGxpbmVUYWJsZVNpemU7ICsrX2kyKSB7XG4gICAgICAgIG1TYW1wbGVWYWx1ZXNbX2kyXSA9IGNhbGNCZXppZXIoX2kyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcbiAgICAgIHZhciBjdXJyZW50WCxcbiAgICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXG4gICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcblxuICAgICAgcmV0dXJuIGN1cnJlbnRUO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcbiAgICAgICAgICBjdXJyZW50U2FtcGxlID0gMSxcbiAgICAgICAgICBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLS1jdXJyZW50U2FtcGxlO1xuICAgICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pLFxuICAgICAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG5cbiAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGYgPSBmdW5jdGlvbiBmKGFYKSB7XG4gICAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuICAgICAgICBwcmVjb21wdXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgICByZXR1cm4gYVg7XG4gICAgICB9XG5cbiAgICAgIGlmIChhWCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFYID09PSAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcbiAgICB9O1xuXG4gICAgZi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHg6IG1YMSxcbiAgICAgICAgeTogbVkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IG1YMixcbiAgICAgICAgeTogbVkyXG4gICAgICB9XTtcbiAgICB9O1xuXG4gICAgdmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuXG4gICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIHJldHVybiBmO1xuICB9XG5cbiAgLyohIFJ1bmdlLUt1dHRhIHNwcmluZyBwaHlzaWNzIGZ1bmN0aW9uIGdlbmVyYXRvci4gQWRhcHRlZCBmcm9tIEZyYW1lci5qcywgY29weXJpZ2h0IEtvZW4gQm9rLiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuXG4gIC8qIEdpdmVuIGEgdGVuc2lvbiwgZnJpY3Rpb24sIGFuZCBkdXJhdGlvbiwgYSBzaW11bGF0aW9uIGF0IDYwRlBTIHdpbGwgZmlyc3QgcnVuIHdpdGhvdXQgYSBkZWZpbmVkIGR1cmF0aW9uIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBwYXRoLiBBIHNlY29uZCBwYXNzXG4gICAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xuICB2YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiAtc3RhdGUudGVuc2lvbiAqIHN0YXRlLnggLSBzdGF0ZS5mcmljdGlvbiAqIHN0YXRlLnY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgeDogaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQsXG4gICAgICAgIHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuICAgICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgICAgZnJpY3Rpb246IGluaXRpYWxTdGF0ZS5mcmljdGlvblxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwcmluZ0ludGVncmF0ZVN0YXRlKHN0YXRlLCBkdCkge1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICB9LFxuICAgICAgICAgIGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBhKSxcbiAgICAgICAgICBjID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYiksXG4gICAgICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgICAgIGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcbiAgICAgICAgICBkdmR0ID0gMS4wIC8gNi4wICogKGEuZHYgKyAyLjAgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG4gICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHY6IDAsXG4gICAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICAgIGZyaWN0aW9uOiBudWxsXG4gICAgICB9LFxuICAgICAgICAgIHBhdGggPSBbMF0sXG4gICAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICAgIHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcbiAgICAgICAgICBEVCA9IDE2IC8gMTAwMCxcbiAgICAgICAgICBoYXZlX2R1cmF0aW9uLFxuICAgICAgICAgIGR0LFxuICAgICAgICAgIGxhc3Rfc3RhdGU7XG4gICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuICAgICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgICAgaW5pdFN0YXRlLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgICBoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG4gICAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuXG4gICAgICBpZiAoaGF2ZV9kdXJhdGlvbikge1xuICAgICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgICB0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuXG4gICAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHQgPSBEVDtcbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuICAgICAgICAvKiBTdG9yZSB0aGUgcG9zaXRpb24uICovXG5cbiAgICAgICAgcGF0aC5wdXNoKDEgKyBsYXN0X3N0YXRlLngpO1xuICAgICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgICAgLyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovXG5cbiAgICAgICAgaWYgKCEoTWF0aC5hYnMobGFzdF9zdGF0ZS54KSA+IHRvbGVyYW5jZSAmJiBNYXRoLmFicyhsYXN0X3N0YXRlLnYpID4gdG9sZXJhbmNlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG4gICAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cblxuXG4gICAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uIChwZXJjZW50Q29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjdWJpY0JlemllciA9IGZ1bmN0aW9uIGN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKSB7XG4gICAgdmFyIGJlemllciA9IGdlbmVyYXRlQ3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGJlemllcihwZXJjZW50KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBlYXNpbmdzID0ge1xuICAgICdsaW5lYXInOiBmdW5jdGlvbiBsaW5lYXIoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgICAnZWFzZSc6IGN1YmljQmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSksXG4gICAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKSxcbiAgICAnZWFzZS1vdXQnOiBjdWJpY0JlemllcigwLCAwLCAwLjU4LCAxKSxcbiAgICAnZWFzZS1pbi1vdXQnOiBjdWJpY0JlemllcigwLjQyLCAwLCAwLjU4LCAxKSxcbiAgICAvLyBzaW5lXG4gICAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSksXG4gICAgJ2Vhc2Utb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjM5LCAwLjU3NSwgMC41NjUsIDEpLFxuICAgICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC40NDUsIDAuMDUsIDAuNTUsIDAuOTUpLFxuICAgIC8vIHF1YWRcbiAgICAnZWFzZS1pbi1xdWFkJzogY3ViaWNCZXppZXIoMC41NSwgMC4wODUsIDAuNjgsIDAuNTMpLFxuICAgICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCksXG4gICAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjQ1NSwgMC4wMywgMC41MTUsIDAuOTU1KSxcbiAgICAvLyBjdWJpY1xuICAgICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5KSxcbiAgICAnZWFzZS1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpLFxuICAgICdlYXNlLWluLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEpLFxuICAgIC8vIHF1YXJ0XG4gICAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllcigwLjg5NSwgMC4wMywgMC42ODUsIDAuMjIpLFxuICAgICdlYXNlLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjc3LCAwLCAwLjE3NSwgMSksXG4gICAgLy8gcXVpbnRcbiAgICAnZWFzZS1pbi1xdWludCc6IGN1YmljQmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiksXG4gICAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC4yMywgMSwgMC4zMiwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC44NiwgMCwgMC4wNywgMSksXG4gICAgLy8gZXhwb1xuICAgICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllcigwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUpLFxuICAgICdlYXNlLW91dC1leHBvJzogY3ViaWNCZXppZXIoMC4xOSwgMSwgMC4yMiwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LWV4cG8nOiBjdWJpY0JlemllcigxLCAwLCAwLCAxKSxcbiAgICAvLyBjaXJjXG4gICAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKDAuNiwgMC4wNCwgMC45OCwgMC4zMzUpLFxuICAgICdlYXNlLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC4wNzUsIDAuODIsIDAuMTY1LCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuNzg1LCAwLjEzNSwgMC4xNSwgMC44NiksXG4gICAgLy8gdXNlciBwYXJhbSBlYXNpbmdzLi4uXG4gICAgJ3NwcmluZyc6IGZ1bmN0aW9uIHNwcmluZyh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAvLyBjYW4ndCBnZXQgYSBzcHJpbmcgdy8gZHVyYXRpb24gMFxuICAgICAgICByZXR1cm4gZWFzaW5ncy5saW5lYXI7IC8vIGR1cmF0aW9uIDAgPT4ganVtcCB0byBlbmQgc28gaW1wbCBkb2Vzbid0IG1hdHRlclxuICAgICAgfVxuXG4gICAgICB2YXIgc3ByaW5nID0gZ2VuZXJhdGVTcHJpbmdSSzQodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKHBlcmNlbnQpO1xuICAgICAgfTtcbiAgICB9LFxuICAgICdjdWJpYy1iZXppZXInOiBjdWJpY0JlemllclxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pIHtcbiAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gZWFzaW5nRm4oc3RhcnQsIGVuZCwgcGVyY2VudCk7XG5cbiAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnJvdW5kVmFsdWUgfHwgdHlwZS5jb2xvcikge1xuICAgICAgdmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwgPSBNYXRoLm1heCh2YWwsIHR5cGUubWluKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsID0gTWF0aC5taW4odmFsLCB0eXBlLm1heCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKHByb3AsIHNwZWMpIHtcbiAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgfHwgcHJvcC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgJiYgKHNwZWMgPT0gbnVsbCB8fCBzcGVjLnR5cGUudW5pdHMgIT09ICclJykpIHtcbiAgICAgICAgcmV0dXJuIHByb3AucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9wLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4sIHByb3BTcGVjKSB7XG4gICAgdmFyIHR5cGUgPSBwcm9wU3BlYyAhPSBudWxsID8gcHJvcFNwZWMudHlwZSA6IG51bGw7XG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGdldFZhbHVlKHN0YXJ0UHJvcCwgcHJvcFNwZWMpO1xuICAgIHZhciBlbmQgPSBnZXRWYWx1ZShlbmRQcm9wLCBwcm9wU3BlYyk7XG5cbiAgICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICAgIHJldHVybiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHN0YXJ0KSAmJiBhcnJheShlbmQpKSB7XG4gICAgICB2YXIgZWFzZWRBcnIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNpID0gc3RhcnRbaV07XG4gICAgICAgIHZhciBlaSA9IGVuZFtpXTtcblxuICAgICAgICBpZiAoc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGdldEVhc2VkVmFsdWUodHlwZSwgc2ksIGVpLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gICAgICAgICAgZWFzZWRBcnIucHVzaCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVhc2VkQXJyLnB1c2goZWkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlYXNlZEFycjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcCQxKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICB2YXIgcEVhc2luZyA9IGFuaV9wLmVhc2luZztcbiAgICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuICAgIHZhciBjeSA9IGlzQ29yZSA/IHNlbGYgOiBzZWxmLmN5KCk7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgIGlmICghYW5pX3AuZWFzaW5nSW1wbCkge1xuICAgICAgaWYgKHBFYXNpbmcgPT0gbnVsbCkge1xuICAgICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1snbGluZWFyJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICAgIHZhciBlYXNpbmdWYWxzO1xuXG4gICAgICAgIGlmIChzdHJpbmcocEVhc2luZykpIHtcbiAgICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuICAgICAgICAgIGVhc2luZ1ZhbHMgPSBlYXNpbmdQcm9wLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICAgIGVhc2luZ1ZhbHMgPSBwRWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgaWYgKHN0cmluZyhlYXNpbmdWYWxzKSkge1xuICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiArbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYW5pX3AuZHVyYXRpb24pOyAvLyBuZWVkIGR1cmF0aW9uIHRvIGdlbmVyYXRlIHNwcmluZ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICAgIHZhciBwZXJjZW50O1xuXG4gICAgaWYgKGFuaV9wLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gICAgfVxuXG4gICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICBwZXJjZW50ID0gYW5pX3AucHJvZ3Jlc3M7XG4gICAgfVxuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYW5pX3AuZGVsYXkgPT0gbnVsbCkge1xuICAgICAgLy8gdGhlbiB1cGRhdGVcbiAgICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgICB2YXIgZW5kUG9zID0gYW5pX3AucG9zaXRpb247XG5cbiAgICAgIGlmIChlbmRQb3MgJiYgaXNFbGVzICYmICFzZWxmLmxvY2tlZCgpKSB7XG4gICAgICAgIHZhciBuZXdQb3MgPSB7fTtcblxuICAgICAgICBpZiAodmFsaWQoc3RhcnRQb3MueCwgZW5kUG9zLngpKSB7XG4gICAgICAgICAgbmV3UG9zLnggPSBlYXNlKHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLnksIGVuZFBvcy55KSkge1xuICAgICAgICAgIG5ld1Bvcy55ID0gZWFzZShzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucG9zaXRpb24obmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW47XG4gICAgICB2YXIgZW5kUGFuID0gYW5pX3AucGFuO1xuICAgICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG5cbiAgICAgIGlmIChhbmltYXRpbmdQYW4pIHtcbiAgICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLngsIGVuZFBhbi54KSkge1xuICAgICAgICAgIHBhbi54ID0gZWFzZShzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZChzdGFydFBhbi55LCBlbmRQYW4ueSkpIHtcbiAgICAgICAgICBwYW4ueSA9IGVhc2Uoc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmVtaXQoJ3BhbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgICAgdmFyIGVuZFpvb20gPSBhbmlfcC56b29tO1xuICAgICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuXG4gICAgICBpZiAoYW5pbWF0aW5nWm9vbSkge1xuICAgICAgICBpZiAodmFsaWQoc3RhcnRab29tLCBlbmRab29tKSkge1xuICAgICAgICAgIF9wLnpvb20gPSBib3VuZChfcC5taW5ab29tLCBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKSwgX3AubWF4Wm9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmVtaXQoJ3pvb20nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tKSB7XG4gICAgICAgIHNlbGYuZW1pdCgndmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzID0gYW5pX3Auc3R5bGU7XG5cbiAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGggPiAwICYmIGlzRWxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIGVuZCA9IHByb3A7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pX3Auc3RhcnRTdHlsZVtfbmFtZV07XG4gICAgICAgICAgdmFyIHByb3BTcGVjID0gc3R5bGUucHJvcGVydGllc1tzdGFydC5uYW1lXTtcbiAgICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZywgcHJvcFNwZWMpO1xuICAgICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKHNlbGYsIF9uYW1lLCBlYXNlZFZhbCk7XG4gICAgICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgICAgICBzZWxmLmVtaXQoJ3N0eWxlJyk7XG4gICAgICB9IC8vIGlmXG5cbiAgICB9XG5cbiAgICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbihzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIGFuaV9wLnN0YXJ0VGltZSA9IG5vdyAtIGFuaV9wLnByb2dyZXNzICogYW5pX3AuZHVyYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwQWxsKG5vdywgY3kpIHtcbiAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgdmFyIGRvbmVFbGVzID0gW107XG5cbiAgICBmdW5jdGlvbiBzdGVwT25lKGVsZSwgaXNDb3JlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgY3VycmVudCA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgdmFyIHJhbkFuaXMgPSBmYWxzZTsgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG5cbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGxiYWNrcyA9IGZ1bmN0aW9uIGNhbGxiYWNrcyhfY2FsbGJhY2tzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgdmFyIGNiID0gX2NhbGxiYWNrc1tqXTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoMCwgX2NhbGxiYWNrcy5sZW5ndGgpO1xuICAgICAgfTsgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcblxuXG4gICAgICBmb3IgKHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcbiAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICAgIGlmIChhbmlfcC5zdG9wcGVkKSB7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG5cblxuICAgICAgICBpZiAoYW5pX3AucGxheWluZyAmJiBhbmlfcC5hcHBseWluZykge1xuICAgICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFuaV9wLnN0YXJ0ZWQpIHtcbiAgICAgICAgICBzdGFydEFuaW1hdGlvbihlbGUsIGFuaSwgbm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXAkMShlbGUsIGFuaSwgbm93LCBpc0NvcmUpO1xuXG4gICAgICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcblxuICAgICAgICBpZiAoYW5pX3Auc3RlcCAhPSBudWxsKSB7XG4gICAgICAgICAgYW5pX3Auc3RlcChub3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmNvbXBsZXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0NvcmUgJiYgY3VycmVudC5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbkFuaXM7XG4gICAgfSAvLyBzdGVwRWxlbWVudFxuICAgIC8vIGhhbmRsZSBhbGwgZWxlc1xuXG5cbiAgICB2YXIgcmFuRWxlQW5pID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgICAgdmFyIGhhbmRsZWRUaGlzRWxlID0gc3RlcE9uZShlbGUpO1xuICAgICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cblxuICAgIHZhciByYW5Db3JlQW5pID0gc3RlcE9uZShjeSwgdHJ1ZSk7IC8vIG5vdGlmeSByZW5kZXJlclxuXG4gICAgaWYgKHJhbkVsZUFuaSB8fCByYW5Db3JlQW5pKSB7XG4gICAgICBpZiAoZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN5Lm5vdGlmeSgnZHJhdycsIGVsZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICB9XG4gICAgfSAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcblxuXG4gICAgZWxlcy51bm1lcmdlKGRvbmVFbGVzKTtcbiAgICBjeS5lbWl0KCdzdGVwJyk7XG4gIH0gLy8gc3RlcEFsbFxuXG4gIHZhciBjb3JlZm4kOCA9IHtcbiAgICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICAgIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICAgIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gICAgc3RvcDogZGVmaW5lLnN0b3AoKSxcbiAgICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uIGFkZFRvQW5pbWF0aW9uUG9vbChlbGVzKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cblxuICAgICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZShlbGVzKTtcbiAgICB9LFxuICAgIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uTG9vcCgpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIGN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuICAgICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgICAgLy8gYW5kIGV4cGxpY2l0IGN5LmRlc3Ryb3koKSBpcyBuZWNlc3NhcnkgdG8gc3RvcCB0aGUgbG9vcFxuXG5cbiAgICAgIGZ1bmN0aW9uIGhlYWRsZXNzU3RlcCgpIHtcbiAgICAgICAgaWYgKCFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRpb25TdGVwKG5vdykge1xuICAgICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICAgICAgaGVhZGxlc3NTdGVwKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuXG4gICAgICBpZiAocmVuZGVyZXIgJiYgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAgIC8vIGxldCB0aGUgcmVuZGVyZXIgc2NoZWR1bGUgYW5pbWF0aW9uc1xuICAgICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgICB9LCByZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmFuaW1hdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFuYWdlIHRoZSBhbmltYXRpb24gbG9vcCBvdXJzZWx2ZXNcbiAgICAgICAgaGVhZGxlc3NTdGVwKCk7IC8vIGZpcnN0IGNhbGxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGVtaXR0ZXJPcHRpb25zID0ge1xuICAgIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG5cbiAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjeSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGN5LCBldnQpIHtcbiAgICAgIGV2dC5jeSA9IGN5O1xuICAgICAgZXZ0LnRhcmdldCA9IGN5O1xuICAgIH0sXG4gICAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogY3k7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhcmdTZWxlY3RvciA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICAgIGlmIChzdHJpbmcoYXJnKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZWxlc2ZuID0ge1xuICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICB9LFxuICAgIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmU6IGZ1bmN0aW9uIG9uZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGVsZXMpIHtcbiAgICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgICB0aGlzLm5vdGlmeShldmVudCwgZWxlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIGRlZmluZS5ldmVudEFsaWFzZXNPbihlbGVzZm4pO1xuXG4gIHZhciBjb3JlZm4kNyA9IHtcbiAgICBwbmc6IGZ1bmN0aW9uIHBuZyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICByZXR1cm4gcmVuZGVyZXIucG5nKG9wdGlvbnMpO1xuICAgIH0sXG4gICAganBnOiBmdW5jdGlvbiBqcGcob3B0aW9ucykge1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmpwZyhvcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIGNvcmVmbiQ3LmpwZWcgPSBjb3JlZm4kNy5qcGc7XG5cbiAgdmFyIGNvcmVmbiQ2ID0ge1xuICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0xheW91dCBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgIHZhciBMYXlvdXQgPSBjeS5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuXG4gICAgICBpZiAoTGF5b3V0ID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ05vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kLiAgRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD8nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlcztcblxuICAgICAgaWYgKHN0cmluZyhvcHRpb25zLmVsZXMpKSB7XG4gICAgICAgIGVsZXMgPSBjeS4kKG9wdGlvbnMuZWxlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzID0gb3B0aW9ucy5lbGVzICE9IG51bGwgPyBvcHRpb25zLmVsZXMgOiBjeS4kKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBjeTogY3ksXG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxuICB9O1xuICBjb3JlZm4kNi5jcmVhdGVMYXlvdXQgPSBjb3JlZm4kNi5tYWtlTGF5b3V0ID0gY29yZWZuJDYubGF5b3V0O1xuXG4gIHZhciBjb3JlZm4kNSA9IHtcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcykge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHRoaXMuYmF0Y2hpbmcoKSkge1xuICAgICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXSB8fCB0aGlzLmNvbGxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoZXZlbnRFbGVzICE9IG51bGwpIHtcbiAgICAgICAgICBlbGVzLm1lcmdlKGV2ZW50RWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47IC8vIG5vdGlmaWNhdGlvbnMgYXJlIGRpc2FibGVkIGR1cmluZyBiYXRjaGluZ1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG5cbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTsgLy8gZXhpdCBpZiBkZXN0cm95KCkgY2FsbGVkIG9uIGNvcmUgb3IgcmVuZGVyZXIgaW4gYmV0d2VlbiBmcmFtZXMgIzE0OTkgIzE1MjhcblxuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKCkgfHwgIXJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKTtcbiAgICB9LFxuICAgIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vdGlmaWNhdGlvbnMoYm9vbCkge1xuICAgICAgdmFyIHAgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiBub05vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgIH0sXG4gICAgYmF0Y2hpbmc6IGZ1bmN0aW9uIGJhdGNoaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYmF0Y2hDb3VudCA+IDA7XG4gICAgfSxcbiAgICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKF9wLmJhdGNoQ291bnQgPT0gbnVsbCkge1xuICAgICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgX3AuYmF0Y2hOb3RpZmljYXRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIF9wLmJhdGNoQ291bnQrKztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIF9wLmJhdGNoQ291bnQtLTtcblxuICAgICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpOyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuXG4gICAgICAgIE9iamVjdC5rZXlzKF9wLmJhdGNoTm90aWZpY2F0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgdmFyIGVsZXMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgIGlmIChlbGVzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBiYXRjaERhdGE6IGZ1bmN0aW9uIGJhdGNoRGF0YShtYXApIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgIHZhciBkYXRhID0gbWFwW2lkXTtcbiAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbmRlcmVyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICBoaWRlRWRnZXNPblZpZXdwb3J0OiBmYWxzZSxcbiAgICB0ZXh0dXJlT25WaWV3cG9ydDogZmFsc2UsXG4gICAgbW90aW9uQmx1cjogZmFsc2UsXG4gICAgbW90aW9uQmx1ck9wYWNpdHk6IDAuMDUsXG4gICAgcGl4ZWxSYXRpbzogdW5kZWZpbmVkLFxuICAgIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IDQsXG4gICAgdG91Y2hUYXBUaHJlc2hvbGQ6IDgsXG4gICAgd2hlZWxTZW5zaXRpdml0eTogMSxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgc2hvd0ZwczogZmFsc2VcbiAgfSk7XG4gIHZhciBjb3JlZm4kNCA9IHtcbiAgICByZW5kZXJUbzogZnVuY3Rpb24gcmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gICAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICByLnJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIH0sXG4gICAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgICAgdGhpcy5ub3RpZnkoJ2RyYXcnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVTaXplKCk7XG4gICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3Jlc2l6ZScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIFJlbmRlcmVyUHJvdG8gPSBjeS5leHRlbnNpb24oJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lKTtcblxuICAgICAgaWYgKFJlbmRlcmVyUHJvdG8gPT0gbnVsbCkge1xuICAgICAgICBlcnJvcihcIkNhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgXCIuY29uY2F0KG9wdGlvbnMubmFtZSwgXCJgIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0P1wiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm4oXCJZb3UgaGF2ZSBzZXQgYSBjdXN0b20gd2hlZWwgc2Vuc2l0aXZpdHkuICBUaGlzIHdpbGwgbWFrZSB5b3VyIGFwcCB6b29tIHVubmF0dXJhbGx5IHdoZW4gdXNpbmcgbWFpbnN0cmVhbSBtaWNlLiAgWW91IHNob3VsZCBjaGFuZ2UgdGhpcyB2YWx1ZSBmcm9tIHRoZSBkZWZhdWx0IG9ubHkgaWYgeW91IGNhbiBndWFyYW50ZWUgdGhhdCBhbGwgeW91ciB1c2VycyB3aWxsIHVzZSB0aGUgc2FtZSBoYXJkd2FyZSBhbmQgT1MgY29uZmlndXJhdGlvbiBhcyB5b3VyIGN1cnJlbnQgbWFjaGluZS5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciByT3B0cyA9IHJlbmRlcmVyRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgICByT3B0cy5jeSA9IGN5O1xuICAgICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhyT3B0cyk7XG4gICAgICB0aGlzLm5vdGlmeSgnaW5pdCcpO1xuICAgIH0sXG4gICAgZGVzdHJveVJlbmRlcmVyOiBmdW5jdGlvbiBkZXN0cm95UmVuZGVyZXIoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgY3kubm90aWZ5KCdkZXN0cm95Jyk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcblxuICAgICAgaWYgKGRvbUVsZSkge1xuICAgICAgICBkb21FbGUuX2N5cmVnID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoZG9tRWxlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuXG4gICAgICBjeS5tdXRhYmxlRWxlbWVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICBfcC5yc2NyYXRjaCA9IHt9O1xuICAgICAgICBfcC5yc3R5bGUgPSB7fTtcbiAgICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbiBvblJlbmRlcihmbikge1xuICAgICAgcmV0dXJuIHRoaXMub24oJ3JlbmRlcicsIGZuKTtcbiAgICB9LFxuICAgIG9mZlJlbmRlcjogZnVuY3Rpb24gb2ZmUmVuZGVyKGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgICB9XG4gIH07XG4gIGNvcmVmbiQ0LmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuJDQucmVzaXplO1xuXG4gIHZhciBjb3JlZm4kMyA9IHtcbiAgICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gICAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgICAvLyAtIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgaW4gdGhlIGdyYXBoIG9uIHNlbGVjdG9yIGFyZ1xuICAgIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gICAgY29sbGVjdGlvbjogZnVuY3Rpb24gY29sbGVjdGlvbihlbGVzLCBvcHRzKSB7XG4gICAgICBpZiAoc3RyaW5nKGVsZXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiQoZWxlcyk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgICAgcmV0dXJuIGVsZXMuY29sbGVjdGlvbigpO1xuICAgICAgfSBlbHNlIGlmIChhcnJheShlbGVzKSkge1xuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcywgZWxlcywgb3B0cy51bmlxdWUsIG9wdHMucmVtb3ZlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzKTtcbiAgICB9LFxuICAgIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9LFxuICAgIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgICAkOiBmdW5jdGlvbiAkKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWxlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtdXRhYmxlRWxlbWVudHM6IGZ1bmN0aW9uIG11dGFibGVFbGVtZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICAgIH1cbiAgfTsgLy8gYWxpYXNlc1xuXG4gIGNvcmVmbiQzLmVsZW1lbnRzID0gY29yZWZuJDMuZmlsdGVyID0gY29yZWZuJDMuJDtcblxuICB2YXIgc3R5Zm4kOCA9IHt9OyAvLyBrZXlzIGZvciBzdHlsZSBibG9ja3MsIGUuZy4gdHRmZnR0XG5cbiAgdmFyIFRSVUUgPSAndCc7XG4gIHZhciBGQUxTRSA9ICdmJzsgLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbiAgLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4gIC8vIC0gaXRzIGJ5cGFzc1xuICAvLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG5cbiAgc3R5Zm4kOC5hcHBseSA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHVwZGF0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgZm9yICh2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpZV07XG4gICAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoZWxlKTtcblxuICAgICAgaWYgKGN4dE1ldGEuZW1wdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSk7XG5cbiAgICAgIGlmIChlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSkge1xuICAgICAgICBzZWxmLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgYXBwLmRpZmZQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoaW50c0RpZmYgPSBzZWxmLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcblxuICAgICAgaWYgKGhpbnRzRGlmZikge1xuICAgICAgICB1cGRhdGVkRWxlcy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlbWVudHNcblxuXG4gICAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xuICB9O1xuXG4gIHN0eWZuJDguZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiAob2xkQ3h0S2V5LCBuZXdDeHRLZXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG5cbiAgICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH1cblxuICAgIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gVFJVRTtcbiAgICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoY3h0SGFzRGlmZmVkIHx8IG5ld0hhc0N4dCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgICAgfSBlbHNlIGlmIChjeHRIYXNEaWZmZWQpIHtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICAgIH0gZWxzZSBpZiAoY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTsgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAgIC8vIGlzIGNhY2hlZClcblxuICAgICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICAgIHZhciBoYXNMYXRlckN4dCA9IG5ld0N4dEtleVtrXSA9PT0gVFJVRTtcblxuICAgICAgICAgICAgaWYgKCFoYXNMYXRlckN4dCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG5cbiAgICAgICAgICAgIGxhdGVyQ3h0T3ZlcnJpZGVzID0gbGF0ZXJDeHQucHJvcGVydGllc1twcm9wLm5hbWVdICE9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgZGlmZlByb3BzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICB9IC8vIGlmXG5cbiAgICB9IC8vIGZvciBjb250ZXh0c1xuXG5cbiAgICBjYWNoZVtkdWFsQ3h0S2V5XSA9IGRpZmZQcm9wcztcbiAgICByZXR1cm4gZGlmZlByb3BzO1xuICB9O1xuXG4gIHN0eWZuJDguZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRLZXkgPSAnJztcbiAgICB2YXIgZGlmZlByb3BzO1xuICAgIHZhciBwcmV2S2V5ID0gZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5IHx8ICcnOyAvLyBnZXQgdGhlIGN4dCBrZXlcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyhlbGUpOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICAgIGlmIChjb250ZXh0U2VsZWN0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN4dEtleSArPSBUUlVFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0S2V5ICs9IEZBTFNFO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGNvbnRleHRcblxuXG4gICAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZihwcmV2S2V5LCBjeHRLZXkpO1xuICAgIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjeHRLZXksXG4gICAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHMsXG4gICAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICAgIH07XG4gIH07IC8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcblxuXG4gIHN0eWZuJDguZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEpIHtcbiAgICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307IC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG5cbiAgICBpZiAoY3h0U3R5bGVzW2N4dEtleV0pIHtcbiAgICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICBfcHJpdmF0ZToge1xuICAgICAgICBrZXk6IGN4dEtleVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcblxuICAgICAgaWYgKCFoYXNDeHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgc3R5Zm4kOC5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gICAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuICAgIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbZGlmZlByb3BOYW1lXTtcbiAgICAgIHZhciBlbGVQcm9wID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuXG4gICAgICBpZiAoIWN4dFByb3ApIHtcbiAgICAgICAgLy8gbm8gY29udGV4dCBwcm9wIG1lYW5zIGRlbGV0ZVxuICAgICAgICBpZiAoIWVsZVByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAvLyBuYiBhZmZlY3RzIGluaXRpYWwgYXBwbGljYXRpb24gb24gbWFwcGVkIHZhbHVlcyBsaWtlIGNvbnRyb2wtcG9pbnQtZGlzdGFuY2VzXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgICAgZGVsZXRlQnlwYXNzZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgICBcImRlbGV0ZVwiOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIHRoZSBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcblxuXG4gICAgICBpZiAoZWxlUHJvcCA9PT0gY3h0UHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBhIG1hcHBlZCBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcblxuXG4gICAgICBpZiAoY3h0UHJvcC5tYXBwZWQgPT09IHR5cGVzLmZuIC8vIGNvbnRleHQgcHJvcCBpcyBmdW5jdGlvbiBtYXBwZXJcbiAgICAgICYmIGVsZVByb3AgIT0gbnVsbCAvLyBzb21lIHByb3BzIGNhbiBiZSBudWxsIGV2ZW4gYnkgZGVmYXVsdCAoZS5nLiBhIHByb3AgdGhhdCBvdmVycmlkZXMgYW5vdGhlciBvbmUpXG4gICAgICAmJiBlbGVQcm9wLm1hcHBpbmcgIT0gbnVsbCAvLyBlbGUgcHJvcCBpcyBhIGNvbmNyZXRlIHZhbHVlIGZyb20gZnJvbSBhIG1hcHBlclxuICAgICAgJiYgZWxlUHJvcC5tYXBwaW5nLnZhbHVlID09PSBjeHRQcm9wLnZhbHVlIC8vIHRoZSBjdXJyZW50IHByb3Agb24gdGhlIGVsZSBpcyBhIGZsYXQgcHJvcCB2YWx1ZSBmb3IgdGhlIGZ1bmN0aW9uIG1hcHBlclxuICAgICAgKSB7XG4gICAgICAgIC8vIE5CIGRvbid0IHdyaXRlIHRvIGN4dFByb3AsIGFzIGl0J3Mgc2hhcmVkIGFtb25nIGVsZXMgKHN0b3JlZCBpbiBzdHlsZXNoZWV0KVxuICAgICAgICB2YXIgbWFwcGluZyA9IGVsZVByb3AubWFwcGluZzsgLy8gY2FuIHdyaXRlIHRvIG1hcHBpbmcsIGFzIGl0J3MgYSBwZXItZWxlIGNvcHlcblxuICAgICAgICB2YXIgZm5WYWx1ZSA9IG1hcHBpbmcuZm5WYWx1ZSA9IGN4dFByb3AudmFsdWUoZWxlKTsgLy8gdGVtcG9yYXJpbHkgY2FjaGUgdGhlIHZhbHVlIGluIGNhc2Ugb2YgYSBtaXNzXG5cbiAgICAgICAgaWYgKGZuVmFsdWUgPT09IG1hcHBpbmcucHJldkZuVmFsdWUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbZGlmZlByb3BOYW1lXSA9IHtcbiAgICAgICAgcHJldjogZWxlUHJvcFxuICAgICAgfTtcbiAgICAgIHNlbGYuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGN4dFByb3ApO1xuICAgICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgICAgaWYgKHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MpIHtcbiAgICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gICAgfTtcbiAgfTtcblxuICBzdHlmbiQ4LnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvcE5hbWVzID0gc2VsZi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG4gICAgdmFyIHByb3BHcktleXMgPSBzZWxmLnByb3BlcnR5R3JvdXBLZXlzO1xuXG4gICAgdmFyIHByb3BIYXNoID0gZnVuY3Rpb24gcHJvcEhhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpIHtcbiAgICAgIHJldHVybiBzZWxmLmdldFByb3BlcnRpZXNIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KTtcbiAgICB9O1xuXG4gICAgdmFyIG9sZFN0eWxlS2V5ID0gX3Auc3R5bGVLZXk7XG5cbiAgICBpZiAoZWxlLnJlbW92ZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJzsgLy8gZ2V0IHRoZSBzdHlsZSBrZXkgaGFzaGVzIHBlciBwcm9wIGdyb3VwXG4gICAgLy8gYnV0IGxhemlseSAtLSBvbmx5IHVzZSBub24tZGVmYXVsdCBwcm9wIHZhbHVlcyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBoYXNoZXNcbiAgICAvL1xuXG4gICAgdmFyIG92ZXJyaWRkZW5TdHlsZXMgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMob3ZlcnJpZGRlblN0eWxlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BHcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncktleSA9IHByb3BHcktleXNbaV07XG4gICAgICBfcC5zdHlsZUtleXNbZ3JLZXldID0gW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVHcktleTEgPSBmdW5jdGlvbiB1cGRhdGVHcktleTEodmFsLCBncktleSkge1xuICAgICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV1bMF0gPSBoYXNoSW50KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XVswXSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVHcktleTIgPSBmdW5jdGlvbiB1cGRhdGVHcktleTIodmFsLCBncktleSkge1xuICAgICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV1bMV0gPSBoYXNoSW50QWx0KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XVsxXSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVHcktleSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5KHZhbCwgZ3JLZXkpIHtcbiAgICAgIHVwZGF0ZUdyS2V5MSh2YWwsIGdyS2V5KTtcbiAgICAgIHVwZGF0ZUdyS2V5Mih2YWwsIGdyS2V5KTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUdyS2V5V1N0ciA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5V1N0cihzdHJWYWwsIGdyS2V5KSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgY2ggPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdXBkYXRlR3JLZXkxKGNoLCBncktleSk7XG4gICAgICAgIHVwZGF0ZUdyS2V5MihjaCwgZ3JLZXkpO1xuICAgICAgfVxuICAgIH07IC8vIC0gaGFzaGluZyB3b3JrcyBvbiAzMiBiaXQgaW50cyBiL2Mgd2UgdXNlIGJpdHdpc2Ugb3BzXG4gICAgLy8gLSBzbWFsbCBudW1iZXJzIGdldCBjdXQgb2ZmIChlLmcuIDAuMTIzIGlzIHNlZW4gYXMgMCBieSB0aGUgaGFzaGluZyBmdW5jdGlvbilcbiAgICAvLyAtIHJhaXNlIHVwIHNtYWxsIG51bWJlcnMgc28gbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgYXJlIHNlZW4gYnkgaGFzaGluZ1xuICAgIC8vIC0gbWFrZSBzbWFsbCBudW1iZXJzIGxhcmdlciB0aGFuIGEgbm9ybWFsIHZhbHVlIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgICAvLyAtIHdvcmtzIGluIHByYWN0aWNlIGFuZCBpdCdzIHJlbGF0aXZlbHkgY2hlYXBcblxuXG4gICAgdmFyIE4gPSAyMDAwMDAwMDAwO1xuXG4gICAgdmFyIGNsZWFuTnVtID0gZnVuY3Rpb24gY2xlYW5OdW0odmFsKSB7XG4gICAgICByZXR1cm4gLTEyOCA8IHZhbCAmJiB2YWwgPCAxMjggJiYgTWF0aC5mbG9vcih2YWwpICE9PSB2YWwgPyBOIC0gKHZhbCAqIDEwMjQgfCAwKSA6IHZhbDtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BOYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcE5hbWVzW19pXTtcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gb3ZlcnJpZGRlblN0eWxlc1tuYW1lXTtcblxuICAgICAgaWYgKHBhcnNlZFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BJbmZvID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wSW5mby50eXBlO1xuICAgICAgdmFyIF9ncktleSA9IHByb3BJbmZvLmdyb3VwS2V5O1xuICAgICAgdmFyIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChwcm9wSW5mby5oYXNoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcHJvcEluZm8uaGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZFByb3AucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgICB9IC8vIG1pZ2h0IG5vdCBiZSBhIG51bWJlciBpZiBpdCBhbGxvd3MgZW51bXNcblxuXG4gICAgICB2YXIgbnVtYmVyVmFsID0gcHJvcEluZm8uZW51bXMgPT0gbnVsbCA/IHBhcnNlZFByb3AudmFsdWUgOiBudWxsO1xuICAgICAgdmFyIGhhdmVOb3JtTnVtID0gbm9ybWFsaXplZE51bWJlclZhbCAhPSBudWxsO1xuICAgICAgdmFyIGhhdmVVbml0ZWROdW0gPSBudW1iZXJWYWwgIT0gbnVsbDtcbiAgICAgIHZhciBoYXZlTnVtID0gaGF2ZU5vcm1OdW0gfHwgaGF2ZVVuaXRlZE51bTtcbiAgICAgIHZhciB1bml0cyA9IHBhcnNlZFByb3AudW5pdHM7IC8vIG51bWJlcnMgYXJlIGNoZWFwZXIgdG8gaGFzaCB0aGFuIHN0cmluZ3NcbiAgICAgIC8vIDEgaGFzaCBvcCB2cyBuIGhhc2ggb3BzIChmb3IgbGVuZ3RoIG4gc3RyaW5nKVxuXG4gICAgICBpZiAodHlwZS5udW1iZXIgJiYgaGF2ZU51bSAmJiAhdHlwZS5tdWx0aXBsZSkge1xuICAgICAgICB2YXIgdiA9IGhhdmVOb3JtTnVtID8gbm9ybWFsaXplZE51bWJlclZhbCA6IG51bWJlclZhbDtcbiAgICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG5cbiAgICAgICAgaWYgKCFoYXZlTm9ybU51bSAmJiB1bml0cyAhPSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlR3JLZXlXU3RyKHVuaXRzLCBfZ3JLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVHcktleVdTdHIocGFyc2VkUHJvcC5zdHJWYWx1ZSwgX2dyS2V5KTtcbiAgICAgIH1cbiAgICB9IC8vIG92ZXJhbGwgc3R5bGUga2V5XG4gICAgLy9cblxuXG4gICAgdmFyIGhhc2ggPSBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF07XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wR3JLZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZ3JLZXkyID0gcHJvcEdyS2V5c1tfaTJdO1xuICAgICAgdmFyIGdySGFzaCA9IF9wLnN0eWxlS2V5c1tfZ3JLZXkyXTtcbiAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGdySGFzaFswXSwgaGFzaFswXSk7XG4gICAgICBoYXNoWzFdID0gaGFzaEludEFsdChnckhhc2hbMV0sIGhhc2hbMV0pO1xuICAgIH1cblxuICAgIF9wLnN0eWxlS2V5ID0gY29tYmluZUhhc2hlcyhoYXNoWzBdLCBoYXNoWzFdKTsgLy8gbGFiZWwgZGltc1xuICAgIC8vXG5cbiAgICB2YXIgc2sgPSBfcC5zdHlsZUtleXM7XG4gICAgX3AubGFiZWxEaW1zS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgdmFyIGxhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWydsYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLmxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGxhYmVsS2V5cyk7XG4gICAgX3AubGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBsYWJlbEtleXMpKTtcblxuICAgIGlmICghaXNOb2RlKSB7XG4gICAgICB2YXIgc291cmNlTGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgICAgX3Auc291cmNlTGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoc291cmNlTGFiZWxLZXlzKTtcbiAgICAgIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgc291cmNlTGFiZWxLZXlzKSk7XG4gICAgICB2YXIgdGFyZ2V0TGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgICAgX3AudGFyZ2V0TGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkodGFyZ2V0TGFiZWxLZXlzKTtcbiAgICAgIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgdGFyZ2V0TGFiZWxLZXlzKSk7XG4gICAgfSAvLyBub2RlXG4gICAgLy9cblxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgdmFyIF9wJHN0eWxlS2V5cyA9IF9wLnN0eWxlS2V5cyxcbiAgICAgICAgICBub2RlQm9keSA9IF9wJHN0eWxlS2V5cy5ub2RlQm9keSxcbiAgICAgICAgICBub2RlQm9yZGVyID0gX3Akc3R5bGVLZXlzLm5vZGVCb3JkZXIsXG4gICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gX3Akc3R5bGVLZXlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICBjb21wb3VuZCA9IF9wJHN0eWxlS2V5cy5jb21wb3VuZCxcbiAgICAgICAgICBwaWUgPSBfcCRzdHlsZUtleXMucGllO1xuICAgICAgdmFyIG5vZGVLZXlzID0gW25vZGVCb2R5LCBub2RlQm9yZGVyLCBiYWNrZ3JvdW5kSW1hZ2UsIGNvbXBvdW5kLCBwaWVdLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPSBudWxsO1xuICAgICAgfSkucmVkdWNlKGhhc2hBcnJheXMsIFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXSk7XG4gICAgICBfcC5ub2RlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KG5vZGVLZXlzKTtcbiAgICAgIF9wLmhhc1BpZSA9IHBpZSAhPSBudWxsICYmIHBpZVswXSAhPT0gREVGQVVMVF9IQVNIX1NFRUQgJiYgcGllWzFdICE9PSBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbiAgfTtcblxuICBzdHlmbiQ4LmNsZWFyU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgX3Auc3R5bGVDeHRLZXkgPSAnJztcbiAgICBfcC5zdHlsZUtleXMgPSB7fTtcbiAgICBfcC5zdHlsZUtleSA9IG51bGw7XG4gICAgX3AubGFiZWxLZXkgPSBudWxsO1xuICAgIF9wLmxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gbnVsbDtcbiAgICBfcC5zb3VyY2VMYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgICBfcC50YXJnZXRMYWJlbEtleSA9IG51bGw7XG4gICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IG51bGw7XG4gICAgX3Aubm9kZUtleSA9IG51bGw7XG4gICAgX3AuaGFzUGllID0gbnVsbDtcbiAgfTsgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4gIC8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAvL1xuICAvLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4gIC8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuICAvLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbiAgLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuICAvLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5cblxuICBzdHlmbiQ4LmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlLCBwYXJzZWRQcm9wKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGZsYXRQcm9wO1xuICAgIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gICAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbcHJvcC5uYW1lXS50eXBlO1xuICAgIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVtwcm9wLm5hbWVdO1xuICAgIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZmxhdFByb3BNYXBwaW5nID0gJ21hcHBpbmcnO1xuXG4gICAgdmFyIGdldFZhbCA9IGZ1bmN0aW9uIGdldFZhbChwKSB7XG4gICAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChwLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcC5wZlZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHAudmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gY2hlY2tUcmlnZ2VycygpIHtcbiAgICAgIHZhciBmcm9tVmFsID0gZ2V0VmFsKG9yaWdQcm9wKTtcbiAgICAgIHZhciB0b1ZhbCA9IGdldFZhbChwcm9wKTtcbiAgICAgIHNlbGYuY2hlY2tUcmlnZ2VycyhlbGUsIHByb3AubmFtZSwgZnJvbVZhbCwgdG9WYWwpO1xuICAgIH07XG5cbiAgICBpZiAocHJvcCAmJiBwcm9wLm5hbWUuc3Vic3RyKDAsIDMpID09PSAncGllJykge1xuICAgICAgd2FybignVGhlIHBpZSBzdHlsZSBwcm9wZXJ0aWVzIGFyZSBkZXByZWNhdGVkLiAgQ3JlYXRlIGNoYXJ0cyB1c2luZyBiYWNrZ3JvdW5kIGltYWdlcyBpbnN0ZWFkLicpO1xuICAgIH0gLy8gZWRnZSBzYW5pdHkgY2hlY2tzIHRvIHByZXZlbnQgdGhlIGNsaWVudCBmcm9tIG1ha2luZyBzZXJpb3VzIG1pc3Rha2VzXG5cblxuICAgIGlmIChwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgZWxlLmlzRWRnZSgpICYmICggLy8gbG9vcHMgbXVzdCBiZSBidW5kbGVkIGJlemllcnNcbiAgICBwYXJzZWRQcm9wLnZhbHVlICE9PSAnYmV6aWVyJyAmJiBlbGUuaXNMb29wKCkgfHwgLy8gZWRnZXMgY29ubmVjdGVkIHRvIGNvbXBvdW5kIG5vZGVzIGNhbiBub3QgYmUgaGF5c3RhY2tzXG4gICAgcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2hheXN0YWNrJyAmJiAoZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCkpKSkge1xuICAgICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BbXCJkZWxldGVcIl0pIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgYW5kIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBmYWxzZXkgdmFsdWVcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcC5kZWxldGVCeXBhc3NlZCkge1xuICAgICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgLy8gZGVsZXRlIGJ5cGFzc2VkXG4gICAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgICB9XG4gICAgfSAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcblxuXG4gICAgaWYgKHByb3AuZGVsZXRlQnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGJ5cGFzc2VkIHByb3BlcnR5IHdhcyBhbHJlYWR5IGFwcGxpZWQgKGFuZCB0aGVyZWZvcmUgcGFyc2VkKSwgd2UgY2FuIGp1c3QgcmVwbGFjZSBpdCAobm8gcmVhcHBseWluZyBuZWNlc3NhcnkpXG4gICAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcbiAgICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24gcHJpbnRNYXBwaW5nRXJyKCkge1xuICAgICAgd2FybignRG8gbm90IGFzc2lnbiBtYXBwaW5ncyB0byBlbGVtZW50cyB3aXRob3V0IGNvcnJlc3BvbmRpbmcgZGF0YSAoaS5lLiBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGhhcyBubyBtYXBwaW5nIGZvciBwcm9wZXJ0eSBgJyArIHByb3AubmFtZSArICdgIHdpdGggZGF0YSBmaWVsZCBgJyArIHByb3AuZmllbGQgKyAnYCk7IHRyeSBhIGBbJyArIHByb3AuZmllbGQgKyAnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJyArIHByb3AuZmllbGQgKyAnYCBkZWZpbmVkJyk7XG4gICAgfTsgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuXG5cbiAgICBzd2l0Y2ggKHByb3AubWFwcGVkKSB7XG4gICAgICAvLyBmbGF0dGVuIHRoZSBwcm9wZXJ0eSBpZiBtYXBwZWRcbiAgICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBmaWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFtmaWVsZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpZWxkVmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwZXJjZW50O1xuXG4gICAgICAgICAgaWYgKCFudW1iZXIkMShmaWVsZFZhbCkpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgY29udGludW91cyBtYXBwZXJzIHdpdGhvdXQgc3BlY2lmeWluZyBudW1lcmljIGRhdGEgKGkuZS4gYCcgKyBwcm9wLmZpZWxkICsgJzogJyArIGZpZWxkVmFsICsgJ2AgZm9yIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBub24tbnVtZXJpYyknKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpZWxkV2lkdGggPSBwcm9wLmZpZWxkTWF4IC0gcHJvcC5maWVsZE1pbjtcblxuICAgICAgICAgICAgaWYgKGZpZWxkV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIC0tIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgYXMgbm8gcHJvcHMgb2YgemVybyByYW5nZSBzaG91bGQgYmUgcGFzc2VkIGhlcmVcbiAgICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyBmaWVsZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcblxuXG4gICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZS5jb2xvcikge1xuICAgICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICAgICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICAgICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcbiAgICAgICAgICAgIHZhciBjbHIgPSBbTWF0aC5yb3VuZChyMSArIChyMiAtIHIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogcGVyY2VudCksIE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChhMSArIChhMiAtIGExKSAqIHBlcmNlbnQpXTtcbiAgICAgICAgICAgIGZsYXRQcm9wID0ge1xuICAgICAgICAgICAgICAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsXG4gICAgICAgICAgICAgIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgdGhlIHByb3BlcnR5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGRpcmVjdCBtYXBwaW5nXG5cbiAgICAgIGNhc2UgdHlwZXMuZGF0YTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgICB2YXIgX2ZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcblxuICAgICAgICAgIHZhciBfZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgX2ZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIF9maWVsZCA9IF9maWVsZHNbX2kzXTtcbiAgICAgICAgICAgIF9maWVsZFZhbCA9IF9maWVsZFZhbFtfZmllbGRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfZmllbGRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgX2ZpZWxkVmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiBkb24ndCBhcHBseSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgICAgICAgIHZhciBmblJldFZhbCA9IHByb3AuZm5WYWx1ZSAhPSBudWxsID8gcHJvcC5mblZhbHVlIDogZm4oZWxlKTsgLy8gY2hlY2sgZm9yIGNhY2hlZCB2YWx1ZSBiZWZvcmUgY2FsbGluZyBmdW5jdGlvblxuXG4gICAgICAgICAgcHJvcC5wcmV2Rm5WYWx1ZSA9IGZuUmV0VmFsO1xuXG4gICAgICAgICAgaWYgKGZuUmV0VmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIG51bGwgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBudWxsKScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcblxuICAgICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIGludmFsaWQgdmFsdWVzIGZvciB0aGUgcHJvcGVydHkgdHlwZSAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIGludmFsaWQpJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IGNvcHkocHJvcCk7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gICAgfSAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcblxuXG4gICAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgICAgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgICAgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgc3R5Zm4kOC5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMsIGtlZXBCeXBhc3Nlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB0aGlzLmNsZWFyU3R5bGVIaW50cyhlbGUpO1xuICAgICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuXG4gICAgICBpZiAoIWtlZXBCeXBhc3Nlcykge1xuICAgICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tqXTtcbiAgICAgICAgICB2YXIgZWxlUHJvcCA9IHN0eWxlW3Byb3BOYW1lXTtcblxuICAgICAgICAgIGlmIChlbGVQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgICAgICBlbGVQcm9wLmJ5cGFzc2VkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0eWxlW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG5cblxuICBzdHlmbiQ4LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgZWxlcy51cGRhdGVTdHlsZSgpO1xuICB9OyAvLyBkaWZmUHJvcHMgOiB7IG5hbWUgPT4geyBwcmV2LCBuZXh0IH0gfVxuXG5cbiAgc3R5Zm4kOC51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChlbGUsIGRpZmZQcm9wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpLnZhbHVlO1xuICAgIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKS5wZlZhbHVlO1xuICAgIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZGVsYXknKS5wZlZhbHVlO1xuXG4gICAgaWYgKHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwKSB7XG4gICAgICB2YXIgc3R5bGUgPSB7fTsgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuXG4gICAgICB2YXIgYW55UHJldiA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBzdHlQcm9wID0gZWxlLnBzdHlsZShwcm9wKTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3BdO1xuXG4gICAgICAgIGlmICghZGlmZlByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICAgIHZhciBpbml0VmFsID0gdm9pZCAwO1xuICAgICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgICAgaWYgKCFmcm9tUHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuXG5cbiAgICAgICAgaWYgKG51bWJlciQxKGZyb21Qcm9wLnBmVmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC5wZlZhbHVlKSkge1xuICAgICAgICAgIGRpZmYgPSB0b1Byb3AucGZWYWx1ZSAtIGZyb21Qcm9wLnBmVmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG5cbiAgICAgICAgICBpbml0VmFsID0gZnJvbVByb3AucGZWYWx1ZSArIGluaXREdCAqIGRpZmY7IC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShmcm9tUHJvcC52YWx1ZSkgJiYgbnVtYmVyJDEodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcblxuICAgICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC52YWx1ZSArIGluaXREdCAqIGRpZmY7IC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmIChhcnJheShmcm9tUHJvcC52YWx1ZSkgJiYgYXJyYXkodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV0gfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXTtcbiAgICAgICAgICBpbml0VmFsID0gZnJvbVByb3Auc3RyVmFsdWU7XG4gICAgICAgIH0gLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG5cblxuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgIHN0eWxlW3Byb3BdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcblxuICAgICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBwcm9wLCBpbml0VmFsKTsgLy8gZnJvbSB2YWxcblxuICAgICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcbiAgICAgIC8vIGNhbid0IHRyYW5zaXRpb24gaWYgdGhlcmUncyBub3RoaW5nIHByZXZpb3VzIHRvIHRyYW5zaXRpb24gZnJvbVxuXG5cbiAgICAgIGlmICghYW55UHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgZWxlLmRlbGF5QW5pbWF0aW9uKGRlbGF5KS5wbGF5KCkucHJvbWlzZSgpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5hbmltYXRpb24oe1xuICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpLnZhbHVlLFxuICAgICAgICAgIHF1ZXVlOiBmYWxzZVxuICAgICAgICB9KS5wbGF5KCkucHJvbWlzZSgpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgICAgc2VsZi5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIH1cblxuICAgICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF9wLnRyYW5zaXRpb25pbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcbiAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgc3R5Zm4kOC5jaGVja1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGdldFRyaWdnZXIsIG9uVHJpZ2dlcikge1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuXG4gICAgaWYgKHRyaWdnZXJDaGVjayAhPSBudWxsICYmIHRyaWdnZXJDaGVjayhmcm9tVmFsdWUsIHRvVmFsdWUpKSB7XG4gICAgICBvblRyaWdnZXIocHJvcCk7XG4gICAgfVxuICB9O1xuXG4gIHN0eWZuJDguY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AudHJpZ2dlcnNaT3JkZXI7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX3ByaXZhdGUuY3kubm90aWZ5KCd6b3JkZXInLCBlbGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHN0eWZuJDguY2hlY2tCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gICAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc0JvdW5kcztcbiAgICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpOyAvLyBpZiB0aGUgcHJvcCBjaGFuZ2UgbWFrZXMgdGhlIGJiIG9mIHBsbCBiZXppZXIgZWRnZXMgaW52YWxpZCxcbiAgICAgIC8vIHRoZW4gZGlydHkgdGhlIHBsbCBlZGdlIGJiIGNhY2hlIGFzIHdlbGxcblxuICAgICAgaWYgKCAvLyBvbmx5IGZvciBiZXppZXJzIC0tIHNvIHBlcmZvcm1hbmNlIG9mIG90aGVyIGVkZ2VzIGlzbid0IGFmZmVjdGVkXG4gICAgICBwcm9wLnRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnMgJiYgKG5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgKGZyb21WYWx1ZSA9PT0gJ2JlemllcicgfHwgdG9WYWx1ZSA9PT0gJ2JlemllcicpIHx8IG5hbWUgPT09ICdkaXNwbGF5JyAmJiAoZnJvbVZhbHVlID09PSAnbm9uZScgfHwgdG9WYWx1ZSA9PT0gJ25vbmUnKSkpIHtcbiAgICAgICAgZWxlLnBhcmFsbGVsRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwbGxFZGdlKSB7XG4gICAgICAgICAgaWYgKHBsbEVkZ2UuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBzdHlmbiQ4LmNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICBlbGUuZGlydHlTdHlsZUNhY2hlKCk7XG4gICAgdGhpcy5jaGVja1pPcmRlclRyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgIHRoaXMuY2hlY2tCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgfTtcblxuICB2YXIgc3R5Zm4kNyA9IHt9OyAvLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbiAgLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcblxuICBzdHlmbiQ3LmFwcGx5QnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlOyAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG5cbiAgICBpZiAobmFtZSA9PT0gJyonIHx8IG5hbWUgPT09ICcqKicpIHtcbiAgICAgIC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKF9uYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocGFyc2VkUHJvcCkge1xuICAgICAgICAgICAgcHJvcHMucHVzaChwYXJzZWRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgICB2YXIgX3BhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKF9wYXJzZWRQcm9wKSB7XG4gICAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgIC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzcGVjaWZpZWRQcm9wcyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9uYW1lMiA9IG5hbWVzW19pXTtcbiAgICAgICAgdmFyIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW19uYW1lMl07XG5cbiAgICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgICBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tkYXNoMmNhbWVsKF9uYW1lMildO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9wYXJzZWRQcm9wMiA9IHRoaXMucGFyc2UoX25hbWUyLCBfdmFsdWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKF9wYXJzZWRQcm9wMikge1xuICAgICAgICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcblxuXG4gICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gbm93LCBhcHBseSB0aGUgYnlwYXNzIHByb3BlcnRpZXMgb24gdGhlIGVsZW1lbnRzXG5cblxuICAgIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAvLyBmb3IgZWFjaCBlbGVcbiAgICAgIHZhciBlbGUgPSBlbGVzW19pMl07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgICB2YXIgZGlmZlByb3AgPSB2b2lkIDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgICB2YXIgX3Byb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzW19wcm9wLm5hbWVdID0ge1xuICAgICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY29weShfcHJvcCkpIHx8IHJldDtcblxuICAgICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcblxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTsgLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cblxuXG4gIHN0eWZuJDcub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtuYW1lXTtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdLnR5cGU7XG4gICAgICB2YXIgaXNDb2xvciA9IHR5cGUuY29sb3I7XG4gICAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9ICFwcm9wID8gbnVsbCA6IHByb3AucGZWYWx1ZSAhPSBudWxsID8gcHJvcC5wZlZhbHVlIDogcHJvcC52YWx1ZTtcblxuICAgICAgaWYgKCFwcm9wIHx8ICFwcm9wLmJ5cGFzcykge1xuICAgICAgICAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICAgIHByb3Auc3RyVmFsdWUgPSAncmdiKCcgKyB2YWx1ZS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgIHByb3Auc3RyVmFsdWUgPSB2YWx1ZS5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja1RyaWdnZXJzKGVsZSwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgc3R5Zm4kNy5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZXMsIHRoaXMucHJvcGVydHlOYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICB9O1xuXG4gIHN0eWZuJDcucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgICAgICBpZiAoIXByZXZQcm9wIHx8ICFwcmV2UHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICAvLyBpZiBhIGJ5cGFzcyBkb2Vzbid0IGV4aXN0IGZvciB0aGUgcHJvcCwgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wLm5hbWVdID0ge1xuICAgICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcblxuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlbGVzXG5cbiAgfTtcblxuICB2YXIgc3R5Zm4kNiA9IHt9OyAvLyBnZXRzIHdoYXQgYW4gZW0gc2l6ZSBjb3JyZXNwb25kcyB0byBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gYSBkb20gZWxlbWVudFxuXG4gIHN0eWZuJDYuZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuXG4gICAgaWYgKHB4ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHB4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7IC8vIGZvciBoZWFkbGVzc1xuICAgIH1cbiAgfTsgLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcblxuXG4gIHN0eWZuJDYuY29udGFpbmVyQ3NzID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuXG4gICAgaWYgKHdpbmRvdyQxICYmIGRvbUVsZW1lbnQgJiYgd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgcmV0dXJuIHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdHlmbiQ1ID0ge307IC8vIGdldHMgdGhlIHJlbmRlcmVkIHN0eWxlIGZvciBhbiBlbGVtZW50XG5cbiAgc3R5Zm4kNS5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcCkge1xuICAgIGlmIChwcm9wKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoZWxlLCB0cnVlKTtcbiAgICB9XG4gIH07IC8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG5cbiAgc3R5Zm4kNS5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgcnN0eWxlID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gc2VsZi5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwpO1xuXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgIHJzdHlsZVtwcm9wLm5hbWVdID0gdmFsO1xuICAgICAgICAgIHJzdHlsZVtkYXNoMmNhbWVsKHByb3AubmFtZSldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByc3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIHN0eWZuJDUuZ2V0SW5kZXhlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcGVydHksIHN1YnByb3BlcnR5LCBpbmRleCkge1xuICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICAgIHJldHVybiBwc3R5bGUgIT0gbnVsbCA/IHBzdHlsZSA6IGVsZS5jeSgpLnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1bMF07XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgaWYgKHByb3AuYWxpYXMpIHtcbiAgICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3AudmFsdWUsXG4gICAgICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgICAgIHN0clZhbHVlID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICAgIGlmIChpc1JlbmRlcmVkVmFsICYmIHR5cGUubnVtYmVyICYmIHZhbHVlICE9IG51bGwgJiYgbnVtYmVyJDEodmFsdWUpKSB7XG4gICAgICAgICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICAgICAgICB2YXIgZ2V0UmVuZGVyZWRWYWx1ZSA9IGZ1bmN0aW9uIGdldFJlbmRlcmVkVmFsdWUodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICogem9vbTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzID0gZnVuY3Rpb24gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsLCB1bml0cykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlbmRlcmVkVmFsdWUodmFsKSArIHVuaXRzO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgaXNBcnJheVZhbHVlID0gYXJyYXkodmFsdWUpO1xuICAgICAgICAgIHZhciBoYXZlVW5pdHMgPSBpc0FycmF5VmFsdWUgPyB1bml0cy5ldmVyeShmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgcmV0dXJuIHUgIT0gbnVsbDtcbiAgICAgICAgICB9KSA6IHVuaXRzICE9IG51bGw7XG5cbiAgICAgICAgICBpZiAoaGF2ZVVuaXRzKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModiwgdW5pdHNbaV0pO1xuICAgICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsdWUsIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZyh2KSA/IHYgOiAnJyArIGdldFJlbmRlcmVkVmFsdWUodik7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJyArIGdldFJlbmRlcmVkVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBzdHlmbiQ1LmdldEFuaW1hdGlvblN0YXJ0U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBhbmlQcm9wcykge1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmlQcm9wID0gYW5pUHJvcHNbaV07XG4gICAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcbiAgICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKG5hbWUpO1xuXG4gICAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBtYWtlIGEgcHJvcCBvZiBpdFxuICAgICAgICBpZiAocGxhaW5PYmplY3Qoc3R5bGVQcm9wKSkge1xuICAgICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHN0eWxlUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgICByc3R5bGVbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfTtcblxuICBzdHlmbiQ1LmdldFByb3BzTGlzdCA9IGZ1bmN0aW9uIChwcm9wc09iaikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcnN0eWxlID0gW107XG4gICAgdmFyIHN0eWxlID0gcHJvcHNPYmo7XG4gICAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHN0eWxlW25hbWVdO1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVdIHx8IHByb3BzW2NhbWVsMmRhc2gobmFtZSldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHZhbCk7XG5cbiAgICAgICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9O1xuXG4gIHN0eWZuJDUuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWVzLCBzZWVkKSB7XG4gICAgdmFyIGhhc2ggPSBzZWVkLnNsaWNlKCk7XG4gICAgdmFyIG5hbWUsIHZhbCwgc3RyVmFsLCBjaFZhbDtcbiAgICB2YXIgaSwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgICB2YWwgPSBlbGUucHN0eWxlKG5hbWUsIGZhbHNlKTtcblxuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh2YWwucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyVmFsID0gdmFsLnN0clZhbHVlO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjaFZhbCA9IHN0clZhbC5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgICAgICBoYXNoWzFdID0gaGFzaEludEFsdChjaFZhbCwgaGFzaFsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICBzdHlmbiQ1LmdldFByb3BlcnRpZXNIYXNoID0gc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2g7XG5cbiAgdmFyIHN0eWZuJDQgPSB7fTtcblxuICBzdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgc3R5bGUuY3NzKG5hbWUsIHZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07IC8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuXG5cbiAgc3R5Zm4kNC5mcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICAgIHN0eWxlLmFwcGVuZEZyb21Kc29uKGpzb24pO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTsgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuXG5cbiAgc3R5Zm4kNC5qc29uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBqc29uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjeHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICAgIHZhciBjc3MgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICBjc3NbcHJvcC5uYW1lXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGpzb24ucHVzaCh7XG4gICAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgICBzdHlsZTogY3NzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxuICB2YXIgc3R5Zm4kMyA9IHt9O1xuXG4gIHN0eWZuJDMuYXBwZW5kRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gICAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICAgIHZhciBibG9ja1JlbTtcbiAgICB2YXIgcHJvcEFuZFZhbFN0cjsgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuXG4gICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoc2VsQW5kQmxvY2tTdHIubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgcHJvcGVydHkgYW5kIHZhbHVlIGZyb20gdGhlIHJlbWFpbmluZyBibG9jayB0ZXh0IHRvIHBhcnNlXG4gICAgICBpZiAoYmxvY2tSZW0ubGVuZ3RoID4gcHJvcEFuZFZhbFN0ci5sZW5ndGgpIHtcbiAgICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcblxuICAgICAgaWYgKG5vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgICBpZiAoIXNlbEFuZEJsb2NrKSB7XG4gICAgICAgIHdhcm4oJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTsgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG5cbiAgICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuXG4gICAgICBpZiAoc2VsZWN0b3JTdHIgIT09ICdjb3JlJykge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rvci5pbnZhbGlkKSB7XG4gICAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBzZWxlY3RvciBmb3VuZCBpbiBzdHJpbmcgc3R5bGVzaGVldDogJyArIHNlbGVjdG9yU3RyKTsgLy8gc2tpcCB0aGlzIHNlbGVjdG9yIGFuZCBibG9ja1xuXG4gICAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXG5cbiAgICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBfbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgICAgIGlmIChfbm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPykoPzpcXHMqO3xcXHMqJCkvKTtcblxuICAgICAgICBpZiAoIXByb3BBbmRWYWwpIHtcbiAgICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIGZvcm1hdHRpbmcgb2Ygc3R5bGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlZmluaXRpb25zIGZvdW5kIGluOicgKyBibG9ja1N0cik7XG4gICAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICAgIHZhciB2YWxTdHIgPSBwcm9wQW5kVmFsWzJdO1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wU3RyXTtcblxuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7IC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcblxuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKHByb3BTdHIsIHZhbFN0cik7XG5cbiAgICAgICAgaWYgKCFwYXJzZWRQcm9wKSB7XG4gICAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIpOyAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG5cbiAgICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRCbG9jaykge1xuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuXG5cbiAgICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgc3R5bGUuY3NzKF9wcm9wLm5hbWUsIF9wcm9wLnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICBzdHlmbiQzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICAgIHN0eWxlLmFwcGVuZEZyb21TdHJpbmcoc3RyaW5nKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgdmFyIHN0eWZuJDIgPSB7fTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBudW1iZXIkMSA9IG51bWJlcjtcbiAgICB2YXIgcmdiYSA9IHJnYmFOb0JhY2tSZWZzO1xuICAgIHZhciBoc2xhID0gaHNsYU5vQmFja1JlZnM7XG4gICAgdmFyIGhleDMkMSA9IGhleDM7XG4gICAgdmFyIGhleDYkMSA9IGhleDY7XG5cbiAgICB2YXIgZGF0YSA9IGZ1bmN0aW9uIGRhdGEocHJlZml4KSB7XG4gICAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJztcbiAgICB9O1xuXG4gICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiBtYXBEYXRhKHByZWZpeCkge1xuICAgICAgdmFyIG1hcEFyZyA9IG51bWJlciQxICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyQxICsgJ3wnICsgaGV4NiQxO1xuICAgICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gICAgfTtcblxuICAgIHZhciB1cmxSZWdleGVzID0gWydedXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKSQnLCAnXihub25lKSQnLCAnXiguKykkJ107IC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcblxuICAgIHN0eWZuJDIudHlwZXMgPSB7XG4gICAgICB0aW1lOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICB1bml0czogJ3N8bXMnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAnbXMnXG4gICAgICB9LFxuICAgICAgcGVyY2VudDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgIHVuaXRzOiAnJScsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICclJ1xuICAgICAgfSxcbiAgICAgIHBlcmNlbnRhZ2VzOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgdW5pdHM6ICclJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJyUnLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHplcm9PbmVOdW1iZXI6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICAgIH0sXG4gICAgICB6ZXJvT25lTnVtYmVyczoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBuT25lT25lTnVtYmVyOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAtMSxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICB1bml0bGVzczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG5vbk5lZ2F0aXZlSW50OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgICB1bml0bGVzczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXVxuICAgICAgfSxcbiAgICAgIG5vZGVTaXplOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBlbnVtczogWydsYWJlbCddXG4gICAgICB9LFxuICAgICAgbnVtYmVyOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICAgIH0sXG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9zaXRpdmVOdW1iZXI6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBzdHJpY3RNaW46IHRydWVcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwXG4gICAgICB9LFxuICAgICAgYmlkaXJlY3Rpb25hbFNpemU6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgICBiaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICAgIHNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGF4aXNEaXJlY3Rpb246IHtcbiAgICAgICAgZW51bXM6IFsnaG9yaXpvbnRhbCcsICdsZWZ0d2FyZCcsICdyaWdodHdhcmQnLCAndmVydGljYWwnLCAndXB3YXJkJywgJ2Rvd253YXJkJywgJ2F1dG8nXVxuICAgICAgfSxcbiAgICAgIHBhZGRpbmdSZWxhdGl2ZVRvOiB7XG4gICAgICAgIGVudW1zOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdhdmVyYWdlJywgJ21pbicsICdtYXgnXVxuICAgICAgfSxcbiAgICAgIGJnV0g6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgICAgZW51bXM6IFsnYXV0byddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnUG9zOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnUmVsYXRpdmVUbzoge1xuICAgICAgICBlbnVtczogWydpbm5lcicsICdpbmNsdWRlLXBhZGRpbmcnXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ1JlcGVhdDoge1xuICAgICAgICBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdGaXQ6IHtcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICdjb250YWluJywgJ2NvdmVyJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdDcm9zc09yaWdpbjoge1xuICAgICAgICBlbnVtczogWydhbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJywgJ251bGwnXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ0NsaXA6IHtcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICdub2RlJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdDb250YWlubWVudDoge1xuICAgICAgICBlbnVtczogWydpbnNpZGUnLCAnb3ZlciddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbG9yOiB0cnVlXG4gICAgICB9LFxuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZpbGw6IHtcbiAgICAgICAgZW51bXM6IFsnc29saWQnLCAnbGluZWFyLWdyYWRpZW50JywgJ3JhZGlhbC1ncmFkaWVudCddXG4gICAgICB9LFxuICAgICAgYm9vbDoge1xuICAgICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXVxuICAgICAgfSxcbiAgICAgIGJvb2xzOiB7XG4gICAgICAgIGVudW1zOiBbJ3llcycsICdubyddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJ11cbiAgICAgIH0sXG4gICAgICBsaW5lQ2FwOiB7XG4gICAgICAgIGVudW1zOiBbJ2J1dHQnLCAncm91bmQnLCAnc3F1YXJlJ11cbiAgICAgIH0sXG4gICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZSddXG4gICAgICB9LFxuICAgICAgY3VydmVTdHlsZToge1xuICAgICAgICBlbnVtczogWydiZXppZXInLCAndW5idW5kbGVkLWJlemllcicsICdoYXlzdGFjaycsICdzZWdtZW50cycsICdzdHJhaWdodCcsICdzdHJhaWdodC10cmlhbmdsZScsICd0YXhpJ11cbiAgICAgIH0sXG4gICAgICBmb250RmFtaWx5OiB7XG4gICAgICAgIHJlZ2V4OiAnXihbXFxcXHctIFxcXFxcIl0rKD86XFxcXHMqLFxcXFxzKltcXFxcdy0gXFxcXFwiXSspKikkJ1xuICAgICAgfSxcbiAgICAgIGZvbnRTdHlsZToge1xuICAgICAgICBlbnVtczogWydpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnXVxuICAgICAgfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHtcbiAgICAgICAgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdXG4gICAgICB9LFxuICAgICAgdGV4dERlY29yYXRpb246IHtcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJ11cbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhbnNmb3JtOiB7XG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZSddXG4gICAgICB9LFxuICAgICAgdGV4dFdyYXA6IHtcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICd3cmFwJywgJ2VsbGlwc2lzJ11cbiAgICAgIH0sXG4gICAgICB0ZXh0T3ZlcmZsb3dXcmFwOiB7XG4gICAgICAgIGVudW1zOiBbJ3doaXRlc3BhY2UnLCAnYW55d2hlcmUnXVxuICAgICAgfSxcbiAgICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHtcbiAgICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZSddXG4gICAgICB9LFxuICAgICAgbm9kZVNoYXBlOiB7XG4gICAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnY3V0cmVjdGFuZ2xlJywgJ2N1dC1yZWN0YW5nbGUnLCAnYm90dG9tcm91bmRyZWN0YW5nbGUnLCAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsICdiYXJyZWwnLCAnZWxsaXBzZScsICd0cmlhbmdsZScsICdyb3VuZC10cmlhbmdsZScsICdzcXVhcmUnLCAncGVudGFnb24nLCAncm91bmQtcGVudGFnb24nLCAnaGV4YWdvbicsICdyb3VuZC1oZXhhZ29uJywgJ2NvbmNhdmVoZXhhZ29uJywgJ2NvbmNhdmUtaGV4YWdvbicsICdoZXB0YWdvbicsICdyb3VuZC1oZXB0YWdvbicsICdvY3RhZ29uJywgJ3JvdW5kLW9jdGFnb24nLCAndGFnJywgJ3JvdW5kLXRhZycsICdzdGFyJywgJ2RpYW1vbmQnLCAncm91bmQtZGlhbW9uZCcsICd2ZWUnLCAncmhvbWJvaWQnLCAncG9seWdvbiddXG4gICAgICB9LFxuICAgICAgb3ZlcmxheVNoYXBlOiB7XG4gICAgICAgIGVudW1zOiBbJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdlbGxpcHNlJ11cbiAgICAgIH0sXG4gICAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHtcbiAgICAgICAgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ11cbiAgICAgIH0sXG4gICAgICBhcnJvd1NoYXBlOiB7XG4gICAgICAgIGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAnY2lyY2xlLXRyaWFuZ2xlJywgJ3RyaWFuZ2xlLWNyb3NzJywgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsICd2ZWUnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ2NoZXZyb24nLCAnbm9uZSddXG4gICAgICB9LFxuICAgICAgYXJyb3dGaWxsOiB7XG4gICAgICAgIGVudW1zOiBbJ2ZpbGxlZCcsICdob2xsb3cnXVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgZW51bXM6IFsnZWxlbWVudCcsICdub25lJ11cbiAgICAgIH0sXG4gICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgIGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ11cbiAgICAgIH0sXG4gICAgICB6Q29tcG91bmREZXB0aDoge1xuICAgICAgICBlbnVtczogWydib3R0b20nLCAnb3JwaGFuJywgJ2F1dG8nLCAndG9wJ11cbiAgICAgIH0sXG4gICAgICB6SW5kZXhDb21wYXJlOiB7XG4gICAgICAgIGVudW1zOiBbJ2F1dG8nLCAnbWFudWFsJ11cbiAgICAgIH0sXG4gICAgICB2YWxpZ246IHtcbiAgICAgICAgZW51bXM6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXVxuICAgICAgfSxcbiAgICAgIGhhbGlnbjoge1xuICAgICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddXG4gICAgICB9LFxuICAgICAganVzdGlmaWNhdGlvbjoge1xuICAgICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdhdXRvJ11cbiAgICAgIH0sXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIHN0cmluZzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IGRhdGEoJ2RhdGEnKVxuICAgICAgfSxcbiAgICAgIGxheW91dERhdGE6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKVxuICAgICAgfSxcbiAgICAgIHNjcmF0Y2g6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IGRhdGEoJ3NjcmF0Y2gnKVxuICAgICAgfSxcbiAgICAgIG1hcERhdGE6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKVxuICAgICAgfSxcbiAgICAgIG1hcExheW91dERhdGE6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKVxuICAgICAgfSxcbiAgICAgIG1hcFNjcmF0Y2g6IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcFNjcmF0Y2gnKVxuICAgICAgfSxcbiAgICAgIGZuOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIGZuOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXJsOiB7XG4gICAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVybHM6IHtcbiAgICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHByb3BMaXN0OiB7XG4gICAgICAgIHByb3BMaXN0OiB0cnVlXG4gICAgICB9LFxuICAgICAgYW5nbGU6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJ1xuICAgICAgfSxcbiAgICAgIHRleHRSb3RhdGlvbjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnLFxuICAgICAgICBlbnVtczogWydub25lJywgJ2F1dG9yb3RhdGUnXVxuICAgICAgfSxcbiAgICAgIHBvbHlnb25Qb2ludExpc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgZXZlbk11bHRpcGxlOiB0cnVlLFxuICAgICAgICBtaW46IC0xLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgICB9LFxuICAgICAgZWRnZURpc3RhbmNlczoge1xuICAgICAgICBlbnVtczogWydpbnRlcnNlY3Rpb24nLCAnbm9kZS1wb3NpdGlvbiddXG4gICAgICB9LFxuICAgICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgICAgZW51bXM6IFsnaW5zaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcsICdvdXRzaWRlLXRvLWxpbmUnLCAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJ10sXG4gICAgICAgIHNpbmdsZUVudW06IHRydWUsXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWxBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIGNhbiBiZSAlIG9yIHB4IG9ubHlcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzQXJyWzBdICE9PSAnZGVnJyAmJiB1bml0c0FyclswXSAhPT0gJ3JhZCcgJiYgdW5pdHNBcnJbMV0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzFdICE9PSAncmFkJztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAvLyBjYW4gYmUgZW51bSwgZGVnLCBvciByYWQgb25seVxuICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKHZhbEFyclswXSkgfHwgdW5pdHNBcnJbMF0gPT09ICdkZWcnIHx8IHVuaXRzQXJyWzBdID09PSAncmFkJztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVhc2luZzoge1xuICAgICAgICByZWdleGVzOiBbJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCcsICdeKGN1YmljLWJlemllcilcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCddLFxuICAgICAgICBlbnVtczogWydsaW5lYXInLCAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JywgJ2Vhc2UtaW4tc2luZScsICdlYXNlLW91dC1zaW5lJywgJ2Vhc2UtaW4tb3V0LXNpbmUnLCAnZWFzZS1pbi1xdWFkJywgJ2Vhc2Utb3V0LXF1YWQnLCAnZWFzZS1pbi1vdXQtcXVhZCcsICdlYXNlLWluLWN1YmljJywgJ2Vhc2Utb3V0LWN1YmljJywgJ2Vhc2UtaW4tb3V0LWN1YmljJywgJ2Vhc2UtaW4tcXVhcnQnLCAnZWFzZS1vdXQtcXVhcnQnLCAnZWFzZS1pbi1vdXQtcXVhcnQnLCAnZWFzZS1pbi1xdWludCcsICdlYXNlLW91dC1xdWludCcsICdlYXNlLWluLW91dC1xdWludCcsICdlYXNlLWluLWV4cG8nLCAnZWFzZS1vdXQtZXhwbycsICdlYXNlLWluLW91dC1leHBvJywgJ2Vhc2UtaW4tY2lyYycsICdlYXNlLW91dC1jaXJjJywgJ2Vhc2UtaW4tb3V0LWNpcmMnXVxuICAgICAgfSxcbiAgICAgIGdyYWRpZW50RGlyZWN0aW9uOiB7XG4gICAgICAgIGVudW1zOiBbJ3RvLWJvdHRvbScsICd0by10b3AnLCAndG8tbGVmdCcsICd0by1yaWdodCcsICd0by1ib3R0b20tcmlnaHQnLCAndG8tYm90dG9tLWxlZnQnLCAndG8tdG9wLXJpZ2h0JywgJ3RvLXRvcC1sZWZ0JywgJ3RvLXJpZ2h0LWJvdHRvbScsICd0by1sZWZ0LWJvdHRvbScsICd0by1yaWdodC10b3AnLCAndG8tbGVmdC10b3AnIC8vIGRpZmZlcmVudCBvcmRlclxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgYm91bmRzRXhwYW5zaW9uOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbEFycikge1xuICAgICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBsZW5ndGggPT09IDEgfHwgbGVuZ3RoID09PSAyIHx8IGxlbmd0aCA9PT0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRpZmYgPSB7XG4gICAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgICBpZiAoKHZhbDEgPT0gbnVsbCB8fCB2YWwyID09IG51bGwpICYmIHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbnVsbCBjYXNlcyBjb3VsZCByZXByZXNlbnQgYW55IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsMSA9PSAwICYmIHZhbDIgIT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbDEgIT0gMCAmJiB2YWwyID09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbnk6IGZ1bmN0aW9uIGFueSh2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiB2YWwxICE9IHZhbDI7XG4gICAgICB9LFxuICAgICAgZW1wdHlOb25FbXB0eTogZnVuY3Rpb24gZW1wdHlOb25FbXB0eShzdHIxLCBzdHIyKSB7XG4gICAgICAgIHZhciBlbXB0eTEgPSBlbXB0eVN0cmluZyhzdHIxKTtcbiAgICAgICAgdmFyIGVtcHR5MiA9IGVtcHR5U3RyaW5nKHN0cjIpO1xuICAgICAgICByZXR1cm4gZW1wdHkxICYmICFlbXB0eTIgfHwgIWVtcHR5MSAmJiBlbXB0eTI7XG4gICAgICB9XG4gICAgfTsgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgLy9cbiAgICAvLyAtIG4uYi4gYWRkaW5nIGEgbmV3IGdyb3VwIG9mIHByb3BzIG1heSByZXF1aXJlIHVwZGF0ZXMgdG8gdXBkYXRlU3R5bGVIaW50cygpXG4gICAgLy8gLSBhZGRpbmcgbmV3IHByb3BzIHRvIGFuIGV4aXN0aW5nIGdyb3VwIGdldHMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5XG5cbiAgICB2YXIgdCA9IHN0eWZuJDIudHlwZXM7XG4gICAgdmFyIG1haW5MYWJlbCA9IFt7XG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgdHlwZTogdC50ZXh0LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuZW1wdHlOb25FbXB0eVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LXJvdGF0aW9uJyxcbiAgICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtbWFyZ2luLXgnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi15JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgc291cmNlTGFiZWwgPSBbe1xuICAgICAgbmFtZTogJ3NvdXJjZS1sYWJlbCcsXG4gICAgICB0eXBlOiB0LnRleHQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLXRleHQtcm90YXRpb24nLFxuICAgICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teScsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS10ZXh0LW9mZnNldCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgdGFyZ2V0TGFiZWwgPSBbe1xuICAgICAgbmFtZTogJ3RhcmdldC1sYWJlbCcsXG4gICAgICB0eXBlOiB0LnRleHQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LXRleHQtcm90YXRpb24nLFxuICAgICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teScsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC10ZXh0LW9mZnNldCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgbGFiZWxEaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6ICdmb250LWZhbWlseScsXG4gICAgICB0eXBlOiB0LmZvbnRGYW1pbHksXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgICB0eXBlOiB0LmZvbnRTdHlsZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmb250LXdlaWdodCcsXG4gICAgICB0eXBlOiB0LmZvbnRXZWlnaHQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZm9udC1zaXplJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsXG4gICAgICB0eXBlOiB0LnRleHRUcmFuc2Zvcm0sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC13cmFwJyxcbiAgICAgIHR5cGU6IHQudGV4dFdyYXAsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1vdmVyZmxvdy13cmFwJyxcbiAgICAgIHR5cGU6IHQudGV4dE92ZXJmbG93V3JhcCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWhlaWdodCcsXG4gICAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIGNvbW1vbkxhYmVsID0gW3tcbiAgICAgIG5hbWU6ICd0ZXh0LXZhbGlnbicsXG4gICAgICB0eXBlOiB0LnZhbGlnbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWhhbGlnbicsXG4gICAgICB0eXBlOiB0LmhhbGlnbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJyxcbiAgICAgIHR5cGU6IHQuYm9yZGVyU3R5bGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJyxcbiAgICAgIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWp1c3RpZmljYXRpb24nLFxuICAgICAgdHlwZTogdC5qdXN0aWZpY2F0aW9uXG4gICAgfV07XG4gICAgdmFyIGJlaGF2aW9yID0gW3tcbiAgICAgIG5hbWU6ICdldmVudHMnLFxuICAgICAgdHlwZTogdC5ib29sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtZXZlbnRzJyxcbiAgICAgIHR5cGU6IHQuYm9vbFxuICAgIH1dO1xuICAgIHZhciB2aXNpYmlsaXR5ID0gW3tcbiAgICAgIG5hbWU6ICdkaXNwbGF5JyxcbiAgICAgIHR5cGU6IHQuZGlzcGxheSxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnM6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndmlzaWJpbGl0eScsXG4gICAgICB0eXBlOiB0LnZpc2liaWxpdHksXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi56ZXJvTm9uWmVyb1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJyxcbiAgICAgIHR5cGU6IHQuc2l6ZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJyxcbiAgICAgIHR5cGU6IHQuekNvbXBvdW5kRGVwdGgsXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnei1pbmRleC1jb21wYXJlJyxcbiAgICAgIHR5cGU6IHQuekluZGV4Q29tcGFyZSxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd6LWluZGV4JyxcbiAgICAgIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQsXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgb3ZlcmxheSA9IFt7XG4gICAgICBuYW1lOiAnb3ZlcmxheS1wYWRkaW5nJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvdmVybGF5LWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLnplcm9Ob25aZXJvXG4gICAgfSwge1xuICAgICAgbmFtZTogJ292ZXJsYXktc2hhcGUnLFxuICAgICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgdW5kZXJsYXkgPSBbe1xuICAgICAgbmFtZTogJ3VuZGVybGF5LXBhZGRpbmcnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3VuZGVybGF5LWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndW5kZXJsYXktb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi56ZXJvTm9uWmVyb1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd1bmRlcmxheS1zaGFwZScsXG4gICAgICB0eXBlOiB0Lm92ZXJsYXlTaGFwZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciB0cmFuc2l0aW9uID0gW3tcbiAgICAgIG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JyxcbiAgICAgIHR5cGU6IHQucHJvcExpc3RcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsXG4gICAgICB0eXBlOiB0LnRpbWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsXG4gICAgICB0eXBlOiB0LnRpbWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAgICAgdHlwZTogdC5lYXNpbmdcbiAgICB9XTtcblxuICAgIHZhciBub2RlU2l6ZUhhc2hPdmVycmlkZSA9IGZ1bmN0aW9uIG5vZGVTaXplSGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCkge1xuICAgICAgaWYgKHBhcnNlZFByb3AudmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgcmV0dXJuIC1lbGUucG9vbEluZGV4KCk7IC8vIG5vIGhhc2gga2V5IGhpdHMgaXMgdXNpbmcgbGFiZWwgc2l6ZSAoaGl0cmF0ZSBmb3IgcGVyZiBwcm9iYWJseSBsb3cgYW55d2F5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG5vZGVCb2R5ID0gW3tcbiAgICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnd2lkdGgnLFxuICAgICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2hhcGUnLFxuICAgICAgdHlwZTogdC5ub2RlU2hhcGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLFxuICAgICAgdHlwZTogdC5wb2x5Z29uUG9pbnRMaXN0LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpbGwnLFxuICAgICAgdHlwZTogdC5maWxsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJyxcbiAgICAgIHR5cGU6IHQubk9uZU9uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICAgIHR5cGU6IHQuY29sb3JzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgICAgdHlwZTogdC5wZXJjZW50YWdlc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicsXG4gICAgICB0eXBlOiB0LmdyYWRpZW50RGlyZWN0aW9uXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmctcmVsYXRpdmUtdG8nLFxuICAgICAgdHlwZTogdC5wYWRkaW5nUmVsYXRpdmVUbyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdib3VuZHMtZXhwYW5zaW9uJyxcbiAgICAgIHR5cGU6IHQuYm91bmRzRXhwYW5zaW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIG5vZGVCb3JkZXIgPSBbe1xuICAgICAgbmFtZTogJ2JvcmRlci1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JvcmRlci1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdib3JkZXItd2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JvcmRlci1zdHlsZScsXG4gICAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gICAgfV07XG4gICAgdmFyIGJhY2tncm91bmRJbWFnZSA9IFt7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsXG4gICAgICB0eXBlOiB0LnVybHNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsXG4gICAgICB0eXBlOiB0LmJnQ3Jvc3NPcmlnaW5cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCcsXG4gICAgICB0eXBlOiB0LmJnQ29udGFpbm1lbnRcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnLFxuICAgICAgdHlwZTogdC5ib29sc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLFxuICAgICAgdHlwZTogdC5iZ1Bvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLFxuICAgICAgdHlwZTogdC5iZ1Bvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJyxcbiAgICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJyxcbiAgICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgICAgIHR5cGU6IHQuYmdSZXBlYXRcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1maXQnLFxuICAgICAgdHlwZTogdC5iZ0ZpdFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNsaXAnLFxuICAgICAgdHlwZTogdC5iZ0NsaXBcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsXG4gICAgICB0eXBlOiB0LmJnV0hcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLFxuICAgICAgdHlwZTogdC5iZ1dIXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXgnLFxuICAgICAgdHlwZTogdC5iZ1Bvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC15JyxcbiAgICAgIHR5cGU6IHQuYmdQb3NcbiAgICB9XTtcbiAgICB2YXIgY29tcG91bmQgPSBbe1xuICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgIHR5cGU6IHQucG9zaXRpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLFxuICAgICAgdHlwZTogdC5jb21wb3VuZEluY2x1ZGVMYWJlbHMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1sZWZ0JyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLWhlaWdodCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLXRvcCcsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgZWRnZUxpbmUgPSBbe1xuICAgICAgbmFtZTogJ2xpbmUtc3R5bGUnLFxuICAgICAgdHlwZTogdC5saW5lU3R5bGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtZmlsbCcsXG4gICAgICB0eXBlOiB0LmZpbGxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1jYXAnLFxuICAgICAgdHlwZTogdC5saW5lQ2FwXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1kYXNoLXBhdHRlcm4nLFxuICAgICAgdHlwZTogdC5udW1iZXJzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtZGFzaC1vZmZzZXQnLFxuICAgICAgdHlwZTogdC5udW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgICB0eXBlOiB0LmNvbG9yc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY3VydmUtc3R5bGUnLFxuICAgICAgdHlwZTogdC5jdXJ2ZVN0eWxlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVyczogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsXG4gICAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtZW5kcG9pbnQnLFxuICAgICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsXG4gICAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2VnbWVudC1kaXN0YW5jZXMnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJyxcbiAgICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXhpLXR1cm4nLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXhpLWRpcmVjdGlvbicsXG4gICAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLFxuICAgICAgdHlwZTogdC5lZGdlRGlzdGFuY2VzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Fycm93LXNjYWxlJyxcbiAgICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbG9vcC1kaXJlY3Rpb24nLFxuICAgICAgdHlwZTogdC5hbmdsZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsb29wLXN3ZWVwJyxcbiAgICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgZ2hvc3QgPSBbe1xuICAgICAgbmFtZTogJ2dob3N0JyxcbiAgICAgIHR5cGU6IHQuYm9vbCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteCcsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2dob3N0LW9mZnNldC15JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZ2hvc3Qtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9XTtcbiAgICB2YXIgY29yZSA9IFt7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2FjdGl2ZS1iZy1zaXplJyxcbiAgICAgIHR5cGU6IHQuc2l6ZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9XTsgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuXG4gICAgdmFyIHBpZSA9IFtdO1xuICAgIHN0eWZuJDIucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG5cbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLXNpemUnLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgIHBpZS5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgIHR5cGU6IHQuY29sb3JcbiAgICAgIH0pO1xuICAgICAgcGllLnB1c2goe1xuICAgICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICAgIH0pO1xuICAgICAgcGllLnB1c2goe1xuICAgICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICAgIH0pO1xuICAgIH0gLy8gZWRnZSBhcnJvd3NcblxuXG4gICAgdmFyIGVkZ2VBcnJvdyA9IFtdO1xuICAgIHZhciBhcnJvd1ByZWZpeGVzID0gc3R5Zm4kMi5hcnJvd1ByZWZpeGVzID0gWydzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCddO1xuICAgIFt7XG4gICAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgICAgdHlwZTogdC5hcnJvd1NoYXBlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgICB0eXBlOiB0LmFycm93RmlsbFxuICAgIH1dLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdHlwZSA9IHByb3AudHlwZSxcbiAgICAgICAgICAgIHRyaWdnZXJzQm91bmRzID0gcHJvcC50cmlnZ2Vyc0JvdW5kcztcbiAgICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB7fSk7XG4gICAgdmFyIHByb3BzID0gc3R5Zm4kMi5wcm9wZXJ0aWVzID0gW10uY29uY2F0KGJlaGF2aW9yLCB0cmFuc2l0aW9uLCB2aXNpYmlsaXR5LCBvdmVybGF5LCB1bmRlcmxheSwgZ2hvc3QsIGNvbW1vbkxhYmVsLCBsYWJlbERpbWVuc2lvbnMsIG1haW5MYWJlbCwgc291cmNlTGFiZWwsIHRhcmdldExhYmVsLCBub2RlQm9keSwgbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBwaWUsIGNvbXBvdW5kLCBlZGdlTGluZSwgZWRnZUFycm93LCBjb3JlKTtcbiAgICB2YXIgcHJvcEdyb3VwcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cHMgPSB7XG4gICAgICAvLyBjb21tb24gdG8gYWxsIGVsZXNcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvcixcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuICAgICAgb3ZlcmxheTogb3ZlcmxheSxcbiAgICAgIHVuZGVybGF5OiB1bmRlcmxheSxcbiAgICAgIGdob3N0OiBnaG9zdCxcbiAgICAgIC8vIGxhYmVsc1xuICAgICAgY29tbW9uTGFiZWw6IGNvbW1vbkxhYmVsLFxuICAgICAgbGFiZWxEaW1lbnNpb25zOiBsYWJlbERpbWVuc2lvbnMsXG4gICAgICBtYWluTGFiZWw6IG1haW5MYWJlbCxcbiAgICAgIHNvdXJjZUxhYmVsOiBzb3VyY2VMYWJlbCxcbiAgICAgIHRhcmdldExhYmVsOiB0YXJnZXRMYWJlbCxcbiAgICAgIC8vIG5vZGUgcHJvcHNcbiAgICAgIG5vZGVCb2R5OiBub2RlQm9keSxcbiAgICAgIG5vZGVCb3JkZXI6IG5vZGVCb3JkZXIsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGJhY2tncm91bmRJbWFnZSxcbiAgICAgIHBpZTogcGllLFxuICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgZWRnZUxpbmU6IGVkZ2VMaW5lLFxuICAgICAgZWRnZUFycm93OiBlZGdlQXJyb3csXG4gICAgICBjb3JlOiBjb3JlXG4gICAgfTtcbiAgICB2YXIgcHJvcEdyb3VwTmFtZXMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBOYW1lcyA9IHt9O1xuICAgIHZhciBwcm9wR3JvdXBLZXlzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwS2V5cyA9IE9iamVjdC5rZXlzKHByb3BHcm91cHMpO1xuICAgIHByb3BHcm91cEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBwcm9wR3JvdXBOYW1lc1trZXldID0gcHJvcEdyb3Vwc1trZXldLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcC5uYW1lO1xuICAgICAgfSk7XG4gICAgICBwcm9wR3JvdXBzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcC5ncm91cEtleSA9IGtleTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBkZWZpbmUgYWxpYXNlc1xuXG4gICAgdmFyIGFsaWFzZXMgPSBzdHlmbiQyLmFsaWFzZXMgPSBbe1xuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcG9pbnRzVG86ICdsYWJlbCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsXG4gICAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsXG4gICAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJyxcbiAgICAgIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZy1sZWZ0JyxcbiAgICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZy1yaWdodCcsXG4gICAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmctdG9wJyxcbiAgICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZy1ib3R0b20nLFxuICAgICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICAgIH1dOyAvLyBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG5cbiAgICBzdHlmbiQyLnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwLm5hbWU7XG4gICAgfSk7IC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuIHN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbX2ldO1xuICAgICAgcHJvcHNbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gICAgfSAvLyBtYXAgYWxpYXNlc1xuXG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhbGlhc2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbX2kyXTtcbiAgICAgIHZhciBwb2ludHNUb1Byb3AgPSBwcm9wc1thbGlhcy5wb2ludHNUb107XG4gICAgICB2YXIgYWxpYXNQcm9wID0ge1xuICAgICAgICBuYW1lOiBhbGlhcy5uYW1lLFxuICAgICAgICBhbGlhczogdHJ1ZSxcbiAgICAgICAgcG9pbnRzVG86IHBvaW50c1RvUHJvcFxuICAgICAgfTsgLy8gYWRkIGFsaWFzIHByb3AgZm9yIHBhcnNpbmdcblxuICAgICAgcHJvcHMucHVzaChhbGlhc1Byb3ApO1xuICAgICAgcHJvcHNbYWxpYXMubmFtZV0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gICAgfVxuICB9KSgpO1xuXG4gIHN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcygpW25hbWVdO1xuICB9O1xuXG4gIHN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5kZWZhdWx0UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgdmFyIHJhd1Byb3BzID0gZXh0ZW5kKHtcbiAgICAgIC8vIGNvcmUgcHJvcHNcbiAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjUsXG4gICAgICAvLyBjb21tb24gbm9kZS9lZGdlIHByb3BzXG4gICAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICAgJ3RleHQtdmFsaWduJzogJ3RvcCcsXG4gICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICd0ZXh0LWp1c3RpZmljYXRpb24nOiAnYXV0bycsXG4gICAgICAnbGluZS1oZWlnaHQnOiAxLFxuICAgICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICd0ZXh0LW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICdub25lJyxcbiAgICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgICAndGV4dC1vdmVyZmxvdy13cmFwJzogJ3doaXRlc3BhY2UnLFxuICAgICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAwLFxuICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogMCxcbiAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAgICdmb250LXdlaWdodCc6ICdub3JtYWwnLFxuICAgICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAgICd0ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgJ3RhcmdldC10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICd6LWNvbXBvdW5kLWRlcHRoJzogJ2F1dG8nLFxuICAgICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAgICd6LWluZGV4JzogMCxcbiAgICAgICdsYWJlbCc6ICcnLFxuICAgICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICAgJ3RleHQtbWFyZ2luLXknOiAwLFxuICAgICAgJ3NvdXJjZS1sYWJlbCc6ICcnLFxuICAgICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgICAnc291cmNlLXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAwLFxuICAgICAgJ3RhcmdldC10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAgICdvdmVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgJ292ZXJsYXktc2hhcGUnOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAgICd1bmRlcmxheS1vcGFjaXR5JzogMCxcbiAgICAgICd1bmRlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICd1bmRlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAndW5kZXJsYXktc2hhcGUnOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuICAgICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG4gICAgICAvLyBub2RlIHByb3BzXG4gICAgICAnYmFja2dyb3VuZC1ibGFja2VuJzogMCxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICAgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsXG4gICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAgICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknOiAxLFxuICAgICAgJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnOiAnaW5zaWRlJyxcbiAgICAgICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZyc6ICd5ZXMnLFxuICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICAgJ2JhY2tncm91bmQtb2Zmc2V0LXgnOiAwLFxuICAgICAgJ2JhY2tncm91bmQtb2Zmc2V0LXknOiAwLFxuICAgICAgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAgICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnYXV0bycsXG4gICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAnaGVpZ2h0JzogMzAsXG4gICAgICAnd2lkdGgnOiAzMCxcbiAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG4gICAgICAnYm91bmRzLWV4cGFuc2lvbic6IDAsXG4gICAgICAvLyBub2RlIGdyYWRpZW50XG4gICAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nOiAndG8tYm90dG9tJyxcbiAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgICAgLy8gZ2hvc3QgcHJvcHNcbiAgICAgICdnaG9zdCc6ICdubycsXG4gICAgICAnZ2hvc3Qtb2Zmc2V0LXknOiAwLFxuICAgICAgJ2dob3N0LW9mZnNldC14JzogMCxcbiAgICAgICdnaG9zdC1vcGFjaXR5JzogMCxcbiAgICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgICAncGFkZGluZyc6IDAsXG4gICAgICAncGFkZGluZy1yZWxhdGl2ZS10byc6ICd3aWR0aCcsXG4gICAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcbiAgICAgICdtaW4td2lkdGgnOiAwLFxuICAgICAgJ21pbi13aWR0aC1iaWFzLWxlZnQnOiAwLFxuICAgICAgJ21pbi13aWR0aC1iaWFzLXJpZ2h0JzogMCxcbiAgICAgICdtaW4taGVpZ2h0JzogMCxcbiAgICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogMCxcbiAgICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogMFxuICAgIH0sIHtcbiAgICAgIC8vIG5vZGUgcGllIGJnXG4gICAgICAncGllLXNpemUnOiAnMTAwJSdcbiAgICB9LCBbe1xuICAgICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIHZhbHVlOiAnYmxhY2snXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgdmFsdWU6ICcwJSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB2YWx1ZTogMVxuICAgIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9LCB7fSksIHtcbiAgICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAgICdsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICdsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICAgJ2xpbmUtZmlsbCc6ICdzb2xpZCcsXG4gICAgICAnbGluZS1jYXAnOiAnYnV0dCcsXG4gICAgICAnbGluZS1vcGFjaXR5JzogMSxcbiAgICAgICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAgICdzZWdtZW50LWRpc3RhbmNlcyc6IDIwLFxuICAgICAgJ3RheGktdHVybic6ICc1MCUnLFxuICAgICAgJ3RheGktdHVybi1taW4tZGlzdGFuY2UnOiAxMCxcbiAgICAgICd0YXhpLWRpcmVjdGlvbic6ICdhdXRvJyxcbiAgICAgICdlZGdlLWRpc3RhbmNlcyc6ICdpbnRlcnNlY3Rpb24nLFxuICAgICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJyxcbiAgICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLFxuICAgICAgJ2Fycm93LXNjYWxlJzogMSxcbiAgICAgICdsb29wLWRpcmVjdGlvbic6ICctNDVkZWcnLFxuICAgICAgJ2xvb3Atc3dlZXAnOiAnLTkwZGVnJyxcbiAgICAgICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAgICdsaW5lLWRhc2gtcGF0dGVybic6IFs2LCAzXSxcbiAgICAgICdsaW5lLWRhc2gtb2Zmc2V0JzogMFxuICAgIH0sIFt7XG4gICAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgICAgdmFsdWU6ICdub25lJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgICB2YWx1ZTogJyM5OTknXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgICAgdmFsdWU6ICdmaWxsZWQnXG4gICAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICAgIHN0eWZuJDIuYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwge30pKTtcbiAgICB2YXIgcGFyc2VkUHJvcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tpXTtcblxuICAgICAgaWYgKHByb3AucG9pbnRzVG8pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbCA9IHJhd1Byb3BzW25hbWVdO1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbCk7XG4gICAgICBwYXJzZWRQcm9wc1tuYW1lXSA9IHBhcnNlZFByb3A7XG4gICAgfVxuXG4gICAgX3AuZGVmYXVsdFByb3BlcnRpZXMgPSBwYXJzZWRQcm9wcztcbiAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gIH07XG5cbiAgc3R5Zm4kMi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlbGVjdG9yKCc6cGFyZW50JykuY3NzKHtcbiAgICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgJ3BhZGRpbmcnOiAxMCxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNlZWUnLFxuICAgICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAgICdib3JkZXItd2lkdGgnOiAxXG4gICAgfSkuc2VsZWN0b3IoJ2VkZ2UnKS5jc3Moe1xuICAgICAgJ3dpZHRoJzogM1xuICAgIH0pLnNlbGVjdG9yKCc6bG9vcCcpLmNzcyh7XG4gICAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJ1xuICAgIH0pLnNlbGVjdG9yKCdlZGdlOmNvbXBvdW5kJykuY3NzKHtcbiAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnLFxuICAgICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnXG4gICAgfSkuc2VsZWN0b3IoJzpzZWxlY3RlZCcpLmNzcyh7XG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICdsaW5lLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknXG4gICAgfSkuc2VsZWN0b3IoJzpwYXJlbnQ6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0NDRTFGOScsXG4gICAgICAnYm9yZGVyLWNvbG9yJzogJyNhZWM4ZTUnXG4gICAgfSkuc2VsZWN0b3IoJzphY3RpdmUnKS5jc3Moe1xuICAgICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgICB9KTtcbiAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgc3R5Zm4kMSA9IHt9OyAvLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcblxuICBzdHlmbiQxLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGZ1bmN0aW9uIHZhbHVlcyBjYW4ndCBiZSBjYWNoZWQgaW4gYWxsIGNhc2VzLCBhbmQgdGhlcmUgaXNuJ3QgbXVjaCBiZW5lZml0IG9mIGNhY2hpbmcgdGhlbSBhbnl3YXlcblxuICAgIGlmIChmbiQ2KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgICB9XG5cbiAgICB2YXIgZmxhdEtleSA9IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyB8fCBwcm9wSXNGbGF0ID09PSB0cnVlIHx8IHByb3BJc0ZsYXQgPT09IGZhbHNlIHx8IHByb3BJc0ZsYXQgPT0gbnVsbCA/ICdkb250Y2FyZScgOiBwcm9wSXNGbGF0O1xuICAgIHZhciBieXBhc3NLZXkgPSBwcm9wSXNCeXBhc3MgPyAndCcgOiAnZic7XG4gICAgdmFyIHZhbHVlS2V5ID0gJycgKyB2YWx1ZTtcbiAgICB2YXIgYXJnSGFzaCA9IGhhc2hTdHJpbmdzKG5hbWUsIHZhbHVlS2V5LCBieXBhc3NLZXksIGZsYXRLZXkpO1xuICAgIHZhciBwcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlIHx8IFtdO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoIShyZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0pKSB7XG4gICAgICByZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0gPSBzZWxmLnBhcnNlSW1wbFdhcm4obmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gICAgfSAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG5cblxuICAgIGlmIChwcm9wSXNCeXBhc3MgfHwgcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnKSB7XG4gICAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgICByZXQgPSBjb3B5KHJldCk7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0LnZhbHVlID0gY29weShyZXQudmFsdWUpOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgc3R5Zm4kMS5wYXJzZUltcGxXYXJuID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuXG4gICAgaWYgKCFwcm9wICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHdhcm4oXCJUaGUgc3R5bGUgcHJvcGVydHkgYFwiLmNvbmNhdChuYW1lLCBcIjogXCIpLmNvbmNhdCh2YWx1ZSwgXCJgIGlzIGludmFsaWRcIikpO1xuICAgIH1cblxuICAgIGlmIChwcm9wICYmIChwcm9wLm5hbWUgPT09ICd3aWR0aCcgfHwgcHJvcC5uYW1lID09PSAnaGVpZ2h0JykgJiYgdmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHdhcm4oJ1RoZSBzdHlsZSB2YWx1ZSBvZiBgbGFiZWxgIGlzIGRlcHJlY2F0ZWQgZm9yIGAnICsgcHJvcC5uYW1lICsgJ2AnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfTsgLy8gcGFyc2UgYSBwcm9wZXJ0eTsgcmV0dXJuIG51bGwgb24gaW52YWxpZDsgcmV0dXJuIHBhcnNlZCBwcm9wZXJ0eSBvdGhlcndpc2VcbiAgLy8gZmllbGRzIDpcbiAgLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gIC8vIC0gdmFsdWUgOiB0aGUgcGFyc2VkLCBuYXRpdmUtdHlwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gIC8vIC0gc3RyVmFsdWUgOiBhIHN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IHZhbHVlIGluIHZhbGlkIGNzc1xuICAvLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuXG5cbiAgc3R5Zm4kMS5wYXJzZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIHZhciBwYXNzZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuXG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBjYW4ndCBhc3NpZ24gdW5kZWZpbmVkXG4gICAgLy8gdGhlIHByb3BlcnR5IG1heSBiZSBhbiBhbGlhc1xuXG5cbiAgICBpZiAocHJvcGVydHkuYWxpYXMpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVJc1N0cmluZyA9IHN0cmluZyh2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIG5vIHR5cGUsIG5vIGx1Y2tcbiAgICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuXG5cbiAgICBpZiAocHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgICB9O1xuICAgIH0gLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG5cblxuICAgIGlmIChmbiQ2KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcblxuXG4gICAgdmFyIGRhdGEsIG1hcERhdGE7XG5cbiAgICBpZiAoIXZhbHVlSXNTdHJpbmcgfHwgcHJvcElzRmxhdCB8fCB2YWx1ZS5sZW5ndGggPCA3IHx8IHZhbHVlWzFdICE9PSAnYScpIDsgZWxzZSBpZiAodmFsdWUubGVuZ3RoID49IDcgJiYgdmFsdWVbMF0gPT09ICdkJyAmJiAoZGF0YSA9IG5ldyBSZWdFeHAodHlwZXMuZGF0YS5yZWdleCkuZXhlYyh2YWx1ZSkpKSB7XG4gICAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuXG4gICAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cblxuICAgICAgdmFyIF9tYXBwZWQgPSB0eXBlcy5tYXBEYXRhOyAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcblxuICAgICAgaWYgKCEodHlwZS5jb2xvciB8fCB0eXBlLm51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVNaW4gPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNF0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuXG4gICAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cblxuICAgICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgICAgaWYgKCF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuXG5cbiAgICAgIGlmICh2YWx1ZU1pbi5wZlZhbHVlID09PSB2YWx1ZU1heC5wZlZhbHVlIHx8IHZhbHVlTWluLnN0clZhbHVlID09PSB2YWx1ZU1heC5zdHJWYWx1ZSkge1xuICAgICAgICB3YXJuKCdgJyArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSB2YWxpZCBtYXBwZXIgYmVjYXVzZSB0aGUgb3V0cHV0IHJhbmdlIGlzIHplcm87IGNvbnZlcnRpbmcgdG8gYCcgKyBuYW1lICsgJzogJyArIHZhbHVlTWluLnN0clZhbHVlICsgJ2AnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UobmFtZSwgdmFsdWVNaW4uc3RyVmFsdWUpOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuICAgICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAgICYmICggLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgfHwgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICAgKSAmJiAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc2FtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBtYXBEYXRhLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgICAgZmllbGRNaW46IHBhcnNlRmxvYXQobWFwRGF0YVsyXSksXG4gICAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgICBmaWVsZE1heDogcGFyc2VGbG9hdChtYXBEYXRhWzNdKSxcbiAgICAgICAgdmFsdWVNaW46IHZhbHVlTWluLnZhbHVlLFxuICAgICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScpIHtcbiAgICAgIHZhciB2YWxzO1xuXG4gICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICB2YWxzID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHMgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5ldmVuTXVsdGlwbGUgJiYgdmFscy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsQXJyID0gW107XG4gICAgICB2YXIgdW5pdHNBcnIgPSBbXTtcbiAgICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgICAgdmFyIHN0clZhbCA9ICcnO1xuICAgICAgdmFyIGhhc0VudW0gPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gc2VsZi5wYXJzZShuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScpO1xuICAgICAgICBoYXNFbnVtID0gaGFzRW51bSB8fCBzdHJpbmcocC52YWx1ZSk7XG4gICAgICAgIHZhbEFyci5wdXNoKHAudmFsdWUpO1xuICAgICAgICBwZlZhbEFyci5wdXNoKHAucGZWYWx1ZSAhPSBudWxsID8gcC5wZlZhbHVlIDogcC52YWx1ZSk7XG4gICAgICAgIHVuaXRzQXJyLnB1c2gocC51bml0cyk7XG4gICAgICAgIHN0clZhbCArPSAoaSA+IDAgPyAnICcgOiAnJykgKyBwLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS52YWxpZGF0ZSAmJiAhdHlwZS52YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUuc2luZ2xlRW51bSAmJiBoYXNFbnVtKSB7XG4gICAgICAgIGlmICh2YWxBcnIubGVuZ3RoID09PSAxICYmIHN0cmluZyh2YWxBcnJbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgICBwZlZhbHVlOiBwZlZhbEFycixcbiAgICAgICAgc3RyVmFsdWU6IHN0clZhbCxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIHVuaXRzOiB1bml0c0FyclxuICAgICAgfTtcbiAgICB9IC8vIHNldmVyYWwgdHlwZXMgYWxzbyBhbGxvdyBlbnVtc1xuXG5cbiAgICB2YXIgY2hlY2tFbnVtcyA9IGZ1bmN0aW9uIGNoZWNrRW51bXMoKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tfaV07XG5cbiAgICAgICAgaWYgKGVuID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTsgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG5cblxuICAgIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgdmFyIHVuaXRzO1xuICAgICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICAgIGlmICh0eXBlLnVuaXRzKSB7XG4gICAgICAgIC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUudW5pdGxlc3MpIHtcbiAgICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcblxuICAgICAgICAgIGlmICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICAgIH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcblxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goJ14oJyArIG51bWJlciArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyk7XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpOyAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG5cbiAgICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG5cblxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICAgIH0gLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG5cblxuICAgICAgaWYgKHR5cGUuaW50ZWdlciAmJiAhaW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuXG5cbiAgICAgIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA8IHR5cGUubWluIHx8IHR5cGUuc3RyaWN0TWluICYmIHZhbHVlID09PSB0eXBlLm1pbikgfHwgdHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPiB0eXBlLm1heCB8fCB0eXBlLnN0cmljdE1heCAmJiB2YWx1ZSA9PT0gdHlwZS5tYXgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcblxuICAgICAgaWYgKHR5cGUudW5pdGxlc3MgfHwgdW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpIHtcbiAgICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gdmFsdWUgOiB0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZTtcbiAgICAgIH0gLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG5cblxuICAgICAgaWYgKHVuaXRzID09PSAnbXMnIHx8IHVuaXRzID09PSAncycpIHtcbiAgICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgICAgfSAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcmFkXG5cblxuICAgICAgaWYgKHVuaXRzID09PSAnZGVnJyB8fCB1bml0cyA9PT0gJ3JhZCcpIHtcbiAgICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3JhZCcgPyB2YWx1ZSA6IGRlZzJyYWQodmFsdWUpO1xuICAgICAgfSAvLyBub3JtYWxpemUgdmFsdWUgaW4gJVxuXG5cbiAgICAgIGlmICh1bml0cyA9PT0gJyUnKSB7XG4gICAgICAgIHJldC5wZlZhbHVlID0gdmFsdWUgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlLnByb3BMaXN0KSB7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICAgIGlmIChwcm9wc1N0ciA9PT0gJ25vbmUnKSA7IGVsc2Uge1xuICAgICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuICAgICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KC9cXHMqLFxccyp8XFxzKy8pO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BzU3BsaXQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbX2kyXS50cmltKCk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgcHJvcHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oJ2AnICsgcHJvcE5hbWUgKyAnYCBpcyBub3QgYSB2YWxpZCBwcm9wZXJ0eSBuYW1lJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJyAnKSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICB2YXIgdHVwbGUgPSBjb2xvcjJ0dXBsZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghdHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgICAgcGZWYWx1ZTogdHVwbGUsXG4gICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyB0dXBsZVswXSArICcsJyArIHR1cGxlWzFdICsgJywnICsgdHVwbGVbMl0gKyAnKScsXG4gICAgICAgIC8vIG4uYi4gbm8gc3BhY2VzIGIvYyBvZiBtdWx0aXBsZSBzdXBwb3J0XG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMpIHtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGVudW1zXG4gICAgICBpZiAodHlwZS5lbnVtcykge1xuICAgICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG5cbiAgICAgICAgaWYgKGVudW1Qcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIGVudW1Qcm9wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdleGVzID0gdHlwZS5yZWdleGVzID8gdHlwZS5yZWdleGVzIDogW3R5cGUucmVnZXhdO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByZWdleGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleGVzW19pM10pOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZSBzdHJpbmdcblxuICAgICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHR5cGUuc2luZ2xlUmVnZXhNYXRjaFZhbHVlID8gbVsxXSA6IG0sXG4gICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuICAgIH0gZWxzZSBpZiAodHlwZS5zdHJpbmcpIHtcbiAgICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZS5lbnVtcykge1xuICAgICAgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICAgIH1cbiAgfTtcblxuICB2YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShjeSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkpIHtcbiAgICAgIHJldHVybiBuZXcgU3R5bGUoY3kpO1xuICAgIH1cblxuICAgIGlmICghY29yZShjeSkpIHtcbiAgICAgIGVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGNvcmVTdHlsZToge31cbiAgICB9O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG4gIH07XG5cbiAgdmFyIHN0eWZuID0gU3R5bGUucHJvdG90eXBlO1xuXG4gIHN0eWZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnc3R5bGUnO1xuICB9OyAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG5cblxuICBzdHlmbi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgX3AuY29udGV4dFN0eWxlcyA9IHt9O1xuICAgIF9wLnByb3BEaWZmcyA9IHt9O1xuICAgIHRoaXMuY2xlYW5FbGVtZW50cyhlbGVzLCB0cnVlKTtcbiAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIGVsZV9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgICAgZWxlX3Auc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICBlbGVfcC5hcHBsaWVkSW5pdFN0eWxlID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5cblxuICBzdHlmbi5jb3JlID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BOYW1lXSB8fCB0aGlzLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wTmFtZSk7XG4gIH07IC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcblxuXG4gIHN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gICAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvclN0ciA9PT0gJ2NvcmUnID8gbnVsbCA6IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcblxuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgICAgaW5kZXg6IGlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9OyAvLyBhZGQgb25lIG9yIG1hbnkgY3NzIHJ1bGVzIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcblxuXG4gIHN0eWZuLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIG1hcFZhbCA9IG1hcFtwcm9wLm5hbWVdO1xuXG4gICAgICAgIGlmIChtYXBWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1hcFZhbCA9IG1hcFtkYXNoMmNhbWVsKHByb3AubmFtZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jc3NSdWxlKHByb3AubmFtZSwgbWFwVmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuY3NzUnVsZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICB9IC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBzdHlmbi5zdHlsZSA9IHN0eWZuLmNzczsgLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcblxuICBzdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSk7IC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcblxuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXNbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eS5tYXBwZWQpIHtcbiAgICAgICAgdGhpc1tpXS5tYXBwZWRQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgfSAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcblxuXG4gICAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG5cbiAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JJc0NvcmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBzdHlmbi5hcHBlbmQgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICAgIHN0eWxlLmFwcGVuZFRvU3R5bGUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICAgIHRoaXMuYXBwZW5kRnJvbUpzb24oc3R5bGUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgICAgdGhpcy5hcHBlbmRGcm9tU3RyaW5nKHN0eWxlKTtcbiAgICB9IC8vIHlvdSBwcm9iYWJseSB3b3VsZG4ndCB3YW50IHRvIGFwcGVuZCBhIFN0eWxlLCBzaW5jZSB5b3UnZCBkdXBsaWNhdGUgdGhlIGRlZmF1bHQgcGFydHNcblxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIHN0YXRpYyBmdW5jdGlvblxuXG5cbiAgU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoY3ksIGpzb24pIHtcbiAgICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoY3kpO1xuICAgIHN0eWxlLmZyb21Kc29uKGpzb24pO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICBTdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGN5LCBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlKGN5KS5mcm9tU3RyaW5nKHN0cmluZyk7XG4gIH07XG5cbiAgW3N0eWZuJDgsIHN0eWZuJDcsIHN0eWZuJDYsIHN0eWZuJDUsIHN0eWZuJDQsIHN0eWZuJDMsIHN0eWZuJDIsIHN0eWZuJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKHN0eWZuLCBwcm9wcyk7XG4gIH0pO1xuICBTdHlsZS50eXBlcyA9IHN0eWZuLnR5cGVzO1xuICBTdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4ucHJvcGVydGllcztcbiAgU3R5bGUucHJvcGVydHlHcm91cHMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwcztcbiAgU3R5bGUucHJvcGVydHlHcm91cE5hbWVzID0gc3R5Zm4ucHJvcGVydHlHcm91cE5hbWVzO1xuICBTdHlsZS5wcm9wZXJ0eUdyb3VwS2V5cyA9IHN0eWZuLnByb3BlcnR5R3JvdXBLZXlzO1xuXG4gIHZhciBjb3JlZm4kMiA9IHtcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmV3U3R5bGUpIHtcbiAgICAgIGlmIChuZXdTdHlsZSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUobmV3U3R5bGUpO1xuICAgICAgICBzLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgICB9LFxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbUpzb24odGhpcywgc3R5bGUpO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC5zdHlsZSA9IFN0eWxlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Auc3R5bGU7XG4gICAgfSxcbiAgICAvLyBlLmcuIGN5LmRhdGEoKSBjaGFuZ2VkID0+IHJlY2FsYyBlbGUgbWFwcGVyc1xuICAgIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZSgpIHtcbiAgICAgIHRoaXMubXV0YWJsZUVsZW1lbnRzKCkudXBkYXRlU3R5bGUoKTsgLy8ganVzdCBzZW5kIHRvIGFsbCBlbGVzXG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0U2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xuICB2YXIgY29yZWZuJDEgPSB7XG4gICAgYXV0b2xvY2s6IGZ1bmN0aW9uIGF1dG9sb2NrKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvbG9jayA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbiBhdXRvdW5ncmFiaWZ5KGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiBhdXRvdW5zZWxlY3RpZnkoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZShzZWxUeXBlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoX3Auc2VsZWN0aW9uVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBkZWZhdWx0U2VsZWN0aW9uVHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2VsVHlwZSA9PT0gJ2FkZGl0aXZlJyB8fCBzZWxUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3Auc2VsZWN0aW9uVHlwZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gcGFubmluZ0VuYWJsZWQoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB6b29taW5nRW5hYmxlZChib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB1c2VyWm9vbWluZ0VuYWJsZWQoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24gYm94U2VsZWN0aW9uRW5hYmxlZChib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHBhbjogZnVuY3Rpb24gcGFuKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIC8vIC5wYW4oKVxuICAgICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChzdHJpbmcoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIC8vIC5wYW4oJ3gnKVxuICAgICAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgICAgIHJldHVybiBwYW5bZGltXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIkMSh4KSkge1xuICAgICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIkMSh5KSkge1xuICAgICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBpbnZhbGlkXG4gICAgICB9XG5cbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHBsYWluT2JqZWN0KGFyZzApKSB7XG4gICAgICAgICAgICAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIkMSh4KSkge1xuICAgICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLy8gLnBhbkJ5KCd4JywgMTAwKVxuICAgICAgICAgIGRpbSA9IGFyZzA7XG4gICAgICAgICAgdmFsID0gYXJnMTtcblxuICAgICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBpbnZhbGlkXG4gICAgICB9XG5cbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBmaXQ6IGZ1bmN0aW9uIGZpdChlbGVtZW50cywgcGFkZGluZykge1xuICAgICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKTtcblxuICAgICAgaWYgKHZpZXdwb3J0U3RhdGUpIHtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHpvb20gdmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uIGdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgICBpZiAobnVtYmVyJDEoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmI7XG5cbiAgICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQoc2VsKTtcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRpbmdCb3goZWxlbWVudHMpKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYlxuICAgICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICAgIGJiID0ge1xuICAgICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICAgIHkyOiBiYmUueTJcbiAgICAgICAgfTtcbiAgICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgJiYgZWxlbWVudHMuZW1wdHkoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNhbid0IGZpdCB0byBub3RoaW5nXG5cblxuICAgICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICB2YXIgem9vbTtcbiAgICAgIHBhZGRpbmcgPSBudW1iZXIkMShwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgICBpZiAoIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmIGJiLncgPiAwICYmIGJiLmggPiAwKSB7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbigodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCk7IC8vIGNyb3Agem9vbVxuXG4gICAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuICAgICAgICB2YXIgcGFuID0ge1xuICAgICAgICAgIC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgIHBhbjogcGFuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIHpvb21SYW5nZTogZnVuY3Rpb24gem9vbVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBtaW47XG4gICAgICAgIG1pbiA9IG9wdHMubWluO1xuICAgICAgICBtYXggPSBvcHRzLm1heDtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlciQxKG1pbikgJiYgbnVtYmVyJDEobWF4KSAmJiBtaW4gPD0gbWF4KSB7XG4gICAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1pbikgJiYgbWF4ID09PSB1bmRlZmluZWQgJiYgbWluIDw9IF9wLm1heFpvb20pIHtcbiAgICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWF4KSAmJiBtaW4gPT09IHVuZGVmaW5lZCAmJiBtYXggPj0gX3AubWluWm9vbSkge1xuICAgICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG1pblpvb206IGZ1bmN0aW9uIG1pblpvb20oem9vbSkge1xuICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5taW5ab29tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgICBtaW46IHpvb21cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgICAgbWF4OiB6b29tXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Wm9vbWVkVmlld3BvcnQ6IGZ1bmN0aW9uIGdldFpvb21lZFZpZXdwb3J0KHBhcmFtcykge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBjdXJyZW50UGFuID0gX3AucGFuO1xuICAgICAgdmFyIGN1cnJlbnRab29tID0gX3Auem9vbTtcbiAgICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG5cbiAgICAgIHZhciB6b29tO1xuICAgICAgdmFyIGJhaWwgPSBmYWxzZTtcblxuICAgICAgaWYgKCFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgICAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgICAgIGJhaWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyJDEocGFyYW1zKSkge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgICB6b29tID0gcGFyYW1zO1xuICAgICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICAgIHpvb20gPSBwYXJhbXMubGV2ZWw7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocGFyYW1zLnBvc2l0aW9uLCBjdXJyZW50Wm9vbSwgY3VycmVudFBhbik7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyAhPSBudWxsICYmICFfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjcm9wIHpvb21cblxuXG4gICAgICB6b29tID0gem9vbSA+IF9wLm1heFpvb20gPyBfcC5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgX3AubWluWm9vbSA/IF9wLm1pblpvb20gOiB6b29tOyAvLyBjYW4ndCB6b29tIHdpdGggaW52YWxpZCBwYXJhbXNcblxuICAgICAgaWYgKGJhaWwgfHwgIW51bWJlciQxKHpvb20pIHx8IHpvb20gPT09IGN1cnJlbnRab29tIHx8IHBvcyAhPSBudWxsICYmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgICAgdmFyIHBhbjEgPSBjdXJyZW50UGFuO1xuICAgICAgICB2YXIgem9vbTEgPSBjdXJyZW50Wm9vbTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgICAgcGFubmVkOiB0cnVlLFxuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgICAgcGFubmVkOiBmYWxzZSxcbiAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgIHBhbjogY3VycmVudFBhblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24gem9vbShwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldFxuICAgICAgICB2YXIgdnAgPSB0aGlzLmdldFpvb21lZFZpZXdwb3J0KHBhcmFtcyk7XG4gICAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Auem9vbSA9IHZwLnpvb207XG5cbiAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgIF9wLnBhbi54ID0gdnAucGFuLng7XG4gICAgICAgICAgX3AucGFuLnkgPSB2cC5wYW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnem9vbScgKyAodnAucGFubmVkID8gJyBwYW4nIDogJycpICsgJyB2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3cG9ydDogZnVuY3Rpb24gdmlld3BvcnQob3B0cykge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgICB2YXIgZXZlbnRzID0gW107IC8vIHRvIHRyaWdnZXJcblxuICAgICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW51bWJlciQxKG9wdHMuem9vbSkpIHtcbiAgICAgICAgem9vbURlZmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwbGFpbk9iamVjdChvcHRzLnBhbikpIHtcbiAgICAgICAgcGFuRGVmZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXpvb21EZWZkICYmICFwYW5EZWZkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoem9vbURlZmQpIHtcbiAgICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgICAgaWYgKHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9wLnpvb20gPSB6O1xuICAgICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgICBpZiAobnVtYmVyJDEocC54KSkge1xuICAgICAgICAgIF9wLnBhbi54ID0gcC54O1xuICAgICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlciQxKHAueSkpIHtcbiAgICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFuRmFpbGVkKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50cy5qb2luKCcgJykpO1xuICAgICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBjZW50ZXI6IGZ1bmN0aW9uIGNlbnRlcihlbGVtZW50cykge1xuICAgICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKGVsZW1lbnRzKTtcblxuICAgICAgaWYgKHBhbikge1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgZ2V0Q2VudGVyUGFuOiBmdW5jdGlvbiBnZXRDZW50ZXJQYW4oZWxlbWVudHMsIHpvb20pIHtcbiAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNhbid0IGNlbnRyZSBwYW4gdG8gbm90aGluZ1xuXG5cbiAgICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgLy8gbWlkZGxlXG4gICAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgICAgfTtcbiAgICAgIHJldHVybiBwYW47XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld3BvcnQoe1xuICAgICAgICBwYW46IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgem9vbTogMVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuc2l6ZUNhY2hlID0gbnVsbDtcbiAgICB9LFxuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IF9wLmNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBfcC5zaXplQ2FjaGUgPSBfcC5zaXplQ2FjaGUgfHwgKGNvbnRhaW5lciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuXG4gICAgICAgIHZhciB2YWwgPSBmdW5jdGlvbiB2YWwobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSB2YWwoJ3BhZGRpbmctdG9wJykgLSB2YWwoJ3BhZGRpbmctYm90dG9tJylcbiAgICAgICAgfTtcbiAgICAgIH0oKSA6IHtcbiAgICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplKCkud2lkdGg7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUoKS5oZWlnaHQ7XG4gICAgfSxcbiAgICBleHRlbnQ6IGZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuICAgICAgdmFyIGIgPSB7XG4gICAgICAgIHgxOiAocmIueDEgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICB4MjogKHJiLngyIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgeTE6IChyYi55MSAtIHBhbi55KSAvIHpvb20sXG4gICAgICAgIHkyOiAocmIueTIgLSBwYW4ueSkgLyB6b29tXG4gICAgICB9O1xuICAgICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgICBiLmggPSBiLnkyIC0gYi55MTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uIHJlbmRlcmVkRXh0ZW50KCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiB3aWR0aCxcbiAgICAgICAgeTI6IGhlaWdodCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGZ1bmN0aW9uIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoX2ludCkge1xuICAgICAgaWYgKF9pbnQpIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZSA9IF9pbnQ7ZWxzZSByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgY29yZWZuJDEuY2VudHJlID0gY29yZWZuJDEuY2VudGVyOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gIGNvcmVmbiQxLmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4kMS5hdXRvbG9jaztcbiAgY29yZWZuJDEuYXV0b3VuZ3JhYmlmeU5vZGVzID0gY29yZWZuJDEuYXV0b3VuZ3JhYmlmeTtcblxuICB2YXIgZm4gPSB7XG4gICAgZGF0YTogZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgZm4uYXR0ciA9IGZuLmRhdGE7XG4gIGZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuXG4gIHZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBvcHRzID0gZXh0ZW5kKHt9LCBvcHRzKTtcbiAgICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7IC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gICAgLy8gZS5nLiBjeXRvc2NhcGUoeyBjb250YWluZXI6ICQoJyNjeScpIH0pXG5cbiAgICBpZiAoY29udGFpbmVyICYmICFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgICB9XG5cbiAgICB2YXIgcmVnID0gY29udGFpbmVyID8gY29udGFpbmVyLl9jeXJlZyA6IG51bGw7IC8vIGUuZy4gYWxyZWFkeSByZWdpc3RlcmVkIHNvbWUgaW5mbyAoZS5nLiByZWFkaWVzKSB2aWEganF1ZXJ5XG5cbiAgICByZWcgPSByZWcgfHwge307XG5cbiAgICBpZiAocmVnICYmIHJlZy5jeSkge1xuICAgICAgcmVnLmN5LmRlc3Ryb3koKTtcbiAgICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICAgIH1cblxuICAgIHZhciByZWFkaWVzID0gcmVnLnJlYWRpZXMgPSByZWcucmVhZGllcyB8fCBbXTtcblxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5fY3lyZWcgPSByZWc7XG4gICAgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG5cblxuICAgIHJlZy5jeSA9IGN5O1xuICAgIHZhciBoZWFkID0gd2luZG93JDEgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgb3B0aW9ucy5sYXlvdXQgPSBleHRlbmQoe1xuICAgICAgbmFtZTogaGVhZCA/ICdncmlkJyA6ICdudWxsJ1xuICAgIH0sIG9wdGlvbnMubGF5b3V0KTtcbiAgICBvcHRpb25zLnJlbmRlcmVyID0gZXh0ZW5kKHtcbiAgICAgIG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJ1xuICAgIH0sIG9wdGlvbnMucmVuZGVyZXIpO1xuXG4gICAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uIGRlZlZhbChkZWYsIHZhbCwgYWx0VmFsKSB7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gZWxzZSBpZiAoYWx0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICAgIHJlYWR5OiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgLy8gY2FjaGVkIG9wdGlvbnNcbiAgICAgIGVsZW1lbnRzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAgIC8vIGVsZW1lbnRzIGluIHRoZSBncmFwaFxuICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgICBhbmlFbGVzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAgIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgICBkYXRhOiBvcHRpb25zLmRhdGEgfHwge30sXG4gICAgICAvLyBkYXRhIGZvciB0aGUgY29yZVxuICAgICAgc2NyYXRjaDoge30sXG4gICAgICAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLFxuICAgICAgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgICAgbWluWm9vbTogMWUtNTAsXG4gICAgICBtYXhab29tOiAxZTUwLFxuICAgICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5wYW5uaW5nRW5hYmxlZCksXG4gICAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICAgIGF1dG9sb2NrOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b2xvY2ssIG9wdGlvbnMuYXV0b2xvY2tOb2RlcyksXG4gICAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICAgIHpvb206IG51bWJlciQxKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIkMShvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgICB5OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgY3VycmVudDogW10sXG4gICAgICAgIHF1ZXVlOiBbXVxuICAgICAgfSxcbiAgICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgICAgbXVsdGlDbGlja0RlYm91bmNlVGltZTogZGVmVmFsKDI1MCwgb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKVxuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTsgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG5cbiAgICB0aGlzLnNlbGVjdGlvblR5cGUob3B0aW9ucy5zZWxlY3Rpb25UeXBlKTsgLy8gaW5pdCB6b29tIGJvdW5kc1xuXG4gICAgdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgbWluOiBvcHRpb25zLm1pblpvb20sXG4gICAgICBtYXg6IG9wdGlvbnMubWF4Wm9vbVxuICAgIH0pO1xuXG4gICAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24gbG9hZEV4dERhdGEoZXh0RGF0YSwgbmV4dCkge1xuICAgICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZShwcm9taXNlKTtcblxuICAgICAgaWYgKGFueUlzUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZSQxLmFsbChleHREYXRhKS50aGVuKG5leHQpOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KGV4dERhdGEpOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgICB9XG4gICAgfTsgLy8gc3RhcnQgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHNvIHdlIGhhdmUgc29tZXRoaW5nIGJlZm9yZSBsb2FkaW5nIGFuIGV4dGVybmFsIHN0eWxlc2hlZXRcblxuXG4gICAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgICAgY3kuc2V0U3R5bGUoW10pO1xuICAgIH0gLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuXG5cbiAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyKTsgLy8gYWxsb3cgcmVuZGVyaW5nIGhpbnRzIGluIHRvcCBsZXZlbCBvcHRpb25zXG5cbiAgICBjeS5pbml0UmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcblxuICAgIHZhciBzZXRFbGVzQW5kTGF5b3V0ID0gZnVuY3Rpb24gc2V0RWxlc0FuZExheW91dChlbGVtZW50cywgb25sb2FkLCBvbmRvbmUpIHtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpOyAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG5cbiAgICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgICAgIGlmIChvbGRFbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICBjeS5hZGQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgICBjeS5lbWl0KGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgY3kuZW1pdEFuZE5vdGlmeSgnbG9hZCcpO1xuICAgICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjeS5vbmUoJ2RvbmUnLCBvbmRvbmUpO1xuICAgICAgICBjeS5lbWl0KCdkb25lJyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXlvdXRPcHRzID0gZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgICAgY3kubGF5b3V0KGxheW91dE9wdHMpLnJ1bigpO1xuICAgIH07XG5cbiAgICBsb2FkRXh0RGF0YShbb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50c10sIGZ1bmN0aW9uICh0aGVucykge1xuICAgICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgICAgdmFyIGluaXRFbGVzID0gdGhlbnNbMV07IC8vIGluaXQgc3R5bGVcblxuICAgICAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgICAgICBjeS5zdHlsZSgpLmFwcGVuZChpbml0U3R5bGUpO1xuICAgICAgfSAvLyBpbml0aWFsIGxvYWRcblxuXG4gICAgICBzZXRFbGVzQW5kTGF5b3V0KGluaXRFbGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG9ucmVhZHlcbiAgICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICAgIF9wLnJlYWR5ID0gdHJ1ZTsgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuXG4gICAgICAgIGlmIChmbiQ2KG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIH0gLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmbiA9IHJlYWRpZXNbaV07XG4gICAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZykge1xuICAgICAgICAgIHJlZy5yZWFkaWVzID0gW107XG4gICAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuXG4gICAgICAgIGN5LmVtaXQoJ3JlYWR5Jyk7XG4gICAgICB9LCBvcHRpb25zLmRvbmUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjb3JlZm4gPSBDb3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuICBleHRlbmQoY29yZWZuLCB7XG4gICAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdjb3JlJztcbiAgICB9LFxuICAgIGlzUmVhZHk6IGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZGVzdHJveWVkO1xuICAgIH0sXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdCgncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIGlmIChjeS5kZXN0cm95ZWQoKSkgcmV0dXJuO1xuICAgICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN5O1xuICAgIH0sXG4gICAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuaGFzRWxlbWVudFdpdGhJZChpZCk7XG4gICAgfSxcbiAgICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9LFxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzO1xuICAgIH0sXG4gICAgaGVhZGxlc3M6IGZ1bmN0aW9uIGhlYWRsZXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXIuaXNIZWFkbGVzcygpO1xuICAgIH0sXG4gICAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gICAgfSxcbiAgICBhZGRUb1Bvb2w6IGZ1bmN0aW9uIGFkZFRvUG9vbChlbGVzKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLm1lcmdlKGVsZXMpO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHJlbW92ZUZyb21Qb29sOiBmdW5jdGlvbiByZW1vdmVGcm9tUG9vbChlbGVzKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoZWxlcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIgfHwgbnVsbDtcbiAgICB9LFxuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcblxuICAgICAgaWYgKCFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICAgICAgfVxuXG4gICAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICBfcC5zdHlsZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgY3kuaW52YWxpZGF0ZVNpemUoKTtcbiAgICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgICAgLy8gYWxsb3cgY3VzdG9tIHJlbmRlcmVyIG5hbWUgdG8gYmUgcmUtdXNlZCwgb3RoZXJ3aXNlIHVzZSBjYW52YXNcbiAgICAgICAgbmFtZTogb3B0aW9ucy5yZW5kZXJlci5uYW1lID09PSAnbnVsbCcgPyAnY2FudmFzJyA6IG9wdGlvbnMucmVuZGVyZXIubmFtZVxuICAgICAgfSkpO1xuICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICBjeS5zdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgICByZXR1cm4gY3k7XG4gICAgfSxcbiAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICAgIGN5LmluaXRSZW5kZXJlcih7XG4gICAgICAgIG5hbWU6ICdudWxsJ1xuICAgICAgfSk7XG4gICAgICBjeS5lbWl0KCd1bm1vdW50Jyk7XG4gICAgICByZXR1cm4gY3k7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGNvcHkodGhpcy5fcHJpdmF0ZS5vcHRpb25zKTtcbiAgICB9LFxuICAgIGpzb246IGZ1bmN0aW9uIGpzb24ob2JqKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgICB2YXIgZ2V0RnJlc2hSZWYgPSBmdW5jdGlvbiBnZXRGcmVzaFJlZihlbGUpIHtcbiAgICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKGVsZS5pZCgpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAgIC8vIHNldFxuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgICAgaWYgKG9iai5lbGVtZW50cykge1xuICAgICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgICAgdmFyIHVwZGF0ZUVsZXMgPSBmdW5jdGlvbiB1cGRhdGVFbGVzKGpzb25zLCBncikge1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuXG4gICAgICAgICAgICAgIGlmICghanNvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgd2FybignY3kuanNvbigpIGNhbm5vdCBoYW5kbGUgZWxlbWVudHMgd2l0aG91dCBhbiBJRCBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBpZCA9ICcnICsganNvbi5kYXRhLmlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgIGlkSW5Kc29uW2lkXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKGVsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBlbGVtZW50IHNob3VsZCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAgICAgdG9Nb2QucHVzaCh7XG4gICAgICAgICAgICAgICAgICBlbGU6IGVsZSxcbiAgICAgICAgICAgICAgICAgIGpzb246IGpzb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2hvdWxkIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3I7XG4gICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjeS5hZGQodG9BZGQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9Nb2QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfdG9Nb2QkX2kgPSB0b01vZFtfaV0sXG4gICAgICAgICAgICAgICAgICBfZWxlID0gX3RvTW9kJF9pLmVsZSxcbiAgICAgICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG5cbiAgICAgICAgICAgICAgX2VsZS5qc29uKF9qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGFycmF5KG9iai5lbGVtZW50cykpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzOiBbXVxuICAgICAgICAgICAgdXBkYXRlRWxlcyhvYmouZWxlbWVudHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50czogeyBub2RlczogW10sIGVkZ2VzOiBbXSB9XG4gICAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZ3IgPSBncnNbaV07XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG5cbiAgICAgICAgICAgICAgaWYgKGFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZXMoZWxlbWVudHMsIGdyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXJlbnRzVG9SZW1vdmUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuICFpZEluSnNvbltlbGUuaWQoKV07XG4gICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgcGFyZW50c1RvUmVtb3ZlLm1lcmdlKGVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdCByZW1vdmVkIHcvcGFyZW50XG5cbiAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlLmNoaWxkcmVuKCkubW92ZSh7XG4gICAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7IC8vIGludGVybWVkaWF0ZSBwYXJlbnRzIG1heSBiZSBtb3ZlZCBieSBwcmlvciBsaW5lLCBzbyBtYWtlIHN1cmUgd2UgcmVtb3ZlIGJ5IGZyZXNoIHJlZnNcblxuICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGcmVzaFJlZihlbGUpLnJlbW92ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5zdHlsZSkge1xuICAgICAgICAgIGN5LnN0eWxlKG9iai5zdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLnpvb20gIT0gbnVsbCAmJiBvYmouem9vbSAhPT0gX3Auem9vbSkge1xuICAgICAgICAgIGN5Lnpvb20ob2JqLnpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5wYW4pIHtcbiAgICAgICAgICBpZiAob2JqLnBhbi54ICE9PSBfcC5wYW4ueCB8fCBvYmoucGFuLnkgIT09IF9wLnBhbi55KSB7XG4gICAgICAgICAgICBjeS5wYW4ob2JqLnBhbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgICAgY3kuZGF0YShvYmouZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gWydtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJywgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsICdib3hTZWxlY3Rpb25FbmFibGVkJywgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5JywgJ211bHRpQ2xpY2tEZWJvdW5jZVRpbWUnXTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBmaWVsZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBmID0gZmllbGRzW19pMl07XG5cbiAgICAgICAgICBpZiAob2JqW2ZdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN5W2ZdKG9ialtmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXRcbiAgICAgICAgdmFyIGZsYXQgPSAhIW9iajtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcblxuICAgICAgICBpZiAoZmxhdCkge1xuICAgICAgICAgIGpzb24uZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCkubWFwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGUuanNvbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpzb24uZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgICAgIGlmICghanNvbi5lbGVtZW50c1tncm91cF0pIHtcbiAgICAgICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCkge1xuICAgICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpzb24uZGF0YSA9IGNvcHkoY3kuZGF0YSgpKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfcC5vcHRpb25zO1xuICAgICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gX3Auem9vbWluZ0VuYWJsZWQ7XG4gICAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gX3AudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAgICBqc29uLnpvb20gPSBfcC56b29tO1xuICAgICAgICBqc29uLm1pblpvb20gPSBfcC5taW5ab29tO1xuICAgICAgICBqc29uLm1heFpvb20gPSBfcC5tYXhab29tO1xuICAgICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gX3AucGFubmluZ0VuYWJsZWQ7XG4gICAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gX3AudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAgICBqc29uLnBhbiA9IGNvcHkoX3AucGFuKTtcbiAgICAgICAganNvbi5ib3hTZWxlY3Rpb25FbmFibGVkID0gX3AuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgICAganNvbi5yZW5kZXJlciA9IGNvcHkob3B0aW9ucy5yZW5kZXJlcik7XG4gICAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgICAganNvbi50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgICAganNvbi5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAgICBqc29uLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBvcHRpb25zLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvcmVmbi4kaWQgPSBjb3JlZm4uZ2V0RWxlbWVudEJ5SWQ7XG4gIFtjb3JlZm4kOSwgY29yZWZuJDgsIGVsZXNmbiwgY29yZWZuJDcsIGNvcmVmbiQ2LCBjb3JlZm4kNSwgY29yZWZuJDQsIGNvcmVmbiQzLCBjb3JlZm4kMiwgY29yZWZuJDEsIGZuXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChjb3JlZm4sIHByb3BzKTtcbiAgfSk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICB2YXIgZGVmYXVsdHMkNyA9IHtcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBjaXJjbGU6IGZhbHNlLFxuICAgIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgICBncmlkOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIGNyZWF0ZSBhbiBldmVuIGdyaWQgaW50byB3aGljaCB0aGUgREFHIGlzIHBsYWNlZCAoY2lyY2xlOmZhbHNlIG9ubHkpXG4gICAgc3BhY2luZ0ZhY3RvcjogMS43NSxcbiAgICAvLyBwb3NpdGl2ZSBzcGFjaW5nIGZhY3RvciwgbGFyZ2VyID0+IG1vcmUgc3BhY2UgYmV0d2VlbiBub2RlcyAoTi5CLiBuL2EgaWYgY2F1c2VzIG92ZXJsYXApXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gICAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgICByb290czogdW5kZWZpbmVkLFxuICAgIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgICBkZXB0aFNvcnQ6IHVuZGVmaW5lZCxcbiAgICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgbm9kZXMgYXQgZXF1YWwgZGVwdGguIGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWQsXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbiAgfTtcbiAgdmFyIGRlcHJlY2F0ZWRPcHRpb25EZWZhdWx0cyA9IHtcbiAgICBtYXhpbWFsOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHNoaWZ0IG5vZGVzIGRvd24gdGhlaXIgbmF0dXJhbCBCRlMgZGVwdGhzIGluIG9yZGVyIHRvIGF2b2lkIHVwd2FyZHMgZWRnZXMgKERBR1Mgb25seSk7IHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc29cbiAgICBhY3ljbGljOiBmYWxzZSAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGFjeWNsaWMgYW5kIHRodXMgYSBub2RlIGNvdWxkIGJlIHNoaWZ0ZWQgKGR1ZSB0byB0aGUgbWF4aW1hbCBvcHRpb24pIG11bHRpcGxlIHRpbWVzIHdpdGhvdXQgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wOyBzZXR0aW5nIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWUgYWxzbzsgaWYgeW91IGFyZSB1bmNlcnRhaW4gd2hldGhlciBhIHRyZWUgaXMgYWN5Y2xpYywgc2V0IHRvIGZhbHNlIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSBsb29wc1xuXG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB2YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8oZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnKTtcbiAgfTtcblxuICB2YXIgc2V0SW5mbyA9IGZ1bmN0aW9uIHNldEluZm8oZWxlLCBvYmopIHtcbiAgICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcsIG9iaik7XG4gIH07XG5cbiAgZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDcsIGRlcHJlY2F0ZWRPcHRpb25EZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBCcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gIW4uaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgICB2YXIgZ3JhcGggPSBlbGVzO1xuICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgdmFyIG1heGltYWwgPSBvcHRpb25zLmFjeWNsaWMgfHwgb3B0aW9ucy5tYXhpbWFsIHx8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzID4gMDsgLy8gbWF4aW1hbEFkanVzdG1lbnRzIGZvciBjb21wYXQuIHcvIG9sZCBjb2RlOyBhbHNvLCBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZVxuXG4gICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICBoOiBjeS5oZWlnaHQoKVxuICAgIH0pO1xuICAgIHZhciByb290cztcblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdGlvbnMucm9vdHMpKSB7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgfSBlbHNlIGlmIChhcnJheShvcHRpb25zLnJvb3RzKSkge1xuICAgICAgdmFyIHJvb3RzQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIHJvb3RzQXJyYXkucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24ocm9vdHNBcnJheSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcob3B0aW9ucy5yb290cykpIHtcbiAgICAgIHJvb3RzID0gY3kuJChvcHRpb25zLnJvb3RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgIHJvb3RzID0gbm9kZXMucm9vdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gZWxlcy5jb21wb25lbnRzKCk7XG4gICAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzW19pXTtcbiAgICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoZmFsc2UpO1xuICAgICAgICAgIHZhciBjb21wUm9vdHMgPSBjb21wLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlLmRlZ3JlZShmYWxzZSkgPT09IG1heERlZ3JlZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByb290cyA9IHJvb3RzLmFkZChjb21wUm9vdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb21wb25lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIF9sb29wKF9pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZXB0aHMgPSBbXTtcbiAgICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuXG4gICAgdmFyIGFkZFRvRGVwdGggPSBmdW5jdGlvbiBhZGRUb0RlcHRoKGVsZSwgZCkge1xuICAgICAgaWYgKGRlcHRoc1tkXSA9PSBudWxsKSB7XG4gICAgICAgIGRlcHRoc1tkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IGRlcHRoc1tkXS5sZW5ndGg7XG4gICAgICBkZXB0aHNbZF0ucHVzaChlbGUpO1xuICAgICAgc2V0SW5mbyhlbGUsIHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIGRlcHRoOiBkXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNoYW5nZURlcHRoID0gZnVuY3Rpb24gY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCkge1xuICAgICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgICAgIGRlcHRoID0gX2dldEluZm8uZGVwdGgsXG4gICAgICAgICAgaW5kZXggPSBfZ2V0SW5mby5pbmRleDtcblxuICAgICAgZGVwdGhzW2RlcHRoXVtpbmRleF0gPSBudWxsO1xuICAgICAgYWRkVG9EZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgICB9OyAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG5cblxuICAgIGdyYXBoLmJmcyh7XG4gICAgICByb290czogcm9vdHMsXG4gICAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdChub2RlLCBlZGdlLCBwTm9kZSwgaSwgZGVwdGgpIHtcbiAgICAgICAgdmFyIGVsZSA9IG5vZGVbMF07XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICBhZGRUb0RlcHRoKGVsZSwgZGVwdGgpO1xuICAgICAgICBmb3VuZEJ5QmZzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIGNoZWNrIGZvciBub2RlcyBub3QgZm91bmQgYnkgYmZzXG5cbiAgICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcblxuICAgICAgaWYgKGZvdW5kQnlCZnNbX2VsZS5pZCgpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ycGhhbk5vZGVzLnB1c2goX2VsZSk7XG4gICAgICB9XG4gICAgfSAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG5cblxuICAgIHZhciBhc3NpZ25EZXB0aHNBdCA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRoc0F0KGkpIHtcbiAgICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIF9lbGUyID0gZWxlc1tqXTtcblxuICAgICAgICBpZiAoX2VsZTIgPT0gbnVsbCkge1xuICAgICAgICAgIGVsZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgIGotLTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEluZm8oX2VsZTIsIHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBpbmRleDogalxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFzc2lnbkRlcHRocyA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRocygpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGRlcHRocy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGFzc2lnbkRlcHRoc0F0KF9pMyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBhZGp1c3RNYXhpbWFsbHkgPSBmdW5jdGlvbiBhZGp1c3RNYXhpbWFsbHkoZWxlLCBzaGlmdGVkKSB7XG4gICAgICB2YXIgZUluZm8gPSBnZXRJbmZvKGVsZSk7XG4gICAgICB2YXIgaW5jb21lcnMgPSBlbGUuaW5jb21lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5pc05vZGUoKSAmJiBlbGVzLmhhcyhlbCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBtYXhEZXB0aCA9IC0xO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGluY21yID0gaW5jb21lcnNba107XG4gICAgICAgIHZhciBpSW5mbyA9IGdldEluZm8oaW5jbXIpO1xuICAgICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBpSW5mby5kZXB0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlSW5mby5kZXB0aCA8PSBtYXhEZXB0aCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWN5Y2xpYyAmJiBzaGlmdGVkW2lkXSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0RlcHRoID0gbWF4RGVwdGggKyAxO1xuICAgICAgICBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgICAgICAgc2hpZnRlZFtpZF0gPSBuZXdEZXB0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9OyAvLyBmb3IgdGhlIGRpcmVjdGVkIGNhc2UsIHRyeSB0byBtYWtlIHRoZSBlZGdlcyBhbGwgZ28gZG93biAoaS5lLiBkZXB0aCBpID0+IGRlcHRoIGkgKyAxKVxuXG5cbiAgICBpZiAoZGlyZWN0ZWQgJiYgbWF4aW1hbCkge1xuICAgICAgdmFyIFEgPSBbXTtcbiAgICAgIHZhciBzaGlmdGVkID0ge307XG5cbiAgICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShuKSB7XG4gICAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICAgIHJldHVybiBRLnNoaWZ0KCk7XG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgICB9KTtcblxuICAgICAgd2hpbGUgKFEubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX2VsZTMgPSBkZXF1ZXVlKCk7XG5cbiAgICAgICAgdmFyIGRpZFNoaWZ0ID0gYWRqdXN0TWF4aW1hbGx5KF9lbGUzLCBzaGlmdGVkKTtcblxuICAgICAgICBpZiAoZGlkU2hpZnQpIHtcbiAgICAgICAgICBfZWxlMy5vdXRnb2VycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5pc05vZGUoKSAmJiBlbGVzLmhhcyhlbCk7XG4gICAgICAgICAgfSkuZm9yRWFjaChlbnF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWRTaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGRvdWJsZSBtYXhpbWFsIHNoaWZ0IGZvciBub2RlIGAnICsgX2VsZTMuaWQoKSArICdgLiAgQmFpbGluZyBtYXhpbWFsIGFkanVzdG1lbnQgZHVlIHRvIGN5Y2xlLiAgVXNlIGBvcHRpb25zLm1heGltYWw6IHRydWVgIG9ubHkgb24gREFHcy4nKTtcbiAgICAgICAgICBicmVhazsgLy8gZXhpdCBvbiBmYWlsdXJlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NpZ25EZXB0aHMoKTsgLy8gY2xlYXIgaG9sZXNcbiAgICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcblxuICAgIHZhciBtaW5EaXN0YW5jZSA9IDA7XG5cbiAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIG4gPSBub2Rlc1tfaTRdO1xuICAgICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgICB2YXIgaCA9IG5iYi5oO1xuICAgICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICAgIH1cbiAgICB9IC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuXG5cbiAgICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG5cbiAgICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0V2VpZ2h0ZWRQZXJjZW50KGVsZSkge1xuICAgICAgaWYgKGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV07XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVEZXB0aCA9IGdldEluZm8oZWxlKS5kZXB0aDtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCk7XG4gICAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgICB2YXIgc2FtcGxlcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tfaTVdO1xuXG4gICAgICAgIGlmIChuZWlnaGJvci5pc0VkZ2UoKSB8fCBuZWlnaGJvci5pc1BhcmVudCgpIHx8ICFub2Rlcy5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmYgPSBnZXRJbmZvKG5laWdoYm9yKTtcblxuICAgICAgICBpZiAoYmYgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICAgIHZhciBkZXB0aCA9IGJmLmRlcHRoOyAvLyB1bmFzc2lnbmVkIG5laWdoYm91cnMgc2hvdWxkbid0IGFmZmVjdCB0aGUgb3JkZXJpbmdcblxuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCB8fCBkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbkRlcHRoID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGRlcHRoIDwgZWxlRGVwdGgpIHtcbiAgICAgICAgICAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgICBzYW1wbGVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuXG4gICAgICBpZiAoc2FtcGxlcyA9PT0gMCkge1xuICAgICAgICAvLyBwdXQgbG9uZSBub2RlcyBhdCB0aGUgc3RhcnRcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0gPSBwZXJjZW50O1xuICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgfTsgLy8gcmVhcnJhbmdlIHRoZSBpbmRpY2VzIGluIGVhY2ggZGVwdGggbGV2ZWwgYmFzZWQgb24gY29ubmVjdGl2aXR5XG5cblxuICAgIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiBzb3J0Rm4oYSwgYikge1xuICAgICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYSk7XG4gICAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudChiKTtcbiAgICAgIHZhciBkaWZmID0gYXBjdCAtIGJwY3Q7XG5cbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhc2NlbmRpbmcoYS5pZCgpLCBiLmlkKCkpOyAvLyBtYWtlIHN1cmUgc29ydCBkb2Vzbid0IGhhdmUgZG9uJ3QtY2FyZSBjb21wYXJpc29uc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmRlcHRoU29ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3J0Rm4gPSBvcHRpb25zLmRlcHRoU29ydDtcbiAgICB9IC8vIHNvcnQgZWFjaCBsZXZlbCB0byBtYWtlIGNvbm5lY3RlZCBub2RlcyBjbG9zZXJcblxuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGVwdGhzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIGRlcHRoc1tfaTZdLnNvcnQoc29ydEZuKTtcblxuICAgICAgYXNzaWduRGVwdGhzQXQoX2k2KTtcbiAgICB9IC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgdG8gYSBuZXcgdG9wLWxldmVsIGRlcHRoXG5cblxuICAgIHZhciBvcnBoYW5EZXB0aCA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgb3JwaGFuTm9kZXMubGVuZ3RoOyBfaTcrKykge1xuICAgICAgb3JwaGFuRGVwdGgucHVzaChvcnBoYW5Ob2Rlc1tfaTddKTtcbiAgICB9XG5cbiAgICBkZXB0aHMudW5zaGlmdChvcnBoYW5EZXB0aCk7XG4gICAgYXNzaWduRGVwdGhzKCk7XG4gICAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuXG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgZGVwdGhzLmxlbmd0aDsgX2k4KyspIHtcbiAgICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heChkZXB0aHNbX2k4XS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUpO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgICAgeTogYmIueDEgKyBiYi5oIC8gMlxuICAgIH07XG4gICAgdmFyIG1heERlcHRoU2l6ZSA9IGRlcHRocy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWxlcykge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZWxlcy5sZW5ndGgpO1xuICAgIH0sIDApO1xuXG4gICAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWxlKSB7XG4gICAgICB2YXIgX2dldEluZm8yID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgICAgIGRlcHRoID0gX2dldEluZm8yLmRlcHRoLFxuICAgICAgICAgIGluZGV4ID0gX2dldEluZm8yLmluZGV4O1xuXG4gICAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoYmIudyAvICgob3B0aW9ucy5ncmlkID8gbWF4RGVwdGhTaXplIDogZGVwdGhTaXplKSArIDEpLCBtaW5EaXN0YW5jZSk7XG4gICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoKTtcbiAgICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgocmFkaXVzU3RlcFNpemUsIG1pbkRpc3RhbmNlKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNpcmNsZSkge1xuICAgICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkgLyAyKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gZGVwdGhzW2RlcHRoXS5sZW5ndGggKiBpbmRleDtcblxuICAgICAgICBpZiAoZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQ2ID0ge1xuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gICAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICAgIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICAgIHJhZGl1czogdW5kZWZpbmVkLFxuICAgIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gICAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gICAgc29ydDogdW5kZWZpbmVkLFxuICAgIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbiAgfTtcblxuICBmdW5jdGlvbiBDaXJjbGVMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNiwgb3B0aW9ucyk7XG4gIH1cblxuICBDaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgfVxuXG4gICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICBoOiBjeS5oZWlnaHQoKVxuICAgIH0pO1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICAgIH07XG4gICAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gICAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHI7XG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5yYWRpdXMpKSB7XG4gICAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChub2Rlcy5sZW5ndGggPD0gMSkge1xuICAgICAgciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBNYXRoLm1pbihiYi5oLCBiYi53KSAvIDIgLSBtaW5EaXN0YW5jZTtcbiAgICB9IC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG5cblxuICAgIGlmIChub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgICAgdmFyIHJ4ID0gciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB2YXIgcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuXG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQ1ID0ge1xuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gICAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAgIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgICBzd2VlcDogdW5kZWZpbmVkLFxuICAgIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICAgIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgICBlcXVpZGlzdGFudDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgICBtaW5Ob2RlU3BhY2luZzogMTAsXG4gICAgLy8gbWluIHNwYWNpbmcgYmV0d2VlbiBvdXRzaWRlIG9mIG5vZGVzICh1c2VkIGZvciByYWRpdXMgYWRqdXN0bWVudClcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gICAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAgIC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgICByZXR1cm4gbm9kZS5kZWdyZWUoKTtcbiAgICB9LFxuICAgIGxldmVsV2lkdGg6IGZ1bmN0aW9uIGxldmVsV2lkdGgobm9kZXMpIHtcbiAgICAgIC8vIHRoZSB2YXJpYXRpb24gb2YgY29uY2VudHJpYyB2YWx1ZXMgaW4gZWFjaCBsZXZlbFxuICAgICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbiAgfTtcblxuICBmdW5jdGlvbiBDb25jZW50cmljTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDUsIG9wdGlvbnMpO1xuICB9XG5cbiAgQ29uY2VudHJpY0xheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICBoOiBjeS5oZWlnaHQoKVxuICAgIH0pO1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICAgIH07XG4gICAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG5cbiAgICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDsgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG5cbiAgICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBub2RlOiBub2RlXG4gICAgICB9KTsgLy8gZm9yIHN0eWxlIG1hcHBpbmdcblxuICAgICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbmNlbnRyaWMgPSB2YWx1ZTtcbiAgICB9IC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG5cblxuICAgIG5vZGVzLnVwZGF0ZVN0eWxlKCk7IC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICAgIHZhciBuYmIgPSBfbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuXG4gICAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KG1heE5vZGVTaXplLCBuYmIudywgbmJiLmgpO1xuICAgIH0gLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuXG5cbiAgICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICB9KTtcbiAgICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aChub2Rlcyk7IC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG5cbiAgICB2YXIgbGV2ZWxzID0gW1tdXTtcbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVZhbHVlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1tfaTJdO1xuXG4gICAgICBpZiAoY3VycmVudExldmVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUpO1xuXG4gICAgICAgIGlmIChkaWZmID49IGxldmVsV2lkdGgpIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgICBsZXZlbHMucHVzaChjdXJyZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMZXZlbC5wdXNoKHZhbCk7XG4gICAgfSAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cblxuICAgIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgICBpZiAoIW9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAvLyB0aGVuIHN0cmljdGx5IGNvbnN0cmFpbiB0byBiYlxuICAgICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICAgIHZhciBtYXhSID0gTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdDtcbiAgICAgIHZhciByU3RlcCA9IG1heFIgLyAobGV2ZWxzLmxlbmd0aCArIGZpcnN0THZsSGFzTXVsdGkgPyAxIDogMCk7XG4gICAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICAgIH0gLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuXG5cbiAgICB2YXIgciA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW19pM107XG4gICAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbGV2ZWwubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpOyAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuXG4gICAgICBpZiAobGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdCAqIG1pbkRpc3QgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC5yID0gcjtcbiAgICAgIHIgKz0gbWluRGlzdDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lcXVpZGlzdGFudCkge1xuICAgICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgICB2YXIgX3IgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZXZlbHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX2xldmVsID0gbGV2ZWxzW19pNF07XG4gICAgICAgIHZhciByRGVsdGEgPSBfbGV2ZWwuciAtIF9yO1xuICAgICAgICByRGVsdGFNYXggPSBNYXRoLm1heChyRGVsdGFNYXgsIHJEZWx0YSk7XG4gICAgICB9XG5cbiAgICAgIF9yID0gMDtcblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbGV2ZWxzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcblxuICAgICAgICBpZiAoX2k1ID09PSAwKSB7XG4gICAgICAgICAgX3IgPSBfbGV2ZWwyLnI7XG4gICAgICAgIH1cblxuICAgICAgICBfbGV2ZWwyLnIgPSBfcjtcbiAgICAgICAgX3IgKz0gckRlbHRhTWF4O1xuICAgICAgfVxuICAgIH0gLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuXG5cbiAgICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG5cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBsZXZlbHMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIF9sZXZlbDMgPSBsZXZlbHNbX2k2XTtcbiAgICAgIHZhciBfZFRoZXRhID0gX2xldmVsMy5kVGhldGE7XG4gICAgICB2YXIgX3IyID0gX2xldmVsMy5yO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9sZXZlbDMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIF92YWwgPSBfbGV2ZWwzW2pdO1xuICAgICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIF9yMiAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgICBwb3NbX3ZhbC5ub2RlLmlkKCldID0gcDtcbiAgICAgIH1cbiAgICB9IC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuXG5cbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgcmV0dXJuIHBvc1tpZF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLypcbiAgVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbiAgaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG4gIEJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZTpcbiAgaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuICBNb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuICAqL1xuICB2YXIgREVCVUc7XG4gIC8qKlxuICAgKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICAgKi9cblxuICB2YXIgZGVmYXVsdHMkNCA9IHtcbiAgICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAgIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30sXG4gICAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAgIC8vIHRydWUgOiBBbmltYXRlIGNvbnRpbnVvdXNseSBhcyB0aGUgbGF5b3V0IGlzIHJ1bm5pbmdcbiAgICAvLyBmYWxzZSA6IEp1c3Qgc2hvdyB0aGUgZW5kIHJlc3VsdFxuICAgIC8vICdlbmQnIDogQW5pbWF0ZSB3aXRoIHRoZSBlbmQgcmVzdWx0LCBmcm9tIHRoZSBpbml0aWFsIHBvc2l0aW9ucyB0byB0aGUgZW5kIHBvc2l0aW9uc1xuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgLy8gRWFzaW5nIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgLy8gQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWRcbiAgICAvLyBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWRcbiAgICAvLyBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0ZTp0cnVlXG4gICAgLy8gKHByZXZlbnRzIGZsYXNoaW5nIG9uIGZhc3QgcnVucylcbiAgICBhbmltYXRpb25UaHJlc2hvbGQ6IDI1MCxcbiAgICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlXG4gICAgcmVmcmVzaDogMjAsXG4gICAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gUGFkZGluZyBvbiBmaXRcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyBSYW5kb21pemUgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBub2RlcyAodHJ1ZSkgb3IgdXNlIGV4aXN0aW5nIHBvc2l0aW9ucyAoZmFsc2UpXG4gICAgcmFuZG9taXplOiBmYWxzZSxcbiAgICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gICAgY29tcG9uZW50U3BhY2luZzogNDAsXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICAgIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgICAgcmV0dXJuIDIwNDg7XG4gICAgfSxcbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgICBub2RlT3ZlcmxhcDogNCxcbiAgICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICAgIG5lc3RpbmdGYWN0b3I6IDEuMixcbiAgICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgICBncmF2aXR5OiAxLFxuICAgIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgIG51bUl0ZXI6IDEwMDAsXG4gICAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgICBpbml0aWFsVGVtcDogMTAwMCxcbiAgICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICAgIGNvb2xpbmdGYWN0b3I6IDAuOTksXG4gICAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gICAgbWluVGVtcDogMS4wXG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICAgKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICAgKi9cblxuICBmdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDQsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucy5sYXlvdXQgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAgICovXG5cblxuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICBsYXlvdXQuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9IC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuXG5cbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgICAgREVCVUcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBERUJVRyA9IGZhbHNlO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuXG5cbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7IC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcblxuICAgIGlmIChERUJVRykge1xuICAgICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICAgIH0gLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuXG5cbiAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgIHZhciByZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpOyAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuXG4gICAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uIG1haW5Mb29wKGkpIHtcbiAgICAgIGlmIChsYXlvdXQuc3RvcHBlZCB8fCBpID49IG9wdGlvbnMubnVtSXRlcikge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cblxuXG4gICAgICBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcblxuICAgICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7IC8vIGxvZ0RlYnVnKFwiTmV3IHRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuXG4gICAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlZnJlc2goKTsgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgICAgIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICAgICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBnZXRTY2FsZWRQb3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxvb3BSZXQgPSB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGZyYW1lID0gZnVuY3Rpb24gZnJhbWUoKSB7XG4gICAgICAgIHZhciBmID0gMDtcblxuICAgICAgICB3aGlsZSAobG9vcFJldCAmJiBmIDwgb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBmKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxvb3BSZXQpIHtcbiAgICAgICAgICAvLyBpdCdzIGRvbmVcbiAgICAgICAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICAgICAgaWYgKG5vdyAtIHN0YXJ0VGltZSA+PSBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZyYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChsb29wUmV0KSB7XG4gICAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAgICovXG5cblxuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRocmVhZCkge1xuICAgICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICAgKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAgICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAgICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gICAqL1xuXG5cbiAgdmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICAgIHZhciBsYXlvdXRJbmZvID0ge1xuICAgICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgICAgbGF5b3V0Tm9kZXM6IFtdLFxuICAgICAgaWRUb0luZGV4OiB7fSxcbiAgICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgICBncmFwaFNldDogW10sXG4gICAgICBpbmRleFRvR3JhcGg6IFtdLFxuICAgICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgICAgZWRnZVNpemU6IGVkZ2VzLnNpemUoKSxcbiAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgICAgY2xpZW50V2lkdGg6IGN5LndpZHRoKCksXG4gICAgICBjbGllbnRIZWlnaHQ6IGN5LndpZHRoKCksXG4gICAgICBib3VuZGluZ0JveDogbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgICB9KVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICAgIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9uZW50W2pdO1xuICAgICAgICBpZDJjbXB0SWRbbm9kZS5pZCgpXSA9IGk7XG4gICAgICB9XG4gICAgfSAvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBjcmVhdGluZyBsYXlvdXQgbm9kZXNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHRlbXBOb2RlID0ge307XG4gICAgICB0ZW1wTm9kZS5pc0xvY2tlZCA9IG4ubG9ja2VkKCk7XG4gICAgICB0ZW1wTm9kZS5pZCA9IG4uZGF0YSgnaWQnKTtcbiAgICAgIHRlbXBOb2RlLnBhcmVudElkID0gbi5kYXRhKCdwYXJlbnQnKTtcbiAgICAgIHRlbXBOb2RlLmNtcHRJZCA9IGlkMmNtcHRJZFtuLmlkKCldO1xuICAgICAgdGVtcE5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRlbXBOb2RlLnBvc2l0aW9uWCA9IG4ucG9zaXRpb24oJ3gnKTtcbiAgICAgIHRlbXBOb2RlLnBvc2l0aW9uWSA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICAgIHRlbXBOb2RlLm9mZnNldFggPSAwO1xuICAgICAgdGVtcE5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICB0ZW1wTm9kZS5oZWlnaHQgPSBuYmIudztcbiAgICAgIHRlbXBOb2RlLndpZHRoID0gbmJiLmg7XG4gICAgICB0ZW1wTm9kZS5tYXhYID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggLyAyO1xuICAgICAgdGVtcE5vZGUubWluWCA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICAgIHRlbXBOb2RlLm1heFkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUubWluWSA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgICB0ZW1wTm9kZS5wYWRMZWZ0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgICAgdGVtcE5vZGUucGFkUmlnaHQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgICB0ZW1wTm9kZS5wYWRUb3AgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgICB0ZW1wTm9kZS5wYWRCb3R0b20gPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7IC8vIGZvcmNlc1xuXG4gICAgICB0ZW1wTm9kZS5ub2RlUmVwdWxzaW9uID0gZm4kNihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uOyAvLyBBZGQgbmV3IG5vZGVcblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTsgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuXG4gICAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5pZF0gPSBpO1xuICAgIH0gLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuXG5cbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuXG4gICAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAgIHZhciB0ZW1wR3JhcGggPSBbXTsgLy8gU2Vjb25kIHBhc3MgdG8gYWRkIGNoaWxkIGluZm9ybWF0aW9uIGFuZFxuICAgIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7IC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuXG4gICAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAgIC8vIEFkZCBub2RlIElkIHRvIHBhcmVudCdzIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG5cblxuICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCh0ZW1wR3JhcGgpOyAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgdmFyIG5vZGVfaWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgIHZhciBub2RlX2l4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZV9peF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICAgIH1cbiAgICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgICAgdGVtcEVkZ2UuaWQgPSBlLmRhdGEoJ2lkJyk7XG4gICAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSgnc291cmNlJyk7XG4gICAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7IC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG5cbiAgICAgIHZhciBpZGVhbExlbmd0aCA9IGZuJDYob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgoZSkgOiBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgICAgIHZhciBlbGFzdGljaXR5ID0gZm4kNihvcHRpb25zLmVkZ2VFbGFzdGljaXR5KSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkoZSkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5OyAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcblxuICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuXG4gICAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICAgIHZhciBsY2EgPSBmaW5kTENBKHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyk7IC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcblxuICAgICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICAgIHZhciBkZXB0aCA9IDA7IC8vIFNvdXJjZSBkZXB0aFxuXG4gICAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuXG4gICAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9IC8vIFRhcmdldCBkZXB0aFxuXG5cbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgICB3aGlsZSAoLTEgPT09IGxjYUdyYXBoLmluZGV4T2YodGVtcE5vZGUuaWQpKSB7XG4gICAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfSAvLyBsb2dEZWJ1ZygnTENBIG9mIG5vZGVzICcgKyB0ZW1wRWRnZS5zb3VyY2VJZCArICcgYW5kICcgKyB0ZW1wRWRnZS50YXJnZXRJZCArXG4gICAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuICAgICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcblxuXG4gICAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgICAgfVxuXG4gICAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgICAgdGVtcEVkZ2UuZWxhc3RpY2l0eSA9IGVsYXN0aWNpdHk7XG4gICAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICAgIH0gLy8gRmluYWxseSwgcmV0dXJuIGxheW91dEluZm8gb2JqZWN0XG5cblxuICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAgICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gICAqICAgICAgICAgIChmcm9tIHRoZSBncmFwaCBoaWVyYXJjaHkgaW5kdWNlZCB0cmVlKSB3aG9zZVxuICAgKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAgICpcbiAgICogQGFyZyBub2RlMTogbm9kZTEncyBJRFxuICAgKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gICAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAgICpcbiAgICovXG5cblxuICB2YXIgZmluZExDQSA9IGZ1bmN0aW9uIGZpbmRMQ0Eobm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gICAgLy8gRmluZCB0aGVpciBjb21tb24gYW5jZXN0ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgZ3JhcGhcbiAgICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcblxuICAgIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLFxuICAgICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXMuZ3JhcGg7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICAgKlxuICAgKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAgICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdG9ycyAobWF4OiAyKSBmb3VuZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICAgKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmdcbiAgICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAgICovXG5cblxuICB2YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbiBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdOyAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuXG4gICAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY291bnQ6IDIsXG4gICAgICAgIGdyYXBoOiBncmFwaEl4XG4gICAgICB9O1xuICAgIH0gLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcblxuXG4gICAgdmFyIGMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGVJZCA9IGdyYXBoW2ldO1xuICAgICAgdmFyIG5vZGVJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJeF0uY2hpbGRyZW47IC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuXG4gICAgICBpZiAoMCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG5cbiAgICAgIGlmICgwID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoMSA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgICAgYysrO1xuXG4gICAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogYyxcbiAgICAgIGdyYXBoOiBncmFwaEl4XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAgICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZ1xuICAgKi9cblxuXG52YXIgcHJpbnRMYXlvdXRJbmZvOyBcbiAgLyoqXG4gICAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICAgKi9cblxuXG4gIHZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbiByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpIHtcbiAgICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07IC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuXG4gICAgICBpZiAoMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFNjYWxlSW5Cb3VuZHNGbiA9IGZ1bmN0aW9uIGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcykge1xuICAgIHZhciBiYiA9IGxheW91dEluZm8uYm91bmRpbmdCb3g7XG4gICAgdmFyIGNvc2VCQiA9IHtcbiAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB5MjogLUluZmluaXR5XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZS5kYXRhKCdpZCcpXV07XG4gICAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgICBjb3NlQkIueTEgPSBNYXRoLm1pbihjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSk7XG4gICAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIH0pO1xuICAgICAgY29zZUJCLncgPSBjb3NlQkIueDIgLSBjb3NlQkIueDE7XG4gICAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgICAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogbG5vZGUucG9zaXRpb25YLFxuICAgICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cblxuXG4gIHZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24gcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB2YXIgbGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQ7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gICAgbm9kZXMucG9zaXRpb25zKGdldFNjYWxlZFBvcyk7IC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG5cbiAgICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gICAqL1xuICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIC8vICAgaWYgKERFQlVHKSB7XG4gIC8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuICAvLyAgIH1cbiAgLy8gfTtcblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG5cblxuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgX3N0ZXApIHtcbiAgICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAgIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gICAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gICAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG5cbiAgICBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8pOyAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcblxuICAgIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7IC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcblxuICAgIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuXG4gICAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8pO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICAgKi9cblxuXG4gIHZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAvLyBOb2RlcyBvbmx5IHJlcGVsIGVhY2ggb3RoZXIgaWYgdGhleSBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JhcGhcbiAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7IC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtrXV1dO1xuICAgICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcmFuZG9tRGlzdGFuY2UgPSBmdW5jdGlvbiByYW5kb21EaXN0YW5jZShtYXgpIHtcbiAgICByZXR1cm4gLW1heCArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gICAqL1xuXG5cbiAgdmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcbiAgICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgICB2YXIgY21wdElkMiA9IG5vZGUyLmNtcHRJZDtcblxuICAgIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG5cblxuICAgIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICAgIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICAgIHZhciBtYXhSYW5kRGlzdCA9IDE7IC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG5cbiAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICBkaXJlY3Rpb25YID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgICAgdmFyIGZvcmNlID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7IC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTsgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXJlY3Rpb25ZIC8gZGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgZm9yY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbFxuICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpOyAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcblxuICAgICAgdmFyIGRpc3RhbmNlWCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgZGlzdGFuY2VZID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxcik7IC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG5cbiAgICAgIHZhciBmb3JjZSA9IChub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbikgLyBkaXN0YW5jZVNxcjtcbiAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gICAgfSAvLyBBcHBseSBmb3JjZVxuXG5cbiAgICBpZiAoIW5vZGUxLmlzTG9ja2VkKSB7XG4gICAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIH1cblxuICAgIGlmICghbm9kZTIuaXNMb2NrZWQpIHtcbiAgICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgfSAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cblxuICAgIHJldHVybjtcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gICAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAgICovXG5cblxuICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG4gICAgaWYgKGRYID4gMCkge1xuICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUyLm1heFggLSBub2RlMS5taW5YO1xuICAgIH1cblxuICAgIGlmIChkWSA+IDApIHtcbiAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUxLm1heFkgLSBub2RlMi5taW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAgICogICAgICAgICAgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCBvZiBpdCdzIHNvdXJjZS90YXJnZXQgbm9kZVxuICAgKi9cblxuXG4gIHZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uIGZpbmRDbGlwcGluZ1BvaW50KG5vZGUsIGRYLCBkWSkge1xuICAgIC8vIFNob3JjdXRzXG4gICAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICAgIHZhciBIID0gbm9kZS5oZWlnaHQgfHwgMTtcbiAgICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgICB2YXIgZGlyU2xvcGUgPSBkWSAvIGRYO1xuICAgIHZhciBub2RlU2xvcGUgPSBIIC8gVzsgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAgIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gICAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7XG4gICAgLy9cbiAgICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuXG4gICAgdmFyIHJlcyA9IHt9OyAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuXG4gICAgaWYgKDAgPT09IGRYICYmIDAgPCBkWSkge1xuICAgICAgcmVzLnggPSBYOyAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG5cbiAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcblxuXG4gICAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgICAgcmVzLnggPSBYO1xuICAgICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG5cblxuICAgIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICByZXMueCA9IFggKyBXIC8gMjtcbiAgICAgIHJlcy55ID0gWSArIFcgKiBkWSAvIDIgLyBkWDsgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuXG5cbiAgICBpZiAoMCA+IGRYICYmIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgICByZXMueSA9IFkgLSBXICogZFkgLyAyIC8gZFg7IC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG5cblxuICAgIGlmICgwIDwgZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICAgIHJlcy54ID0gWCArIEggKiBkWCAvIDIgLyBkWTtcbiAgICAgIHJlcy55ID0gWSArIEggLyAyOyAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuXG5cbiAgICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgICByZXMueCA9IFggLSBIICogZFggLyAyIC8gZFk7XG4gICAgICByZXMueSA9IFkgLSBIIC8gMjsgLy8gcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cblxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICAgKi9cblxuXG4gIHZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgICB2YXIgZWRnZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciBzb3VyY2UgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgICAgdmFyIHRhcmdldCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdOyAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuXG4gICAgICB2YXIgZGlyZWN0aW9uWCA9IHRhcmdldC5wb3NpdGlvblggLSBzb3VyY2UucG9zaXRpb25YO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTsgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuXG4gICAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG5cblxuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KHNvdXJjZSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgIHZhciBsID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcbiAgICAgIHZhciBmb3JjZSA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIGVkZ2UuZWxhc3RpY2l0eTtcblxuICAgICAgaWYgKDAgIT09IGwpIHtcbiAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgICB9IC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG5cblxuICAgICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgICBzb3VyY2Uub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFyZ2V0LmlzTG9ja2VkKSB7XG4gICAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgICAgfSAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICAgKi9cblxuXG4gIHZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZ3Jhdml0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTsgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7IC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuXG4gICAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgICB2YXIgY2VudGVyWCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGNlbnRlclkgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICAgIHZhciB0ZW1wID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgICB2YXIgcGFyZW50ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgICAgfSAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTsgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuXG4gICAgICAgIGlmIChub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmIChkID4gZGlzdFRocmVzaG9sZCkge1xuICAgICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTsgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgICB9IC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cblxuXG4gIHZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbiBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuXG4gICAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG4gICAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG5cbiAgICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7IC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG5cbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZUlkID0gcXVldWVbc3RhcnQrK107XG4gICAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjsgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuXG4gICAgICBpZiAoMCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5pc0xvY2tlZCkge1xuICAgICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7IC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuW2ldXV07IC8vIFByb3BhZ2F0ZSBvZmZzZXRcblxuICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTsgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcblxuICAgICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB9IC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG5cblxuICAgICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gICAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAgICovXG5cblxuICB2YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24gdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoIHx8IG4uaXNMb2NrZWQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuXG5cbiAgICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcbiAgICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54O1xuICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICBuLm9mZnNldFggPSAwO1xuICAgICAgbi5vZmZzZXRZID0gMDtcbiAgICAgIG4ubWluWCA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICAgIG4ubWF4WCA9IG4ucG9zaXRpb25YICsgbi53aWR0aDtcbiAgICAgIG4ubWluWSA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7XG4gICAgICBuLm1heFkgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0OyAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuXG4gICAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gICAgfSAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgICAgbi53aWR0aCA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgICAgbi5oZWlnaHQgPSBuLm1heFkgLSBuLm1pblk7IC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICAvLyBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICAgKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LlxuICAgOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLlxuICAgICovXG5cblxuICB2YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uIGxpbWl0Rm9yY2UoZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAgIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICAgIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuXG4gICAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICB4OiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHg6IGZvcmNlWCxcbiAgICAgICAgeTogZm9yY2VZXG4gICAgICB9O1xuICAgIH0gLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZVxuICAgKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICAgKi9cblxuXG4gIHZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobm9kZSwgbGF5b3V0SW5mbykge1xuICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuXG4gICAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCBQYXJlbnQgTm9kZVxuXG5cbiAgICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlOyAvLyBNYXhYXG5cbiAgICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgICB9IC8vIE1pblhcblxuXG4gICAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICAgIH0gLy8gTWF4WVxuXG5cbiAgICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICAgIH0gLy8gTWluWVxuXG5cbiAgICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICAgIH0gLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcblxuXG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgICB9IC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cblxuICAgIHJldHVybjtcbiAgfTtcblxuICB2YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24gc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSA9IGNvbXBvbmVudHNbY2lkXSB8fCBbXTtcbiAgICAgIGNvbXBvbmVudC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciB0b3RhbEEgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYy54MSA9IEluZmluaXR5O1xuICAgICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICAgIGMueTEgPSBJbmZpbml0eTtcbiAgICAgIGMueTIgPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbiA9IGNbal07XG4gICAgICAgIGMueDEgPSBNYXRoLm1pbihjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyKTtcbiAgICAgICAgYy54MiA9IE1hdGgubWF4KGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aCAvIDIpO1xuICAgICAgICBjLnkxID0gTWF0aC5taW4oYy55MSwgbi5wb3NpdGlvblkgLSBuLmhlaWdodCAvIDIpO1xuICAgICAgICBjLnkyID0gTWF0aC5tYXgoYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIpO1xuICAgICAgfVxuXG4gICAgICBjLncgPSBjLngyIC0gYy54MTtcbiAgICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuICAgICAgdG90YWxBICs9IGMudyAqIGMuaDtcbiAgICB9XG5cbiAgICBjb21wb25lbnRzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gICAgfSk7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgdXNlZFcgPSAwO1xuICAgIHZhciByb3dIID0gMDtcbiAgICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuID0gY1tqXTtcblxuICAgICAgICBpZiAoIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgICBuLnBvc2l0aW9uWCArPSB4IC0gYy54MTtcbiAgICAgICAgICBuLnBvc2l0aW9uWSArPSB5IC0gYy55MTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgIHVzZWRXICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgIHJvd0ggPSBNYXRoLm1heChyb3dILCBjLmgpO1xuXG4gICAgICBpZiAodXNlZFcgPiBtYXhSb3dXKSB7XG4gICAgICAgIHkgKz0gcm93SCArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHVzZWRXID0gMDtcbiAgICAgICAgcm93SCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQzID0ge1xuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCxcbiAgICAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2RlcyB3aGVuIGF2b2lkT3ZlcmxhcDogdHJ1ZVxuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gICAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgICBjb25kZW5zZTogZmFsc2UsXG4gICAgLy8gdXNlcyBhbGwgYXZhaWxhYmxlIHNwYWNlIG9uIGZhbHNlLCB1c2VzIG1pbmltYWwgc3BhY2Ugb24gdHJ1ZVxuICAgIHJvd3M6IHVuZGVmaW5lZCxcbiAgICAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICAgIGNvbHM6IHVuZGVmaW5lZCxcbiAgICAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSxcbiAgICAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICAgIHNvcnQ6IHVuZGVmaW5lZCxcbiAgICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG4gIH07XG5cbiAgZnVuY3Rpb24gR3JpZExheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQzLCBvcHRpb25zKTtcbiAgfVxuXG4gIEdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSk7XG5cbiAgICBpZiAoYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKSB7XG4gICAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBiYi54MSxcbiAgICAgICAgICB5OiBiYi55MVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgICAgdmFyIHNwbGl0cyA9IE1hdGguc3FydChjZWxscyAqIGJiLmggLyBiYi53KTtcbiAgICAgIHZhciByb3dzID0gTWF0aC5yb3VuZChzcGxpdHMpO1xuICAgICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcblxuICAgICAgdmFyIHNtYWxsID0gZnVuY3Rpb24gc21hbGwodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29scyk7XG5cbiAgICAgICAgICBpZiAobWluID09IHJvd3MpIHtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbiBsYXJnZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyb3dzLCBjb2xzKTtcblxuICAgICAgICAgIGlmIChtYXggPT0gcm93cykge1xuICAgICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICAgIHZhciBvQ29scyA9IG9wdGlvbnMuY29scyAhPSBudWxsID8gb3B0aW9ucy5jb2xzIDogb3B0aW9ucy5jb2x1bW5zOyAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuXG4gICAgICBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgICAgY29scyA9IG9Db2xzO1xuICAgICAgfSBlbHNlIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwpIHtcbiAgICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgICBjb2xzID0gTWF0aC5jZWlsKGNlbGxzIC8gcm93cyk7XG4gICAgICB9IGVsc2UgaWYgKG9Sb3dzID09IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgICBjb2xzID0gb0NvbHM7XG4gICAgICAgIHJvd3MgPSBNYXRoLmNlaWwoY2VsbHMgLyBjb2xzKTtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgZWxzZSBpZiAoY29scyAqIHJvd3MgPiBjZWxscykge1xuICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICB2YXIgbGcgPSBsYXJnZSgpOyAvLyByZWR1Y2luZyB0aGUgc21hbGwgc2lkZSB0YWtlcyBhd2F5IHRoZSBtb3N0IGNlbGxzLCBzbyB0cnkgaXQgZmlyc3RcblxuICAgICAgICBpZiAoKHNtIC0gMSkgKiBsZyA+PSBjZWxscykge1xuICAgICAgICAgIHNtYWxsKHNtIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGxnIC0gMSkgKiBzbSA+PSBjZWxscykge1xuICAgICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB0b28gbG93LCBhZGQgcm93cyBvciBjb2x1bW5zXG4gICAgICAgIHdoaWxlIChjb2xzICogcm93cyA8IGNlbGxzKSB7XG4gICAgICAgICAgdmFyIF9zbSA9IHNtYWxsKCk7XG5cbiAgICAgICAgICB2YXIgX2xnID0gbGFyZ2UoKTsgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuXG5cbiAgICAgICAgICBpZiAoKF9sZyArIDEpICogX3NtID49IGNlbGxzKSB7XG4gICAgICAgICAgICBsYXJnZShfbGcgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hbGwoX3NtICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICAgIHZhciBjZWxsSGVpZ2h0ID0gYmIuaCAvIHJvd3M7XG5cbiAgICAgIGlmIChvcHRpb25zLmNvbmRlbnNlKSB7XG4gICAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICAgIGNlbGxIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgICBpZiAocG9zLnggPT0gbnVsbCB8fCBwb3MueSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBmb3IgYmJcbiAgICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICAgIHBvcy55ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmJiID0gbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBwID0gb3B0aW9ucy5hdm9pZE92ZXJsYXBQYWRkaW5nO1xuICAgICAgICAgIHZhciB3ID0gbmJiLncgKyBwO1xuICAgICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuICAgICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KGNlbGxXaWR0aCwgdyk7XG4gICAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KGNlbGxIZWlnaHQsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjZWxsVXNlZCA9IHt9OyAvLyBlLmcuICdjLTAtMicgPT4gdHJ1ZVxuXG4gICAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uIHVzZWQocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgICB9OyAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuXG5cbiAgICAgIHZhciByb3cgPSAwO1xuICAgICAgdmFyIGNvbCA9IDA7XG5cbiAgICAgIHZhciBtb3ZlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uIG1vdmVUb05leHRDZWxsKCkge1xuICAgICAgICBjb2wrKztcblxuICAgICAgICBpZiAoY29sID49IGNvbHMpIHtcbiAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcblxuXG4gICAgICB2YXIgaWQybWFuUG9zID0ge307XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcblxuICAgICAgICBpZiAocmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgICAgdmFyIF9wb3MgPSB7XG4gICAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChfcG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICAgIF9wb3MuY29sID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgICBfcG9zLmNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3Bvcy5yb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmluZCB1bnVzZWQgcm93XG4gICAgICAgICAgICBfcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgICAgX3Bvcy5yb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZDJtYW5Qb3NbX25vZGUuaWQoKV0gPSBfcG9zO1xuICAgICAgICAgIHVzZShfcG9zLnJvdywgX3Bvcy5jb2wpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICBpZiAoZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzUGFyZW50KCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG5cblxuICAgICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbZWxlbWVudC5pZCgpXTtcblxuICAgICAgICBpZiAocmNQb3MpIHtcbiAgICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICB3aGlsZSAodXNlZChyb3csIGNvbCkpIHtcbiAgICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgICAgdXNlKHJvdywgY29sKTtcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQyID0ge1xuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAgIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3BcblxuICB9OyAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcblxuICBmdW5jdGlvbiBOdWxsTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDIsIG9wdGlvbnMpO1xuICB9IC8vIHJ1bnMgdGhlIGxheW91dFxuXG5cbiAgTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpczsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIChkaXNhYmxlIGVzbGludCBmb3IgbmV4dCBsaW5lIGFzIHRoaXMgc2VydmVzIGFzIGV4YW1wbGUgbGF5b3V0IGNvZGUgdG8gZXh0ZXJuYWwgZGV2ZWxvcGVycylcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIG9wdGlvbnMuY3k7XG4gICAgbGF5b3V0LmVtaXQoJ2xheW91dHN0YXJ0Jyk7IC8vIHB1dHMgYWxsIG5vZGVzIGF0ICgwLCAwKVxuICAgIC8vIG4uYi4gbW9zdCBsYXlvdXRzIHdvdWxkIHVzZSBsYXlvdXRQb3NpdGlvbnMoKSwgaW5zdGVhZCBvZiBwb3NpdGlvbnMoKSBhbmQgbWFudWFsIGV2ZW50c1xuXG4gICAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH0pOyAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG5cbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC5lbWl0KCdsYXlvdXRyZWFkeScpOyAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgbGF5b3V0LmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTsgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5cblxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQxID0ge1xuICAgIHBvc2l0aW9uczogdW5kZWZpbmVkLFxuICAgIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gICAgem9vbTogdW5kZWZpbmVkLFxuICAgIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBwYW46IHVuZGVmaW5lZCxcbiAgICAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbiAgfTtcblxuICBmdW5jdGlvbiBQcmVzZXRMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMSwgb3B0aW9ucyk7XG4gIH1cblxuICBQcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgdmFyIHBvc0lzRm4gPSBmbiQ2KG9wdGlvbnMucG9zaXRpb25zKTtcblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb3B5UG9zaXRpb24obm9kZS5wb3NpdGlvbigpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc0lzRm4pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgICAgaWYgKHBvcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgIGlmIChub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIGZpdCBwYWRkaW5nXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJhbmRvbUxheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBSYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KTtcblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3Mobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi53KSxcbiAgICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi5oKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBsYXlvdXQgPSBbe1xuICAgIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICAgIGltcGw6IEJyZWFkdGhGaXJzdExheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ2NpcmNsZScsXG4gICAgaW1wbDogQ2lyY2xlTGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAnY29uY2VudHJpYycsXG4gICAgaW1wbDogQ29uY2VudHJpY0xheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ2Nvc2UnLFxuICAgIGltcGw6IENvc2VMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdncmlkJyxcbiAgICBpbXBsOiBHcmlkTGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAnbnVsbCcsXG4gICAgaW1wbDogTnVsbExheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ3ByZXNldCcsXG4gICAgaW1wbDogUHJlc2V0TGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAncmFuZG9tJyxcbiAgICBpbXBsOiBSYW5kb21MYXlvdXRcbiAgfV07XG5cbiAgZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IDA7IC8vIGZvciB0ZXN0aW5nXG4gIH1cblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuICB2YXIgdGhyb3dJbWdFcnIgPSBmdW5jdGlvbiB0aHJvd0ltZ0VycigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgaGVhZGxlc3MgaW5zdGFuY2UgY2FuIG5vdCByZW5kZXIgaW1hZ2VzJyk7XG4gIH07XG5cbiAgTnVsbFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IG5vb3AsXG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMrKztcbiAgICB9LFxuICAgIGluaXQ6IG5vb3AsXG4gICAgaXNIZWFkbGVzczogZnVuY3Rpb24gaXNIZWFkbGVzcygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcG5nOiB0aHJvd0ltZ0VycixcbiAgICBqcGc6IHRocm93SW1nRXJyXG4gIH07XG5cbiAgdmFyIEJScCRmID0ge307XG4gIEJScCRmLmFycm93U2hhcGVXaWR0aCA9IDAuMztcblxuICBCUnAkZi5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJvd1NoYXBlcyA9IHRoaXMuYXJyb3dTaGFwZXMgPSB7fTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzOyAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAgIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gICAgLy8gKDAsIDEpIGlzIGRpcmVjdGlvbiB0b3dhcmRzIG5vZGVcbiAgICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uYWwgYXBpOlxuICAgIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gICAgLy8gZHJhdzogZHJhd1xuICAgIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICAgIHZhciBiYkNvbGxpZGUgPSBmdW5jdGlvbiBiYkNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgICAgdmFyIHkxID0gdHJhbnNsYXRpb24ueSAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgICB2YXIgaW5zaWRlID0geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHhTY2FsZWQgPSB4Um90YXRlZCAqIHNpemU7XG4gICAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcbiAgICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocHRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICAgICAgcmV0UHRzLnB1c2godHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0UHRzO1xuICAgIH07XG5cbiAgICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiBwb2ludHNUb0FycihwdHMpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwdHNbaV07XG4gICAgICAgIHJldC5wdXNoKHAueCwgcC55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS5wZlZhbHVlICogMjtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICAgIGlmIChzdHJpbmcoZGVmbikpIHtcbiAgICAgICAgZGVmbiA9IGFycm93U2hhcGVzW2RlZm5dO1xuICAgICAgfVxuXG4gICAgICBhcnJvd1NoYXBlc1tuYW1lXSA9IGV4dGVuZCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZykge1xuICAgICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgICAgIHZhciBwb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2FwOiBzdGFuZGFyZEdhcFxuICAgICAgfSwgZGVmbik7XG4gICAgfTtcblxuICAgIGRlZmluZUFycm93U2hhcGUoJ25vbmUnLCB7XG4gICAgICBjb2xsaWRlOiBmYWxzaWZ5LFxuICAgICAgcm91Z2hDb2xsaWRlOiBmYWxzaWZ5LFxuICAgICAgZHJhdzogbm9vcCQxLFxuICAgICAgc3BhY2luZzogemVyb2lmeSxcbiAgICAgIGdhcDogemVyb2lmeVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlJywge1xuICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjNdXG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnYXJyb3cnLCAndHJpYW5nbGUnKTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgICBwb2ludHM6IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICAgIGNvbnRyb2xQb2ludDogWzAsIC0wLjE1XSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHZhciBjdHJsUHQgPSB0aGlzLmNvbnRyb2xQb2ludDtcbiAgICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyk7XG4gICAgICB9LFxuICAgICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtdGVlJywge1xuICAgICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgICAgcG9pbnRzVGVlOiBbLTAuMTUsIC0wLjQsIC0wLjE1LCAtMC41LCAwLjE1LCAtMC41LCAwLjE1LCAtMC40XSxcbiAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRlZVB0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlLXRyaWFuZ2xlJywge1xuICAgICAgcmFkaXVzOiAwLjE1LFxuICAgICAgcG9pbnRzVHI6IFswLCAtMC4xNSwgMC4xNSwgLTAuNDUsIC0wLjE1LCAtMC40NSwgMCwgLTAuMTVdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgY2lyY2xlSW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IGNpcmNsZUluc2lkZTtcbiAgICAgIH0sXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUciwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgICB9LFxuICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgICAgYmFzZUNyb3NzTGluZVB0czogWy0wLjE1LCAtMC40LCAvLyBmaXJzdCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgIC0wLjE1LCAtMC40LCAwLjE1LCAtMC40LCAvLyBzZWNvbmQgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAwLjE1LCAtMC40XSxcbiAgICAgIGNyb3NzTGluZVB0czogZnVuY3Rpb24gY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCkge1xuICAgICAgICAvLyBzaGlmdCBwb2ludHMgc28gdGhhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3Jvc3MgcG9pbnRzIG1hdGNoZXMgZWRnZSB3aWR0aFxuICAgICAgICB2YXIgcCA9IHRoaXMuYmFzZUNyb3NzTGluZVB0cy5zbGljZSgpO1xuICAgICAgICB2YXIgc2hpZnRGYWN0b3IgPSBlZGdlV2lkdGggLyBzaXplO1xuICAgICAgICB2YXIgeTAgPSAzO1xuICAgICAgICB2YXIgeTEgPSA1O1xuICAgICAgICBwW3kwXSA9IHBbeTBdIC0gc2hpZnRGYWN0b3I7XG4gICAgICAgIHBbeTFdID0gcFt5MV0gLSBzaGlmdEZhY3RvcjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgIH0sXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndmVlJywge1xuICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjMsIDAsIC0wLjE1XSxcbiAgICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC41MjU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlJywge1xuICAgICAgcmFkaXVzOiAwLjE1LFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgaW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgIH0sXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICAgIH0sXG4gICAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndGVlJywge1xuICAgICAgcG9pbnRzOiBbLTAuMTUsIDAsIC0wLjE1LCAtMC4xLCAwLjE1LCAtMC4xLCAwLjE1LCAwXSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0sXG4gICAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3NxdWFyZScsIHtcbiAgICAgIHBvaW50czogWy0wLjE1LCAwLjAwLCAwLjE1LCAwLjAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM11cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdkaWFtb25kJywge1xuICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjE1LCAwLCAtMC4zLCAwLjE1LCAtMC4xNSwgMCwgMF0sXG4gICAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnY2hldnJvbicsIHtcbiAgICAgIHBvaW50czogWzAsIDAsIC0wLjE1LCAtMC4xNSwgLTAuMSwgLTAuMiwgMCwgLTAuMSwgMC4xLCAtMC4yLCAwLjE1LCAtMC4xNV0sXG4gICAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICAgIHJldHVybiAwLjk1ICogZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBCUnAkZSA9IHt9OyAvLyBQcm9qZWN0IG1vdXNlXG5cbiAgQlJwJGUucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICB2YXIgc2NhbGUgPSBvZmZzZXRzWzRdO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgeCA9ICgoY2xpZW50WCAtIG9mZnNldExlZnQpIC8gc2NhbGUgLSBwYW4ueCkgLyB6b29tO1xuICAgIHZhciB5ID0gKChjbGllbnRZIC0gb2Zmc2V0VG9wKSAvIHNjYWxlIC0gcGFuLnkpIC8gem9vbTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xuXG4gIEJScCRlLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyQkIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHN0eWxlVmFsdWUobmFtZSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgfTtcblxuICAgIHZhciBwYWRkaW5nID0ge1xuICAgICAgbGVmdDogc3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXG4gICAgICByaWdodDogc3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLFxuICAgICAgdG9wOiBzdHlsZVZhbHVlKCdwYWRkaW5nLXRvcCcpLFxuICAgICAgYm90dG9tOiBzdHlsZVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgfTtcbiAgICB2YXIgYm9yZGVyID0ge1xuICAgICAgbGVmdDogc3R5bGVWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSxcbiAgICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICAgIHRvcDogc3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpLFxuICAgICAgYm90dG9tOiBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgICB9O1xuICAgIHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB2YXIgcGFkZGluZ0hvciA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgdmFyIHBhZGRpbmdWZXIgPSBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICAgIHZhciBib3JkZXJIb3IgPSBib3JkZXIubGVmdCArIGJvcmRlci5yaWdodDtcbiAgICB2YXIgc2NhbGUgPSByZWN0LndpZHRoIC8gKGNsaWVudFdpZHRoICsgYm9yZGVySG9yKTtcbiAgICB2YXIgdW5zY2FsZWRXID0gY2xpZW50V2lkdGggLSBwYWRkaW5nSG9yO1xuICAgIHZhciB1bnNjYWxlZEggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVmVyO1xuICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgcGFkZGluZy5sZWZ0ICsgYm9yZGVyLmxlZnQ7XG4gICAgdmFyIHRvcCA9IHJlY3QudG9wICsgcGFkZGluZy50b3AgKyBib3JkZXIudG9wO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCID0gW2xlZnQsIHRvcCwgdW5zY2FsZWRXLCB1bnNjYWxlZEgsIHNjYWxlXTtcbiAgfTtcblxuICBCUnAkZS5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG4gIH07XG5cbiAgQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZE5lYXJlc3RFbGVtZW50cyh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaClbMF07XG4gIH07XG5cbiAgQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgdmFyIG5lYXIgPSBbXTsgLy8gMSBub2RlIG1heCwgMSBlZGdlIG1heFxuXG4gICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gci5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICAgIHZhciBub2RlVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICAgIHZhciBsYWJlbFRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gICAgdmFyIG5lYXJFZGdlO1xuICAgIHZhciBuZWFyTm9kZTtcblxuICAgIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgICAgZWxlcyA9IGVsZXMuaW50ZXJhY3RpdmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRWxlKGVsZSwgc3FEaXN0KSB7XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGlmIChuZWFyTm9kZSkge1xuICAgICAgICAgIHJldHVybjsgLy8gY2FuJ3QgcmVwbGFjZSBub2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVhck5vZGUgPSBlbGU7XG4gICAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgICBpZiAobmVhckVkZ2UpIHtcbiAgICAgICAgICAvLyB0aGVuIHJlcGxhY2UgZXhpc3RpbmcgZWRnZVxuICAgICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgICAgaWYgKG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgJiYgbmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgICAgbmVhcltpXSA9IGVsZTtcbiAgICAgICAgICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKSB7XG4gICAgICB2YXIgd2lkdGggPSBub2RlLm91dGVyV2lkdGgoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICYmIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICAgKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IHIubm9kZVNoYXBlc1tzZWxmLmdldE5vZGVTaGFwZShub2RlKV07XG5cbiAgICAgICAgaWYgKHNoYXBlLmNoZWNrUG9pbnQoeCwgeSwgMCwgd2lkdGgsIGhlaWdodCwgcG9zLngsIHBvcy55KSkge1xuICAgICAgICAgIGFkZEVsZShub2RlLCAwKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICAgIHZhciB3aWR0aCA9IHN0eWxlV2lkdGggLyAyICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG5cbiAgICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcURpc3Q7XG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGlmIChpbkxpbmVWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKSkpIHtcbiAgICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgaWYgKGluQmV6aWVyVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdKSkpIHtcbiAgICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBlZGdlIGJ1dCBkaWRuJ3QgaGl0IGl0LCBtYXliZSB3ZSBoaXQgaXRzIGFycm93c1xuXG5cbiAgICAgIHZhciBzcmMgPSBzcmMgfHwgX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IHRndCB8fCBfcC50YXJnZXQ7XG4gICAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKHN0eWxlV2lkdGgsIHNjYWxlKTtcbiAgICAgIHZhciBhcnJvd3MgPSBbe1xuICAgICAgICBuYW1lOiAnc291cmNlJyxcbiAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgIHk6IHJzLmFycm93U3RhcnRZLFxuICAgICAgICBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAndGFyZ2V0JyxcbiAgICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgICB5OiBycy5hcnJvd0VuZFksXG4gICAgICAgIGFuZ2xlOiBycy50Z3RBcnJvd0FuZ2xlXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtaWQtc291cmNlJyxcbiAgICAgICAgeDogcnMubWlkWCxcbiAgICAgICAgeTogcnMubWlkWSxcbiAgICAgICAgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21pZC10YXJnZXQnLFxuICAgICAgICB4OiBycy5taWRYLFxuICAgICAgICB5OiBycy5taWRZLFxuICAgICAgICBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZVxuICAgICAgfV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1tlZGdlLnBzdHlsZShhci5uYW1lICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlXTtcbiAgICAgICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG5cbiAgICAgICAgaWYgKHNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgICAgeDogYXIueCxcbiAgICAgICAgICB5OiBhci55XG4gICAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkgJiYgc2hhcGUuY29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgICAgeDogYXIueCxcbiAgICAgICAgICB5OiBhci55XG4gICAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG5cblxuICAgICAgaWYgKGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hlY2tOb2RlKHNyYyk7XG4gICAgICAgIGNoZWNrTm9kZSh0Z3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb3Aob2JqLCBuYW1lLCBwcmUpIHtcbiAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgbmFtZSwgcHJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0xhYmVsKGVsZSwgcHJlZml4KSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICAgIHZhciBwcmVmaXhEYXNoO1xuXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgdmFyIGJiID0gX3AubGFiZWxCb3VuZHNbcHJlZml4IHx8ICdtYWluJ107XG4gICAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnZhbHVlO1xuICAgICAgdmFyIGV2ZW50c0VuYWJsZWQgPSBlbGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcblxuICAgICAgaWYgKCFldmVudHNFbmFibGVkIHx8ICF0ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGx4ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgICB2YXIgbHkgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICAgIHZhciB0aGV0YSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcbiAgICAgIHZhciBveCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICAgIHZhciBveSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICAgIHZhciBseDEgPSBiYi54MSAtIHRoIC0gb3g7IC8vICgtb3gsIC1veSkgYXMgYmIgYWxyZWFkeSBpbmNsdWRlcyBtYXJnaW5cblxuICAgICAgdmFyIGx4MiA9IGJiLngyICsgdGggLSBveDsgLy8gYW5kIHJvdGF0aW9uIGlzIGFib3V0IChseCwgbHkpXG5cbiAgICAgIHZhciBseTEgPSBiYi55MSAtIHRoIC0gb3k7XG4gICAgICB2YXIgbHkyID0gYmIueTIgKyB0aCAtIG95O1xuXG4gICAgICBpZiAodGhldGEpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgICB4ID0geCAtIGx4O1xuICAgICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgbHgsXG4gICAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgICB2YXIgcG9pbnRzID0gWy8vIHdpdGggdGhlIG1hcmdpbiBhZGRlZCBhZnRlciB0aGUgcm90YXRpb24gaXMgYXBwbGllZFxuICAgICAgICBweDF5MS54ICsgb3gsIHB4MXkxLnkgKyBveSwgcHgyeTEueCArIG94LCBweDJ5MS55ICsgb3ksIHB4MnkyLnggKyBveCwgcHgyeTIueSArIG95LCBweDF5Mi54ICsgb3gsIHB4MXkyLnkgKyBveV07XG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIGEgY2hlYXBlciBiYiBjaGVja1xuICAgICAgICBpZiAoaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBjaGVja05vZGUoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGVkZ2VcbiAgICAgICAgY2hlY2tFZGdlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpIHx8IGNoZWNrTGFiZWwoZWxlLCAnc291cmNlJykgfHwgY2hlY2tMYWJlbChlbGUsICd0YXJnZXQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVhcjtcbiAgfTsgLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuXG5cbiAgQlJwJGUuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5pbnRlcmFjdGl2ZTtcbiAgICB2YXIgYm94ID0gW107XG4gICAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgdmFyIHkxYyA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG4gICAgeDEgPSB4MWM7XG4gICAgeDIgPSB4MmM7XG4gICAgeTEgPSB5MWM7XG4gICAgeTIgPSB5MmM7XG4gICAgdmFyIGJveEJiID0gbWFrZUJvdW5kaW5nQm94KHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHkxOiB5MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkyOiB5MlxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tlXTtcblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGVsZTtcbiAgICAgICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgICBpbmNsdWRlRWRnZXM6IGZhbHNlLFxuICAgICAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJveEJiLCBub2RlQmIpICYmICFib3VuZGluZ0JveEluQm91bmRpbmdCb3gobm9kZUJiLCBib3hCYikpIHtcbiAgICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuXG4gICAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgIHZhciBwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzIHx8IF9wLnJzdHlsZS5saW5lUHRzIHx8IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgICB2YXIgYWxsSW5zaWRlID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXBvaW50SW5Cb3VuZGluZ0JveChib3hCYiwgcHRzW2ldKSkge1xuICAgICAgICAgICAgICBhbGxJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbEluc2lkZSkge1xuICAgICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xuICB9O1xuXG4gIHZhciBCUnAkZCA9IHt9O1xuXG4gIEJScCRkLmNhbGN1bGF0ZUFycm93QW5nbGVzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gICAgdmFyIGlzQmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdiZXppZXInO1xuICAgIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gICAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgICB2YXIgaXNDb21wb3VuZCA9IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnO1xuICAgIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnOyAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cblxuICAgIHZhciBkaXNwWCwgZGlzcFk7XG4gICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBtaWRYLCBtaWRZO1xuXG4gICAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgICAgc3RhcnRZID0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgICBlbmRYID0gcnMuYXJyb3dFbmRYO1xuICAgICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgICB9XG5cbiAgICBtaWRYID0gcnMubWlkWDtcbiAgICBtaWRZID0gcnMubWlkWTsgLy8gc291cmNlXG4gICAgLy9cblxuICAgIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgICBkaXNwWCA9IHN0YXJ0WCAtIHJzLnNlZ3B0c1swXTtcbiAgICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICAgIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0Jlemllcikge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEpO1xuICAgICAgdmFyIGJZID0gcWJlemllckF0KHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMSk7XG4gICAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICAgIH1cblxuICAgIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIG1pZCB0YXJnZXRcbiAgICAvL1xuXG4gICAgdmFyIG1pZFggPSBycy5taWRYO1xuICAgIHZhciBtaWRZID0gcnMubWlkWTtcblxuICAgIGlmIChpc0hheXN0YWNrKSB7XG4gICAgICBtaWRYID0gKHN0YXJ0WCArIGVuZFgpIC8gMjtcbiAgICAgIG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyO1xuICAgIH1cblxuICAgIGRpc3BYID0gZW5kWCAtIHN0YXJ0WDtcbiAgICBkaXNwWSA9IGVuZFkgLSBzdGFydFk7XG5cbiAgICBpZiAoaXNTZWdtZW50cykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgICAgdmFyIGkzID0gaTIgKyAyO1xuICAgICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgdmFyIGNwdHMgPSBycy5jdHJscHRzO1xuICAgICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgICB2YXIgYnAxeCwgYnAxeTtcblxuICAgICAgaWYgKGNwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG5cbiAgICAgICAgdmFyIGljID0gcDAgKyAyO1xuICAgICAgICB2YXIgcDEgPSBpYyArIDI7XG4gICAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wKTtcbiAgICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjApO1xuICAgICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMDAwMSk7XG4gICAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wMDAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpYyA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gY3RycHRcblxuICAgICAgICB2YXIgcDAgPSBpYyAtIDI7IC8vIHN0YXJ0cHRcblxuICAgICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjQ5OTkpO1xuICAgICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNDk5OSk7XG4gICAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC41KTtcbiAgICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjUpO1xuICAgICAgfVxuXG4gICAgICBkaXNwWCA9IGJwMXggLSBicDB4O1xuICAgICAgZGlzcFkgPSBicDF5IC0gYnAweTtcbiAgICB9XG5cbiAgICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICAgIHJzLm1pZERpc3BYID0gZGlzcFg7XG4gICAgcnMubWlkRGlzcFkgPSBkaXNwWTsgLy8gbWlkIHNvdXJjZVxuICAgIC8vXG5cbiAgICBkaXNwWCAqPSAtMTtcbiAgICBkaXNwWSAqPSAtMTtcblxuICAgIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSA7IGVsc2Uge1xuICAgICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICAgIHZhciBpMyA9IGkyICsgMjtcbiAgICAgICAgZGlzcFggPSAtKHB0c1tpM10gLSBwdHNbaTJdKTtcbiAgICAgICAgZGlzcFkgPSAtKHB0c1tpMyArIDFdIC0gcHRzW2kyICsgMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIHRhcmdldFxuICAgIC8vXG5cbiAgICBpZiAoaXNTZWdtZW50cykge1xuICAgICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICAgIGRpc3BZID0gZW5kWSAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgdmFyIGwgPSBwdHMubGVuZ3RoO1xuICAgICAgdmFyIGJYID0gcWJlemllckF0KHB0c1tsIC0gNl0sIHB0c1tsIC0gNF0sIHB0c1tsIC0gMl0sIDAuOSk7XG4gICAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzW2wgLSA1XSwgcHRzW2wgLSAzXSwgcHRzW2wgLSAxXSwgMC45KTtcbiAgICAgIGRpc3BYID0gZW5kWCAtIGJYO1xuICAgICAgZGlzcFkgPSBlbmRZIC0gYlk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BYID0gZW5kWCAtIG1pZFg7XG4gICAgICBkaXNwWSA9IGVuZFkgLSBtaWRZO1xuICAgIH1cblxuICAgIHJzLnRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG4gIH07XG5cbiAgQlJwJGQuZ2V0QXJyb3dXaWR0aCA9IEJScCRkLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24gKGVkZ2VXaWR0aCwgc2NhbGUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdO1xuXG4gICAgaWYgKGNhY2hlZFZhbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9XG5cbiAgICBjYWNoZWRWYWwgPSBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpICogc2NhbGU7XG4gICAgY2FjaGVbZWRnZVdpZHRoICsgJywgJyArIHNjYWxlXSA9IGNhY2hlZFZhbDtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9O1xuXG4gIHZhciBCUnAkYyA9IHt9O1xuXG4gIEJScCRjLmZpbmRIYXlzdGFja1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgIGlmICghcnMuaGF5c3RhY2spIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBycy5zb3VyY2UgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgICBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgcnMudGFyZ2V0ID0ge1xuICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ2hheXN0YWNrLXJhZGl1cycpLnZhbHVlO1xuICAgICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICBycy5oYXlzdGFja1B0cyA9IHJzLmFsbHB0cyA9IFtycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueSwgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LCBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnldO1xuICAgICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICAgIHJzLm1pZFkgPSAocnMuYWxscHRzWzFdICsgcnMuYWxscHRzWzNdKSAvIDI7IC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG5cbiAgICAgIHJzLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICAgIHJzLmhheXN0YWNrID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoZWRnZSk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKGVkZ2UpO1xuICAgICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhlZGdlKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZmluZFNlZ21lbnRzUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gICAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICAgICAgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzLFxuICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gICAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXdlaWdodHMnKTtcbiAgICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtZGlzdGFuY2VzJyk7XG4gICAgdmFyIHNlZ21lbnRzTiA9IE1hdGgubWluKHNlZ21lbnRXcy5wZlZhbHVlLmxlbmd0aCwgc2VnbWVudERzLnBmVmFsdWUubGVuZ3RoKTtcbiAgICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gICAgcnMuc2VncHRzID0gW107XG5cbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNlZ21lbnRzTjsgcysrKSB7XG4gICAgICB2YXIgdyA9IHNlZ21lbnRXcy5wZlZhbHVlW3NdO1xuICAgICAgdmFyIGQgPSBzZWdtZW50RHMucGZWYWx1ZVtzXTtcbiAgICAgIHZhciB3MSA9IDEgLSB3O1xuICAgICAgdmFyIHcyID0gdztcbiAgICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgIH07XG4gICAgICBycy5zZWdwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGQpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYy5maW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgLy8gU2VsZi1lZGdlXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgZGlyQ291bnRzID0gcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgICBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3M7XG4gICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gICAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxvb3BEaXIgPSBlZGdlLnBzdHlsZSgnbG9vcC1kaXJlY3Rpb24nKS5wZlZhbHVlO1xuICAgIHZhciBsb29wU3dwID0gZWRnZS5wc3R5bGUoJ2xvb3Atc3dlZXAnKS5wZlZhbHVlO1xuICAgIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gICAgdmFyIGogPSBpO1xuICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgaiA9IDA7XG4gICAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgfVxuXG4gICAgdmFyIGxvb3BBbmdsZSA9IGxvb3BEaXIgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgb3V0QW5nbGUgPSBsb29wQW5nbGUgLSBsb29wU3dwIC8gMjtcbiAgICB2YXIgaW5BbmdsZSA9IGxvb3BBbmdsZSArIGxvb3BTd3AgLyAyOyAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuXG4gICAgdmFyIGRjID0gU3RyaW5nKGxvb3BEaXIgKyAnXycgKyBsb29wU3dwKTtcbiAgICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG4gICAgcnMuY3RybHB0cyA9IFtzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4ob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnggKyBNYXRoLmNvcyhpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXTtcbiAgfTtcblxuICBCUnAkYy5maW5kQ29tcG91bmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAvLyBDb21wb3VuZCBlZGdlXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICAgIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICAgIHZhciBqID0gaTtcbiAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIGogPSAwO1xuICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgIH1cblxuICAgIHZhciBsb29wVyA9IDUwO1xuICAgIHZhciBsb29wYVBvcyA9IHtcbiAgICAgIHg6IHNyY1Bvcy54IC0gc3JjVyAvIDIsXG4gICAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gICAgfTtcbiAgICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgICB4OiB0Z3RQb3MueCAtIHRndFcgLyAyLFxuICAgICAgeTogdGd0UG9zLnkgLSB0Z3RIIC8gMlxuICAgIH07XG4gICAgdmFyIGxvb3BQb3MgPSB7XG4gICAgICB4OiBNYXRoLm1pbihsb29wYVBvcy54LCBsb29wYlBvcy54KSxcbiAgICAgIHk6IE1hdGgubWluKGxvb3BhUG9zLnksIGxvb3BiUG9zLnkpXG4gICAgfTsgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG5cbiAgICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMC41O1xuICAgIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkpO1xuICAgIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkpO1xuICAgIHJzLmN0cmxwdHMgPSBbbG9vcFBvcy54LCBsb29wUG9zLnkgLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQSwgbG9vcFBvcy54IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEIsIGxvb3BQb3MueV07XG4gIH07XG5cbiAgQlJwJGMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgLy8gU3RyYWlnaHQgZWRnZSB3aXRoaW4gYnVuZGxlXG4gICAgZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG4gIH07XG5cbiAgQlJwJGMuZmluZEJlemllclBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSxcbiAgICAgICAgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHM7XG4gICAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICAgIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICAgIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXdlaWdodHMnKTtcbiAgICB2YXIgYmV6aWVyTiA9IGN0cmxwdERpc3RzICYmIGN0cmxwdFdzID8gTWF0aC5taW4oY3RybHB0RGlzdHMudmFsdWUubGVuZ3RoLCBjdHJscHRXcy52YWx1ZS5sZW5ndGgpIDogMTtcbiAgICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07IC8vIChNdWx0aSliZXppZXJcblxuICAgIHZhciBtdWx0aSA9IGVkZ2VJc1VuYnVuZGxlZDtcbiAgICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICAgIHJzLmN0cmxwdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrKSB7XG4gICAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckluZm8uZWxlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZSAqIChlZGdlSXNTd2FwcGVkID8gLTEgOiAxKTtcbiAgICAgIHZhciBtYW5jdHJscHREaXN0ID0gdm9pZCAwO1xuICAgICAgdmFyIHNpZ24gPSBzaWdudW0obm9ybWN0cmxwdERpc3QpO1xuXG4gICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG5cbiAgICAgICAgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbYl07XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgICAgLy8gbXVsdGkgb3Igc2luZ2xlIHVuYnVuZGxlZFxuICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBzaWduICogY3RybHB0RGlzdCA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuICAgICAgdmFyIHcxID0gMSAtIGN0cmxwdFdlaWdodDtcbiAgICAgIHZhciB3MiA9IGN0cmxwdFdlaWdodDtcbiAgICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgIH07XG4gICAgICBycy5jdHJscHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYy5maW5kVGF4aVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAgIC8vIFRheGljYWIgZ2VvbWV0cnkgd2l0aCB0d28gdHVybnMgbWF4aW11bVxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICAgIHZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG4gICAgdmFyIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIExFRlRXQVJEID0gJ2xlZnR3YXJkJztcbiAgICB2YXIgUklHSFRXQVJEID0gJ3JpZ2h0d2FyZCc7XG4gICAgdmFyIERPV05XQVJEID0gJ2Rvd253YXJkJztcbiAgICB2YXIgVVBXQVJEID0gJ3Vwd2FyZCc7XG4gICAgdmFyIEFVVE8gPSAnYXV0byc7XG4gICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gICAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgICB2YXIgZEluY2x1ZGVzTm9kZUJvZHkgPSBlZGdlRGlzdGFuY2VzICE9PSAnbm9kZS1wb3NpdGlvbic7XG4gICAgdmFyIHRheGlEaXIgPSBlZGdlLnBzdHlsZSgndGF4aS1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgICB2YXIgcmF3VGF4aURpciA9IHRheGlEaXI7IC8vIHVucHJvY2Vzc2VkIHZhbHVlXG5cbiAgICB2YXIgdGF4aVR1cm4gPSBlZGdlLnBzdHlsZSgndGF4aS10dXJuJyk7XG4gICAgdmFyIHR1cm5Jc1BlcmNlbnQgPSB0YXhpVHVybi51bml0cyA9PT0gJyUnO1xuICAgIHZhciB0YXhpVHVyblBmVmFsID0gdGF4aVR1cm4ucGZWYWx1ZTtcbiAgICB2YXIgdHVybklzTmVnYXRpdmUgPSB0YXhpVHVyblBmVmFsIDwgMDsgLy8gaS5lLiBmcm9tIHRhcmdldCBzaWRlXG5cbiAgICB2YXIgbWluRCA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJykucGZWYWx1ZTtcbiAgICB2YXIgZHcgPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNXICsgdGd0VykgLyAyIDogMDtcbiAgICB2YXIgZGggPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNIICsgdGd0SCkgLyAyIDogMDtcbiAgICB2YXIgcGR4ID0gcG9zUHRzLngyIC0gcG9zUHRzLngxO1xuICAgIHZhciBwZHkgPSBwb3NQdHMueTIgLSBwb3NQdHMueTE7IC8vIHRha2UgYXdheSB0aGUgZWZmZWN0aXZlIHcvaCBmcm9tIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGRlbHRhIHZhbHVlXG5cbiAgICB2YXIgc3ViRFdIID0gZnVuY3Rpb24gc3ViRFdIKGR4eSwgZHdoKSB7XG4gICAgICBpZiAoZHh5ID4gMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZHh5IC0gZHdoLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihkeHkgKyBkd2gsIDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHggPSBzdWJEV0gocGR4LCBkdyk7XG4gICAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICAgIHZhciBpc0V4cGxpY2l0RGlyID0gZmFsc2U7XG5cbiAgICBpZiAocmF3VGF4aURpciA9PT0gQVVUTykge1xuICAgICAgdGF4aURpciA9IE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSA/IEhPUklaT05UQUwgOiBWRVJUSUNBTDtcbiAgICB9IGVsc2UgaWYgKHJhd1RheGlEaXIgPT09IFVQV0FSRCB8fCByYXdUYXhpRGlyID09PSBET1dOV0FSRCkge1xuICAgICAgdGF4aURpciA9IFZFUlRJQ0FMO1xuICAgICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChyYXdUYXhpRGlyID09PSBMRUZUV0FSRCB8fCByYXdUYXhpRGlyID09PSBSSUdIVFdBUkQpIHtcbiAgICAgIHRheGlEaXIgPSBIT1JJWk9OVEFMO1xuICAgICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzVmVydCA9IHRheGlEaXIgPT09IFZFUlRJQ0FMO1xuICAgIHZhciBsID0gaXNWZXJ0ID8gZHkgOiBkeDtcbiAgICB2YXIgcGwgPSBpc1ZlcnQgPyBwZHkgOiBwZHg7XG4gICAgdmFyIHNnbkwgPSBzaWdudW0ocGwpO1xuICAgIHZhciBmb3JjZWREaXIgPSBmYWxzZTtcblxuICAgIGlmICghKGlzRXhwbGljaXREaXIgJiYgKHR1cm5Jc1BlcmNlbnQgfHwgdHVybklzTmVnYXRpdmUpKSAvLyBmb3JjaW5nIGluIHRoaXMgY2FzZSB3b3VsZCBjYXVzZSB3ZWlyZCBncm93aW5nIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAmJiAocmF3VGF4aURpciA9PT0gRE9XTldBUkQgJiYgcGwgPCAwIHx8IHJhd1RheGlEaXIgPT09IFVQV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gTEVGVFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCAmJiBwbCA8IDApKSB7XG4gICAgICBzZ25MICo9IC0xO1xuICAgICAgbCA9IHNnbkwgKiBNYXRoLmFicyhsKTtcbiAgICAgIGZvcmNlZERpciA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGQ7XG5cbiAgICBpZiAodHVybklzUGVyY2VudCkge1xuICAgICAgdmFyIHAgPSB0YXhpVHVyblBmVmFsIDwgMCA/IDEgKyB0YXhpVHVyblBmVmFsIDogdGF4aVR1cm5QZlZhbDtcbiAgICAgIGQgPSBwICogbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGsgPSB0YXhpVHVyblBmVmFsIDwgMCA/IGwgOiAwO1xuICAgICAgZCA9IGsgKyB0YXhpVHVyblBmVmFsICogc2duTDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0SXNUb29DbG9zZSA9IGZ1bmN0aW9uIGdldElzVG9vQ2xvc2UoZCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKGQpIDwgbWluRCB8fCBNYXRoLmFicyhkKSA+PSBNYXRoLmFicyhsKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzVG9vQ2xvc2VTcmMgPSBnZXRJc1Rvb0Nsb3NlKGQpO1xuICAgIHZhciBpc1Rvb0Nsb3NlVGd0ID0gZ2V0SXNUb29DbG9zZShNYXRoLmFicyhsKSAtIE1hdGguYWJzKGQpKTtcbiAgICB2YXIgaXNUb29DbG9zZSA9IGlzVG9vQ2xvc2VTcmMgfHwgaXNUb29DbG9zZVRndDtcblxuICAgIGlmIChpc1Rvb0Nsb3NlICYmICFmb3JjZWREaXIpIHtcbiAgICAgIC8vIG5vbi1pZGVhbCByb3V0aW5nXG4gICAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICAgIC8vIHZlcnRpY2FsIGZhbGxiYWNrc1xuICAgICAgICB2YXIgbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY0ggLyAyO1xuICAgICAgICB2YXIgbFNoYXBlSW5zaWRlVGd0ID0gTWF0aC5hYnMocGR4KSA8PSB0Z3RXIC8gMjtcblxuICAgICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgICB2YXIgeCA9IChwb3NQdHMueDEgKyBwb3NQdHMueDIpIC8gMjtcbiAgICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICAgIHkyID0gcG9zUHRzLnkyO1xuICAgICAgICAgIHJzLnNlZ3B0cyA9IFt4LCB5MSwgeCwgeTJdO1xuICAgICAgICB9IGVsc2UgaWYgKGxTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgICAgdmFyIHkgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG4gICAgICAgICAgdmFyIHgxID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgICB4MiA9IHBvc1B0cy54MjtcbiAgICAgICAgICBycy5zZWdwdHMgPSBbeDEsIHksIHgyLCB5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMLXNoYXBlIGZhbGxiYWNrICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIHdpdGggdHJlZSBzaWJsaW5ncylcbiAgICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngxLCBwb3NQdHMueTJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBob3Jpem9udGFsIGZhbGxiYWNrc1xuICAgICAgICB2YXIgX2xTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNXIC8gMjtcblxuICAgICAgICB2YXIgX2xTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeSkgPD0gdGd0SCAvIDI7XG5cbiAgICAgICAgaWYgKF9sU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgICB2YXIgX3kgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG5cbiAgICAgICAgICB2YXIgX3ggPSBwb3NQdHMueDEsXG4gICAgICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgICBycy5zZWdwdHMgPSBbX3gsIF95LCBfeDIsIF95XTtcbiAgICAgICAgfSBlbHNlIGlmIChfbFNoYXBlSW5zaWRlVGd0KSB7XG4gICAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgICAgdmFyIF94MyA9IChwb3NQdHMueDEgKyBwb3NQdHMueDIpIC8gMjtcblxuICAgICAgICAgIHZhciBfeTIgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICAgIF95MyA9IHBvc1B0cy55MjtcbiAgICAgICAgICBycy5zZWdwdHMgPSBbX3gzLCBfeTIsIF94MywgX3kzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIGZvciB0cmVlIHNpYmxpbmdzKVxuICAgICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDIsIHBvc1B0cy55MV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWRlYWwgcm91dGluZ1xuICAgICAgaWYgKGlzVmVydCkge1xuICAgICAgICB2YXIgX3k0ID0gcG9zUHRzLnkxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY0ggLyAyICogc2duTCA6IDApO1xuXG4gICAgICAgIHZhciBfeDQgPSBwb3NQdHMueDEsXG4gICAgICAgICAgICBfeDUgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtfeDQsIF95NCwgX3g1LCBfeTRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICB2YXIgX3g2ID0gcG9zUHRzLngxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY1cgLyAyICogc2duTCA6IDApO1xuXG4gICAgICAgIHZhciBfeTUgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtfeDYsIF95NSwgX3g2LCBfeTZdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAkYy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDsgLy8gY2FuIG9ubHkgY29ycmVjdCBiZXppZXJzIGZvciBub3cuLi5cblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICAgIHRndEggPSBwYWlySW5mby50Z3RILFxuICAgICAgICAgIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUsXG4gICAgICAgICAgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZTtcbiAgICAgIHZhciBiYWRTdGFydCA9ICFudW1iZXIkMShycy5zdGFydFgpIHx8ICFudW1iZXIkMShycy5zdGFydFkpO1xuICAgICAgdmFyIGJhZEFTdGFydCA9ICFudW1iZXIkMShycy5hcnJvd1N0YXJ0WCkgfHwgIW51bWJlciQxKHJzLmFycm93U3RhcnRZKTtcbiAgICAgIHZhciBiYWRFbmQgPSAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpO1xuICAgICAgdmFyIGJhZEFFbmQgPSAhbnVtYmVyJDEocnMuYXJyb3dFbmRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dFbmRZKTtcbiAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICAgIH0sIHtcbiAgICAgICAgeDogcnMuc3RhcnRYLFxuICAgICAgICB5OiBycy5zdGFydFlcbiAgICAgIH0pO1xuICAgICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgICAgdmFyIGVuZEFDcERpc3QgPSBkaXN0KHtcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgICAgfSwge1xuICAgICAgICB4OiBycy5lbmRYLFxuICAgICAgICB5OiBycy5lbmRZXG4gICAgICB9KTtcbiAgICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCkge1xuICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7IC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuXG4gICAgICAgIHZhciBjcEQgPSB7XG4gICAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gc3JjUG9zLngsXG4gICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoY3BELnggKiBjcEQueCArIGNwRC55ICogY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuXG4gICAgICAgIHZhciBjcE0gPSB7XG4gICAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgIH07XG4gICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgICAgdmFyIGNwUHJvaiA9IHtcbiAgICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIGNwUHJvai54LCBjcFByb2oueSwgMCk7XG5cbiAgICAgICAgaWYgKGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwKSB7XG4gICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTsgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG5cbiAgICAgICAgdmFyIF9jcEQgPSB7XG4gICAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHRndFBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9jcEwgPSBNYXRoLnNxcnQoX2NwRC54ICogX2NwRC54ICsgX2NwRC55ICogX2NwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcblxuXG4gICAgICAgIHZhciBfY3BNID0ge1xuICAgICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICB4OiBfY3BELnggLyBfY3BMLFxuICAgICAgICAgIHk6IF9jcEQueSAvIF9jcExcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3JhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuXG4gICAgICAgIHZhciBfY3BQcm9qID0ge1xuICAgICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgX2NwTS54ICogMiAqIF9yYWRpdXMsXG4gICAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIDIgKiBfcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIF9jcFByb2oueCwgX2NwUHJvai55LCAwKTtcblxuICAgICAgICBpZiAoY2xvc2VFbmRBQ3ApIHtcbiAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSB0Z3RDdHJsUHRJbnRuWzBdICsgX2NwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICBycy5jdHJscHRzWzFdID0gdGd0Q3RybFB0SW50blsxXSArIF9jcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgICAgIC8vIHJlY2FsYyBlbmRwdHNcbiAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAkYy5zdG9yZUFsbHB0cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgcnMuYWxscHRzID0gW107XG4gICAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG5cbiAgICAgIGZvciAodmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIpIHtcbiAgICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgICAgcnMuYWxscHRzLnB1c2gocnMuY3RybHB0c1tiXSwgcnMuY3RybHB0c1tiICsgMV0pOyAvLyB0aGUgbWlkcHQgYmV0d2VlbiBjdHJscHRzIGFzIGludGVybWVkaWF0ZSBkZXN0aW5hdGlvbiBwdHNcblxuICAgICAgICBpZiAoYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCkge1xuICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKChycy5jdHJscHRzW2JdICsgcnMuY3RybHB0c1tiICsgMl0pIC8gMiwgKHJzLmN0cmxwdHNbYiArIDFdICsgcnMuY3RybHB0c1tiICsgM10pIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG4gICAgICB2YXIgbSwgbXQ7XG5cbiAgICAgIGlmIChycy5jdHJscHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICAgIHJzLm1pZFggPSBycy5hbGxwdHNbbV07XG4gICAgICAgIHJzLm1pZFkgPSBycy5hbGxwdHNbbSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMztcbiAgICAgICAgbXQgPSAwLjU7XG4gICAgICAgIHJzLm1pZFggPSBxYmV6aWVyQXQocnMuYWxscHRzW21dLCBycy5hbGxwdHNbbSArIDJdLCBycy5hbGxwdHNbbSArIDRdLCBtdCk7XG4gICAgICAgIHJzLm1pZFkgPSBxYmV6aWVyQXQocnMuYWxscHRzW20gKyAxXSwgcnMuYWxscHRzW20gKyAzXSwgcnMuYWxscHRzW20gKyA1XSwgbXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICAgIHJzLmFsbHB0cyA9IFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWV07IC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcblxuICAgICAgcnMubWlkWCA9IChycy5zdGFydFggKyBycy5lbmRYICsgcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFgpIC8gNDtcbiAgICAgIHJzLm1pZFkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSArIHJzLmFycm93U3RhcnRZICsgcnMuYXJyb3dFbmRZKSAvIDQ7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgcnMuYWxscHRzID0gW107XG4gICAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgICBycy5hbGxwdHMucHVzaC5hcHBseShycy5hbGxwdHMsIHJzLnNlZ3B0cyk7XG4gICAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcblxuICAgICAgaWYgKHJzLnNlZ3B0cy5sZW5ndGggJSA0ID09PSAwKSB7XG4gICAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICAgIHJzLm1pZFggPSAocnMuc2VncHRzW2kxXSArIHJzLnNlZ3B0c1tpMl0pIC8gMjtcbiAgICAgICAgcnMubWlkWSA9IChycy5zZWdwdHNbaTEgKyAxXSArIHJzLnNlZ3B0c1tpMiArIDFdKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2kgPSBycy5zZWdwdHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1tfaV07XG4gICAgICAgIHJzLm1pZFkgPSBycy5zZWdwdHNbX2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiAocnMubm9kZXNPdmVybGFwIHx8IG51bWJlciQxKHJzLnN0YXJ0WCkgJiYgbnVtYmVyJDEocnMuc3RhcnRZKSAmJiBudW1iZXIkMShycy5lbmRYKSAmJiBudW1iZXIkMShycy5lbmRZKSkge1xuICAgICAgcnMubG9nZ2VkRXJyID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcnMubG9nZ2VkRXJyKSB7XG4gICAgICAgIHJzLmxvZ2dlZEVyciA9IHRydWU7XG4gICAgICAgIHdhcm4oJ0VkZ2UgYCcgKyBlZGdlLmlkKCkgKyAnYCBoYXMgaW52YWxpZCBlbmRwb2ludHMgYW5kIHNvIGl0IGlzIGltcG9zc2libGUgdG8gZHJhdy4gIEFkanVzdCB5b3VyIGVkZ2Ugc3R5bGUgKGUuZy4gY29udHJvbCBwb2ludHMpIGFjY29yZGluZ2x5IG9yIHVzZSBhbiBhbHRlcm5hdGl2ZSBlZGdlIHR5cGUuICBUaGlzIGlzIGV4cGVjdGVkIGJlaGF2aW91ciB3aGVuIHRoZSBzb3VyY2Ugbm9kZSBhbmQgdGhlIHRhcmdldCBub2RlIG92ZXJsYXAuJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmZpbmRFZGdlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGhhc2hUYWJsZSA9IHtcbiAgICAgIG1hcDogbmV3IE1hcCQyKCksXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChwYWlySWQpIHtcbiAgICAgICAgdmFyIG1hcDIgPSB0aGlzLm1hcC5nZXQocGFpcklkWzBdKTtcblxuICAgICAgICBpZiAobWFwMiAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcDIuZ2V0KHBhaXJJZFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwYWlySWQsIHZhbCkge1xuICAgICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuXG4gICAgICAgIGlmIChtYXAyID09IG51bGwpIHtcbiAgICAgICAgICBtYXAyID0gbmV3IE1hcCQyKCk7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0KHBhaXJJZFswXSwgbWFwMik7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAyLnNldChwYWlySWRbMV0sIHZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcGFpcklkcyA9IFtdO1xuICAgIHZhciBoYXlzdGFja0VkZ2VzID0gW107IC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlOyAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgICAvLyB0aGV5IHNob3VsZG4ndCB0YWtlIHVwIHNwYWNlXG5cbiAgICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJyB8fCBjdXJ2ZVN0eWxlID09PSAndGF4aSc7XG4gICAgICB2YXIgZWRnZUlzQmV6aWVyID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdiZXppZXInO1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjSW5kZXggPSBzcmMucG9vbEluZGV4KCk7XG4gICAgICB2YXIgdGd0SW5kZXggPSB0Z3QucG9vbEluZGV4KCk7XG4gICAgICB2YXIgcGFpcklkID0gW3NyY0luZGV4LCB0Z3RJbmRleF0uc29ydCgpO1xuICAgICAgdmFyIHRhYmxlRW50cnkgPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG5cbiAgICAgIGlmICh0YWJsZUVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgdGFibGVFbnRyeSA9IHtcbiAgICAgICAgICBlbGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBoYXNoVGFibGUuc2V0KHBhaXJJZCwgdGFibGVFbnRyeSk7XG4gICAgICAgIHBhaXJJZHMucHVzaChwYWlySWQpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZUVudHJ5LmVsZXMucHVzaChlZGdlKTtcblxuICAgICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgICB0YWJsZUVudHJ5Lmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlSXNCZXppZXIpIHtcbiAgICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gICAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwKSB7XG4gICAgICB2YXIgcGFpcklkID0gcGFpcklkc1twXTtcbiAgICAgIHZhciBwYWlySW5mbyA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcbiAgICAgIHZhciBzd2FwcGVkcGFpckluZm8gPSB2b2lkIDA7XG5cbiAgICAgIGlmICghcGFpckluZm8uaGFzVW5idW5kbGVkKSB7XG4gICAgICAgIHZhciBwbGxFZGdlcyA9IHBhaXJJbmZvLmVsZXNbMF0ucGFyYWxsZWxFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmlzQnVuZGxlZEJlemllcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJBcnJheShwYWlySW5mby5lbGVzKTtcbiAgICAgICAgcGxsRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBwYWlySW5mby5lbGVzLnB1c2goZWRnZSk7XG4gICAgICAgIH0pOyAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuXG4gICAgICAgIHBhaXJJbmZvLmVsZXMuc29ydChmdW5jdGlvbiAoZWRnZTEsIGVkZ2UyKSB7XG4gICAgICAgICAgcmV0dXJuIGVkZ2UxLnBvb2xJbmRleCgpIC0gZWRnZTIucG9vbEluZGV4KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RFZGdlID0gcGFpckluZm8uZWxlc1swXTtcbiAgICAgIHZhciBzcmMgPSBmaXJzdEVkZ2Uuc291cmNlKCk7XG4gICAgICB2YXIgdGd0ID0gZmlyc3RFZGdlLnRhcmdldCgpOyAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50IHcuci50LiBwYWlySWRcblxuICAgICAgaWYgKHNyYy5wb29sSW5kZXgoKSA+IHRndC5wb29sSW5kZXgoKSkge1xuICAgICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgICAgc3JjID0gdGd0O1xuICAgICAgICB0Z3QgPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgdGd0UG9zID0gcGFpckluZm8udGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgICB2YXIgc3JjVyA9IHBhaXJJbmZvLnNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIHNyY0ggPSBwYWlySW5mby5zcmNIID0gc3JjLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgdGd0VyA9IHBhaXJJbmZvLnRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIHRndEggPSBwYWlySW5mby50Z3RIID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIHZhciBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlID0gci5ub2RlU2hhcGVzW190aGlzLmdldE5vZGVTaGFwZShzcmMpXTtcblxuICAgICAgdmFyIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHRndCldO1xuXG4gICAgICBwYWlySW5mby5kaXJDb3VudHMgPSB7XG4gICAgICAgICdub3J0aCc6IDAsXG4gICAgICAgICd3ZXN0JzogMCxcbiAgICAgICAgJ3NvdXRoJzogMCxcbiAgICAgICAgJ2Vhc3QnOiAwLFxuICAgICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICAgJ3NvdXRod2VzdCc6IDAsXG4gICAgICAgICdub3J0aGVhc3QnOiAwLFxuICAgICAgICAnc291dGhlYXN0JzogMFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFpckluZm8uZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IHBhaXJJbmZvLmVsZXNbX2kyXTtcbiAgICAgICAgdmFyIHJzID0gX2VkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgICAgdmFyIF9jdXJ2ZVN0eWxlID0gX2VkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuXG4gICAgICAgIHZhciBfZWRnZUlzVW5idW5kbGVkID0gX2N1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3RheGknOyAvLyB3aGV0aGVyIHRoZSBub3JtYWxpc2VkIHBhaXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGVkZ2UncyBzcmMtdGd0IG9yZGVyXG5cblxuICAgICAgICB2YXIgZWRnZUlzU3dhcHBlZCA9ICFzcmMuc2FtZShfZWRnZS5zb3VyY2UoKSk7XG5cbiAgICAgICAgaWYgKCFwYWlySW5mby5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uICYmIHNyYyAhPT0gdGd0ICYmIChwYWlySW5mby5oYXNCZXppZXIgfHwgcGFpckluZm8uaGFzVW5idW5kbGVkKSkge1xuICAgICAgICAgIHBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gPSB0cnVlOyAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIHRndFBvcy54LCB0Z3RQb3MueSwgMCk7XG4gICAgICAgICAgdmFyIHNyY0ludG4gPSBwYWlySW5mby5zcmNJbnRuID0gc3JjT3V0c2lkZTsgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG5cbiAgICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBzcmNQb3MueCwgc3JjUG9zLnksIDApO1xuICAgICAgICAgIHZhciB0Z3RJbnRuID0gcGFpckluZm8udGd0SW50biA9IHRndE91dHNpZGU7XG4gICAgICAgICAgdmFyIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cyA9IHtcbiAgICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzID0ge1xuICAgICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgICAgeDI6IHRndFBvcy54LFxuICAgICAgICAgICAgeTE6IHNyY1Bvcy55LFxuICAgICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZHkgPSB0Z3RPdXRzaWRlWzFdIC0gc3JjT3V0c2lkZVsxXTtcbiAgICAgICAgICB2YXIgZHggPSB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXTtcbiAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgdmFyIHZlY3RvciA9IHBhaXJJbmZvLnZlY3RvciA9IHtcbiAgICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgICAgeTogZHlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB2ZWN0b3JOb3JtID0gcGFpckluZm8udmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICAgIHg6IHZlY3Rvci54IC8gbCxcbiAgICAgICAgICAgIHk6IHZlY3Rvci55IC8gbFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICAgIH07IC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuXG4gICAgICAgICAgcGFpckluZm8ubm9kZXNPdmVybGFwID0gIW51bWJlciQxKGwpIHx8IHRndFNoYXBlLmNoZWNrUG9pbnQoc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55KSB8fCBzcmNTaGFwZS5jaGVja1BvaW50KHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIDAsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSk7XG4gICAgICAgICAgcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UgPSB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICAgICAgICBzd2FwcGVkcGFpckluZm8gPSB7XG4gICAgICAgICAgICBub2Rlc092ZXJsYXA6IHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCxcbiAgICAgICAgICAgIGRpckNvdW50czogcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgICAgICAgY2FsY3VsYXRlZEludGVyc2VjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGhhc0JlemllcjogcGFpckluZm8uaGFzQmV6aWVyLFxuICAgICAgICAgICAgaGFzVW5idW5kbGVkOiBwYWlySW5mby5oYXNVbmJ1bmRsZWQsXG4gICAgICAgICAgICBlbGVzOiBwYWlySW5mby5lbGVzLFxuICAgICAgICAgICAgc3JjUG9zOiB0Z3RQb3MsXG4gICAgICAgICAgICB0Z3RQb3M6IHNyY1BvcyxcbiAgICAgICAgICAgIHNyY1c6IHRndFcsXG4gICAgICAgICAgICBzcmNIOiB0Z3RILFxuICAgICAgICAgICAgdGd0Vzogc3JjVyxcbiAgICAgICAgICAgIHRndEg6IHNyY0gsXG4gICAgICAgICAgICBzcmNJbnRuOiB0Z3RJbnRuLFxuICAgICAgICAgICAgdGd0SW50bjogc3JjSW50bixcbiAgICAgICAgICAgIHNyY1NoYXBlOiB0Z3RTaGFwZSxcbiAgICAgICAgICAgIHRndFNoYXBlOiBzcmNTaGFwZSxcbiAgICAgICAgICAgIHBvc1B0czoge1xuICAgICAgICAgICAgICB4MTogcG9zUHRzLngyLFxuICAgICAgICAgICAgICB5MTogcG9zUHRzLnkyLFxuICAgICAgICAgICAgICB4MjogcG9zUHRzLngxLFxuICAgICAgICAgICAgICB5MjogcG9zUHRzLnkxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUHRzOiB7XG4gICAgICAgICAgICAgIHgxOiBpbnRlcnNlY3Rpb25QdHMueDIsXG4gICAgICAgICAgICAgIHkxOiBpbnRlcnNlY3Rpb25QdHMueTIsXG4gICAgICAgICAgICAgIHgyOiBpbnRlcnNlY3Rpb25QdHMueDEsXG4gICAgICAgICAgICAgIHkyOiBpbnRlcnNlY3Rpb25QdHMueTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWN0b3I6IHtcbiAgICAgICAgICAgICAgeDogLXZlY3Rvci54LFxuICAgICAgICAgICAgICB5OiAtdmVjdG9yLnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWN0b3JOb3JtOiB7XG4gICAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLngsXG4gICAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtLnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZToge1xuICAgICAgICAgICAgICB4OiAtdmVjdG9yTm9ybUludmVyc2UueCxcbiAgICAgICAgICAgICAgeTogLXZlY3Rvck5vcm1JbnZlcnNlLnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhc3NlZFBhaXJJbmZvID0gZWRnZUlzU3dhcHBlZCA/IHN3YXBwZWRwYWlySW5mbyA6IHBhaXJJbmZvO1xuICAgICAgICBycy5ub2Rlc092ZXJsYXAgPSBwYXNzZWRQYWlySW5mby5ub2Rlc092ZXJsYXA7XG4gICAgICAgIHJzLnNyY0ludG4gPSBwYXNzZWRQYWlySW5mby5zcmNJbnRuO1xuICAgICAgICBycy50Z3RJbnRuID0gcGFzc2VkUGFpckluZm8udGd0SW50bjtcblxuICAgICAgICBpZiAoaGFzQ29tcG91bmRzICYmIChzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkpICYmIChzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSB8fCBzcmMuc2FtZSh0Z3QpICYmIHNyYy5pc1BhcmVudCgpKSkge1xuICAgICAgICAgIF90aGlzLmZpbmRDb21wb3VuZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgICAgX3RoaXMuZmluZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnKSB7XG4gICAgICAgICAgX3RoaXMuZmluZFNlZ21lbnRzUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICAgIF90aGlzLmZpbmRUYXhpUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgIV9lZGdlSXNVbmJ1bmRsZWQgJiYgcGFpckluZm8uZWxlcy5sZW5ndGggJSAyID09PSAxICYmIF9pMiA9PT0gTWF0aC5mbG9vcihwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIpKSB7XG4gICAgICAgICAgX3RoaXMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyhfZWRnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuZmluZEJlemllclBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5maW5kRW5kcG9pbnRzKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG5cbiAgICAgICAgX3RoaXMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLnN0b3JlQWxscHRzKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKF9lZGdlKTtcbiAgICAgIH0gLy8gZm9yIHBhaXIgZWRnZXNcblxuICAgIH07XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIF9sb29wKHApO1xuICAgIH0gLy8gZm9yIHBhaXIgaWRzXG4gICAgLy8gaGF5c3RhY2tzIGF2b2lkIHRoZSBleHBlbnNlIG9mIHBhaXJJbmZvIHN0dWZmIChpbnRlcnNlY3Rpb25zIGV0Yy4pXG5cblxuICAgIHRoaXMuZmluZEhheXN0YWNrUG9pbnRzKGhheXN0YWNrRWRnZXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFB0cyhwdHMpIHtcbiAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICBpZiAocHRzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgICByZXRQdHMucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXRQdHM7XG4gIH1cblxuICBCUnAkYy5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gICAgICByZXR1cm4gZ2V0UHRzKHJzLnNlZ3B0cyk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnYmV6aWVyJyB8fCB0eXBlID09PSAnbXVsdGliZXppZXInIHx8IHR5cGUgPT09ICdzZWxmJyB8fCB0eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICAgIHJldHVybiBnZXRQdHMocnMuY3RybHB0cyk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmdldEVkZ2VNaWRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFlcbiAgICB9O1xuICB9O1xuXG4gIHZhciBCUnAkYiA9IHt9O1xuXG4gIEJScCRiLm1hbnVhbEVuZHB0VG9QeCA9IGZ1bmN0aW9uIChub2RlLCBwcm9wKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBucG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gICAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgICBpZiAocHJvcC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBwID0gW3Byb3AucGZWYWx1ZVswXSwgcHJvcC5wZlZhbHVlWzFdXTtcblxuICAgICAgaWYgKHByb3AudW5pdHNbMF0gPT09ICclJykge1xuICAgICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wLnVuaXRzWzFdID09PSAnJScpIHtcbiAgICAgICAgcFsxXSA9IHBbMV0gKiBoO1xuICAgICAgfVxuXG4gICAgICBwWzBdICs9IG5wb3MueDtcbiAgICAgIHBbMV0gKz0gbnBvcy55O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmdsZSA9IHByb3AucGZWYWx1ZVswXTtcbiAgICAgIGFuZ2xlID0gLU1hdGguUEkgLyAyICsgYW5nbGU7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2tcblxuICAgICAgdmFyIGwgPSAyICogTWF0aC5tYXgodywgaCk7XG4gICAgICB2YXIgX3AgPSBbbnBvcy54ICsgTWF0aC5jb3MoYW5nbGUpICogbCwgbnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogbF07XG4gICAgICByZXR1cm4gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5pbnRlcnNlY3RMaW5lKG5wb3MueCwgbnBvcy55LCB3LCBoLCBfcFswXSwgX3BbMV0sIDApO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYi5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGludGVyc2VjdDtcbiAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICB2YXIgc3JjUG9zID0gc291cmNlLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICAgIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICAgIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICAgIHZhciBzcmNEaXN0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgICB2YXIgdGF4aSA9IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgICB2YXIgc2VsZiA9IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gICAgdmFyIGJlemllciA9IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBzZWxmO1xuICAgIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgICB2YXIgc2VnbWVudHMgPSBldCA9PT0gJ3NlZ21lbnRzJztcbiAgICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICAgIHZhciBvdmVycmlkZUVuZHB0cyA9IHNlbGYgfHwgdGF4aTtcbiAgICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gICAgdmFyIHNyY01hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHNyY01hbkVuZHB0LnZhbHVlO1xuICAgIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgICB2YXIgdGd0TWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogdGd0TWFuRW5kcHQudmFsdWU7XG4gICAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgICBycy50Z3RNYW5FbmRwdCA9IHRndE1hbkVuZHB0O1xuICAgIHZhciBwMTsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHRhcmdldCBzaWRlXG5cbiAgICB2YXIgcDI7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiBzb3VyY2Ugc2lkZVxuXG4gICAgdmFyIHAxX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHRhcmdldCBzaGFwZVxuXG4gICAgdmFyIHAyX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHNvdXJjZSBzaGFwZVxuXG4gICAgaWYgKGJlemllcikge1xuICAgICAgdmFyIGNwU3RhcnQgPSBbcnMuY3RybHB0c1swXSwgcnMuY3RybHB0c1sxXV07XG4gICAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFtycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAxXV0gOiBjcFN0YXJ0O1xuICAgICAgcDEgPSBjcEVuZDtcbiAgICAgIHAyID0gY3BTdGFydDtcbiAgICB9IGVsc2UgaWYgKGxpbmVzKSB7XG4gICAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbdGd0UG9zLngsIHRndFBvcy55XSA6IHJzLnNlZ3B0cy5zbGljZSgwLCAyKTtcbiAgICAgIHZhciB0Z3RBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFtzcmNQb3MueCwgc3JjUG9zLnldIDogcnMuc2VncHRzLnNsaWNlKHJzLnNlZ3B0cy5sZW5ndGggLSAyKTtcbiAgICAgIHAxID0gdGd0QXJyb3dGcm9tUHQ7XG4gICAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICAgIH1cblxuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgICAgaW50ZXJzZWN0ID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdC51bml0cykge1xuICAgICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgodGFyZ2V0LCB0Z3RNYW5FbmRwdCk7XG4gICAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICAgIGludGVyc2VjdCA9IHJzLnRndEludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgICBwMV9pID0gcDE7XG4gICAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRhcmdldC5vdXRlcldpZHRoKCksIHRhcmdldC5vdXRlckhlaWdodCgpLCBwMV9pWzBdLCBwMV9pWzFdLCAwKTtcblxuICAgICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgICAgdmFyIHRycyA9IHRhcmdldC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgICAgdmFyIGx3ID0gdHJzLmxhYmVsV2lkdGg7XG4gICAgICAgIHZhciBsaCA9IHRycy5sYWJlbEhlaWdodDtcbiAgICAgICAgdmFyIGx4ID0gdHJzLmxhYmVsWDtcbiAgICAgICAgdmFyIGx5ID0gdHJzLmxhYmVsWTtcbiAgICAgICAgdmFyIGx3MiA9IGx3IC8gMjtcbiAgICAgICAgdmFyIGxoMiA9IGxoIC8gMjtcbiAgICAgICAgdmFyIHZhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgICBpZiAodmEgPT09ICd0b3AnKSB7XG4gICAgICAgICAgbHkgLT0gbGgyO1xuICAgICAgICB9IGVsc2UgaWYgKHZhID09PSAnYm90dG9tJykge1xuICAgICAgICAgIGx5ICs9IGxoMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG5cbiAgICAgICAgaWYgKGhhID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBseCAtPSBsdzI7XG4gICAgICAgIH0gZWxzZSBpZiAoaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBseCArPSBsdzI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMV9pWzBdLCBwMV9pWzFdLCBbbHggLSBsdzIsIGx5IC0gbGgyLCBseCArIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSArIGxoMiwgbHggLSBsdzIsIGx5ICsgbGgyXSwgdGd0UG9zLngsIHRndFBvcy55KTtcblxuICAgICAgICBpZiAobGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciByZWZQdCA9IHNyY1BvcztcbiAgICAgICAgICB2YXIgaW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgICAgICB2YXIgbGFiSW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChsYWJlbEludGVyc2VjdCkpO1xuICAgICAgICAgIHZhciBtaW5TcURpc3QgPSBpbnRTcWRpc3Q7XG5cbiAgICAgICAgICBpZiAobGFiSW50U3FkaXN0IDwgaW50U3FkaXN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3QgPSBsYWJlbEludGVyc2VjdDtcbiAgICAgICAgICAgIG1pblNxRGlzdCA9IGxhYkludFNxZGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGxhYkludDJTcURpc3QgPSBzcWRpc3QocmVmUHQsIHtcbiAgICAgICAgICAgICAgeDogbGFiZWxJbnRlcnNlY3RbMl0sXG4gICAgICAgICAgICAgIHk6IGxhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxhYkludDJTcURpc3QgPCBtaW5TcURpc3QpIHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gW2xhYmVsSW50ZXJzZWN0WzJdLCBsYWJlbEludGVyc2VjdFszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycm93RW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyB0Z3REaXN0KTtcbiAgICB2YXIgZWRnZUVuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkgKyB0Z3REaXN0KTtcbiAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcblxuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgICAgaW50ZXJzZWN0ID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdC51bml0cykge1xuICAgICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoc291cmNlLCBzcmNNYW5FbmRwdCk7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgICBwMl9pID0gcDI7XG4gICAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgICAgcDJfaSA9IFt0Z3RQb3MueCwgdGd0UG9zLnldO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNvdXJjZS5vdXRlcldpZHRoKCksIHNvdXJjZS5vdXRlckhlaWdodCgpLCBwMl9pWzBdLCBwMl9pWzFdLCAwKTtcblxuICAgICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgICAgdmFyIHNycyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgICAgdmFyIF9sdyA9IHNycy5sYWJlbFdpZHRoO1xuICAgICAgICB2YXIgX2xoID0gc3JzLmxhYmVsSGVpZ2h0O1xuICAgICAgICB2YXIgX2x4ID0gc3JzLmxhYmVsWDtcbiAgICAgICAgdmFyIF9seSA9IHNycy5sYWJlbFk7XG5cbiAgICAgICAgdmFyIF9sdzIgPSBfbHcgLyAyO1xuXG4gICAgICAgIHZhciBfbGgyID0gX2xoIC8gMjtcblxuICAgICAgICB2YXIgX3ZhID0gc291cmNlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgICBpZiAoX3ZhID09PSAndG9wJykge1xuICAgICAgICAgIF9seSAtPSBfbGgyO1xuICAgICAgICB9IGVsc2UgaWYgKF92YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBfbHkgKz0gX2xoMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfaGEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuXG4gICAgICAgIGlmIChfaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIF9seCAtPSBfbHcyO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIF9seCArPSBfbHcyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9sYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAyX2lbMF0sIHAyX2lbMV0sIFtfbHggLSBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgKyBfbGgyLCBfbHggLSBfbHcyLCBfbHkgKyBfbGgyXSwgc3JjUG9zLngsIHNyY1Bvcy55KTtcblxuICAgICAgICBpZiAoX2xhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgX3JlZlB0ID0gdGd0UG9zO1xuXG4gICAgICAgICAgdmFyIF9pbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcblxuICAgICAgICAgIHZhciBfbGFiSW50U3FkaXN0ID0gc3FkaXN0KF9yZWZQdCwgYXJyYXkycG9pbnQoX2xhYmVsSW50ZXJzZWN0KSk7XG5cbiAgICAgICAgICB2YXIgX21pblNxRGlzdCA9IF9pbnRTcWRpc3Q7XG5cbiAgICAgICAgICBpZiAoX2xhYkludFNxZGlzdCA8IF9pbnRTcWRpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IFtfbGFiZWxJbnRlcnNlY3RbMF0sIF9sYWJlbEludGVyc2VjdFsxXV07XG4gICAgICAgICAgICBfbWluU3FEaXN0ID0gX2xhYkludFNxZGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2xhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBfbGFiSW50MlNxRGlzdCA9IHNxZGlzdChfcmVmUHQsIHtcbiAgICAgICAgICAgICAgeDogX2xhYmVsSW50ZXJzZWN0WzJdLFxuICAgICAgICAgICAgICB5OiBfbGFiZWxJbnRlcnNlY3RbM11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoX2xhYkludDJTcURpc3QgPCBfbWluU3FEaXN0KSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdCA9IFtfbGFiZWxJbnRlcnNlY3RbMl0sIF9sYWJlbEludGVyc2VjdFszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycm93U3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHNyY0Rpc3QpO1xuICAgIHZhciBlZGdlU3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG4gICAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuXG4gICAgaWYgKGhhc0VuZHB0cykge1xuICAgICAgaWYgKCFudW1iZXIkMShycy5zdGFydFgpIHx8ICFudW1iZXIkMShycy5zdGFydFkpIHx8ICFudW1iZXIkMShycy5lbmRYKSB8fCAhbnVtYmVyJDEocnMuZW5kWSkpIHtcbiAgICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScCRiLmdldFNvdXJjZUVuZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJzLmhheXN0YWNrUHRzWzBdLFxuICAgICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzFdXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgICAgeTogcnMuYXJyb3dTdGFydFlcbiAgICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGIuZ2V0VGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMl0sXG4gICAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbM11cbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICAgICAgeTogcnMuYXJyb3dFbmRZXG4gICAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHZhciBCUnAkYSA9IHt9O1xuXG4gIGZ1bmN0aW9uIHB1c2hCZXppZXJQdHMociwgZWRnZSwgcHRzKSB7XG4gICAgdmFyIHFiZXppZXJBdCQxID0gZnVuY3Rpb24gcWJlemllckF0JDEocDEsIHAyLCBwMywgdCkge1xuICAgICAgcmV0dXJuIHFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgICB9O1xuXG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCQxKHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIHApLFxuICAgICAgICB5OiBxYmV6aWVyQXQkMShwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCBwKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgQlJwJGEuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7IC8vIGNsZWFyIHRoZSBjYWNoZWQgcG9pbnRzIHN0YXRlXG5cbiAgICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gbnVsbDtcbiAgICBfcC5yc3R5bGUubGluZVB0cyA9IG51bGw7XG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICAgIGlmIChldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgX3AucnN0eWxlLmJlemllclB0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcHVzaEJlemllclB0cyh0aGlzLCBlZGdlLCBycy5hbGxwdHMuc2xpY2UoaSwgaSArIDYpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV0ID09PSAnc2VnbWVudHMnKSB7XG4gICAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBscHRzLnB1c2goe1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXQgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG4gICAgICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBbe1xuICAgICAgICB4OiBocHRzWzBdLFxuICAgICAgICB5OiBocHRzWzFdXG4gICAgICB9LCB7XG4gICAgICAgIHg6IGhwdHNbMl0sXG4gICAgICAgIHk6IGhwdHNbM11cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIF9wLnJzdHlsZS5hcnJvd1dpZHRoID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xuICB9O1xuXG4gIEJScCRhLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gICAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xuICB9O1xuXG4gIC8qIGdsb2JhbCBkb2N1bWVudCAqL1xuXG4gIHZhciBCUnAkOSA9IHt9O1xuXG4gIEJScCQ5LnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBub2RlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZTtcblxuICAgIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0WCwgdGV4dFk7XG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICB2YXIgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpO1xuICAgIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgIHZhciBub2RlUG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC12YWxpZ24nKS5zdHJWYWx1ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICAgIH1cblxuICAgIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnkgLSBub2RlSGVpZ2h0IC8gMiAtIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGUuZy4gbWlkZGxlXG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICAgIH1cblxuICAgIHJzLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzLmxhYmVsWSA9IHRleHRZO1xuICAgIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhub2RlKTtcbiAgICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKG5vZGUpO1xuICB9O1xuXG4gIHZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGR5IC8gZHgpO1xuXG4gICAgaWYgKGR4ID09PSAwICYmIGFuZ2xlIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSAqIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBhbmdsZTtcbiAgfTtcblxuICB2YXIgbGluZUFuZ2xlID0gZnVuY3Rpb24gbGluZUFuZ2xlKHAwLCBwMSkge1xuICAgIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICAgIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICAgIHJldHVybiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KTtcbiAgfTtcblxuICB2YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiBiZXppZXJBbmdsZShwMCwgcDEsIHAyLCB0KSB7XG4gICAgdmFyIHQwID0gYm91bmQoMCwgdCAtIDAuMDAxLCAxKTtcbiAgICB2YXIgdDEgPSBib3VuZCgwLCB0ICsgMC4wMDEsIDEpO1xuICAgIHZhciBscDAgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gICAgdmFyIGxwMSA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQxKTtcbiAgICByZXR1cm4gbGluZUFuZ2xlKGxwMCwgbHAxKTtcbiAgfTtcblxuICBCUnAkOS5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcDtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgY29udGVudCA9IHtcbiAgICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgICBzb3VyY2U6IGVkZ2UucHN0eWxlKCdzb3VyY2UtbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gICAgfTtcblxuICAgIGlmIChjb250ZW50Lm1pZCB8fCBjb250ZW50LnNvdXJjZSB8fCBjb250ZW50LnRhcmdldCkgOyBlbHNlIHtcbiAgICAgIHJldHVybjsgLy8gbm8gbGFiZWxzID0+IG5vIGNhbGNzXG4gICAgfSAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAgIC8vXG5cblxuICAgIHAgPSB7XG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWVxuICAgIH07XG5cbiAgICB2YXIgc2V0UnMgPSBmdW5jdGlvbiBzZXRScyhwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgc2V0UnMoJ2xhYmVsWCcsIG51bGwsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIG51bGwsIHAueSk7XG4gICAgdmFyIG1pZEFuZ2xlID0gbGluZUFuZ2xlRnJvbURlbHRhKHJzLm1pZERpc3BYLCBycy5taWREaXNwWSk7XG4gICAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgbnVsbCwgbWlkQW5nbGUpO1xuXG4gICAgdmFyIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8gPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCkge1xuICAgICAgaWYgKGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgICB9IC8vIHVzZSBjYWNoZSBzbyBvbmx5IDF4IHBlciBlZGdlXG5cblxuICAgICAgdmFyIGN0cmxwdHMgPSBbXTsgLy8gc3RvcmUgZWFjaCBjdHJscHQgaW5mbyBpbml0XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICB2YXIgcDAgPSB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAxID0ge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgICB9OyAvLyBjdHJscHRcblxuICAgICAgICB2YXIgcDIgPSB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2kgKyA0XSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDVdXG4gICAgICAgIH07XG4gICAgICAgIGN0cmxwdHMucHVzaCh7XG4gICAgICAgICAgcDA6IHAwLFxuICAgICAgICAgIHAxOiBwMSxcbiAgICAgICAgICBwMjogcDIsXG4gICAgICAgICAgc3RhcnREaXN0OiAwLFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICBzZWdtZW50czogW11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICAgIHZhciBuUHJvanMgPSByLmJlemllclByb2pQY3RzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgdmFyIHByZXZTZWdtZW50ID0gY3Auc2VnbWVudHNbY3Auc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICBwMTogcDEsXG4gICAgICAgICAgdDA6IHQwLFxuICAgICAgICAgIHQxOiB0MSxcbiAgICAgICAgICBzdGFydERpc3Q6IHByZXZTZWdtZW50ID8gcHJldlNlZ21lbnQuc3RhcnREaXN0ICsgcHJldlNlZ21lbnQubGVuZ3RoIDogMCxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICBjcC5zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgfSAvLyB1cGRhdGUgZWFjaCBjdHJscHQgd2l0aCBzZWdtZW50IGluZm9cblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY3RybHB0cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNwID0gY3RybHB0c1tfaV07XG4gICAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW19pIC0gMV07XG5cbiAgICAgICAgaWYgKHByZXZDcCkge1xuICAgICAgICAgIGNwLnN0YXJ0RGlzdCA9IHByZXZDcC5zdGFydERpc3QgKyBwcmV2Q3AubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkU2VnbWVudChjcCwgY3AucDAsIGJwdHNbX2kgKiBuUHJvanNdLCAwLCByLmJlemllclByb2pQY3RzWzBdKTsgLy8gZmlyc3RcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKykge1xuICAgICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBqXSwgYnB0c1tfaSAqIG5Qcm9qcyArIGogKyAxXSwgci5iZXppZXJQcm9qUGN0c1tqXSwgci5iZXppZXJQcm9qUGN0c1tqICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUgPSBjdHJscHRzO1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24ocHJlZml4KSB7XG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuXG4gICAgICBpZiAoIWNvbnRlbnRbcHJlZml4XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLXRleHQtb2Zmc2V0JykucGZWYWx1ZTtcblxuICAgICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgICBjYXNlICdiZXppZXInOlxuICAgICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNwcyA9IGNyZWF0ZUNvbnRyb2xQb2ludEluZm8oKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIHZhciBzdGFydERpc3QgPSAwO1xuICAgICAgICAgICAgdmFyIHRvdGFsRGlzdCA9IDA7IC8vIGZpbmQgdGhlIHNlZ21lbnQgd2UncmUgb25cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9jcCA9IGNwc1tpc1NyYyA/IGkgOiBjcHMubGVuZ3RoIC0gMSAtIGldO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2NwLnNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zZWcgPSBfY3Auc2VnbWVudHNbaXNTcmMgPyBqIDogX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDEgLSBqXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGlzdCA9IHRvdGFsRGlzdDtcbiAgICAgICAgICAgICAgICB0b3RhbERpc3QgKz0gX3NlZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3A6IF9jcCxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogX3NlZ1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlbGVjdGVkLnNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgdFNlZ21lbnQgPSAob2Zmc2V0IC0gc3RhcnREaXN0KSAvIHNlZy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgICAgICB2YXIgdCA9IGlzU3JjID8gc2VnLnQwICsgc2VnRHQgKiB0U2VnbWVudCA6IHNlZy50MSAtIHNlZ0R0ICogdFNlZ21lbnQ7XG4gICAgICAgICAgICB0ID0gYm91bmQoMCwgdCwgMSk7XG4gICAgICAgICAgICBwID0gcWJlemllclB0QXQoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgICBhbmdsZSA9IGJlemllckFuZ2xlKGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgICAgIGRpLFxuICAgICAgICAgICAgICAgIGQwO1xuICAgICAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgICAgIHZhciBsID0gcnMuYWxscHRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyICsgMyA8IGw7IF9pMiArPSAyKSB7XG4gICAgICAgICAgICAgIGlmIChpc1NyYykge1xuICAgICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMl0sXG4gICAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMiArIDJdLFxuICAgICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDNdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gMiAtIF9pMl0sXG4gICAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDEgLSBfaTJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gNCAtIF9pMl0sXG4gICAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDMgLSBfaTJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpID0gZGlzdChwMCwgcDEpO1xuICAgICAgICAgICAgICBkMCA9IGQ7XG4gICAgICAgICAgICAgIGQgKz0gZGk7XG5cbiAgICAgICAgICAgICAgaWYgKGQgPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBEID0gb2Zmc2V0IC0gZDA7XG5cbiAgICAgICAgICAgIHZhciBfdCA9IHBEIC8gZGk7XG5cbiAgICAgICAgICAgIF90ID0gYm91bmQoMCwgX3QsIDEpO1xuICAgICAgICAgICAgcCA9IGxpbmVBdChwMCwgcDEsIF90KTtcbiAgICAgICAgICAgIGFuZ2xlID0gbGluZUFuZ2xlKHAwLCBwMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgICBzZXRScygnbGFiZWxZJywgcHJlZml4LCBwLnkpO1xuICAgICAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgcHJlZml4LCBhbmdsZSk7XG4gICAgfTtcblxuICAgIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3NvdXJjZScpO1xuICAgIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3RhcmdldCcpO1xuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoZWRnZSk7XG4gIH07XG5cbiAgQlJwJDkuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSk7XG5cbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAnc291cmNlJyk7XG4gICAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9O1xuXG4gIEJScCQ5LmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCk7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBlbGUucHN0eWxlKCdsaW5lLWhlaWdodCcpLnBmVmFsdWU7XG4gICAgdmFyIHRleHRXcmFwID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykuc3RyVmFsdWU7XG4gICAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KSB8fCBbXTtcbiAgICB2YXIgbnVtTGluZXMgPSB0ZXh0V3JhcCAhPT0gJ3dyYXAnID8gMSA6IE1hdGgubWF4KGxpbmVzLmxlbmd0aCwgMSk7XG4gICAgdmFyIG5vcm1QZXJMaW5lSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCAvIG51bUxpbmVzO1xuICAgIHZhciBsYWJlbExpbmVIZWlnaHQgPSBub3JtUGVyTGluZUhlaWdodCAqIGxpbmVIZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gbGFiZWxEaW1zLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0ICsgKG51bUxpbmVzIC0gMSkgKiAobGluZUhlaWdodCAtIDEpICogbm9ybVBlckxpbmVIZWlnaHQ7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIHdpZHRoKTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4LCBsYWJlbExpbmVIZWlnaHQpO1xuICB9O1xuXG4gIEJScCQ5LmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcGZkID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHBmZCArICdsYWJlbCcpLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gZWxlLnBzdHlsZSgndGV4dC10cmFuc2Zvcm0nKS52YWx1ZTtcblxuICAgIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uIHJzY3JhdGNoKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgpO1xuICAgICAgfVxuICAgIH07IC8vIGZvciBlbXB0eSB0ZXh0LCBza2lwIGFsbCBwcm9jZXNzaW5nXG5cblxuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0ZXh0VHJhbnNmb3JtID09ICdub25lJykgOyBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWU7XG5cbiAgICBpZiAod3JhcFN0eWxlID09PSAnd3JhcCcpIHtcbiAgICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpOyAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG5cbiAgICAgIGlmIChsYWJlbEtleSAhPSBudWxsICYmIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknKSA9PT0gbGFiZWxLZXkpIHtcbiAgICAgICAgcmV0dXJuIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB6d3NwID0gXCJcXHUyMDBCXCI7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIG92ZXJmbG93ID0gZWxlLnBzdHlsZSgndGV4dC1vdmVyZmxvdy13cmFwJykudmFsdWU7XG4gICAgICB2YXIgb3ZlcmZsb3dBbnkgPSBvdmVyZmxvdyA9PT0gJ2FueXdoZXJlJztcbiAgICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcbiAgICAgIHZhciB3b3Jkc1JlZ2V4ID0gL1tcXHNcXHUyMDBiXSsvO1xuICAgICAgdmFyIHdvcmRTZXBhcmF0b3IgPSBvdmVyZmxvd0FueSA/ICcnIDogJyAnO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICAgIHZhciBsaW5lRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgbGluZSk7XG4gICAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICAgIGlmIChvdmVyZmxvd0FueSkge1xuICAgICAgICAgIHZhciBwcm9jZXNzZWRMaW5lID0gbGluZS5zcGxpdCgnJykuam9pbih6d3NwKTtcbiAgICAgICAgICBsaW5lID0gcHJvY2Vzc2VkTGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lVyA+IG1heFcpIHtcbiAgICAgICAgICAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCh3b3Jkc1JlZ2V4KTtcbiAgICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuXG4gICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1t3XTtcbiAgICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyB3b3JkU2VwYXJhdG9yICsgd29yZDtcbiAgICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGVzdExpbmUpO1xuICAgICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh0ZXN0VyA8PSBtYXhXKSB7XG4gICAgICAgICAgICAgIC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICAgIGlmIChzdWJsaW5lKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goc3VibGluZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdWJsaW5lID0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcblxuXG4gICAgICAgICAgaWYgKCFzdWJsaW5lLm1hdGNoKC9eW1xcc1xcdTIwMGJdKyQvKSkge1xuICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goc3VibGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcblxuXG4gICAgICByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCB3cmFwcGVkTGluZXMpO1xuICAgICAgdGV4dCA9IHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknLCBsYWJlbEtleSk7XG4gICAgfSBlbHNlIGlmICh3cmFwU3R5bGUgPT09ICdlbGxpcHNpcycpIHtcbiAgICAgIHZhciBfbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBlbGxpcHNpemVkID0gJyc7XG4gICAgICB2YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbiAgICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCkud2lkdGggPCBfbWF4Vykge1xuICAgICAgICAvLyB0aGUgbGFiZWwgYWxyZWFkeSBmaXRzXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcykud2lkdGg7XG5cbiAgICAgICAgaWYgKHdpZHRoV2l0aE5leHRDaCA+IF9tYXhXKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbGxpcHNpemVkICs9IHRleHRbaV07XG5cbiAgICAgICAgaWYgKGkgPT09IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGluY0xhc3RDaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpbmNMYXN0Q2gpIHtcbiAgICAgICAgZWxsaXBzaXplZCArPSBlbGxpcHNpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsbGlwc2l6ZWQ7XG4gICAgfSAvLyBpZiBlbGxpcHNpemVcblxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgQlJwJDkuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBqdXN0aWZpY2F0aW9uID0gZWxlLnBzdHlsZSgndGV4dC1qdXN0aWZpY2F0aW9uJykuc3RyVmFsdWU7XG4gICAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuXG4gICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdhdXRvJykge1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuICdsZWZ0JztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGp1c3RpZmljYXRpb247XG4gICAgfVxuICB9O1xuXG4gIEJScCQ5LmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHRleHQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGNhY2hlS2V5ID0gaGFzaFN0cmluZyh0ZXh0LCBlbGUuX3ByaXZhdGUubGFiZWxEaW1zS2V5KTtcbiAgICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IFtdKTtcbiAgICB2YXIgZXhpc3RpbmdWYWwgPSBjYWNoZVtjYWNoZUtleV07XG5cbiAgICBpZiAoZXhpc3RpbmdWYWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsO1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gMDsgLy8gYWRkIHBhZGRpbmcgYXJvdW5kIHRleHQgZGltcywgYXMgdGhlIG1lYXN1cmVtZW50IGlzbid0IHRoYXQgYWNjdXJhdGVcblxuICAgIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gICAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlO1xuICAgIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICAgIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhcztcbiAgICB2YXIgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0O1xuXG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjMmQgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBkcyA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICBkcy50b3AgPSAnLTk5OTlweCc7XG4gICAgICBkcy56SW5kZXggPSAnLTEnO1xuICAgICAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB9XG5cbiAgICBjMmQuZm9udCA9IFwiXCIuY29uY2F0KGZTdHlsZSwgXCIgXCIpLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZhbWlseSk7XG4gICAgdmFyIHdpZHRoID0gMDtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICB2YXIgbWV0cmljcyA9IGMyZC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICAgIHZhciB3ID0gTWF0aC5jZWlsKG1ldHJpY3Mud2lkdGgpO1xuICAgICAgdmFyIGggPSBzaXplO1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3LCB3aWR0aCk7XG4gICAgICBoZWlnaHQgKz0gaDtcbiAgICB9XG5cbiAgICB3aWR0aCArPSBwYWRkaW5nO1xuICAgIGhlaWdodCArPSBwYWRkaW5nO1xuICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBwcmVmaXhEYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHJvdCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcblxuICAgIGlmIChyb3RTdHIgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgcm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICAgIHJldHVybiBycy5sYWJlbEF1dG9BbmdsZTtcbiAgICB9IGVsc2UgaWYgKHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvdC5wZlZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBCUnAkOS5jYWxjdWxhdGVMYWJlbEFuZ2xlcyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgcnMubGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUpO1xuXG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgICAgIHJzLnRhcmdldExhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCUnAkOCA9IHt9O1xuICB2YXIgVE9PX1NNQUxMX0NVVF9SRUNUID0gMjg7XG4gIHZhciB3YXJuZWRDdXRSZWN0ID0gZmFsc2U7XG5cbiAgQlJwJDguZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykudmFsdWU7XG5cbiAgICBpZiAoc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnICYmIChub2RlLndpZHRoKCkgPCBUT09fU01BTExfQ1VUX1JFQ1QgfHwgbm9kZS5oZWlnaHQoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCkpIHtcbiAgICAgIGlmICghd2FybmVkQ3V0UmVjdCkge1xuICAgICAgICB3YXJuKCdUaGUgYGN1dHJlY3RhbmdsZWAgbm9kZSBzaGFwZSBjYW4gbm90IGJlIHVzZWQgYXQgc21hbGwgc2l6ZXMgc28gYHJlY3RhbmdsZWAgaXMgdXNlZCBpbnN0ZWFkJyk7XG4gICAgICAgIHdhcm5lZEN1dFJlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgaWYgKHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kLXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0LXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdiYXJyZWwnKSB7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hhcGUgPT09ICdwb2x5Z29uJykge1xuICAgICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnZhbHVlO1xuICAgICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbihwb2ludHMpLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHZhciBCUnAkNyA9IHt9O1xuXG4gIEJScCQ3LnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgICB2YXIgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIHZhciByID0gdGhpcztcblxuICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShlbGVzKSB7XG4gICAgICB2YXIgZGlydHlTdHlsZUNhY2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGVsZXNUb1VwZGF0ZS5tZXJnZShlbGVzKTtcblxuICAgICAgaWYgKGRpcnR5U3R5bGVDYWNoZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgci5iaW5kZXIoY3kpLm9uKCdib3VuZHMuKiBkaXJ0eS4qJywgZnVuY3Rpb24gb25EaXJ0eUJvdW5kcyhlKSB7XG4gICAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgICBlbnF1ZXVlKGVsZSk7XG4gICAgfSkub24oJ3N0eWxlLiogYmFja2dyb3VuZC4qJywgZnVuY3Rpb24gb25EaXJ0eVN0eWxlKGUpIHtcbiAgICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICAgIGVucXVldWUoZWxlLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgdXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiB1cGRhdGVFbGVDYWxjcyh3aWxsRHJhdykge1xuICAgICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7IC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBoYXZlIHVwLXRvLWRhdGUgc3R5bGUgKGUuZy4gc3R5bGVzaGVldCBtYXBwZXJzKVxuICAgICAgICAvLyBiZWZvcmUgY2FsY3VsYXRpbmcgcmVuZGVyZWQgc3R5bGUgKGFuZCBwc3R5bGUgbWlnaHQgbm90IGJlIGNhbGxlZCB5ZXQpXG5cbiAgICAgICAgZWxlc1RvVXBkYXRlLmNsZWFuU3R5bGUoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzVG9VcGRhdGVbaV07XG4gICAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG5cbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpICYmICFyc3R5bGUuY2xlYW5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGVucXVldWUoZWxlLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm5zKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZuc1tfaV07XG4gICAgICAgICAgICBmbih3aWxsRHJhdywgZWxlc1RvVXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlbGVzVG9VcGRhdGUpO1xuICAgICAgICBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHIuZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVFbGVDYWxjcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgci5iZWZvcmVSZW5kZXIodXBkYXRlRWxlQ2FsY3MsIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVDYWxjcyk7XG4gIH07XG5cbiAgQlJwJDcub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBmbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgfHwgW107XG4gICAgZm5zLnB1c2goZm4pO1xuICB9O1xuXG4gIEJScCQ3LnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGVzLCB1c2VDYWNoZSkge1xuICAgIHZhciBpc0NsZWFuQ29ubmVjdGVkID0gZnVuY3Rpb24gaXNDbGVhbkNvbm5lY3RlZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUucnN0eWxlLmNsZWFuQ29ubmVjdGVkO1xuICAgIH07XG5cbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHVzZSBjYWNoZSBieSBkZWZhdWx0IGZvciBwZXJmXG5cblxuICAgIGlmICh1c2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VDYWNoZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7IC8vIGFuIGVkZ2UgbWF5IGJlIGltcGxpY2l0bHkgZGlydHkgYi9jIG9mIG9uZSBvZiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICAvLyAoYW5kIGEgcmVxdWVzdCBmb3IgcmVjYWxjIG1heSBjb21lIGluIGJldHdlZW4gZnJhbWVzKVxuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpICYmICghaXNDbGVhbkNvbm5lY3RlZChlbGUuc291cmNlKCkpIHx8ICFpc0NsZWFuQ29ubmVjdGVkKGVsZS50YXJnZXQoKSkpKSB7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgfSAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcblxuXG4gICAgICBpZiAodXNlQ2FjaGUgJiYgcnN0eWxlLmNsZWFuIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG5cblxuICAgICAgaWYgKGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3AuZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWRnZXNcbiAgICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICByc3R5bGUuY2xlYW4gPSB0cnVlO1xuICAgIH0gLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcbiAgICAgIHZhciBfcDIgPSBfZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIF9yc3R5bGUgPSBfcDIucnN0eWxlO1xuXG4gICAgICB2YXIgcG9zID0gX2VsZS5wb3NpdGlvbigpO1xuXG4gICAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihfZWxlKTtcbiAgICAgIF9yc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICAgIF9yc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICAgIF9yc3R5bGUubm9kZVcgPSBfZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgX3JzdHlsZS5ub2RlSCA9IF9lbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoZWRnZXMpOyAvLyB1cGRhdGUgZWRnZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBfZWxlMiA9IGVkZ2VzW19pM107XG4gICAgICB2YXIgX3AzID0gX2VsZTIuX3ByaXZhdGU7XG4gICAgICB2YXIgX3JzdHlsZTIgPSBfcDMucnN0eWxlO1xuICAgICAgdmFyIHJzID0gX3AzLnJzY3JhdGNoOyAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuXG4gICAgICBfcnN0eWxlMi5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgICBfcnN0eWxlMi5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgICBfcnN0eWxlMi50Z3RYID0gcnMuYXJyb3dFbmRYO1xuICAgICAgX3JzdHlsZTIudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICAgIF9yc3R5bGUyLm1pZFggPSBycy5taWRYO1xuICAgICAgX3JzdHlsZTIubWlkWSA9IHJzLm1pZFk7XG4gICAgICBfcnN0eWxlMi5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICAgIF9yc3R5bGUyLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgICAgX3JzdHlsZTIudGFyZ2V0TGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCUnAkNiA9IHt9O1xuXG4gIEJScCQ2LnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcblxuICAgIGlmICghZWxlcykge1xuICAgICAgLy8ganVzdCBsZXQgdGhpcyBiZSByZWNhbGN1bGF0ZWQgb24gdGhlIG5leHQgeiBzb3J0IHRpY2tcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVzLmRyYWcgPSBbXTtcbiAgICBlbGVzLm5vbmRyYWcgPSBbXTtcbiAgICB2YXIgZ3JhYlRhcmdldHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICBncmFiVGFyZ2V0cy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2UgaWYgKHJzLmluRHJhZ0xheWVyKSB7XG4gICAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzLm5vbmRyYWcucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH0gLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhYlRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIEJScCQ2LmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbiAgfTtcblxuICBCUnAkNi5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uIChmb3JjZVJlY2FsYykge1xuICAgIGlmIChmb3JjZVJlY2FsYyB8fCAhdGhpcy5jYWNoZWRaU29ydGVkRWxlcykge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcbiAgICAgIGVsZXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgICAgIGVsZXMuaW50ZXJhY3RpdmUgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IGVsZXM7XG4gICAgICB0aGlzLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVzO1xuICB9O1xuXG4gIHZhciBCUnAkNSA9IHt9O1xuICBbQlJwJGUsIEJScCRkLCBCUnAkYywgQlJwJGIsIEJScCRhLCBCUnAkOSwgQlJwJDgsIEJScCQ3LCBCUnAkNl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoQlJwJDUsIHByb3BzKTtcbiAgfSk7XG5cbiAgdmFyIEJScCQ0ID0ge307XG5cbiAgQlJwJDQuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbiAodXJsLCBjcm9zc09yaWdpbiwgb25Mb2FkKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuICAgIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXTtcblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgaWYgKCFjYWNoZS5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICBjYWNoZS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW1hZ2UuZXJyb3IgPSB0cnVlO1xuICAgICAgfSk7IC8vICMxNTgyIHNhZmFyaSBkb2Vzbid0IGxvYWQgZGF0YSB1cmlzIHdpdGggY3Jvc3NPcmlnaW4gcHJvcGVybHlcbiAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcblxuICAgICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgICAgdmFyIGlzRGF0YVVyaSA9IHVybC5zdWJzdHJpbmcoMCwgZGF0YVVyaVByZWZpeC5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IGRhdGFVcmlQcmVmaXg7XG5cbiAgICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICAgIC8vIGlmIGNyb3Nzb3JpZ2luIGlzICdudWxsJyhzdHJpbmdpZmllZCksIHRoZW4gbWFudWFsbHkgc2V0IGl0IHRvIG51bGwgXG4gICAgICAgIGNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPT09ICdudWxsJyA/IG51bGwgOiBjcm9zc09yaWdpbjtcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCUnAkMyA9IHt9O1xuICAvKiBnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgUmVzaXplT2JzZXJ2ZXIsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuICBCUnAkMy5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7IC8vIGNvcHlcblxuICAgIHZhciBiID0gdGhpcy5iaW5kZXIodGFyZ2V0KTtcbiAgICByZXR1cm4gYi5vbi5hcHBseShiLCBhcmdzKTtcbiAgfTtcblxuICBCUnAkMy5iaW5kZXIgPSBmdW5jdGlvbiAodGd0KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciB0Z3RJc0RvbSA9IHRndCA9PT0gd2luZG93IHx8IHRndCA9PT0gZG9jdW1lbnQgfHwgdGd0ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvbUVsZW1lbnQodGd0KTtcblxuICAgIGlmIChyLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9PSBudWxsKSB7XG4gICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gbm90IHN1cHBvcnRlZFxuICAgICAgfVxuXG4gICAgICByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZTtcbiAgICB9XG5cbiAgICB2YXIgb24gPSBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodGd0SXNEb20gJiYgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB1c2VDYXB0dXJlIHcvIG9wdHMgb2JqXG4gICAgICAgIGFyZ3NbMl0gPSB7XG4gICAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHIuYmluZGluZ3MucHVzaCh7XG4gICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcbiAgICAgICh0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24pLmFwcGx5KHRndCwgYXJncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiBvbixcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IG9uLFxuICAgICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgICAgYmluZDogb25cbiAgICB9O1xuICB9O1xuXG4gIEJScCQzLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGUoKSAmJiAhbm9kZS5sb2NrZWQoKSAmJiBub2RlLmdyYWJiYWJsZSgpO1xuICB9O1xuXG4gIEJScCQzLm5vZGVJc0dyYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUlzRHJhZ2dhYmxlKG5vZGUpICYmIG5vZGUuaW50ZXJhY3RpdmUoKTtcbiAgfTtcblxuICBCUnAkMy5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIHZhciBpc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiB0cmlnZ2VyRXZlbnRzKHRhcmdldCwgbmFtZXMsIGUsIHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICB0YXJnZXQuZW1pdCh7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiBpc011bHRTZWxLZXlEb3duKGUpIHtcbiAgICAgIHJldHVybiBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7IC8vIG1heWJlIGUuYWx0S2V5XG4gICAgfTtcblxuICAgIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIGRvd25zKSB7XG4gICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG5cbiAgICAgIGlmIChyLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBkb3duICYmIGRvd24ucGFubmFibGUoKSkge1xuICAgICAgICAvLyBhIGdyYWJiYWJsZSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlbGUgPT4gbm8gcGFzc3Rocm91Z2ggcGFubmluZ1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgZG93bnMgJiYgaSA8IGRvd25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTsgLy9pZiBhbnkgcGFyZW50IG5vZGUgaW4gZXZlbnQgaGllcmFyY2h5IGlzbid0IHBhbm5hYmxlLCByZWplY3QgcGFzc3Rocm91Z2hcblxuICAgICAgICAgIGlmIChkb3duLmlzTm9kZSgpICYmIGRvd24uaXNQYXJlbnQoKSAmJiAhZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsb3dQYXNzdGhyb3VnaDtcbiAgICB9O1xuXG4gICAgdmFyIHNldEdyYWJiZWQgPSBmdW5jdGlvbiBzZXRHcmFiYmVkKGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgc2V0RnJlZWQgPSBmdW5jdGlvbiBzZXRGcmVlZChlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBzZXRJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHNldEluRHJhZ0xheWVyKGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uIHNldE91dERyYWdMYXllcihlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uIHNldEdyYWJUYXJnZXQoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUdyYWJUYXJnZXQgPSBmdW5jdGlvbiByZW1vdmVHcmFiVGFyZ2V0KGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgYWRkVG9EcmFnTGlzdCA9IGZ1bmN0aW9uIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKSB7XG4gICAgICB2YXIgbGlzdCA9IG9wdHMuYWRkVG9MaXN0O1xuICAgICAgdmFyIGxpc3RIYXNFbGUgPSBsaXN0LmhhcyhlbGUpO1xuXG4gICAgICBpZiAoIWxpc3RIYXNFbGUgJiYgZWxlLmdyYWJiYWJsZSgpICYmICFlbGUubG9ja2VkKCkpIHtcbiAgICAgICAgbGlzdC5tZXJnZShlbGUpO1xuICAgICAgICBzZXRHcmFiYmVkKGVsZSk7XG4gICAgICB9XG4gICAgfTsgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuXG5cbiAgICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbiBhZGREZXNjZW5kYW50c1RvRHJhZyhub2RlLCBvcHRzKSB7XG4gICAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cblxuICAgICAgdmFyIGlubmVyTm9kZXMgPSBub2RlLmRlc2NlbmRhbnRzKCk7XG5cbiAgICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoaW5uZXJOb2Rlcywgb3B0cyk7XG4gICAgICB9XG4gICAgfTsgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG5cblxuICAgIHZhciBhZGROb2Rlc1RvRHJhZyA9IGZ1bmN0aW9uIGFkZE5vZGVzVG9EcmFnKG5vZGVzLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBlbGUuaXNFZGdlKCk7XG4gICAgICAgIH0pLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZXMsIG9wdHMpOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcbiAgICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG5cbiAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGVzLCB7XG4gICAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgICB9KTtcbiAgICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZE5vZGVUb0RyYWcgPSBhZGROb2Rlc1RvRHJhZztcblxuICAgIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24gZnJlZURyYWdnZWRFbGVtZW50cyhncmFiYmVkRWxlcykge1xuICAgICAgaWYgKCFncmFiYmVkRWxlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGp1c3QgZ28gb3ZlciBhbGwgZWxlbWVudHMgcmF0aGVyIHRoYW4gZG9pbmcgYSBidW5jaCBvZiAocG9zc2libHkgZXhwZW5zaXZlKSB0cmF2ZXJzYWxzXG5cblxuICAgICAgci5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBzZXRGcmVlZChlbGUpO1xuICAgICAgICBzZXRPdXREcmFnTGF5ZXIoZWxlKTtcbiAgICAgICAgcmVtb3ZlR3JhYlRhcmdldChlbGUpO1xuICAgICAgfSk7XG4gICAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gICAgfTsgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gICAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG5cblxuICAgIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGUsIG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuXG4gICAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcblxuXG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5hbmNlc3RvcnMoKS5vcnBoYW5zKCk7IC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcblxuICAgICAgaWYgKHBhcmVudC5zYW1lKG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVzID0gcGFyZW50LmRlc2NlbmRhbnRzKCkuc3Bhd25TZWxmKCkubWVyZ2UocGFyZW50KS51bm1lcmdlKG5vZGUpLnVubWVyZ2Uobm9kZS5kZXNjZW5kYW50cygpKTtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBibHVyQWN0aXZlRG9tRWxlbWVudCA9IGZ1bmN0aW9uIGJsdXJBY3RpdmVEb21FbGVtZW50KCkge1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgIT0gbnVsbCkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhdmVNdXRhdGlvbnNBcGkgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGhhdmVSZXNpemVPYnNlcnZlckFwaSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7IC8vIHdhdGNoIGZvciB3aGVuIHRoZSBjeSBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb21cblxuICAgIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dG5zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgICAgaWYgKHJOb2Rlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChyTm9kZSA9PT0gci5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvblJlc2l6ZSA9IGRlYm91bmNlXzEoZnVuY3Rpb24gKCkge1xuICAgICAgci5jeS5yZXNpemUoKTtcbiAgICB9LCAxMDApO1xuXG4gICAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICAgIHIuc3R5bGVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICByLnN0eWxlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lciwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIGF1dG8gcmVzaXplXG5cblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaWYgKGhhdmVSZXNpemVPYnNlcnZlckFwaSkge1xuICAgICAgci5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgci5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZm9yRWFjaFVwID0gZnVuY3Rpb24gZm9yRWFjaFVwKGRvbUVsZSwgZm4pIHtcbiAgICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgICBmbihkb21FbGUpO1xuICAgICAgICBkb21FbGUgPSBkb21FbGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGludmFsaWRhdGVDb29yZHMgPSBmdW5jdGlvbiBpbnZhbGlkYXRlQ29vcmRzKCkge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICB9O1xuXG4gICAgZm9yRWFjaFVwKHIuY29udGFpbmVyLCBmdW5jdGlvbiAoZG9tRWxlKSB7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICd0cmFuc2l0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdhbmltYXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgIH0pOyAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIGluQm94U2VsZWN0aW9uID0gZnVuY3Rpb24gaW5Cb3hTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gci5zZWxlY3Rpb25bNF0gIT09IDA7XG4gICAgfTtcblxuICAgIHZhciBldmVudEluQ29udGFpbmVyID0gZnVuY3Rpb24gZXZlbnRJbkNvbnRhaW5lcihlKSB7XG4gICAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgdmFyIHggPSBjb250YWluZXJQYWdlQ29vcmRzWzBdO1xuICAgICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgICAgdmFyIHdpZHRoID0gY29udGFpbmVyUGFnZUNvb3Jkc1syXTtcbiAgICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJQYWdlQ29vcmRzWzNdO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGUudG91Y2hlcyA/IGUudG91Y2hlcyA6IFtlXTtcbiAgICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9zaXRpb25zW2ldO1xuXG4gICAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgICAgYXRMZWFzdE9uZVBvc0luc2lkZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdExlYXN0T25lUG9zSW5zaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHIuY29udGFpbmVyO1xuICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIHZhciBjb250YWluZXJJc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgICBpZiAodFBhcmVudCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb250YWluZXJJc1RhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9OyAvLyBQcmltYXJ5IGtleVxuXG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoZSkge1xuICAgICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gZ3BvcztcblxuICAgICAgdmFyIGNoZWNrRm9yVGFwaG9sZCA9IGZ1bmN0aW9uIGNoZWNrRm9yVGFwaG9sZCgpIHtcbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQoci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICAgIGVsZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgICAgfTsgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG5cblxuICAgICAgaWYgKGUud2hpY2ggPT0gMykge1xuICAgICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgICBuZWFyLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7IC8vIFByaW1hcnkgYnV0dG9uXG4gICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgfSAvLyBFbGVtZW50IGRyYWdnaW5nXG5cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHVuZGVyIHRoZSBjdXJzb3IgYW5kIGl0IGlzIGRyYWdnYWJsZSwgcHJlcGFyZSB0byBncmFiIGl0XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgICBlbGUuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgICAgICBpZiAoIW5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHRyaWdnZXJHcmFiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3ducyA9IG5lYXJzO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH07XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IGVsc2UgaWYgKG5lYXIucGFubmFibGUoKSkge1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICAgIH1cblxuICAgICAgICBjaGVja0ZvclRhcGhvbGQoKTtcbiAgICAgIH0gLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG5cblxuICAgICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuICAgIH0sIGZhbHNlKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZW1vdmUnLCBmdW5jdGlvbiBtb3VzZW1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgZ3BvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgICB2YXIgbWRvd25HUG9zID0gci5ob3ZlckRhdGEubWRvd25HUG9zO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgICAgdmFyIG5lYXIgPSBudWxsO1xuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcblxuICAgICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgICB2YXIgZHggPSBncG9zWzBdIC0gbWRvd25HUG9zWzBdO1xuICAgICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuXG4gICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vtb3ZlJywgJ3Ztb3VzZW1vdmUnLCAndGFwZHJhZyddLCBlLCB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9KTtcblxuICAgICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnYm94c3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9OyAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuXG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMykge1xuICAgICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICAgIGRvd24uZW1pdChjeHRFdnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcblxuICAgICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgICB2YXIgZGVsdGFQO1xuXG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuKSB7XG4gICAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgICAgeDogKHBvc1swXSAtIG1kUG9zWzBdKSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IChwb3NbMV0gLSBtZFBvc1sxXSkgKiB6b29tXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kucGFuQnkoZGVsdGFQKTtcbiAgICAgICAgICBjeS5lbWl0KCdkcmFncGFuJyk7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICAgIH0gLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcblxuXG4gICAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7IC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgICAgfSBlbHNlIGlmIChzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24ucGFubmFibGUoKSkpIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAobXVsdFNlbEtleURvd24gfHwgIWN5LnBhbm5pbmdFbmFibGVkKCkgfHwgIWN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSkge1xuICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIHIuaG92ZXJEYXRhLmRvd25zKTtcblxuICAgICAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KG1kb3duUG9zKTtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghZG93biB8fCAhZG93bi5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlciddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHRha2UgYWN0aW9uXG4gICAgICAgICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSkge1xuICAgICAgICAgICAgICAvLyBkcmFnIG5vZGVcbiAgICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuICAgICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuXG4gICAgICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZW1lbnRzLCB7XG4gICAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlciQxKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KCdwb3NpdGlvbiBkcmFnJyk7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuXG5cbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgICBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgdmFyIGNsaWNrVGltZW91dCwgZGlkRG91YmxlQ2xpY2ssIHByZXZDbGlja1RpbWVTdGFtcDtcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gbW91c2V1cEhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgICBpZiAoIWNhcHR1cmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICAgIGlmIChyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG5cbiAgICAgIGlmIChkb3duKSB7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgICB2YXIgY3h0VGFwID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICAgIGRvd24uZW1pdChjeHRUYXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KGN4dFRhcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZXVwJywgJ3RhcGVuZCcsICd2bW91c2V1cCddLCBlLCB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJiAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAgICFyLmhvdmVyRGF0YS5kcmFnZ2VkICYmIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgICAhci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICAgICAgICApIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcImNsaWNrXCIsIFwidGFwXCIsIFwidmNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaWREb3VibGVDbGljayA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGUudGltZVN0YW1wIC0gcHJldkNsaWNrVGltZVN0YW1wIDw9IGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSkge1xuICAgICAgICAgICAgY2xpY2tUaW1lb3V0ICYmIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXQpO1xuICAgICAgICAgICAgZGlkRG91YmxlQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgcHJldkNsaWNrVGltZVN0YW1wID0gbnVsbDtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiZGJsY2xpY2tcIiwgXCJkYmx0YXBcIiwgXCJ2ZGJsY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGRpZERvdWJsZUNsaWNrKSByZXR1cm47XG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wib25lY2xpY2tcIiwgXCJvbmV0YXBcIiwgXCJ2b25lY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKTtcbiAgICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuXG5cbiAgICAgICAgaWYgKGRvd24gPT0gbnVsbCAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG4gICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuXG4gICAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICB9IC8vIFNpbmdsZSBzZWxlY3Rpb25cblxuXG4gICAgICAgIGlmIChuZWFyID09IGRvd24gJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykgOyBlbHNlIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShuZWFyKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoYm94Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScpIHtcbiAgICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UoYm94KS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG4gICAgICAgICAgfSAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuXG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IC8vIENhbmNlbCBkcmFnIHBhblxuXG5cbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGRvd25XYXNHcmFiYmVkKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cblxuICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgPSBmYWxzZTtcbiAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBudWxsO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiB3aGVlbEhhbmRsZXIoZSkge1xuICAgICAgaWYgKHIuc2Nyb2xsaW5nUGFnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuXG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBycG9zID0gW3Bvc1swXSAqIHpvb20gKyBwYW4ueCwgcG9zWzFdICogem9vbSArIHBhbi55XTtcblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoci5kYXRhLndoZWVsVGltZW91dCk7XG4gICAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgdmFyIGRpZmY7XG5cbiAgICAgICAgaWYgKGUuZGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgICBkaWZmID0gZS5kZWx0YVkgLyAtMjUwO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGFZIC8gMTAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuXG4gICAgICAgIGlmIChuZWVkc1doZWVsRml4KSB7XG4gICAgICAgICAgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1pvb20gPSBjeS56b29tKCkgKiBNYXRoLnBvdygxMCwgZGlmZik7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnKSB7XG4gICAgICAgICAgbmV3Wm9vbSA9IHIuZ2VzdHVyZVN0YXJ0Wm9vbSAqIGUuc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBjeS56b29tKHtcbiAgICAgICAgICBsZXZlbDogbmV3Wm9vbSxcbiAgICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBycG9zWzBdLFxuICAgICAgICAgICAgeTogcnBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN5LmVtaXQoZS50eXBlID09PSAnZ2VzdHVyZWNoYW5nZScgPyAncGluY2h6b29tJyA6ICdzY3JvbGx6b29tJyk7XG4gICAgICB9XG4gICAgfTsgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgICAvLyAtLVxuXG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTW91c2VTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChyLnNjcm9sbGluZ1BhZ2VUaW1lb3V0KTtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgICB9LCAyNTApO1xuICAgIH0sIHRydWUpOyAvLyBkZXNrdG9wIHNhZmFyaSBwaW5jaCB0byB6b29tIHN0YXJ0XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2dlc3R1cmVzdGFydCcsIGZ1bmN0aW9uIGdlc3R1cmVTdGFydEhhbmRsZXIoZSkge1xuICAgICAgci5nZXN0dXJlU3RhcnRab29tID0gci5jeS56b29tKCk7XG5cbiAgICAgIGlmICghci5oYXNUb3VjaFN0YXJ0ZWQpIHtcbiAgICAgICAgLy8gZG9uJ3QgYWZmZWN0IHRvdWNoIGRldmljZXMgbGlrZSBpcGhvbmVcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZWNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAgIC8vIGRvbid0IGFmZmVjdCB0b3VjaCBkZXZpY2VzIGxpa2UgaXBob25lXG4gICAgICAgIHdoZWVsSGFuZGxlcihlKTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTsgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHIuY3kuZW1pdCh7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBmYWxzZSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbiBtb3VzZU92ZXJIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgci5jeS5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBmYWxzZSk7XG4gICAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuXG4gICAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cblxuICAgIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG5cbiAgICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICAgIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICAgIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIH07XG5cbiAgICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uIGRpc3RhbmNlU3EoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gICAgfTtcblxuICAgIHZhciB0b3VjaHN0YXJ0SGFuZGxlcjtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoc3RhcnRIYW5kbGVyKGUpIHtcbiAgICAgIHIuaGFzVG91Y2hTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICB9IC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyk7XG4gICAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICAgIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICAgIGNvbnRhaW5lckhlaWdodCA9IG9mZnNldHNbM107XG4gICAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHQgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgICBjZW50ZXIxID0gWyhmMXgxICsgZjJ4MSkgLyAyLCAoZjF5MSArIGYyeTEpIC8gMl07XG4gICAgICAgIG1vZGVsQ2VudGVyMSA9IFsoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbV07IC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG5cbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcblxuICAgICAgICBpZiAoZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSkge1xuICAgICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAobmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSkge1xuICAgICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgLy8gc2FmYXJpIG9uIGlvcyBwYW5zIHRoZSBwYWdlIG90aGVyd2lzZSAobm9ybWFsbHkgeW91IHNob3VsZCBiZSBhYmxlIHRvIHByZXZlbnRkZWZhdWx0IG9uIHRvdWNobW92ZS4uLilcbiAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG5cbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnRzID0gbmVhcnM7XG5cbiAgICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gbnVsbDtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKHNlbGVjdGVkTm9kZXMsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVzKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIG4uZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSAvLyBUYXAsIHRhcGhvbGRcbiAgICAgICAgLy8gLS0tLS1cblxuXG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgIHZhciBzUG9zID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc1Bvc1tpXSA9IGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFt0b3VjaDAuY2xpZW50WCwgdG91Y2gwLmNsaWVudFldO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICB2YXIgdG91Y2htb3ZlSGFuZGxlcjtcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2htb3ZlSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEdQb3MgPSByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbjtcbiAgICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zKSB7XG4gICAgICAgIHZhciBkaXNwID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgICAgdmFyIGR5ID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydEdQb3NbMV07XG4gICAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMjtcbiAgICAgIH0gLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG5cblxuICAgICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wOyAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7IC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcblxuICAgICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBjb250ZXh0IHN3aXBlXG5cblxuICAgICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBib3ggc2VsZWN0aW9uXG5cbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnYm94c3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IHRydWU7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG5cbiAgICAgICAgaWYgKCFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzICsgMTtcbiAgICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpOyAvLyBwaW5jaCB0byB6b29tXG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHBpbmNoLXRvLXpvb21cbiAgICAgICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgaWYgKGRyYWdnZWRFbGVzKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuICAgICAgICAgICAgZGVfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBkZV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0OyAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG5cbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7IC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcblxuICAgICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICAgIGlmICh0d29GaW5nZXJzU3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxOyAvLyBkZWx0YSBmaW5nZXIgMlxuXG4gICAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxOyAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcblxuICAgICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkgLyAyO1xuICAgICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyOyAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG5cbiAgICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgICAgdmFyIHpvb20yID0gem9vbTEgKiBmYWN0b3I7XG4gICAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTsgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG5cbiAgICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG4gICAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgICAgfTsgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuXG4gICAgICAgICAgaWYgKF9zdGFydCAmJiBfc3RhcnQuYWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICAgICAgX3N0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KCdmcmVlb24nKTtcblxuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICAgIF9zdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG5cbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN5LmVtaXQoJ3BpbmNoem9vbScpO1xuICAgICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgICBmMXkxID0gZjF5MjtcbiAgICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgICBmMnkxID0gZjJ5MjtcbiAgICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBSZS1wcm9qZWN0XG5cblxuICAgICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHNpbmdsZSBmaW5nZXIgZXZlbnRzIGxpa2UgcGFubmluZ1xuICAgICAgKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICAgIHZhciBuZWFyO1xuXG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZykge1xuICAgICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IC8vIGRyYWdnaW5nIG5vZGVzXG5cblxuICAgICAgICBpZiAoY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsICYmIHIubm9kZUlzRHJhZ2dhYmxlKHN0YXJ0KSkge1xuICAgICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVzLCB7XG4gICAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcblxuICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXSkge1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdG91Y2htb3ZlXG5cblxuICAgICAgICB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCB8fCBuZWFyLCBbJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoKCFzdGFydCB8fCAhc3RhcnQuZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgIGxhc3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ291dCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ292ZXInLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9IC8vIGNoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG5cbiAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vd1tpXSAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldICYmIGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHBhbm5pbmdcblxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0LnBhbm5hYmxlKCkpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKHN0YXJ0LCByLnRvdWNoRGF0YS5zdGFydHMpO1xuXG4gICAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKCFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLnN3aXBlUGFubmluZykge1xuICAgICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN5LmVtaXQoJ2RyYWdwYW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjeS5lbWl0KCdkcmFncGFuJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBSZS1wcm9qZWN0XG5cblxuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgICB9IC8vIHRoZSBhY3RpdmUgYmcgaW5kaWNhdG9yIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gbWFraW5nIGEgc3dpcGUgdGhhdCBpcyBuZWl0aGVyIGZvciBkcmFnZ2luZyBub2RlcyBvciBwYW5uaW5nXG5cblxuICAgICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcgJiYgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB0b3VjaGVuZEhhbmRsZXIsIGRpZERvdWJsZVRvdWNoLCB0b3VjaFRpbWVvdXQsIHByZXZUb3VjaFRpbWVTdGFtcDtcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICAgIHIuc3dpcGVQYW5uaW5nID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHhUYXBlbmQ7XG5cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgICAgY3R4VGFwZW5kID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgICAgdmFyIGN0eFRhcCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KGN0eFRhcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG5cblxuICAgICAgaWYgKCFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnYm94ZW5kJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcblxuICAgICAgICBpZiAoYm94Lm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIDsgZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0V2FzR3JhYmJlZCkge1xuICAgICAgICAgICAgc3RhcnQuZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgc3RhcnQuZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgICAgdmFyIGR5ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSAtIG5vd1sxXTtcbiAgICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207IC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuXG4gICAgICAgIGlmICghci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCkge1xuICAgICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpZERvdWJsZVRvdWNoID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2VG91Y2hUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgICB0b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRvdWNoVGltZW91dCk7XG4gICAgICAgICAgICBkaWREb3VibGVUb3VjaCA9IHRydWU7XG4gICAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydkYmx0YXAnLCAndmRibGNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGRpZERvdWJsZVRvdWNoKSByZXR1cm47XG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsnb25ldGFwJywgJ3ZvbmVjbGljayddLCBlLCB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSk7XG4gICAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuXG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICAgJiYgc3RhcnQuX3ByaXZhdGUuc2VsZWN0YWJsZSAmJiByZGlzdDIgPCByLnRvdWNoVGFwVGhyZXNob2xkMiAmJiAhci5waW5jaGluZyAvLyBwaW5jaCB0byB6b29tIHNob3VsZCBub3QgYWZmZWN0IHNlbGVjdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKHN0YXJ0KS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBzdGFydC51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgICB9XG5cbiAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCB0b3VjaHN0YXJ0XG5cbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBudWxsO1xuICAgICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhlIG9sZCBzdGFydCBnbG9iYWwgcG9zJ24gbWF5IG5vdCBiZSB0aGUgc2FtZSBmaW5nZXIgdGhhdCByZW1haW5zXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IC8vci5yZWRyYXcoKTtcblxuICAgIH0sIGZhbHNlKTsgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcblxuICAgIGlmICh0eXBlb2YgVG91Y2hFdmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBwb2ludGVycyA9IFtdO1xuXG4gICAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24gbWFrZVRvdWNoKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICAgIGZvcmNlOiAxLFxuICAgICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICAgIHJhZGl1c1g6IGUud2lkdGggLyAyLFxuICAgICAgICAgIHJhZGl1c1k6IGUuaGVpZ2h0IC8gMixcbiAgICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uIG1ha2VQb2ludGVyKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uIGFkZFBvaW50ZXIoZSkge1xuICAgICAgICBwb2ludGVycy5wdXNoKG1ha2VQb2ludGVyKGUpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJzW2ldO1xuXG4gICAgICAgICAgaWYgKHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICAgICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGUpIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludGVycy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgcC5ldmVudCA9IGU7XG4gICAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiBhZGRUb3VjaGVzVG9FdmVudChlKSB7XG4gICAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLnRvdWNoO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwb2ludGVySXNNb3VzZSA9IGZ1bmN0aW9uIHBvaW50ZXJJc01vdXNlKGUpIHtcbiAgICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gNDtcbiAgICAgIH07XG5cbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFkZFBvaW50ZXIoZSk7XG4gICAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgICB0b3VjaHN0YXJ0SGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgICAgdG91Y2hlbmRIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB1cGRhdGVQb2ludGVyKGUpO1xuICAgICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgICAgdG91Y2htb3ZlSGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQlJwJDIgPSB7fTtcblxuICBCUnAkMi5nZW5lcmF0ZVBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiAnZWxsaXBzZScsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyICsgcGFkZGluZywgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICByZXR1cm4gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgICAvLyBQcmUtY29tcHV0ZSBjb250cm9sIHBvaW50c1xuICAgIC8vIFNpbmNlIHRoZXNlIHBvaW50cyBkZXBlbmQgb24gdGhlIHJhZGl1cyBsZW5ndGggKHdoaWNoIGluIHR1cm5zIGRlcGVuZCBvbiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBub2RlKSB3ZSB3aWxsIG9ubHkgcHJlLWNvbXB1dGVcbiAgICAvLyB0aGUgdW5pdCB2ZWN0b3JzLlxuICAgIC8vIEZvciBzaW1wbGljaXR5IHRoZSBsYXlvdXQgd2lsbCBiZTpcbiAgICAvLyBbIHAwLCBVbml0VmVjdG9yUDBQMSwgcDEsIFVuaVZlY3RvclAxUDIsIC4uLiwgcG4sIFVuaXRWZWN0b3JQblAwIF1cbiAgICB2YXIgYWxsUG9pbnRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaSAqIDI7XG4gICAgICB2YXIgZGVzdEluZGV4ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICBkZXN0SW5kZXggPSAoaSArIDEpICogMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3RJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGFsbFBvaW50c1tpICogNF0gPSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgICAgYWxsUG9pbnRzW2kgKiA0ICsgMV0gPSBwb2ludHNbc291cmNlSW5kZXggKyAxXTtcbiAgICAgIHZhciB4RGVzdCA9IHBvaW50c1tkZXN0SW5kZXhdIC0gcG9pbnRzW3NvdXJjZUluZGV4XTtcbiAgICAgIHZhciB5RGVzdCA9IHBvaW50c1tkZXN0SW5kZXggKyAxXSAtIHBvaW50c1tzb3VyY2VJbmRleCArIDFdO1xuICAgICAgdmFyIG5vcm0gPSBNYXRoLnNxcnQoeERlc3QgKiB4RGVzdCArIHlEZXN0ICogeURlc3QpO1xuICAgICAgYWxsUG9pbnRzW2kgKiA0ICsgMl0gPSB4RGVzdCAvIG5vcm07XG4gICAgICBhbGxQb2ludHNbaSAqIDQgKyAzXSA9IHlEZXN0IC8gbm9ybTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcG9pbnRzOiBhbGxQb2ludHMsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdyb3VuZC1wb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICByZXR1cm4gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydyb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGRpYW0gPSBjb3JuZXJSYWRpdXMgKiAyOyAvLyBDaGVjayBoQm94XG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVDdXRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snY3V0LXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogJ2N1dC1yZWN0YW5nbGUnLFxuICAgICAgY29ybmVyTGVuZ3RoOiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSxcbiAgICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB2YXIgY2wgPSB0aGlzLmNvcm5lckxlbmd0aDtcbiAgICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7IC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSB0cmlhbmdsZSBwdCBvbiBbNCwgNV1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGNsLCB4QmVnaW4gKyBjbCwgeUJlZ2luLCB4QmVnaW4gKyBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBjbCwgeEVuZCAtIGNsLCB5RW5kLCB4RW5kIC0gY2wsIHlFbmQgLSBjbF0sXG4gICAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIGNsLCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBjbCwgeEJlZ2luICsgY2wsIHlFbmQgLSBjbF1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICB2YXIgY1B0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcbiAgICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdC5hcHBseShbXSwgW2NQdHMudG9wTGVmdC5zcGxpY2UoMCwgNCksIGNQdHMudG9wUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbVJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21MZWZ0LnNwbGljZSgwLCA0KV0pO1xuICAgICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICAvLyBDaGVjayBoQm94XG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXRUcmlhbmdsZVB0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BMZWZ0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21SaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbUxlZnQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVCYXJyZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYmFycmVsJ10gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6ICdiYXJyZWwnLFxuICAgICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgLy8gdXNlIHR3byBmaXhlZCB0IHZhbHVlcyBmb3IgdGhlIGJlemllciBjdXJ2ZSBhcHByb3hpbWF0aW9uXG4gICAgICAgIHZhciB0MCA9IDAuMTU7XG4gICAgICAgIHZhciB0MSA9IDAuNTtcbiAgICAgICAgdmFyIHQyID0gMC44NTtcbiAgICAgICAgdmFyIGJQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuXG4gICAgICAgIHZhciBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzID0gZnVuY3Rpb24gYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhwdHMpIHtcbiAgICAgICAgICAvLyBhcHByb3hpbWF0ZSBjdXJ2ZSBwdHMgYmFzZWQgb24gdGhlIHR3byB0IHZhbHVlc1xuICAgICAgICAgIHZhciBtMCA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICAgIH0sIHQwKTtcbiAgICAgICAgICB2YXIgbTEgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgICB9LCB0MSk7XG4gICAgICAgICAgdmFyIG0yID0gcWJlemllclB0QXQoe1xuICAgICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgICAgfSwgdDIpO1xuICAgICAgICAgIHJldHVybiBbcHRzWzBdLCBwdHNbMV0sIG0wLngsIG0wLnksIG0xLngsIG0xLnksIG0yLngsIG0yLnksIHB0c1s0XSwgcHRzWzVdXTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHRzID0gW10uY29uY2F0KGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BMZWZ0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcFJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbVJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbUxlZnQpKTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUJhcnJlbEJlemllclB0czogZnVuY3Rpb24gZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcbiAgICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICAgICAgICB2YXIgY3RybFB0WE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdpZHRoOyAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgY29udHJvbCBwdCBvbiBbNCwgNV1cblxuICAgICAgICB2YXIgcHRzID0ge1xuICAgICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luICsgd09mZnNldCwgeUJlZ2luXSxcbiAgICAgICAgICB0b3BSaWdodDogW3hFbmQgLSB3T2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGhPZmZzZXRdLFxuICAgICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGhPZmZzZXQsIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kIC0gd09mZnNldCwgeUVuZF0sXG4gICAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIHdPZmZzZXQsIHlFbmQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGhPZmZzZXRdXG4gICAgICAgIH07XG4gICAgICAgIHB0cy50b3BMZWZ0LmlzVG9wID0gdHJ1ZTtcbiAgICAgICAgcHRzLnRvcFJpZ2h0LmlzVG9wID0gdHJ1ZTtcbiAgICAgICAgcHRzLmJvdHRvbUxlZnQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgICBwdHMuYm90dG9tUmlnaHQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHRzO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7IC8vIENoZWNrIGhCb3hcblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGhPZmZzZXQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogd09mZnNldCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhcnJlbEN1cnZlUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcblxuICAgICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgICAgdmFyIHgwID0gY3VydmVQdHNbNF07XG4gICAgICAgICAgdmFyIHgxID0gY3VydmVQdHNbMl07XG4gICAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgICAgdmFyIHkwID0gY3VydmVQdHNbNV07IC8vIHZhciB5MSA9IGN1cnZlUHRzWyAzIF07XG5cbiAgICAgICAgICB2YXIgeTIgPSBjdXJ2ZVB0c1sxXTtcbiAgICAgICAgICB2YXIgeE1pbiA9IE1hdGgubWluKHgwLCB4Mik7XG4gICAgICAgICAgdmFyIHhNYXggPSBNYXRoLm1heCh4MCwgeDIpO1xuICAgICAgICAgIHZhciB5TWluID0gTWF0aC5taW4oeTAsIHkyKTtcbiAgICAgICAgICB2YXIgeU1heCA9IE1hdGgubWF4KHkwLCB5Mik7XG5cbiAgICAgICAgICBpZiAoeE1pbiA8PSB4ICYmIHggPD0geE1heCAmJiB5TWluIDw9IHkgJiYgeSA8PSB5TWF4KSB7XG4gICAgICAgICAgICB2YXIgY29lZmYgPSBiZXppZXJQdHNUb1F1YWRDb2VmZih4MCwgeDEsIHgyKTtcbiAgICAgICAgICAgIHZhciByb290cyA9IHNvbHZlUXVhZHJhdGljKGNvZWZmWzBdLCBjb2VmZlsxXSwgY29lZmZbMl0sIHgpO1xuICAgICAgICAgICAgdmFyIHZhbGlkUm9vdHMgPSByb290cy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDAgPD0gciAmJiByIDw9IDE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkUm9vdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsaWRSb290c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3VydmVSZWdpb25zID0gT2JqZWN0LmtleXMoYmFycmVsQ3VydmVQdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVSZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvcm5lciA9IGN1cnZlUmVnaW9uc1tpXTtcbiAgICAgICAgICB2YXIgY29ybmVyUHRzID0gYmFycmVsQ3VydmVQdHNbY29ybmVyXTtcbiAgICAgICAgICB2YXIgdCA9IGdldEN1cnZlVCh4LCB5LCBjb3JuZXJQdHMpO1xuXG4gICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHkwID0gY29ybmVyUHRzWzVdO1xuICAgICAgICAgIHZhciB5MSA9IGNvcm5lclB0c1szXTtcbiAgICAgICAgICB2YXIgeTIgPSBjb3JuZXJQdHNbMV07XG4gICAgICAgICAgdmFyIGJlelkgPSBxYmV6aWVyQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgICAgICBpZiAoY29ybmVyUHRzLmlzVG9wICYmIGJlelkgPD0geSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvcm5lclB0cy5pc0JvdHRvbSAmJiB5IDw9IGJlelkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYm90dG9tLXJvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydib3R0b21yb3VuZHJlY3RhbmdsZSddID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsXG4gICAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB2YXIgdG9wSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcblxuICAgICAgICBpZiAodG9wSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRvcEludGVyc2VjdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGRpYW0gPSAyICogY29ybmVyUmFkaXVzOyAvLyBDaGVjayBoQm94XG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gY2hlY2sgbm9uLXJvdW5kZWQgdG9wIHNpZGVcblxuXG4gICAgICAgIHZhciBvdXRlcldpZHRoID0gd2lkdGggLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICAgIHZhciBvdXRlckhlaWdodCA9IGhlaWdodCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgICAgdmFyIHBvaW50cyA9IFtjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0LCBjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHRdO1xuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5yZWdpc3Rlck5vZGVTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2VuZXJhdGVFbGxpcHNlKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3JlY3RhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSk7XG4gICAgbm9kZVNoYXBlc1snc3F1YXJlJ10gPSBub2RlU2hhcGVzWydyZWN0YW5nbGUnXTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUoKTtcbiAgICB0aGlzLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5nZW5lcmF0ZUJhcnJlbCgpO1xuICAgIHRoaXMuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSgpO1xuICAgIHtcbiAgICAgIHZhciBkaWFtb25kUG9pbnRzID0gWzAsIDEsIDEsIDAsIDAsIC0xLCAtMSwgMF07XG4gICAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICAgICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigncGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXBlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ29jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLW9jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICAgIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gICAge1xuICAgICAgdmFyIG91dGVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICAgIHZhciBpbm5lclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpOyAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuXG4gICAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCg1KSk7XG4gICAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICBpbm5lclBvaW50c1tpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICAgIGlubmVyUG9pbnRzW2kgKiAyICsgMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjAgLyA0OyBpKyspIHtcbiAgICAgICAgc3RhcjVQb2ludHNbaSAqIDRdID0gb3V0ZXJQb2ludHNbaSAqIDJdO1xuICAgICAgICBzdGFyNVBvaW50c1tpICogNCArIDFdID0gb3V0ZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAyXSA9IGlubmVyUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAzXSA9IGlubmVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXI1UG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHN0YXI1UG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigndmVlJywgWy0xLCAtMSwgMCwgLTAuMzMzLCAxLCAtMSwgMCwgMV0pO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaG9tYm9pZCcsIFstMSwgLTEsIDAuMzMzLCAtMSwgMSwgMSwgLTAuMzMzLCAxXSk7XG4gICAgdGhpcy5ub2RlU2hhcGVzWydjb25jYXZlaGV4YWdvbiddID0gdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmUtaGV4YWdvbicsIFstMSwgLTAuOTUsIC0wLjc1LCAwLCAtMSwgMC45NSwgMSwgMC45NSwgMC43NSwgMCwgMSwgLTAuOTVdKTtcbiAgICB7XG4gICAgICB2YXIgdGFnUG9pbnRzID0gWy0xLCAtMSwgMC4yNSwgLTEsIDEsIDAsIDAuMjUsIDEsIC0xLCAxXTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCB0YWdQb2ludHMpO1xuICAgICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdGFnJywgdGFnUG9pbnRzKTtcbiAgICB9XG5cbiAgICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgLy8gdXNlIGNhY2hpbmcgb24gdXNlci1zcGVjaWZpZWQgcG9seWdvbnMgc28gdGhleSBhcmUgYXMgZmFzdCBhcyBuYXRpdmUgc2hhcGVzXG4gICAgICB2YXIga2V5ID0gcG9pbnRzLmpvaW4oJyQnKTtcbiAgICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICAgIHZhciBzaGFwZTtcblxuICAgICAgaWYgKHNoYXBlID0gdGhpc1tuYW1lXSkge1xuICAgICAgICAvLyBnb3QgY2FjaGVkIHNoYXBlXG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH0gLy8gY3JlYXRlIGFuZCBjYWNoZSBuZXcgc2hhcGVcblxuXG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2VuZXJhdGVQb2x5Z29uKG5hbWUsIHBvaW50cyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgQlJwJDEgPSB7fTtcblxuICBCUnAkMS50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbiAgfTtcblxuICBCUnAkMS5yZWRyYXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHIubGFzdERyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHIubGFzdERyYXdUaW1lID0gMDtcbiAgICB9XG5cbiAgICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xuICB9O1xuXG4gIEJScCQxLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChmbiwgcHJpb3JpdHkpIHtcbiAgICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYWRkIHRpY2sgY2FsbGJhY2tzIHdoZW4gZGVzdHJveWVkXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdQcmlvcml0eSBpcyBub3Qgb3B0aW9uYWwgZm9yIGJlZm9yZVJlbmRlcicpO1xuICAgIH1cblxuICAgIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcbiAgICBjYnMucHVzaCh7XG4gICAgICBmbjogZm4sXG4gICAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgICB9KTsgLy8gaGlnaGVyIHByaW9yaXR5IGNhbGxiYWNrcyBleGVjdXRlZCBmaXJzdFxuXG4gICAgY2JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHdpbGxEcmF3LCBzdGFydFRpbWUpIHtcbiAgICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkMS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBjeSA9IHIuY3k7XG5cbiAgICBpZiAoci5yZW5kZXJMb29wU3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihyZXF1ZXN0VGltZSkge1xuICAgICAgaWYgKHIuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGN5LmJhdGNoaW5nKCkpIDsgZWxzZSBpZiAoci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUpIHtcbiAgICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHRydWUsIHJlcXVlc3RUaW1lKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHIucmVuZGVyKHIucmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIHZhciBlbmRUaW1lID0gci5sYXN0RHJhd1RpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICAgIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgICBpZiAoci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGR1cmF0aW9uO1xuICAgICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247IC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcblxuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZSAvIDIgKyBkdXJhdGlvbiAvIDI7XG4gICAgICAgIHIucmVxdWVzdGVkRnJhbWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCBmYWxzZSwgcmVxdWVzdFRpbWUpO1xuICAgICAgfVxuXG4gICAgICByLnNraXBGcmFtZSA9IGZhbHNlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbiAgfTtcblxuICB2YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24gQmFzZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIEJSID0gQmFzZVJlbmRlcmVyO1xuICB2YXIgQlJwID0gQlIucHJvdG90eXBlO1xuICBCUnAuY2xpZW50RnVuY3Rpb25zID0gWydyZWRyYXdIaW50JywgJ3JlbmRlcicsICdyZW5kZXJUbycsICdtYXRjaENhbnZhc1NpemUnLCAnbm9kZVNoYXBlSW1wbCcsICdhcnJvd1NoYXBlSW1wbCddO1xuXG4gIEJScC5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgci5vcHRpb25zID0gb3B0aW9ucztcbiAgICByLmN5ID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgY3RyID0gci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpOyAvLyBwcmVwZW5kIGEgc3R5bGVzaGVldCBpbiB0aGUgaGVhZCBzdWNoIHRoYXRcblxuICAgIGlmICh3aW5kb3ckMSkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93JDEuZG9jdW1lbnQ7XG4gICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgICB2YXIgc3R5bGVzaGVldElkID0gJ19fX19fX19fX19jeXRvc2NhcGVfc3R5bGVzaGVldCc7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gJ19fX19fX19fX19jeXRvc2NhcGVfY29udGFpbmVyJztcbiAgICAgIHZhciBzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlc2hlZXRJZCkgIT0gbnVsbDtcblxuICAgICAgaWYgKGN0ci5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgICBjdHIuY2xhc3NOYW1lID0gKGN0ci5jbGFzc05hbWUgfHwgJycpICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVzaGVldC5pZCA9IHN0eWxlc2hlZXRJZDtcbiAgICAgICAgc3R5bGVzaGVldC5pbm5lckhUTUwgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVzaGVldCwgaGVhZC5jaGlsZHJlblswXSk7IC8vIGZpcnN0IHNvIGxvd2VzdCBwcmlvcml0eVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY3RyKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICB3YXJuKCdBIEN5dG9zY2FwZSBjb250YWluZXIgaGFzIHN0eWxlIHBvc2l0aW9uOnN0YXRpYyBhbmQgc28gY2FuIG5vdCB1c2UgVUkgZXh0ZW5zaW9ucyBwcm9wZXJseScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gICAgci5iZXppZXJQcm9qUGN0cyA9IFswLjA1LCAwLjIyNSwgMC40LCAwLjUsIDAuNiwgMC43NzUsIDAuOTVdOyAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcblxuICAgIHIuaG92ZXJEYXRhID0ge1xuICAgICAgZG93bjogbnVsbCxcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkb3duVGltZTogbnVsbCxcbiAgICAgIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgaW5pdGlhbFBhbjogW251bGwsIG51bGxdLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9O1xuICAgIHIuZHJhZ0RhdGEgPSB7XG4gICAgICBwb3NzaWJsZURyYWdFbGVtZW50czogW11cbiAgICB9O1xuICAgIHIudG91Y2hEYXRhID0ge1xuICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuICAgICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICB9O1xuICAgIHIucmVkcmF3cyA9IDA7XG4gICAgci5zaG93RnBzID0gb3B0aW9ucy5zaG93RnBzO1xuICAgIHIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICByLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuXG4gICAgci5mb3JjZWRQaXhlbFJhdGlvID0gbnVtYmVyJDEob3B0aW9ucy5waXhlbFJhdGlvKSA/IG9wdGlvbnMucGl4ZWxSYXRpbyA6IG51bGw7XG4gICAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuXG4gICAgci5tb3Rpb25CbHVyT3BhY2l0eSA9IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHk7XG4gICAgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ID0gMSAtIHIubW90aW9uQmx1ck9wYWNpdHk7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gICAgci5tYlB4UkJsdXJyeSA9IDE7IC8vMC44O1xuXG4gICAgci5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICAgIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgICByLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gICAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgICByLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICAgIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuICAgIHIuYmluZGluZ3MgPSBbXTtcbiAgICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICAgIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHtcbiAgICAgIC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgICBhbmltYXRpb25zOiA0MDAsXG4gICAgICBlbGVDYWxjczogMzAwLFxuICAgICAgZWxlVHhyRGVxOiAyMDAsXG4gICAgICBseXJUeHJEZXE6IDE1MCxcbiAgICAgIGx5clR4clNraXA6IDEwMFxuICAgIH07XG4gICAgci5yZWdpc3Rlck5vZGVTaGFwZXMoKTtcbiAgICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBCUnAubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxlcykge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgY3kgPSByLmN5OyAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgbm90aWZpZWQgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudE5hbWUgPT09ICdpbml0Jykge1xuICAgICAgci5sb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgICByLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAnYWRkJyB8fCBldmVudE5hbWUgPT09ICdyZW1vdmUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdmUnICYmIGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSB8fCBldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICd6b3JkZXInIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICdyZXNpemUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICB0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgQlJwLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiaW5kaW5nID0gci5iaW5kaW5nc1tpXTtcbiAgICAgIHZhciBiID0gYmluZGluZztcbiAgICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcbiAgICAgICh0Z3Qub2ZmIHx8IHRndC5yZW1vdmVFdmVudExpc3RlbmVyKS5hcHBseSh0Z3QsIGIuYXJncyk7XG4gICAgfVxuXG4gICAgci5iaW5kaW5ncyA9IFtdO1xuICAgIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gICAgci5vblVwZGF0ZUVsZUNhbGNzRm5zID0gW107XG5cbiAgICBpZiAoci5yZW1vdmVPYnNlcnZlcikge1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHIuc3R5bGVPYnNlcnZlcikge1xuICAgICAgci5zdHlsZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiAoci5yZXNpemVPYnNlcnZlcikge1xuICAgICAgci5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHIubGFiZWxDYWxjRGl2KSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgfSBjYXRjaCAoZSkgey8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwLmlzSGVhZGxlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFtCUnAkZiwgQlJwJDUsIEJScCQ0LCBCUnAkMywgQlJwJDIsIEJScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChCUnAsIHByb3BzKTtcbiAgfSk7XG5cbiAgdmFyIGZ1bGxGcHNUaW1lID0gMTAwMCAvIDYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxuICB2YXIgZGVmcyA9IHtcbiAgICBzZXR1cERlcXVldWVpbmc6IGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZyhvcHRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgaWYgKHNlbGYuZGVxdWV1ZWluZ1NldHVwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZGVxdWV1ZWluZ1NldHVwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IGRlYm91bmNlXzEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIG9wdHMuZGVxUmVkcmF3VGhyZXNob2xkKTtcblxuICAgICAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUod2lsbERyYXcsIGZyYW1lU3RhcnRUaW1lKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICAgIHZhciByZW5kZXJUaW1lID0gci5sYXN0UmVkcmF3VGltZTtcbiAgICAgICAgICB2YXIgZGVxZCA9IFtdO1xuICAgICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7IC8vIGlmIHdlIGFyZW4ndCBpbiBhIHRpY2sgdGhhdCBjYXVzZXMgYSBkcmF3LCB0aGVuIHRoZSByZW5kZXJlZCBzdHlsZVxuICAgICAgICAgIC8vIHF1ZXVlIHdvbid0IGF1dG9tYXRpY2FsbHkgYmUgZmx1c2hlZCBiZWZvcmUgZGVxdWV1ZWluZyBzdGFydHNcblxuICAgICAgICAgIGlmICghd2lsbERyYXcpIHtcbiAgICAgICAgICAgIHIuZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBub3cgLSBmcmFtZVN0YXJ0VGltZTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclRpbWUgPCBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSByZW5kZXJpbmcgZmFzdGVyIHRoYW4gdGhlIGlkZWFsIGZwcywgdGhlbiBkbyBkZXF1ZXVlaW5nXG4gICAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG4gICAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWUgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcShzZWxmLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpc0RlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVxZC5wdXNoKHRoaXNEZXFkW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuXG5cbiAgICAgICAgICBpZiAoZGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvcHRzLm9uRGVxZChzZWxmLCBkZXFkKTtcblxuICAgICAgICAgICAgaWYgKCF3aWxsRHJhdyAmJiBvcHRzLnNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBwaXhlbFJhdGlvLCBleHRlbnQpKSB7XG4gICAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcmlvcml0eSA9IG9wdHMucHJpb3JpdHkgfHwgbm9vcCQxO1xuICAgICAgICByLmJlZm9yZVJlbmRlcihkZXF1ZXVlLCBwcmlvcml0eShzZWxmKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VzIGtleXMgc28gZWxlbWVudHMgbWF5IHNoYXJlIHRoZSBzYW1lIGNhY2hlLlxuXG4gIHZhciBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKGdldEtleSkge1xuICAgICAgdmFyIGRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzaWZ5O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCk7XG5cbiAgICAgIHRoaXMuaWRzQnlLZXkgPSBuZXcgTWFwJDIoKTtcbiAgICAgIHRoaXMua2V5Rm9ySWQgPSBuZXcgTWFwJDIoKTtcbiAgICAgIHRoaXMuY2FjaGVzQnlMdmwgPSBuZXcgTWFwJDIoKTtcbiAgICAgIHRoaXMubHZscyA9IFtdO1xuICAgICAgdGhpcy5nZXRLZXkgPSBnZXRLZXk7XG4gICAgICB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gZG9lc0VsZUludmFsaWRhdGVLZXk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAsIFt7XG4gICAgICBrZXk6IFwiZ2V0SWRzRm9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzRm9yKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcihcIkNhbiBub3QgZ2V0IGlkIGxpc3QgZm9yIG51bGwga2V5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkc0J5S2V5ID0gdGhpcy5pZHNCeUtleTtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzQnlLZXkuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKCFpZHMpIHtcbiAgICAgICAgICBpZHMgPSBuZXcgU2V0JDEoKTtcbiAgICAgICAgICBpZHNCeUtleS5zZXQoa2V5LCBpZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkSWRGb3JLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJZEZvcktleShrZXksIGlkKSB7XG4gICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSkuYWRkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVJZEZvcktleVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUlkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KVtcImRlbGV0ZVwiXShpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TnVtYmVyT2ZJZHNGb3JLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1iZXJPZklkc0ZvcktleShrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRzRm9yKGtleSkuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cGRhdGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgICB2YXIgY3VycktleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgICB0aGlzLmFkZElkRm9yS2V5KGN1cnJLZXksIGlkKTtcbiAgICAgICAgdGhpcy5rZXlGb3JJZC5zZXQoaWQsIGN1cnJLZXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgICAgdGhpcy5rZXlGb3JJZFtcImRlbGV0ZVwiXShpZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImtleUhhc0NoYW5nZWRGb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlIYXNDaGFuZ2VkRm9yKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICAgIHZhciBuZXdLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICByZXR1cm4gcHJldktleSAhPT0gbmV3S2V5O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0ludmFsaWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludmFsaWQoZWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUhhc0NoYW5nZWRGb3IoZWxlKSB8fCB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldENhY2hlc0F0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGVzQXQobHZsKSB7XG4gICAgICAgIHZhciBjYWNoZXNCeUx2bCA9IHRoaXMuY2FjaGVzQnlMdmwsXG4gICAgICAgICAgICBsdmxzID0gdGhpcy5sdmxzO1xuICAgICAgICB2YXIgY2FjaGVzID0gY2FjaGVzQnlMdmwuZ2V0KGx2bCk7XG5cbiAgICAgICAgaWYgKCFjYWNoZXMpIHtcbiAgICAgICAgICBjYWNoZXMgPSBuZXcgTWFwJDIoKTtcbiAgICAgICAgICBjYWNoZXNCeUx2bC5zZXQobHZsLCBjYWNoZXMpO1xuICAgICAgICAgIGx2bHMucHVzaChsdmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Q2FjaGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZShrZXksIGx2bCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmdldChrZXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZWxlLCBsdmwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpOyAvLyBnZXR0aW5nIGZvciBhbiBlbGVtZW50IG1heSBuZWVkIHRvIGFkZCB0byB0aGUgaWQgbGlzdCBiL2MgZWxlcyBjYW4gc2hhcmUga2V5c1xuXG4gICAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEZvckNhY2hlZEtleVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvckNhY2hlZEtleShlbGUsIGx2bCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoZWxlLmlkKCkpOyAvLyBuLmIuIHVzZSBjYWNoZWQga2V5LCBub3QgbmV3bHkgY29tcHV0ZWQga2V5XG5cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzQ2FjaGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNDYWNoZShrZXksIGx2bCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmhhcyhrZXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlLCBsdmwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NhY2hlKGtleSwgbHZsKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q2FjaGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpIHtcbiAgICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdldENhY2hlc0F0KGx2bCkuc2V0KGtleSwgY2FjaGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoZWxlLCBsdmwsIGNhY2hlKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICB0aGlzLnNldENhY2hlKGtleSwgbHZsLCBjYWNoZSk7XG4gICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVDYWNoZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlKGtleSwgbHZsKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGVsZSwgbHZsKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW52YWxpZGF0ZUtleVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5sdmxzLmZvckVhY2goZnVuY3Rpb24gKGx2bCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZXR1cm5zIHRydWUgaWYgbm8gb3RoZXIgZWxlcyByZWZlcmVuY2UgdGhlIGludmFsaWRhdGVkIGNhY2hlIChuLmIuIG90aGVyIGVsZXMgbWF5IG5lZWQgdGhlIGNhY2hlIHdpdGggdGhlIHNhbWUga2V5KVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTsgLy8gbi5iLiB1c2Ugc3RvcmVkIGtleSByYXRoZXIgdGhhbiBjdXJyZW50IChwb3RlbnRpYWwga2V5KVxuXG4gICAgICAgIHRoaXMuZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgICB2YXIgZW50aXJlS2V5SW52YWxpZGF0ZWQgPSB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG5cbiAgICAgICAgaWYgKGVudGlyZUtleUludmFsaWRhdGVkKSB7XG4gICAgICAgICAgLy8gY2xlYXIgbWFwcGluZyBmb3IgY3VycmVudCBrZXlcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRpcmVLZXlJbnZhbGlkYXRlZCB8fCB0aGlzLmdldE51bWJlck9mSWRzRm9yS2V5KGtleSkgPT09IDA7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXA7XG4gIH0oKTtcblxuICB2YXIgbWluVHhySCA9IDI1OyAvLyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBjYWNoZSBmb3Igc21hbGwgaGVpZ2h0IGVsZXMgKHNwZWNpYWwgY2FzZSlcblxuICB2YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG5cbiAgdmFyIG1pbkx2bCQxID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxuXG4gIHZhciBtYXhMdmwkMSA9IDM7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxuICB2YXIgbWF4Wm9vbSQxID0gNy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcblxuICB2YXIgZWxlVHhyU3BhY2luZyA9IDg7IC8vIHNwYWNpbmcgYmV0d2VlbiBlbGVtZW50cyBvbiB0ZXh0dXJlcyB0byBhdm9pZCBibGl0dGluZyBvdmVybGFwc1xuXG4gIHZhciBkZWZUeHJXaWR0aCA9IDEwMjQ7IC8vIGRlZmF1bHQvbWluaW11bSB0ZXh0dXJlIHdpZHRoXG5cbiAgdmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcblxuICB2YXIgbWF4VHhySCA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHRleHR1cmVcblxuICB2YXIgbWluVXRpbGl0eSA9IDAuMjsgLy8gaWYgdXNhZ2Ugb2YgdGV4dHVyZSBpcyBsZXNzIHRoYW4gdGhpcywgaXQgaXMgcmV0aXJlZFxuXG4gIHZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcblxuICB2YXIgbWF4RnVsbG5lc3NDaGVja3MgPSAxMDsgLy8gZGVxdWV1ZWQgYWZ0ZXIgdGhpcyBtYW55IGNoZWNrc1xuXG4gIHZhciBkZXFDb3N0JDEgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxuICB2YXIgZGVxQXZnQ29zdCQxID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxuXG4gIHZhciBkZXFOb0RyYXdDb3N0JDEgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG5cbiAgdmFyIGRlcUZhc3RDb3N0JDEgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbiAgdmFyIGRlcVJlZHJhd1RocmVzaG9sZCQxID0gMTAwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxuXG4gIHZhciBtYXhEZXFTaXplJDEgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG4gIHZhciBnZXRUeHJSZWFzb25zID0ge1xuICAgIGRlcXVldWU6ICdkZXF1ZXVlJyxcbiAgICBkb3duc2NhbGU6ICdkb3duc2NhbGUnLFxuICAgIGhpZ2hRdWFsaXR5OiAnaGlnaFF1YWxpdHknXG4gIH07XG4gIHZhciBpbml0RGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICBnZXRLZXk6IG51bGwsXG4gICAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGZhbHNpZnksXG4gICAgZHJhd0VsZW1lbnQ6IG51bGwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogbnVsbCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogbnVsbCxcbiAgICBpc1Zpc2libGU6IHRydWVpZnksXG4gICAgYWxsb3dFZGdlVHhyQ2FjaGluZzogdHJ1ZSxcbiAgICBhbGxvd1BhcmVudFR4ckNhY2hpbmc6IHRydWVcbiAgfSk7XG5cbiAgdmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlKHJlbmRlcmVyLCBpbml0T3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgc2VsZi5vbkRlcXVldWVzID0gW107XG4gICAgdmFyIG9wdHMgPSBpbml0RGVmYXVsdHMoaW5pdE9wdGlvbnMpO1xuICAgIGV4dGVuZChzZWxmLCBvcHRzKTtcbiAgICBzZWxmLmxvb2t1cCA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKG9wdHMuZ2V0S2V5LCBvcHRzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KTtcbiAgICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xuICB9O1xuXG4gIHZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG4gIEVUQ3AucmVhc29ucyA9IGdldFR4clJlYXNvbnM7IC8vIHRoZSBsaXN0IG9mIHRleHR1cmVzIGluIHdoaWNoIG5ldyBzdWJ0ZXh0dXJlcyBmb3IgZWxlbWVudHMgY2FuIGJlIHBsYWNlZFxuXG4gIEVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5lbGVJbWdDYWNoZXMgPSBzZWxmLmVsZUltZ0NhY2hlcyB8fCB7fTtcbiAgICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbiAgfTsgLy8gdGhlIGxpc3Qgb2YgdXN1c2VkIHRleHR1cmVzIHdoaWNoIGNhbiBiZSByZWN5Y2xlZCAoaW4gdXNlIGluIHRleHR1cmUgcXVldWUpXG5cblxuICBFVENwLmdldFJldGlyZWRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiAodHhySCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcnR4dHJRcyA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkIHx8IHt9O1xuICAgIHZhciBydHh0clEgPSBydHh0clFzW3R4ckhdID0gcnR4dHJRc1t0eHJIXSB8fCBbXTtcbiAgICByZXR1cm4gcnR4dHJRO1xuICB9OyAvLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVsc1xuXG5cbiAgRVRDcC5nZXRFbGVtZW50UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5lbGVDYWNoZVF1ZXVlID0gc2VsZi5lbGVDYWNoZVF1ZXVlIHx8IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICAgIH0pO1xuICAgIHJldHVybiBxO1xuICB9OyAvLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVscyAoZWxlbWVudCBpZCBsb29rdXApXG5cblxuICBFVENwLmdldEVsZW1lbnRLZXlUb1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgazJxID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSB8fCB7fTtcbiAgICByZXR1cm4gazJxO1xuICB9O1xuXG4gIEVUQ3AuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7XG5cbiAgICBpZiAoIWJiIHx8IGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCBpc05hTihiYi53KSB8fCBpc05hTihiYi5oKSB8fCAhZWxlLnZpc2libGUoKSB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuYWxsb3dFZGdlVHhyQ2FjaGluZyAmJiBlbGUuaXNFZGdlKCkgfHwgIXNlbGYuYWxsb3dQYXJlbnRUeHJDYWNoaW5nICYmIGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobHZsID09IG51bGwpIHtcbiAgICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gICAgfVxuXG4gICAgaWYgKGx2bCA8IG1pbkx2bCQxKSB7XG4gICAgICBsdmwgPSBtaW5MdmwkMTtcbiAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSQxIHx8IGx2bCA+IG1heEx2bCQxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICAgIHZhciBlbGVTY2FsZWRIID0gYmIuaCAqIHNjYWxlO1xuICAgIHZhciBlbGVTY2FsZWRXID0gYmIudyAqIHNjYWxlO1xuICAgIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUsIHNjYWxlKTtcblxuICAgIGlmICghdGhpcy5pc1Zpc2libGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGVsZUNhY2hlID0gbG9va3VwLmdldChlbGUsIGx2bCk7IC8vIGlmIHRoaXMgZ2V0IHdhcyBvbiBhbiB1bnVzZWQvaW52YWxpZGF0ZWQgY2FjaGUsIHRoZW4gcmVzdG9yZSB0aGUgdGV4dHVyZSB1c2FnZSBtZXRyaWNcblxuICAgIGlmIChlbGVDYWNoZSAmJiBlbGVDYWNoZS5pbnZhbGlkYXRlZCkge1xuICAgICAgZWxlQ2FjaGUuaW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZUNhY2hlLnRleHR1cmUuaW52YWxpZGF0ZWRXaWR0aCAtPSBlbGVDYWNoZS53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoZWxlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBlbGVDYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgdHhySDsgLy8gd2hpY2ggdGV4dHVyZSBoZWlnaHQgdGhpcyBlbGUgYmVsb25ncyB0b1xuXG4gICAgaWYgKGVsZVNjYWxlZEggPD0gbWluVHhySCkge1xuICAgICAgdHhySCA9IG1pblR4ckg7XG4gICAgfSBlbHNlIGlmIChlbGVTY2FsZWRIIDw9IHR4clN0ZXBIKSB7XG4gICAgICB0eHJIID0gdHhyU3RlcEg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4ckggPSBNYXRoLmNlaWwoZWxlU2NhbGVkSCAvIHR4clN0ZXBIKSAqIHR4clN0ZXBIO1xuICAgIH1cblxuICAgIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVykge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIGNhY2hpbmcgbGFyZ2UgZWxlbWVudHMgaXMgbm90IGVmZmljaWVudFxuICAgIH1cblxuICAgIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7IC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcblxuICAgIHZhciB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMl07XG5cbiAgICB2YXIgYWRkTmV3VHhyID0gZnVuY3Rpb24gYWRkTmV3VHhyKCkge1xuICAgICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICAgIH07IC8vIHRyeSB0aGUgbGFzdCBvbmUgaWYgdGhlcmUgaXMgbm8gc2Vjb25kIGxhc3Qgb25lXG5cblxuICAgIGlmICghdHhyKSB7XG4gICAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gICAgfSAvLyBpZiB0aGUgbGFzdCBvbmUgZG9lc24ndCBleGlzdCwgd2UgbmVlZCBhIGZpcnN0IG9uZVxuXG5cbiAgICBpZiAoIXR4cikge1xuICAgICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gICAgfSAvLyBpZiB0aGVyZSdzIG5vIHJvb20gaW4gdGhlIGN1cnJlbnQgdGV4dHVyZSwgd2UgbmVlZCBhIG5ldyBvbmVcblxuXG4gICAgaWYgKHR4ci53aWR0aCAtIHR4ci51c2VkV2lkdGggPCBlbGVTY2FsZWRXKSB7XG4gICAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGFibGVGcm9tID0gZnVuY3Rpb24gc2NhbGFibGVGcm9tKG90aGVyQ2FjaGUpIHtcbiAgICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgICB9O1xuXG4gICAgdmFyIGRlcWluZyA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZGVxdWV1ZTtcbiAgICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICAgIHZhciBkb3duc2NhbGVSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRvd25zY2FsZTtcbiAgICB2YXIgaGlnaGVyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBoaWdoZXIgbGV2ZWxcblxuICAgIGZvciAodmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bCQxOyBsKyspIHtcbiAgICAgIHZhciBjID0gbG9va3VwLmdldChlbGUsIGwpO1xuXG4gICAgICBpZiAoYykge1xuICAgICAgICBoaWdoZXJDYWNoZSA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvbmVVcENhY2hlID0gaGlnaGVyQ2FjaGUgJiYgaGlnaGVyQ2FjaGUubGV2ZWwgPT09IGx2bCArIDEgPyBoaWdoZXJDYWNoZSA6IG51bGw7XG5cbiAgICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24gZG93bnNjYWxlKCkge1xuICAgICAgdHhyLmNvbnRleHQuZHJhd0ltYWdlKG9uZVVwQ2FjaGUudGV4dHVyZS5jYW52YXMsIG9uZVVwQ2FjaGUueCwgMCwgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsIHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIGVsZVNjYWxlZEgpO1xuICAgIH07IC8vIHJlc2V0IGVsZSBhcmVhIGluIHRleHR1cmVcblxuXG4gICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHR4ci5jb250ZXh0LmNsZWFyUmVjdCh0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCB0eHJIKTtcblxuICAgIGlmIChzY2FsYWJsZUZyb20ob25lVXBDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICAgIGRvd25zY2FsZSgpO1xuICAgIH0gZWxzZSBpZiAoc2NhbGFibGVGcm9tKGhpZ2hlckNhY2hlKSkge1xuICAgICAgLy8gdGhlbiB1c2UgdGhlIGhpZ2hlciBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgbmV4dCBsZXZlbCBkb3duXG4gICAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcbiAgICAgIGlmIChoaWdoUXVhbGl0eVJlcSkge1xuICAgICAgICBmb3IgKHZhciBfbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBfbCA+IGx2bDsgX2wtLSkge1xuICAgICAgICAgIG9uZVVwQ2FjaGUgPSBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgX2wsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvd25zY2FsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoZWxlLCBoaWdoZXJDYWNoZS5sZXZlbCAtIDEpO1xuICAgICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcblxuICAgICAgaWYgKCFkZXFpbmcgJiYgIWhpZ2hRdWFsaXR5UmVxICYmICFkb3duc2NhbGVSZXEpIHtcbiAgICAgICAgZm9yICh2YXIgX2wyID0gbHZsIC0gMTsgX2wyID49IG1pbkx2bCQxOyBfbDItLSkge1xuICAgICAgICAgIHZhciBfYyA9IGxvb2t1cC5nZXQoZWxlLCBfbDIpO1xuXG4gICAgICAgICAgaWYgKF9jKSB7XG4gICAgICAgICAgICBsb3dlckNhY2hlID0gX2M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYWxhYmxlRnJvbShsb3dlckNhY2hlKSkge1xuICAgICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcbiAgICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoZWxlLCBsdmwpO1xuICAgICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICAgIH1cblxuICAgICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKHR4ci51c2VkV2lkdGgsIDApO1xuICAgICAgdHhyLmNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnQodHhyLmNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIGZhbHNlKTtcbiAgICAgIHR4ci5jb250ZXh0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSgtdHhyLnVzZWRXaWR0aCwgMCk7XG4gICAgfVxuXG4gICAgZWxlQ2FjaGUgPSB7XG4gICAgICB4OiB0eHIudXNlZFdpZHRoLFxuICAgICAgdGV4dHVyZTogdHhyLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgICAgaGVpZ2h0OiBlbGVTY2FsZWRILFxuICAgICAgc2NhbGVkTGFiZWxTaG93bjogc2NhbGVkTGFiZWxTaG93blxuICAgIH07XG4gICAgdHhyLnVzZWRXaWR0aCArPSBNYXRoLmNlaWwoZWxlU2NhbGVkVyArIGVsZVR4clNwYWNpbmcpO1xuICAgIHR4ci5lbGVDYWNoZXMucHVzaChlbGVDYWNoZSk7XG4gICAgbG9va3VwLnNldChlbGUsIGx2bCwgZWxlQ2FjaGUpO1xuICAgIHNlbGYuY2hlY2tUZXh0dXJlRnVsbG5lc3ModHhyKTtcbiAgICByZXR1cm4gZWxlQ2FjaGU7XG4gIH07XG5cbiAgRVRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlRWxlbWVudChlbGVzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuICAgIHZhciBjYWNoZXMgPSBbXTtcbiAgICB2YXIgaW52YWxpZCA9IGxvb2t1cC5pc0ludmFsaWQoZWxlKTtcblxuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgcmV0dXJuOyAvLyBvdmVycmlkZSB0aGUgaW52YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIGVsZW1lbnQga2V5IGhhcyBub3QgY2hhbmdlZFxuICAgIH1cblxuICAgIGZvciAodmFyIGx2bCA9IG1pbkx2bCQxOyBsdmwgPD0gbWF4THZsJDE7IGx2bCsrKSB7XG4gICAgICB2YXIgY2FjaGUgPSBsb29rdXAuZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9PdGhlckVsZXNVc2VDYWNoZSA9IGxvb2t1cC5pbnZhbGlkYXRlKGVsZSk7XG5cbiAgICBpZiAobm9PdGhlckVsZXNVc2VDYWNoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9jYWNoZSA9IGNhY2hlc1tpXTtcbiAgICAgICAgdmFyIHR4ciA9IF9jYWNoZS50ZXh0dXJlOyAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG5cbiAgICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggKz0gX2NhY2hlLndpZHRoOyAvLyBtYXJrIHRoZSBjYWNoZSBhcyBpbnZhbGlkYXRlZFxuXG4gICAgICAgIF9jYWNoZS5pbnZhbGlkYXRlZCA9IHRydWU7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBpZiBpdHMgdXRpbGl0eSBpcyBsb3dcblxuICAgICAgICBzZWxmLmNoZWNrVGV4dHVyZVV0aWxpdHkodHhyKTtcbiAgICAgIH1cbiAgICB9IC8vIHJlbW92ZSBmcm9tIHF1ZXVlIHNpbmNlIHRoZSBvbGQgcmVxIHdhcyBmb3IgdGhlIG9sZCBzdGF0ZVxuXG5cbiAgICBzZWxmLnJlbW92ZUZyb21RdWV1ZShlbGUpO1xuICB9O1xuXG4gIEVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgICAvLyBpbnZhbGlkYXRlIGFsbCBlbnRyaWVzIGluIHRoZSBjYWNoZSBpZiB0aGUgY2FjaGUgc2l6ZSBpcyBzbWFsbFxuICAgIGlmICh0eHIuaW52YWxpZGF0ZWRXaWR0aCA+PSBtaW5VdGlsaXR5ICogdHhyLndpZHRoKSB7XG4gICAgICB0aGlzLnJldGlyZVRleHR1cmUodHhyKTtcbiAgICB9XG4gIH07XG5cbiAgRVRDcC5jaGVja1RleHR1cmVGdWxsbmVzcyA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgICAvLyBpZiB0ZXh0dXJlIGhhcyBiZWVuIG1vc3RseSBmaWxsZWQgYW5kIHBhc3NlZCBvdmVyIHNldmVyYWwgdGltZXMsIHJlbW92ZVxuICAgIC8vIGl0IGZyb20gdGhlIHF1ZXVlIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FzdGUgdGltZSBsb29raW5nIGF0IGl0IHRvIHB1dCBuZXcgdGhpbmdzXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhyLmhlaWdodCk7XG5cbiAgICBpZiAodHhyLnVzZWRXaWR0aCAvIHR4ci53aWR0aCA+IG1heEZ1bGxuZXNzICYmIHR4ci5mdWxsbmVzc0NoZWNrcyA+PSBtYXhGdWxsbmVzc0NoZWNrcykge1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICAgIH1cbiAgfTtcblxuICBFVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiAodHhyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eHJIID0gdHhyLmhlaWdodDtcbiAgICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICAgIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDsgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgICB0eHIucmV0aXJlZCA9IHRydWU7IC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgICB2YXIgZWxlQ2FjaGVzID0gdHhyLmVsZUNhY2hlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlQ2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgICBsb29rdXAuZGVsZXRlQ2FjaGUoZWxlQ2FjaGUua2V5LCBlbGVDYWNoZS5sZXZlbCk7XG4gICAgfVxuXG4gICAgY2xlYXJBcnJheShlbGVDYWNoZXMpOyAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuICAgIHJ0eHRyUS5wdXNoKHR4cik7XG4gIH07XG5cbiAgRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgICB2YXIgdHhyID0ge307XG4gICAgdHhyUS5wdXNoKHR4cik7XG4gICAgdHhyLmVsZUNhY2hlcyA9IFtdO1xuICAgIHR4ci5oZWlnaHQgPSB0eHJIO1xuICAgIHR4ci53aWR0aCA9IE1hdGgubWF4KGRlZlR4cldpZHRoLCBtaW5XKTtcbiAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICB0eHIuY2FudmFzID0gc2VsZi5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gICAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgcmV0dXJuIHR4cjtcbiAgfTtcblxuICBFVENwLnJlY3ljbGVUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydHh0clEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0eHIgPSBydHh0clFbaV07XG5cbiAgICAgIGlmICh0eHIud2lkdGggPj0gbWluVykge1xuICAgICAgICB0eHIucmV0aXJlZCA9IGZhbHNlO1xuICAgICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgICAgICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICAgICAgICBjbGVhckFycmF5KHR4ci5lbGVDYWNoZXMpO1xuICAgICAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHR4ci5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0eHIud2lkdGgsIHR4ci5oZWlnaHQpO1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkocnR4dHJRLCB0eHIpO1xuICAgICAgICB0eHJRLnB1c2godHhyKTtcbiAgICAgICAgcmV0dXJuIHR4cjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICAgIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgdmFyIGV4aXN0aW5nUmVxID0gazJxW2tleV07XG5cbiAgICBpZiAoZXhpc3RpbmdSZXEpIHtcbiAgICAgIC8vIHVzZSB0aGUgbWF4IGx2bCBiL2MgaW4gYmV0d2VlbiBsdmxzIGFyZSBjaGVhcCB0byBtYWtlXG4gICAgICBleGlzdGluZ1JlcS5sZXZlbCA9IE1hdGgubWF4KGV4aXN0aW5nUmVxLmxldmVsLCBsdmwpO1xuICAgICAgZXhpc3RpbmdSZXEuZWxlcy5tZXJnZShlbGUpO1xuICAgICAgZXhpc3RpbmdSZXEucmVxcysrO1xuICAgICAgcS51cGRhdGVJdGVtKGV4aXN0aW5nUmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcSA9IHtcbiAgICAgICAgZWxlczogZWxlLnNwYXduKCkubWVyZ2UoZWxlKSxcbiAgICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgICAgcmVxczogMSxcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH07XG4gICAgICBxLnB1c2gocmVxKTtcbiAgICAgIGsycVtrZXldID0gcmVxO1xuICAgIH1cbiAgfTtcblxuICBFVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpb1xuICAvKiwgZXh0ZW50Ki9cbiAgKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICAgIHZhciBkZXF1ZXVlZCA9IFtdO1xuICAgIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZSQxOyBpKyspIHtcbiAgICAgIGlmIChxLnNpemUoKSA+IDApIHtcbiAgICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG4gICAgICAgIHZhciBrZXkgPSByZXEua2V5O1xuICAgICAgICB2YXIgZWxlID0gcmVxLmVsZXNbMF07IC8vIGFsbCBlbGVzIGhhdmUgdGhlIHNhbWUga2V5XG5cbiAgICAgICAgdmFyIGNhY2hlRXhpc3RzID0gbG9va3VwLmhhc0NhY2hlKGVsZSwgcmVxLmxldmVsKTsgLy8gY2xlYXIgb3V0IHRoZSBrZXkgdG8gcmVxIGxvb2t1cFxuXG4gICAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gZGVxdWV1ZWluZyBpc24ndCBuZWNlc3Nhcnkgd2l0aCBhbiBleGlzdGluZyBjYWNoZVxuXG4gICAgICAgIGlmIChjYWNoZUV4aXN0cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuICAgICAgICB2YXIgYmIgPSBzZWxmLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gICAgICAgIHNlbGYuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCByZXEubGV2ZWwsIGdldFR4clJlYXNvbnMuZGVxdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVxdWV1ZWQ7XG4gIH07XG5cbiAgRVRDcC5yZW1vdmVGcm9tUXVldWUgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgIHZhciByZXEgPSBrMnFba2V5XTtcblxuICAgIGlmIChyZXEgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlcS5lbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyByZW1vdmUgaWYgbGFzdCBlbGUgaW4gdGhlIHJlcVxuICAgICAgICAvLyBicmluZyB0byBmcm9udCBvZiBxdWV1ZVxuICAgICAgICByZXEucmVxcyA9IE1BWF9JTlQkMTtcbiAgICAgICAgcS51cGRhdGVJdGVtKHJlcSk7XG4gICAgICAgIHEucG9wKCk7IC8vIHJlbW92ZSBmcm9tIHF1ZXVlXG5cbiAgICAgICAgazJxW2tleV0gPSBudWxsOyAvLyByZW1vdmUgZnJvbSBsb29rdXAgbWFwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UganVzdCByZW1vdmUgZWxlIGZyb20gcmVxXG4gICAgICAgIHJlcS5lbGVzLnVubWVyZ2UoZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLm9uRGVxdWV1ZXMucHVzaChmbik7XG4gIH07XG5cbiAgRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMub25EZXF1ZXVlcywgZm4pO1xuICB9O1xuXG4gIEVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICAgIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkJDEsXG4gICAgZGVxQ29zdDogZGVxQ29zdCQxLFxuICAgIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QkMSxcbiAgICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0JDEsXG4gICAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0JDEsXG4gICAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gICAgfSxcbiAgICBvbkRlcWQ6IGZ1bmN0aW9uIG9uRGVxZChzZWxmLCBkZXFkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm4gPSBzZWxmLm9uRGVxdWV1ZXNbaV07XG4gICAgICAgIGZuKGRlcWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdWxkUmVkcmF3OiBmdW5jdGlvbiBzaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZXMgPSBkZXFkW2ldLmVsZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGJiID0gZWxlc1tqXS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxuXG4gIHZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbiAgdmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxuICB2YXIgbWF4Wm9vbSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG5cbiAgdmFyIGRlcVJlZHJhd1RocmVzaG9sZCA9IDUwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxuXG4gIHZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcblxuICB2YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxuXG4gIHZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxuXG4gIHZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG4gIHZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcblxuICB2YXIgbWF4RGVxU2l6ZSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbiAgdmFyIGludmFsaWRUaHJlc2hvbGQgPSAyNTA7IC8vIHRpbWUgdGhyZXNob2xkIGZvciBkaXNhYmxpbmcgYi9jIG9mIGludmFsaWRhdGlvbnNcblxuICB2YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG5cbiAgdmFyIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGhpZ2ggcXVhbGl0eSBlbGUgdHhyIHJlcXVlc3RzIChnZW5lcmFsbHkgZmFzdGVyIGFuZCBjaGVhcGVyIGluIHRoZSBsb25ndGVybSlcbiAgLy8gdmFyIGxvZyA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTsgfTtcblxuICB2YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIExheWVyZWRUZXh0dXJlQ2FjaGUocmVuZGVyZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICBzZWxmLmxheWVyc0J5TGV2ZWwgPSB7fTsgLy8gZS5nLiAyID0+IFsgbGF5ZXIxLCBsYXllcjIsIC4uLiwgbGF5ZXJOIF1cblxuICAgIHNlbGYuZmlyc3RHZXQgPSB0cnVlO1xuICAgIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gMiAqIGludmFsaWRUaHJlc2hvbGQ7XG4gICAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICAgIHNlbGYuZWxlVHhyRGVxcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBzZWxmLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKHNlbGYuZWxlVHhyRGVxcyk7XG4gICAgICBzZWxmLmVsZVR4ckRlcXMudW5tZXJnZShzZWxmLmVsZVR4ckRlcXMpO1xuICAgIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gICAgci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgIGlmIChub3cgLSBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lIDw9IGludmFsaWRUaHJlc2hvbGQpIHtcbiAgICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4clNraXApO1xuXG4gICAgdmFyIHFTb3J0ID0gZnVuY3Rpb24gcVNvcnQoYSwgYikge1xuICAgICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgICB9O1xuXG4gICAgc2VsZi5sYXllcnNRdWV1ZSA9IG5ldyBoZWFwKHFTb3J0KTtcbiAgICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xuICB9O1xuXG4gIHZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG4gIHZhciBsYXllcklkUG9vbCA9IDA7XG4gIHZhciBNQVhfSU5UID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICBMVENwLm1ha2VMYXllciA9IGZ1bmN0aW9uIChiYiwgbHZsKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICAgIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMucmVuZGVyZXIubWFrZU9mZnNjcmVlbkNhbnZhcyh3LCBoKTtcbiAgICB2YXIgbGF5ZXIgPSB7XG4gICAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCxcbiAgICAgIGJiOiBiYixcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICB3aWR0aDogdyxcbiAgICAgIGhlaWdodDogaCxcbiAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICBlbGVzOiBbXSxcbiAgICAgIGVsZXNRdWV1ZTogW10sXG4gICAgICByZXFzOiAwXG4gICAgfTsgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICAgIHZhciBjeHQgPSBsYXllci5jb250ZXh0O1xuICAgIHZhciBkeCA9IC1sYXllci5iYi54MTtcbiAgICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7IC8vIGRvIHRoZSB0cmFuc2Zvcm0gb24gY3JlYXRpb24gdG8gc2F2ZSBjeWNsZXMgKGl0J3MgdGhlIHNhbWUgZm9yIGFsbCBlbGVzKVxuXG4gICAgY3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgY3h0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICAgIHJldHVybiBsYXllcjtcbiAgfTtcblxuICBMVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGZpcnN0R2V0ID0gc2VsZi5maXJzdEdldDtcbiAgICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7IC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICAgIGlmIChsdmwgPT0gbnVsbCkge1xuICAgICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcblxuICAgICAgaWYgKGx2bCA8IG1pbkx2bCkge1xuICAgICAgICBsdmwgPSBtaW5Mdmw7XG4gICAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsdmwsIGVsZXMpO1xuICAgIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICAgIHZhciBsYXllcnMgPSBsYXllcnNCeUx2bFtsdmxdID0gbGF5ZXJzQnlMdmxbbHZsXSB8fCBbXTtcbiAgICB2YXIgYmI7XG4gICAgdmFyIGx2bENvbXBsZXRlID0gc2VsZi5sZXZlbElzQ29tcGxldGUobHZsLCBlbGVzKTtcbiAgICB2YXIgdG1wTGF5ZXJzO1xuXG4gICAgdmFyIGNoZWNrVGVtcExldmVscyA9IGZ1bmN0aW9uIGNoZWNrVGVtcExldmVscygpIHtcbiAgICAgIHZhciBjYW5Vc2VBc1RtcEx2bCA9IGZ1bmN0aW9uIGNhblVzZUFzVG1wTHZsKGwpIHtcbiAgICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcblxuICAgICAgICBpZiAoc2VsZi5sZXZlbElzQ29tcGxldGUobCwgZWxlcykpIHtcbiAgICAgICAgICB0bXBMYXllcnMgPSBsYXllcnNCeUx2bFtsXTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uIGNoZWNrTHZscyhkaXIpIHtcbiAgICAgICAgaWYgKHRtcExheWVycykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGwgPSBsdmwgKyBkaXI7IG1pbkx2bCA8PSBsICYmIGwgPD0gbWF4THZsOyBsICs9IGRpcikge1xuICAgICAgICAgIGlmIChjYW5Vc2VBc1RtcEx2bChsKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjaGVja0x2bHMoKzEpO1xuICAgICAgY2hlY2tMdmxzKC0xKTsgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG5cbiAgICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghbHZsQ29tcGxldGUpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAgIC8vIGFuZCBsYXRlciBxdWV1ZSB0aGUgY3VycmVudCBsYXllcnNldCBzbyB3ZSBjYW4gZ2V0IHRoZSBwcm9wZXIgcXVhbGl0eSBsZXZlbCBzb29uXG4gICAgICBjaGVja1RlbXBMZXZlbHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9nKCdsZXZlbCBjb21wbGV0ZSwgdXNpbmcgZXhpc3RpbmcgbGF5ZXJzXFxuLS0nKTtcbiAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuXG4gICAgdmFyIGdldEJiID0gZnVuY3Rpb24gZ2V0QmIoKSB7XG4gICAgICBpZiAoIWJiKSB7XG4gICAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRpbmdCb3goYmIsIGVsZXNbaV0uYm91bmRpbmdCb3goKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZUxheWVyID0gZnVuY3Rpb24gbWFrZUxheWVyKG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgdmFyIGFmdGVyID0gb3B0cy5hZnRlcjtcbiAgICAgIGdldEJiKCk7XG4gICAgICB2YXIgYXJlYSA9IGJiLncgKiBzY2FsZSAqIChiYi5oICogc2NhbGUpO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG5cbiAgICAgIGlmIChhZnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxheWVycy5pbmRleE9mKGFmdGVyKSArIDE7XG4gICAgICAgIGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCkge1xuICAgICAgICAvLyBubyBhZnRlciBzcGVjaWZpZWQgPT4gZmlyc3QgbGF5ZXIgbWFkZSBzbyBwdXQgYXQgc3RhcnRcbiAgICAgICAgbGF5ZXJzLnVuc2hpZnQobGF5ZXIpO1xuICAgICAgfSAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgICAvL3NlbGYucXVldWVMYXllciggbGF5ZXIgKTtcbiAgICAgIC8vIH1cblxuXG4gICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGlmIChzZWxmLnNraXBwaW5nICYmICFmaXJzdEdldCkge1xuICAgICAgLy8gbG9nKCdza2lwIGxheWVycycpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBsb2coJ2RvIGxheWVycycpO1xuXG5cbiAgICB2YXIgbGF5ZXIgPSBudWxsO1xuICAgIHZhciBtYXhFbGVzUGVyTGF5ZXIgPSBlbGVzLmxlbmd0aCAvIGRlZk51bUxheWVycztcbiAgICB2YXIgYWxsb3dMYXp5UXVldWVpbmcgPSAhZmlyc3RHZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307IC8vIGxvZygnbG9vayBhdCBlbGUnLCBlbGUuaWQoKSk7XG5cbiAgICAgIHZhciBleGlzdGluZ0xheWVyID0gY2FjaGVzW2x2bF07XG5cbiAgICAgIGlmIChleGlzdGluZ0xheWVyKSB7XG4gICAgICAgIC8vIHJldXNlIGxheWVyIGZvciBsYXRlciBlbGVzXG4gICAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgICBsYXllciA9IGV4aXN0aW5nTGF5ZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxheWVyIHx8IGxheWVyLmVsZXMubGVuZ3RoID49IG1heEVsZXNQZXJMYXllciB8fCAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGxheWVyLmJiLCBlbGUuYm91bmRpbmdCb3goKSkpIHtcbiAgICAgICAgLy8gbG9nKCdtYWtlIG5ldyBsYXllciBmb3IgZWxlICVzJywgZWxlLmlkKCkpO1xuICAgICAgICBsYXllciA9IG1ha2VMYXllcih7XG4gICAgICAgICAgaW5zZXJ0OiB0cnVlLFxuICAgICAgICAgIGFmdGVyOiBsYXllclxuICAgICAgICB9KTsgLy8gaWYgbm93IGxheWVyIGNhbiBiZSBidWlsdCB0aGVuIHdlIGNhbid0IHVzZSBsYXllcnMgYXQgdGhpcyBsZXZlbFxuXG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyBsb2coJ25ldyBsYXllciB3aXRoIGlkICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICh0bXBMYXllcnMgfHwgYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgICBzZWxmLnF1ZXVlTGF5ZXIobGF5ZXIsIGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2coJ2RyYXcgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pO1xuICAgICAgfVxuXG4gICAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcbiAgICAgIGNhY2hlc1tsdmxdID0gbGF5ZXI7XG4gICAgfSAvLyBsb2coJy0tJyk7XG5cblxuICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgIC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgICByZXR1cm4gdG1wTGF5ZXJzO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgLy8gbG9nKCdsYXp5IHF1ZXVlIGxldmVsJywgbHZsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcnM7XG4gIH07IC8vIGEgbGF5ZXIgbWF5IHdhbnQgdG8gdXNlIGFuIGVsZSBjYWNoZSBvZiBhIGhpZ2hlciBsZXZlbCB0byBhdm9pZCBibHVycmluZXNzXG4gIC8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuXG5cbiAgTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiAobHZsLCBweFJhdGlvKSB7XG4gICAgcmV0dXJuIGx2bDtcbiAgfTtcblxuICBMVENwLmRyYXdFbGVJbkxheWVyID0gZnVuY3Rpb24gKGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdmFyIGNvbnRleHQgPSBsYXllci5jb250ZXh0O1xuICAgIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGx2bCwgcHhSYXRpbyk7XG5cbiAgICB7XG4gICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIG51bGwsIG51bGwsIGx2bCwgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgTFRDcC5sZXZlbElzQ29tcGxldGUgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbHZsXTtcblxuICAgIGlmICghbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbnVtRWxlc0luTGF5ZXJzID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07IC8vIGlmIHRoZXJlIGFyZSBhbnkgZWxlcyBuZWVkZWQgdG8gYmUgZHJhd24geWV0LCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG5cbiAgICAgIGlmIChsYXllci5yZXFzID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGlmIHRoZSBsYXllciBpcyBpbnZhbGlkLCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG5cblxuICAgICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gICAgfSAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcblxuXG4gICAgaWYgKG51bUVsZXNJbkxheWVycyAhPT0gZWxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBMVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTtcblxuICAgIGlmICghbGF5ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiBpbiBhIGxheWVyIHRoZSBlbGVzIGFyZSBub3QgaW4gdGhlIHNhbWUgb3JkZXIsIHRoZW4gdGhlIGxheWVyIGlzIGludmFsaWRcbiAgICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgb2Zmc2V0ID0gLTE7IC8vIGZpbmQgdGhlIG9mZnNldFxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGxheWVyLmVsZXNbMF0gPT09IGVsZXNbal0pIHtcbiAgICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHRoZW4gdGhlIGxheWVyIGhhcyBub25leGlzdGVudCBlbGVtZW50cyBhbmQgaXMgaW52YWxpZFxuICAgICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cblxuICAgICAgdmFyIG8gPSBvZmZzZXQ7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAobGF5ZXIuZWxlc1tqXSAhPT0gZWxlc1tvICsgal0pIHtcbiAgICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIExUQ3AudXBkYXRlRWxlbWVudHNJbkxheWVycyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGlzRWxlcyA9IGVsZW1lbnQoZWxlc1swXSk7IC8vIGNvbGxlY3QgdWRwYXRlZCBlbGVtZW50cyAoY2FzY2FkZWQgZnJvbSB0aGUgbGF5ZXJzKSBhbmQgdXBkYXRlIGVhY2hcbiAgICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgICB2YXIgZWxlID0gaXNFbGVzID8gZWxlc1tpXSA6IGVsZXNbaV0uZWxlO1xuICAgICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAgIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuXG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgICAgLy8gdGhlIG1hdGNoaW5nIGxldmVsXG5cblxuICAgICAgICBpZiAocmVxICYmIHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGxheWVyLmxldmVsKSAhPT0gcmVxLmxldmVsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUobGF5ZXIsIGVsZSwgcmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTFRDcC5oYXZlTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaGF2ZUxheWVycyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsXTtcblxuICAgICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXZlTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhdmVMYXllcnM7XG4gIH07XG5cbiAgTFRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpOyAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIGludmFsQXNzb2NMYXllcnMobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgICBzZWxmLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgfSk7XG4gIH07XG5cbiAgTFRDcC5pbnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUnKTtcbiAgICB0aGlzLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXZlIGN5Y2xlc1xuXG5cbiAgICB2YXIgbHZsID0gbGF5ZXIubGV2ZWw7XG4gICAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTsgLy8gbG9nKCdpbnZhbGlkYXRlIGxheWVyJywgbGF5ZXIuaWQgKTtcblxuICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTsgLy8gbGF5ZXIuZWxlcyA9IFtdO1xuXG4gICAgbGF5ZXIuZWxlc1F1ZXVlID0gW107XG4gICAgbGF5ZXIuaW52YWxpZCA9IHRydWU7XG5cbiAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG5cbiAgICAgIGlmIChjYWNoZXMpIHtcbiAgICAgICAgY2FjaGVzW2x2bF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBMVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICAgIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiByZWZpbmVFYWNoRWxlKGxheWVyLCBlbGUsIHJlcSkge1xuICAgICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgICAgaWYgKCFyTHlyKSB7XG4gICAgICAgIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudCA9IHNlbGYubWFrZUxheWVyKGxheWVyLmJiLCBsYXllci5sZXZlbCk7XG4gICAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgICAgckx5ci5lbGVzID0gbGF5ZXIuZWxlczsgLy8gbG9nKCdtYWtlIHJlcGxhY2VtZW50IGxheWVyICVzIGZvciAlcyB3aXRoIGxldmVsICVzJywgckx5ci5pZCwgbGF5ZXIuaWQsIHJMeXIubGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJMeXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucXVldWVMYXllcihyTHlyLCByTHlyLmVsZXNbaV0pO1xuICAgICAgICB9IC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTFRDcC5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG5cbiAgICB0aGlzLmVsZVR4ckRlcXMubWVyZ2UoZWxlKTtcbiAgICB0aGlzLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQoKTtcbiAgfTtcblxuICBMVENwLnF1ZXVlTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gICAgdmFyIGVsZXNRID0gbGF5ZXIuZWxlc1F1ZXVlO1xuICAgIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307IC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG5cbiAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoaGFzSWRbZWxlLmlkKCldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWxlc1EucHVzaChlbGUpO1xuICAgICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXIucmVxcykge1xuICAgICAgbGF5ZXIucmVxcysrO1xuICAgICAgcS51cGRhdGVJdGVtKGxheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgICBxLnB1c2gobGF5ZXIpO1xuICAgIH1cbiAgfTtcblxuICBMVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpbykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gICAgdmFyIGRlcWQgPSBbXTtcbiAgICB2YXIgZWxlRGVxcyA9IDA7XG5cbiAgICB3aGlsZSAoZWxlRGVxcyA8IG1heERlcVNpemUpIHtcbiAgICAgIGlmIChxLnNpemUoKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGxheWVyID0gcS5wZWVrKCk7IC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcblxuICAgICAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgICAgIC8vIGxvZygnbGF5ZXIgJXMgaW4gcXVldWUgc2tpcHBlZCBiL2MgaXQgYWxyZWFkeSBoYXMgYSByZXBsYWNlbWVudCcsIGxheWVyLmlkKTtcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG5cblxuICAgICAgaWYgKGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCkge1xuICAgICAgICAvLyBsb2coJ2xheWVyIGlzIG5vIGxvbmdlciB0aGUgbW9zdCB1cHRvZGF0ZSByZXBsYWNlbWVudDsgZGVxdWV1ZWQnLCBsYXllci5pZClcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgJXMgaXMgaW52YWxpZDsgZGVxdWV1ZWQnLCBsYXllci5pZCk7XG4gICAgICAgIHEucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuICAgICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGxheWVyLmxldmVsLCBweFJhdGlvKTtcbiAgICAgICAgZWxlRGVxcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVxZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBlbnRyeSBpbiBkZXFkIHRvIHF1ZXVlIHJlZHJhd2luZyBldGNcbiAgICAgICAgZGVxZC5wdXNoKHRydWUpO1xuICAgICAgfSAvLyBpZiB0aGUgbGF5ZXIgaGFzIGFsbCBpdHMgZWxlcyBkb25lLCB0aGVuIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZVxuXG5cbiAgICAgIGlmIChsYXllci5lbGVzUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHEucG9wKCk7XG4gICAgICAgIGxheWVyLnJlcXMgPSAwOyAvLyBsb2coJ2RlcXVldWUgb2YgbGF5ZXIgJXMgY29tcGxldGUnLCBsYXllci5pZCk7XG4gICAgICAgIC8vIHdoZW4gYSByZXBsYWNlbWVudCBsYXllciBpcyBkZXF1ZXVlZCwgaXQgcmVwbGFjZXMgdGhlIG9sZCBsYXllciBpbiB0aGUgbGV2ZWxcblxuICAgICAgICBpZiAobGF5ZXIucmVwbGFjZXMpIHtcbiAgICAgICAgICBzZWxmLmFwcGx5TGF5ZXJSZXBsYWNlbWVudChsYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVxZDtcbiAgfTtcblxuICBMVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGF5ZXJzSW5MZXZlbCA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsYXllci5sZXZlbF07XG4gICAgdmFyIHJlcGxhY2VkID0gbGF5ZXIucmVwbGFjZXM7XG4gICAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKHJlcGxhY2VkKTsgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgICAvLyByZWZzIHdvdWxkIGJlIGEgbWlzdGFrZSAoaS5lLiBvdmVyd3JpdGluZyB0aGUgdHJ1ZSBhY3RpdmUgbGF5ZXIpXG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IHJlcGxhY2VkLmludmFsaWQpIHtcbiAgICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGF5ZXJzSW5MZXZlbFtpbmRleF0gPSBsYXllcjsgLy8gcmVwbGFjZSBsZXZlbCByZWZcbiAgICAvLyByZXBsYWNlIHJlZnMgaW4gZWxlc1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3AgPSBsYXllci5lbGVzW2ldLl9wcml2YXRlO1xuICAgICAgdmFyIGNhY2hlID0gX3AuaW1nTGF5ZXJDYWNoZXMgPSBfcC5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlW2xheWVyLmxldmVsXSA9IGxheWVyO1xuICAgICAgfVxuICAgIH0gLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuXG4gICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gIH07XG5cbiAgTFRDcC5yZXF1ZXN0UmVkcmF3ID0gZGVib3VuY2VfMShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgIHIucmVkcmF3KCk7XG4gIH0sIDEwMCk7XG4gIExUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICAgIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICAgIGRlcUNvc3Q6IGRlcUNvc3QsXG4gICAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICAgIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCxcbiAgICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvKSB7XG4gICAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8pO1xuICAgIH0sXG4gICAgb25EZXFkOiBub29wJDEsXG4gICAgc2hvdWxkUmVkcmF3OiB0cnVlaWZ5LFxuICAgIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4ckRlcTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBDUnAkYSA9IHt9O1xuICB2YXIgaW1wbDtcblxuICBmdW5jdGlvbiBwb2x5Z29uKGNvbnRleHQsIHBvaW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmlhbmdsZUJhY2tjdXJ2ZShjb250ZXh0LCBwb2ludHMsIGNvbnRyb2xQb2ludCkge1xuICAgIHZhciBmaXJzdFB0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgZmlyc3RQdCA9IHB0O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlhbmdsZVRlZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzKSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICB9XG5cbiAgICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICAgIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICAgIGNvbnRleHQubW92ZVRvKGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGVlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlVHJpYW5nbGUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHJ4LCByeSwgcikge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgIHZhciBmaXJzdFRyUHQgPSB0cmlQdHNbMF07XG4gICAgY29udGV4dC5tb3ZlVG8oZmlyc3RUclB0LngsIGZpcnN0VHJQdC55KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlKGNvbnRleHQsIHJ4LCByeSwgcikge1xuICAgIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgfVxuXG4gIENScCRhLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gKGltcGwgfHwgKGltcGwgPSB7XG4gICAgICAncG9seWdvbic6IHBvbHlnb24sXG4gICAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgICAndHJpYW5nbGUtdGVlJzogdHJpYW5nbGVUZWUsXG4gICAgICAnY2lyY2xlLXRyaWFuZ2xlJzogY2lyY2xlVHJpYW5nbGUsXG4gICAgICAndHJpYW5nbGUtY3Jvc3MnOiB0cmlhbmdsZVRlZSxcbiAgICAgICdjaXJjbGUnOiBjaXJjbGVcbiAgICB9KSlbbmFtZV07XG4gIH07XG5cbiAgdmFyIENScCQ5ID0ge307XG5cbiAgQ1JwJDkuZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdFbGVtZW50T3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3RWxlbWVudFVuZGVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdFZGdlVW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRSb3RhdGlvbiwgZ2V0T3BhY2l0eSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgYmIgPSBlbGVUeHJDYWNoZS5nZXRCb3VuZGluZ0JveChlbGUpO1xuXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWdub3JlIHplcm8gc2l6ZSBjYXNlXG5cblxuICAgIHZhciBlbGVDYWNoZSA9IGVsZVR4ckNhY2hlLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pO1xuXG4gICAgaWYgKGVsZUNhY2hlICE9IG51bGwpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gZ2V0T3BhY2l0eShyLCBlbGUpO1xuXG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGV0YSA9IGdldFJvdGF0aW9uKHIsIGVsZSk7XG4gICAgICB2YXIgeDEgPSBiYi54MSxcbiAgICAgICAgICB5MSA9IGJiLnkxLFxuICAgICAgICAgIHcgPSBiYi53LFxuICAgICAgICAgIGggPSBiYi5oO1xuICAgICAgdmFyIHgsIHksIHN4LCBzeSwgc21vb3RoO1xuXG4gICAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgICAgdmFyIHJvdFB0ID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25Qb2ludChlbGUpO1xuICAgICAgICBzeCA9IHJvdFB0Lng7XG4gICAgICAgIHN5ID0gcm90UHQueTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgICBzbW9vdGggPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcblxuICAgICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZiA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uT2Zmc2V0KGVsZSk7XG4gICAgICAgIHggPSBvZmYueDtcbiAgICAgICAgeSA9IG9mZi55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgxO1xuICAgICAgICB5ID0geTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRHbG9iYWxBbHBoYTtcblxuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgb2xkR2xvYmFsQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGEgKiBvcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVDYWNoZS50ZXh0dXJlLmNhbnZhcywgZWxlQ2FjaGUueCwgMCwgZWxlQ2FjaGUud2lkdGgsIGVsZUNhY2hlLmhlaWdodCwgeCwgeSwgdywgaCk7XG5cbiAgICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1zeCwgLXN5KTtcblxuICAgICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVUeHJDYWNoZS5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpOyAvLyBkaXJlY3QgZHJhdyBmYWxsYmFja1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0WmVyb1JvdGF0aW9uID0gZnVuY3Rpb24gZ2V0WmVyb1JvdGF0aW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCBudWxsKTtcbiAgfTtcblxuICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gICAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xuICB9O1xuXG4gIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG4gIH07XG5cbiAgdmFyIGdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5KHIsIGVsZSkge1xuICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICB9O1xuXG4gIHZhciBnZXRUZXh0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldFRleHRPcGFjaXR5KGUsIGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS5wZlZhbHVlICogZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgfTtcblxuICBDUnAkOS5kcmF3Q2FjaGVkRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCwgbHZsLCByZXF1ZXN0SGlnaFF1YWxpdHkpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIF9yJGRhdGEgPSByLmRhdGEsXG4gICAgICAgIGVsZVR4ckNhY2hlID0gX3IkZGF0YS5lbGVUeHJDYWNoZSxcbiAgICAgICAgbGJsVHhyQ2FjaGUgPSBfciRkYXRhLmxibFR4ckNhY2hlLFxuICAgICAgICBzbGJUeHJDYWNoZSA9IF9yJGRhdGEuc2xiVHhyQ2FjaGUsXG4gICAgICAgIHRsYlR4ckNhY2hlID0gX3IkZGF0YS50bGJUeHJDYWNoZTtcbiAgICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgcmVhc29uID0gcmVxdWVzdEhpZ2hRdWFsaXR5ID09PSB0cnVlID8gZWxlVHhyQ2FjaGUucmVhc29ucy5oaWdoUXVhbGl0eSA6IG51bGw7XG5cbiAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFleHRlbnQgfHwgYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcblxuICAgICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG5cbiAgICAgIHIuZHJhd0VsZW1lbnRVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFplcm9Sb3RhdGlvbiwgZ2V0T3BhY2l0eSk7XG5cbiAgICAgIGlmICghaXNFZGdlIHx8ICFiYWRMaW5lKSB7XG4gICAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgbGJsVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VkZ2UgJiYgIWJhZExpbmUpIHtcbiAgICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBzbGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFNvdXJjZUxhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCB0bGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFRhcmdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgci5kcmF3RWxlbWVudE92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0VsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3TGF5ZXJlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbGF5ZXJzID0gci5kYXRhLmx5clR4ckNhY2hlLmdldExheWVycyhlbGVzLCBweFJhdGlvKTtcblxuICAgIGlmIChsYXllcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgICAgdmFyIGJiID0gbGF5ZXIuYmI7XG5cbiAgICAgICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qIGdsb2JhbCBQYXRoMkQgKi9cbiAgdmFyIENScCQ4ID0ge307XG5cbiAgQ1JwJDguZHJhd0VkZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhZWRnZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG5cblxuICAgIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYjtcblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gICAgfVxuXG4gICAgdmFyIG9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgOiAxO1xuICAgIHZhciBsaW5lT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gZWRnZS5wc3R5bGUoJ2xpbmUtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICAgIHZhciBsaW5lU3R5bGUgPSBlZGdlLnBzdHlsZSgnbGluZS1zdHlsZScpLnZhbHVlO1xuICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBsaW5lQ2FwID0gZWRnZS5wc3R5bGUoJ2xpbmUtY2FwJykudmFsdWU7XG4gICAgdmFyIGVmZmVjdGl2ZUxpbmVPcGFjaXR5ID0gb3BhY2l0eSAqIGxpbmVPcGFjaXR5OyAvLyBzZXBhcmF0ZSBhcnJvdyBvcGFjaXR5IHdvdWxkIHJlcXVpcmUgYXJyb3ctb3BhY2l0eSBwcm9wZXJ0eVxuXG4gICAgdmFyIGVmZmVjdGl2ZUFycm93T3BhY2l0eSA9IG9wYWNpdHkgKiBsaW5lT3BhY2l0eTtcblxuICAgIHZhciBkcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKCkge1xuICAgICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUxpbmVPcGFjaXR5O1xuXG4gICAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJykge1xuICAgICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgICByLmRyYXdFZGdlVHJpYW5nbGVQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCBsaW5lU3R5bGUpO1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByLmRyYXdFZGdlVW5kZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3QXJyb3dzID0gZnVuY3Rpb24gZHJhd0Fycm93cygpIHtcbiAgICAgIHZhciBhcnJvd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUFycm93T3BhY2l0eTtcbiAgICAgIHIuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgYXJyb3dPcGFjaXR5KTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlZGdlLCBudWxsLCBkcmF3TGFiZWwpO1xuICAgIH07XG5cbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB2YXIgZ2hvc3QgPSBlZGdlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiAoZ2hvc3QpIHtcbiAgICAgIHZhciBneCA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgICB2YXIgZ3kgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgICAgdmFyIGdob3N0T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgZWZmZWN0aXZlR2hvc3RPcGFjaXR5ID0gZWZmZWN0aXZlTGluZU9wYWNpdHkgKiBnaG9zdE9wYWNpdHk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgICAgZHJhd0xpbmUoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICAgIGRyYXdBcnJvd3MoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgICB9XG5cbiAgICBkcmF3VW5kZXJsYXkoKTtcbiAgICBkcmF3TGluZSgpO1xuICAgIGRyYXdBcnJvd3MoKTtcbiAgICBkcmF3T3ZlcmxheSgpO1xuICAgIGRyYXdUZXh0KCk7XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5ID0gZnVuY3Rpb24gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkob3ZlcmxheU9yVW5kZXJsYXkpIHtcbiAgICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gICAgICBpZiAoIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wYWNpdHkgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItb3BhY2l0eVwiKSkudmFsdWU7XG5cbiAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBwYWRkaW5nID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXBhZGRpbmdcIikpLnBmVmFsdWU7XG4gICAgICB2YXIgd2lkdGggPSAyICogcGFkZGluZztcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb2xvclwiKSkudmFsdWU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyAmJiAhdXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgIH1cblxuICAgICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCAnc29saWQnKTtcbiAgICB9O1xuICB9O1xuXG4gIENScCQ4LmRyYXdFZGdlT3ZlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG4gIENScCQ4LmRyYXdFZGdlVW5kZXJsYXkgPSBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSgndW5kZXJsYXknKTtcblxuICBDUnAkOC5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICAgIHZhciBsaW5lRGFzaFBhdHRlcm4gPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtb2Zmc2V0JykucGZWYWx1ZTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cy5qb2luKCckJyk7XG4gICAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcblxuICAgICAgaWYgKGtleU1hdGNoZXMpIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYW52YXNDeHQuc2V0TGluZURhc2gpIHtcbiAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2gobGluZURhc2hQYXR0ZXJuKTtcbiAgICAgICAgICBjYW52YXNDeHQubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSkge1xuICAgICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubW92ZVRvKHB0c1swXSwgcHRzWzFdKTtcblxuICAgICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgICBjYXNlICdiZXppZXInOlxuICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgKyAxIDwgcHRzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pXSwgcHRzW19pICsgMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDeHQ7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0gLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG5cblxuICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOC5kcmF3RWRnZVRyaWFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMpIHtcbiAgICAvLyB1c2UgbGluZSBzdHJva2Ugc3R5bGUgZm9yIHRyaWFuZ2xlIGZpbGwgc3R5bGVcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB2ZWN0b3IgPSBbcHRzW2kgKyAyXSAtIHB0c1tpXSwgcHRzW2kgKyAzXSAtIHB0c1tpICsgMV1dO1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCh2ZWN0b3JbMF0gKiB2ZWN0b3JbMF0gKyB2ZWN0b3JbMV0gKiB2ZWN0b3JbMV0pO1xuICAgICAgdmFyIG5vcm1hbCA9IFt2ZWN0b3JbMV0gLyBsZW5ndGgsIC12ZWN0b3JbMF0gLyBsZW5ndGhdO1xuICAgICAgdmFyIHRyaWFuZ2xlSGVhZCA9IFtub3JtYWxbMF0gKiBlZGdlV2lkdGggLyAyLCBub3JtYWxbMV0gKiBlZGdlV2lkdGggLyAyXTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhwdHNbaV0gLSB0cmlhbmdsZUhlYWRbMF0sIHB0c1tpICsgMV0gLSB0cmlhbmdsZUhlYWRbMV0pO1xuICAgICAgY29udGV4dC5saW5lVG8ocHRzW2ldICsgdHJpYW5nbGVIZWFkWzBdLCBwdHNbaSArIDFdICsgdHJpYW5nbGVIZWFkWzFdKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOC5kcmF3QXJyb3doZWFkcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBvcGFjaXR5KSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gICAgaWYgKCFpc0hheXN0YWNrKSB7XG4gICAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3NvdXJjZScsIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgcnMuc3JjQXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtc291cmNlJywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkc3JjQXJyb3dBbmdsZSwgb3BhY2l0eSk7XG5cbiAgICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOC5kcmF3QXJyb3doZWFkID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHByZWZpeCwgeCwgeSwgYW5nbGUsIG9wYWNpdHkpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcblxuICAgIGlmIChhcnJvd1NoYXBlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXJyb3dDbGVhckZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgICB2YXIgYXJyb3dGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWU7XG4gICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGVkZ2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcblxuICAgIGlmIChvcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgICB9XG5cbiAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICBpZiAob3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnKSB7XG4gICAgICAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93Q2xlYXJGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIHgsIHksIGFuZ2xlKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG5cbiAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWNvbG9yJykudmFsdWU7XG4gICAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0ZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuICB9O1xuXG4gIENScCQ4LmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIGZpbGwsIGVkZ2VXaWR0aCwgc2hhcGUsIHgsIHksIGFuZ2xlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKSAmJiBzaGFwZSAhPT0gJ3RyaWFuZ2xlLWNyb3NzJztcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlV2lkdGgsIHNjYWxlKTtcbiAgICB2YXIgc2hhcGVJbXBsID0gci5hcnJvd1NoYXBlc1tzaGFwZV07XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIHZhciBjYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgPSByLmFycm93UGF0aENhY2hlIHx8IFtdO1xuICAgICAgdmFyIGtleSA9IGhhc2hTdHJpbmcoc2hhcGUpO1xuICAgICAgdmFyIGNhY2hlZFBhdGggPSBjYWNoZVtrZXldO1xuXG4gICAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gY2FjaGVkUGF0aDtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjYWNoZVtrZXldID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAvLyBzdG9yZSBpbiB0aGUgcGF0aCBjYWNoZSB3aXRoIHZhbHVlcyBlYXNpbHkgbWFuaXB1bGF0ZWQgbGF0ZXJcbiAgICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgMSwgMCwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIC8vIHNldCB0cmFuc2Zvcm0gdG8gYXJyb3cgcG9zaXRpb24vb3JpZW50YXRpb25cbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICAgICAgY29udGV4dC5zY2FsZShzaXplLCBzaXplKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsbCA9PT0gJ2ZpbGxlZCcgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAoc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSkgLyAodXNlUGF0aHMgPyBzaXplIDogMSk7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIC8vIHJlc2V0IHRyYW5zZm9ybSBieSBhcHBseWluZyBpbnZlcnNlXG4gICAgICBjb250ZXh0LnNjYWxlKDEgLyBzaXplLCAxIC8gc2l6ZSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENScCQ3ID0ge307XG5cbiAgQ1JwJDcuc2FmZURyYXdJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKSB7XG4gICAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICAgIGlmIChpdyA8PSAwIHx8IGloIDw9IDAgfHwgdyA8PSAwIHx8IGggPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGUpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkNy5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBub2RlLCBpbmRleCwgbm9kZU9wYWNpdHkpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgbm9kZVggPSBwb3MueDtcbiAgICB2YXIgbm9kZVkgPSBwb3MueTtcbiAgICB2YXIgc3R5bGVPYmogPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgICB2YXIgZ2V0SW5kZXhlZFN0eWxlID0gc3R5bGVPYmouZ2V0SW5kZXhlZFN0eWxlLmJpbmQoc3R5bGVPYmopO1xuICAgIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtZml0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICAgIHZhciByZXBlYXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcmVwZWF0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICAgIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICAgIHZhciBwYWRkaW5nWDIgPSBub2RlLnBhZGRpbmcoKSAqIDI7XG4gICAgdmFyIG5vZGVUVyA9IG5vZGVXICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICAgIHZhciBub2RlVEggPSBub2RlSCArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2xpcCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1jbGlwJywgJ3ZhbHVlJywgaW5kZXgpO1xuICAgIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICAgIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCAndmFsdWUnLCBpbmRleCkgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgc21vb3RoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZycsICd2YWx1ZScsIGluZGV4KTtcbiAgICB2YXIgaW1nVyA9IGltZy53aWR0aCB8fCBpbWcuY2FjaGVkVztcbiAgICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7IC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG5cbiAgICBpZiAobnVsbCA9PSBpbWdXIHx8IG51bGwgPT0gaW1nSCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgICBpbWdIID0gaW1nLmNhY2hlZEggPSBpbWcuaGVpZ2h0IHx8IGltZy5vZmZzZXRIZWlnaHQ7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG5cbiAgICB2YXIgdyA9IGltZ1c7XG4gICAgdmFyIGggPSBpbWdIO1xuXG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRXO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gICAgfVxuXG4gICAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuICAgIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuICAgIH1cblxuICAgIHZhciB4ID0gbm9kZVggLSBub2RlVFcgLyAyOyAvLyBsZWZ0XG5cbiAgICB2YXIgcG9zWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCk7XG4gICAgdmFyIHBvc1hQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgICBpZiAocG9zWFVuaXRzID09PSAnJScpIHtcbiAgICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHBvc1hQZlZhbDtcbiAgICB9XG5cbiAgICB2YXIgb2ZmWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3VuaXRzJywgaW5kZXgpO1xuICAgIHZhciBvZmZYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICAgIGlmIChvZmZYVW5pdHMgPT09ICclJykge1xuICAgICAgeCArPSAobm9kZVRXIC0gdykgKiBvZmZYUGZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gb2ZmWFBmVmFsO1xuICAgIH1cblxuICAgIHZhciB5ID0gbm9kZVkgLSBub2RlVEggLyAyOyAvLyB0b3BcblxuICAgIHZhciBwb3NZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4KTtcbiAgICB2YXIgcG9zWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICAgIGlmIChwb3NZVW5pdHMgPT09ICclJykge1xuICAgICAgeSArPSAobm9kZVRIIC0gaCkgKiBwb3NZUGZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gcG9zWVBmVmFsO1xuICAgIH1cblxuICAgIHZhciBvZmZZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAndW5pdHMnLCBpbmRleCk7XG4gICAgdmFyIG9mZllQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteScsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gICAgaWYgKG9mZllVbml0cyA9PT0gJyUnKSB7XG4gICAgICB5ICs9IChub2RlVEggLSBoKSAqIG9mZllQZlZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBvZmZZUGZWYWw7XG4gICAgfVxuXG4gICAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgICAgeCAtPSBub2RlWDtcbiAgICAgIHkgLT0gbm9kZVk7XG4gICAgICBub2RlWCA9IDA7XG4gICAgICBub2RlWSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGdBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG4gICAgdmFyIHNtb290aGluZ0VuYWJsZWQgPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcbiAgICB2YXIgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHNtb290aCA9PT0gJ25vJyAmJiBzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNtb290aCA9PT0gJ3llcycgJiYgIXNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICAgICAgICBjb250ZXh0LmNsaXAocnMucGF0aENhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCk7XG4gICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5zYWZlRHJhd0ltYWdlKGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCk7XG5cbiAgICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xuXG4gICAgaWYgKGlzU21vb3RoaW5nU3dpdGNoZWQpIHtcbiAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHNtb290aGluZ0VuYWJsZWQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ1JwJDYgPSB7fTtcblxuICBDUnAkNi5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uIChlbGUsIHNjYWxlKSB7XG4gICAgaWYgKCFzY2FsZSkge1xuICAgICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG4gICAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgdmFyIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgICBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgICB2YXIgbWluU2l6ZSA9IGVsZS5wc3R5bGUoJ21pbi16b29tZWQtZm9udC1zaXplJykucGZWYWx1ZTtcblxuICAgIGlmIChjb21wdXRlZFNpemUgPCBtaW5TaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgQ1JwJDYuZHJhd0VsZW1lbnRUZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgZm9yY2UsIHByZWZpeCkge1xuICAgIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmIChmb3JjZSA9PSBudWxsKSB7XG4gICAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG5cbiAgICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGp1c3RpZmljYXRpb24gPSByLmdldExhYmVsSnVzdGlmaWNhdGlvbihlbGUpO1xuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSBqdXN0aWZpY2F0aW9uO1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG5cbiAgICAgIHZhciBfbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgICB2YXIgc3JjTGFiZWwgPSBlbGUucHN0eWxlKCdzb3VyY2UtbGFiZWwnKTtcbiAgICAgIHZhciB0Z3RMYWJlbCA9IGVsZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpO1xuXG4gICAgICBpZiAoYmFkTGluZSB8fCAoIV9sYWJlbCB8fCAhX2xhYmVsLnZhbHVlKSAmJiAoIXNyY0xhYmVsIHx8ICFzcmNMYWJlbC52YWx1ZSkgJiYgKCF0Z3RMYWJlbCB8fCAhdGd0TGFiZWwudmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgfVxuXG4gICAgdmFyIGFwcGx5Um90YXRpb24gPSAhc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICB2YXIgYmI7XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICAgIH1cblxuICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIG51bGwsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAndGFyZ2V0JywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBwcmVmaXgsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIH1cblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkNi5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjYWNoZTtcbiAgICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07IC8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbiAgLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuXG5cbiAgQ1JwJDYuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gICAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgLy8gRm9udCBzdHlsZVxuICAgIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgICB2YXIgbGFiZWxGYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSAqIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtb3BhY2l0eScpLnZhbHVlICogb3BhY2l0eTtcbiAgICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICAgIHZhciBvdXRsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgICBjb250ZXh0LmZvbnQgPSBsYWJlbFN0eWxlICsgJyAnICsgbGFiZWxXZWlnaHQgKyAnICcgKyBsYWJlbFNpemUgKyAnICcgKyBsYWJlbEZhbWlseTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG5cbiAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIHRoaXMuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eSk7XG4gIH07IC8vIFRPRE8gZW5zdXJlIHJlLXVzZWRcblxuXG4gIGZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiA1O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBDUnAkNi5nZXRUZXh0QW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgdGhldGE7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciB0ZXh0QW5nbGUgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG5cbiAgICBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJykge1xuICAgICAgdGhldGEgPSBlbGUuaXNFZGdlKCkgPyB0ZXh0QW5nbGUgOiAwO1xuICAgIH0gZWxzZSBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdub25lJykge1xuICAgICAgdGhldGEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGV0YSA9IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoZXRhO1xuICB9O1xuXG4gIENScCQ2LmRyYXdUZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIGFwcGx5Um90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuXG4gICAgaWYgKHVzZUVsZU9wYWNpdHkgJiYgKHBhcmVudE9wYWNpdHkgPT09IDAgfHwgZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykudmFsdWUgPT09IDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB1c2UgJ21haW4nIGFzIGFuIGFsaWFzIGZvciB0aGUgbWFpbiBsYWJlbCAoaS5lLiBudWxsIHByZWZpeClcblxuXG4gICAgaWYgKHByZWZpeCA9PT0gJ21haW4nKSB7XG4gICAgICBwcmVmaXggPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB0ZXh0WCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciB0ZXh0WSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgIHZhciBvcmdUZXh0WCwgb3JnVGV4dFk7IC8vIHVzZWQgZm9yIHJvdGF0aW9uXG5cbiAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcblxuICAgIGlmICh0ZXh0ICE9IG51bGwgJiYgdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpKSB7XG4gICAgICB0aGlzLnNldHVwVGV4dFN0eWxlKGNvbnRleHQsIGVsZSwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICAgIHZhciB0ZXh0VyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICAgIHZhciB0ZXh0SCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG5cbiAgICAgIHRleHRYICs9IG1hcmdpblg7XG4gICAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuICAgICAgdmFyIHRoZXRhO1xuXG4gICAgICBpZiAoIWFwcGx5Um90YXRpb24pIHtcbiAgICAgICAgdGhldGEgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhldGEgPSB0aGlzLmdldFRleHRBbmdsZShlbGUsIHByZWZpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgICBvcmdUZXh0WCA9IHRleHRYO1xuICAgICAgICBvcmdUZXh0WSA9IHRleHRZO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmdUZXh0WCwgb3JnVGV4dFkpO1xuICAgICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICAgIHRleHRYID0gMDtcbiAgICAgICAgdGV4dFkgPSAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgdGV4dFkgKz0gdGV4dEggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgYmFja2dyb3VuZFBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkge1xuICAgICAgICB2YXIgYmdYID0gdGV4dFggLSBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgYmdYIC09IHRleHRXIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnWSA9IHRleHRZIC0gdGV4dEggLSBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgICAgdmFyIGJnVyA9IHRleHRXICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgICB2YXIgYmdIID0gdGV4dEggKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCkge1xuICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IGNvbnRleHQuZmlsbFN0eWxlO1xuICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICAgIHZhciBzdHlsZVNoYXBlID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJykuc3RyVmFsdWU7XG5cbiAgICAgICAgICBpZiAoc3R5bGVTaGFwZS5pbmRleE9mKCdyb3VuZCcpID09PSAwKSB7XG4gICAgICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYLCBiZ1ksIGJnVywgYmdILCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkge1xuICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1jb2xvcicpLnZhbHVlO1xuICAgICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1zdHlsZScpLnZhbHVlO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRCb3JkZXJTdHlsZSkge1xuICAgICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuXG4gICAgICAgICAgaWYgKHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1ggKyB3aGl0ZVdpZHRoLCBiZ1kgKyB3aGl0ZVdpZHRoLCBiZ1cgLSB3aGl0ZVdpZHRoICogMiwgYmdIIC0gd2hpdGVXaWR0aCAqIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVdpZHRoID0gMiAqIGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgICAgdmFyIGhhbGZUZXh0VyA9IHRleHRXIC8gMjtcbiAgICAgICAgdmFyIGp1c3RpZmljYXRpb24gPSB0aGlzLmdldExhYmVsSnVzdGlmaWNhdGlvbihlbGUpO1xuXG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIDsgZWxzZSBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiByaWdodFxuICAgICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHRleHRYICs9IC10ZXh0VztcbiAgICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAvLyBhdXRvIGp1c3RmaWNhdGlvbiA6IGNlbnRlclxuICAgICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogbGVmdFxuICAgICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGV4dFggKz0gdGV4dFc7XG4gICAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb3JnVGV4dFgsIC1vcmdUZXh0WSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qIGdsb2JhbCBQYXRoMkQgKi9cbiAgdmFyIENScCQ1ID0ge307XG5cbiAgQ1JwJDUuZHJhd05vZGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICBpZiAoIW51bWJlciQxKHBvcy54KSB8fCAhbnVtYmVyJDEocG9zLnkpKSB7XG4gICAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICAgIH1cblxuICAgIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhbm9kZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICAgIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogcGFkZGluZztcbiAgICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nOyAvL1xuICAgIC8vIHNldHVwIHNoaWZ0XG5cbiAgICB2YXIgYmI7XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICAgIH0gLy9cbiAgICAvLyBsb2FkIGJnIGltYWdlXG5cblxuICAgIHZhciBiZ0ltZ1Byb3AgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICAgIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICAgIHZhciB1cmxEZWZpbmVkID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgQXJyYXkodXJscy5sZW5ndGgpO1xuICAgIHZhciBudW1JbWFnZXMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdXJsID0gdXJsc1tpXTtcbiAgICAgIHZhciBkZWZkID0gdXJsRGVmaW5lZFtpXSA9IHVybCAhPSBudWxsICYmIHVybCAhPT0gJ25vbmUnO1xuXG4gICAgICBpZiAoZGVmZCkge1xuICAgICAgICB2YXIgYmdJbWdDcm9zc09yaWdpbiA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsICd2YWx1ZScsIGkpO1xuICAgICAgICBudW1JbWFnZXMrKzsgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcblxuICAgICAgICBpbWFnZVtpXSA9IHIuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBiZ0ltZ0Nyb3NzT3JpZ2luLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3AuYmFja2dyb3VuZFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy9cbiAgICAvLyBzZXR1cCBzdHlsZXNcblxuXG4gICAgdmFyIGRhcmtuZXNzID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtYmxhY2tlbicpLnZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBiZ09wYWNpdHkgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICAgIHZhciBib3JkZXJDb2xvciA9IG5vZGUucHN0eWxlKCdib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gICAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7IC8vIHNvIGJvcmRlcnMgYXJlIHNxdWFyZSB3aXRoIHRoZSBub2RlIHNoYXBlXG5cbiAgICB2YXIgc2V0dXBTaGFwZUNvbG9yID0gZnVuY3Rpb24gc2V0dXBTaGFwZUNvbG9yKCkge1xuICAgICAgdmFyIGJnT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBiZ09wYWNpdHk7XG4gICAgICByLmVsZUZpbGxTdHlsZShjb250ZXh0LCBub2RlLCBiZ09weSk7XG4gICAgfTtcblxuICAgIHZhciBzZXR1cEJvcmRlckNvbG9yID0gZnVuY3Rpb24gc2V0dXBCb3JkZXJDb2xvcigpIHtcbiAgICAgIHZhciBiZHJPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJvcmRlck9wYWNpdHk7XG4gICAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgYmRyT3B5KTtcbiAgICB9OyAvL1xuICAgIC8vIHNldHVwIHNoYXBlXG5cblxuICAgIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gICAgdmFyIHNoYXBlUHRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykucGZWYWx1ZTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICAgIHZhciBwYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgfHwgW107XG4gICAgICB2YXIga2V5ID0gaGFzaFN0cmluZ3Moc3R5bGVTaGFwZSA9PT0gJ3BvbHlnb24nID8gc3R5bGVTaGFwZSArICcsJyArIHNoYXBlUHRzLmpvaW4oJywnKSA6IHN0eWxlU2hhcGUsICcnICsgbm9kZUhlaWdodCwgJycgKyBub2RlV2lkdGgpO1xuICAgICAgdmFyIGNhY2hlZFBhdGggPSBwYXRoQ2FjaGVba2V5XTtcblxuICAgICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gY2FjaGVkUGF0aDtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIHBhdGhDYWNoZVtrZXldID0gcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKCkge1xuICAgICAgaWYgKCFwYXRoQ2FjaGVIaXQpIHtcbiAgICAgICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhwYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3SW1hZ2VzID0gZnVuY3Rpb24gZHJhd0ltYWdlcygpIHtcbiAgICAgIHZhciBub2RlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICAgIHZhciBpbnNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgICAgIHZhciB0b3RhbENvbXBsZXRlZCA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbWFnZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGJnQ29udGFpbm1lbnQgPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLCAndmFsdWUnLCBfaSk7XG5cbiAgICAgICAgaWYgKGluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnb3ZlcicgfHwgIWluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnaW5zaWRlJykge1xuICAgICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsRGVmaW5lZFtfaV0gJiYgaW1hZ2VbX2ldLmNvbXBsZXRlICYmICFpbWFnZVtfaV0uZXJyb3IpIHtcbiAgICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICAgIHIuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlW19pXSwgbm9kZSwgX2ksIG5vZGVPcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfcC5iYWNrZ3JvdW5kaW5nID0gISh0b3RhbENvbXBsZXRlZCA9PT0gbnVtSW1hZ2VzKTtcblxuICAgICAgaWYgKHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZykge1xuICAgICAgICAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgbm9kZS51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3UGllID0gZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICAgIHZhciByZWRyYXdTaGFwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICB2YXIgcGllT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZWxlT3BhY2l0eTtcblxuICAgICAgaWYgKHIuaGFzUGllKG5vZGUpKSB7XG4gICAgICAgIHIuZHJhd1BpZShjb250ZXh0LCBub2RlLCBwaWVPcGFjaXR5KTsgLy8gcmVkcmF3L3Jlc3RvcmUgcGF0aCBpZiBzdGVwcyBhZnRlciBwaWUgbmVlZCBpdFxuXG4gICAgICAgIGlmIChyZWRyYXdTaGFwZSkge1xuICAgICAgICAgIGlmICghdXNlUGF0aHMpIHtcbiAgICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkYXJrZW4gPSBmdW5jdGlvbiBkYXJrZW4oKSB7XG4gICAgICB2YXIgZGFya2VuT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICAgIHZhciBvcGFjaXR5ID0gKGRhcmtuZXNzID4gMCA/IGRhcmtuZXNzIDogLWRhcmtuZXNzKSAqIGRhcmtlbk9wYWNpdHk7XG4gICAgICB2YXIgYyA9IGRhcmtuZXNzID4gMCA/IDAgOiAyNTU7XG5cbiAgICAgIGlmIChkYXJrbmVzcyAhPT0gMCkge1xuICAgICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGMsIGMsIGMsIG9wYWNpdHkpO1xuXG4gICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd0JvcmRlciA9IGZ1bmN0aW9uIGRyYXdCb3JkZXIoKSB7XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIHN3aXRjaCAoYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGggLyAzO1xuICAgICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgICAgfSAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuXG5cbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICAgIGlmIChzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgICAgci5kcmF3Tm9kZVVuZGVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBub2RlLCBudWxsLCBkcmF3TGFiZWwpO1xuICAgIH07XG5cbiAgICB2YXIgZ2hvc3QgPSBub2RlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiAoZ2hvc3QpIHtcbiAgICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgICB2YXIgZ3kgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgICAgdmFyIGdob3N0T3BhY2l0eSA9IG5vZGUucHN0eWxlKCdnaG9zdC1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgICBzZXR1cFNoYXBlQ29sb3IoZ2hvc3RPcGFjaXR5ICogYmdPcGFjaXR5KTtcbiAgICAgIGRyYXdTaGFwZSgpO1xuICAgICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHksIHRydWUpO1xuICAgICAgc2V0dXBCb3JkZXJDb2xvcihnaG9zdE9wYWNpdHkgKiBib3JkZXJPcGFjaXR5KTtcbiAgICAgIGRyYXdCb3JkZXIoKTtcbiAgICAgIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICAgICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHksIGZhbHNlKTtcbiAgICAgIGRhcmtlbihlZmZHaG9zdE9wYWNpdHkpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICAgIH1cblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXBvcy54LCAtcG9zLnkpO1xuICAgIH1cblxuICAgIGRyYXdVbmRlcmxheSgpO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgIH1cblxuICAgIHNldHVwU2hhcGVDb2xvcigpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWxlT3BhY2l0eSwgdHJ1ZSk7XG4gICAgc2V0dXBCb3JkZXJDb2xvcigpO1xuICAgIGRyYXdCb3JkZXIoKTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkcmF3SW1hZ2VzKGVsZU9wYWNpdHksIGZhbHNlKTtcbiAgICBkYXJrZW4oKTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXBvcy54LCAtcG9zLnkpO1xuICAgIH1cblxuICAgIGRyYXdUZXh0KCk7XG4gICAgZHJhd092ZXJsYXkoKTsgLy9cbiAgICAvLyBjbGVhbiB1cCBzaGlmdFxuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KG92ZXJsYXlPclVuZGVybGF5KSB7XG4gICAgaWYgKCFbJ292ZXJsYXknLCAndW5kZXJsYXknXS5pbmNsdWRlcyhvdmVybGF5T3JVbmRlcmxheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpIHtcbiAgICAgIHZhciByID0gdGhpcztcblxuICAgICAgaWYgKCFub2RlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWRkaW5nID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXBhZGRpbmdcIikpLnBmVmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcbiAgICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb2xvclwiKSkudmFsdWU7XG4gICAgICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItc2hhcGVcIikpLnZhbHVlO1xuXG4gICAgICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICBpZiAobm9kZVdpZHRoID09IG51bGwgfHwgbm9kZUhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG5cbiAgICAgICAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogX3BhZGRpbmc7XG4gICAgICAgICAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogX3BhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgICAgICByLm5vZGVTaGFwZXNbc2hhcGVdLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGggKyBwYWRkaW5nICogMiwgbm9kZUhlaWdodCArIHBhZGRpbmcgKiAyKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBDUnAkNS5kcmF3Tm9kZU92ZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgnb3ZlcmxheScpO1xuICBDUnAkNS5kcmF3Tm9kZVVuZGVybGF5ID0gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7IC8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuXG4gIENScCQ1Lmhhc1BpZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG4gIH07XG5cbiAgQ1JwJDUuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gICAgdmFyIHBpZVNpemUgPSBub2RlLnBzdHlsZSgncGllLXNpemUnKTtcbiAgICB2YXIgeCA9IHBvcy54O1xuICAgIHZhciB5ID0gcG9zLnk7XG4gICAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICAgIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKG5vZGVXLCBub2RlSCkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG5cbiAgICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG5cbiAgICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIHggPSAwO1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBpZVNpemUudW5pdHMgPT09ICclJykge1xuICAgICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS5wZlZhbHVlO1xuICAgIH0gZWxzZSBpZiAocGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScpLnZhbHVlO1xuICAgICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cbiAgICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuXG4gICAgICBpZiAocGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSkge1xuICAgICAgICBwZXJjZW50ID0gMSAtIGxhc3RQZXJjZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcblxuICAgICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTsgLy8gaWdub3JlIGlmXG4gICAgICAvLyAtIHplcm8gc2l6ZVxuICAgICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcblxuICAgICAgaWYgKHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ1JwJDQgPSB7fTtcbiAgdmFyIG1vdGlvbkJsdXJEZWxheSA9IDEwMDsgLy8gdmFyIGlzRmlyZWZveCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgQ1JwJDQuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZGF0YS5jb250ZXh0c1swXTtcblxuICAgIGlmICh0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH07XG5cbiAgQ1JwJDQucGFpbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICAgIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuXG4gICAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZFRvQ3JlYXRlQ2FjaGUpIHtcbiAgICAgIGNhY2hlID0ge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9O1xuICAgICAgY2FjaGVzLnB1c2goY2FjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICBDUnAkNC5jcmVhdGVHcmFkaWVudFN0eWxlRm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYXBlU3R5bGVOYW1lLCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgICB2YXIgZ3JhZGllbnRTdHlsZTtcbiAgICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gICAgdmFyIGNvbG9ycyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtY29sb3JzJykudmFsdWUsXG4gICAgICAgIHBvc2l0aW9ucyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJykucGZWYWx1ZTtcblxuICAgIGlmIChmaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgICAgIGVuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpLFxuICAgICAgICAgICAgbWlkID0gZWxlLm1pZHBvaW50KCk7XG4gICAgICAgIHZhciBkMSA9IGRpc3Qoc3RhcnQsIG1pZCk7XG4gICAgICAgIHZhciBkMiA9IGRpc3QoZW5kLCBtaWQpO1xuICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtaWQueCwgbWlkLnksIDAsIG1pZC54LCBtaWQueSwgTWF0aC5tYXgoZDEsIGQyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCk7XG4gICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHBvcy54LCBwb3MueSwgMCwgcG9zLngsIHBvcy55LCBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIF9zdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICAgICAgX2VuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpO1xuXG4gICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9zdGFydC54LCBfc3RhcnQueSwgX2VuZC54LCBfZW5kLnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9wb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgICAgX3dpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgICAgICBfaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpLFxuICAgICAgICAgICAgaGFsZldpZHRoID0gX3dpZHRoIC8gMixcbiAgICAgICAgICAgIGhhbGZIZWlnaHQgPSBfaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nKS52YWx1ZTtcblxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3RvLWJvdHRvbSc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLXRvcCc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLWxlZnQnOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tcmlnaHQnOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgICBjYXNlICd0by1yaWdodC1ib3R0b20nOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by10b3AtcmlnaHQnOlxuICAgICAgICAgIGNhc2UgJ3RvLXJpZ2h0LXRvcCc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1sZWZ0JzpcbiAgICAgICAgICBjYXNlICd0by1sZWZ0LWJvdHRvbSc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLXRvcC1sZWZ0JzpcbiAgICAgICAgICBjYXNlICd0by1sZWZ0LXRvcCc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgZ3JhZGllbnQgc3R5bGVcblxuICAgIHZhciBoYXNQb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoID09PSBjb2xvcnMubGVuZ3RoO1xuICAgIHZhciBsZW5ndGggPSBjb2xvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZ3JhZGllbnRTdHlsZS5hZGRDb2xvclN0b3AoaGFzUG9zaXRpb25zID8gcG9zaXRpb25zW2ldIDogaSAvIChsZW5ndGggLSAxKSwgJ3JnYmEoJyArIGNvbG9yc1tpXVswXSArICcsJyArIGNvbG9yc1tpXVsxXSArICcsJyArIGNvbG9yc1tpXVsyXSArICcsJyArIG9wYWNpdHkgKyAnKScpO1xuICAgIH1cblxuICAgIHJldHVybiBncmFkaWVudFN0eWxlO1xuICB9O1xuXG4gIENScCQ0LmdyYWRpZW50RmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICAgIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdiYWNrZ3JvdW5kJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudFN0eWxlO1xuICB9O1xuXG4gIENScCQ0LmNvbG9yRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknOyAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG4gICAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAgIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIC8vIH1cbiAgfTtcblxuICBDUnAkNC5lbGVGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gICAgdmFyIGJhY2tncm91bmRGaWxsID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1maWxsJykudmFsdWU7XG5cbiAgICBpZiAoYmFja2dyb3VuZEZpbGwgPT09ICdsaW5lYXItZ3JhZGllbnQnIHx8IGJhY2tncm91bmRGaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgICAgdGhpcy5ncmFkaWVudEZpbGxTdHlsZShjb250ZXh0LCBlbGUsIGJhY2tncm91bmRGaWxsLCBvcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYmFja2dyb3VuZENvbG9yWzBdLCBiYWNrZ3JvdW5kQ29sb3JbMV0sIGJhY2tncm91bmRDb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ0LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gICAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2xpbmUnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICAgIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGVycm9yXG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbiAgfTtcblxuICBDUnAkNC5jb2xvclN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG4gICAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gICAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuXG4gIENScCQ0LmVsZVN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICAgIHZhciBsaW5lRmlsbCA9IGVsZS5wc3R5bGUoJ2xpbmUtZmlsbCcpLnZhbHVlO1xuXG4gICAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICAgIHRoaXMuZ3JhZGllbnRTdHJva2VTdHlsZShjb250ZXh0LCBlbGUsIGxpbmVGaWxsLCBvcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICAgIHRoaXMuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICB9XG4gIH07IC8vIFJlc2l6ZSBjYW52YXNcblxuXG4gIENScCQ0Lm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSByLmRhdGE7XG4gICAgdmFyIGJiID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIHdpZHRoID0gYmJbMl07XG4gICAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICAgIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG5cbiAgICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzO1xuXG4gICAgaWYgKGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQpIHtcbiAgICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICAgIH1cblxuICAgIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICAgIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgci50ZXh0dXJlTXVsdCA9IDE7XG5cbiAgICBpZiAocGl4ZWxSYXRpbyA8PSAxKSB7XG4gICAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdDtcbiAgICB9XG5cbiAgICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgci5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gIH07XG5cbiAgQ1JwJDQucmVuZGVyVG8gPSBmdW5jdGlvbiAoY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgICB0aGlzLnJlbmRlcih7XG4gICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICBmb3JjZWRab29tOiB6b29tLFxuICAgICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICAgIH0pO1xuICB9O1xuXG4gIENScCQ0LnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICAgIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICAgIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGRhdGEgPSByLmRhdGE7XG4gICAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICAgIHZhciBtb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdGlvbkJsdXIgOiByLm1vdGlvbkJsdXI7XG4gICAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGluTm9kZURyYWdHZXN0dXJlID0gci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICAgIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gICAgdmFyIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gbW90aW9uQmx1cjtcblxuICAgIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgICAgaWYgKHIucHJldlB4UmF0aW8gIT09IHBpeGVsUmF0aW8pIHtcbiAgICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHIucHJldlB4UmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoci5tb3Rpb25CbHVyVGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICAgIGlmIChyLm1iRnJhbWVzID09IG51bGwpIHtcbiAgICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIubWJGcmFtZXMrKztcblxuICAgICAgaWYgKHIubWJGcmFtZXMgPCAzKSB7XG4gICAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICAgIH0gLy8gZ28gdG8gbG93ZXIgcXVhbGl0eSBibHVycnkgZnJhbWVzIHdoZW4gc2V2ZXJhbCBtL2IgZnJhbWVzIGhhdmUgYmVlbiByZW5kZXJlZCAoYXZvaWRzIGZsYXNoaW5nKVxuXG5cbiAgICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICB9IC8vIGIvYyBkcmF3VG9Db250ZXh0KCkgbWF5IGJlIGFzeW5jIHcuci50LiByZWRyYXcoKSwga2VlcCB0cmFjayBvZiBsYXN0IHRleHR1cmUgZnJhbWVcbiAgICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuXG5cbiAgICBpZiAoci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcpIHtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgZWZmZWN0aXZlUGFuID0ge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH07XG4gICAgdmFyIHZwID0ge1xuICAgICAgem9vbTogem9vbSxcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgeTogcGFuLnlcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7IC8vIHdlIHdhbnQgdGhlIGxvdyBxdWFsaXR5IG1vdGlvbmJsdXIgb25seSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBiZWluZyBtYW5pcHVsYXRlZCBldGMgKHdoZXJlIGl0J3Mgbm90IG5vdGljZWQpXG5cbiAgICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gICAgfSAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG5cbiAgICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gICAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuICAgIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgZnVuY3Rpb24gbWJjbGVhcihjb250ZXh0LCB4LCB5LCB3LCBoKSB7XG4gICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kpO1xuICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpIHtcbiAgICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgICAgaWYgKCFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkpIHtcbiAgICAgICAgZVBhbiA9IHtcbiAgICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgICB9O1xuICAgICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG4gICAgICAgIHcgPSByLmNhbnZhc1dpZHRoICogbWJQeFJhdGlvO1xuICAgICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlUGFuID0gZWZmZWN0aXZlUGFuO1xuICAgICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG4gICAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICBpZiAoY2xlYXIgPT09ICdtb3Rpb25CbHVyJykge1xuICAgICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHcsIGgpO1xuICAgICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShlUGFuLngsIGVQYW4ueSk7XG4gICAgICAgIGNvbnRleHQuc2NhbGUoZVpvb20sIGVab29tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlZFBhbikge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShmb3JjZWRQYW4ueCwgZm9yY2VkUGFuLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VkWm9vbSkge1xuICAgICAgICBjb250ZXh0LnNjYWxlKGZvcmNlZFpvb20sIGZvcmNlZFpvb20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dHVyZURyYXcpIHtcbiAgICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGV4dHVyZURyYXcpIHtcbiAgICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgICBpZiAoIXIudGV4dHVyZUNhY2hlKSB7XG4gICAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG4gICAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcbiAgICAgICAgci5yZW5kZXIoe1xuICAgICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2cC5tcGFuID0ge1xuICAgICAgICAgIHg6ICgwIC0gdnAucGFuLngpIC8gdnAuem9vbSxcbiAgICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydDtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRzaWRlQmdDb2xvciA9IHN0eWxlLmNvcmUoJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgZmFsc2UpO1xuICAgICAgY29udGV4dC5jbGVhclJlY3QodnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gICAgfSBlbHNlIGlmIChyLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0KSB7XG4gICAgICAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBleHRlbnQgPSBjeS5leHRlbnQoKTtcbiAgICB2YXIgdnBNYW5pcCA9IHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5jeS5hbmltYXRlZCgpO1xuICAgIHZhciBoaWRlRWRnZXMgPSByLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcbiAgICB2YXIgbmVlZE1iQ2xlYXIgPSBbXTtcbiAgICBuZWVkTWJDbGVhcltyLk5PREVdID0gIW5lZWREcmF3W3IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuXG4gICAgaWYgKG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IHRydWU7XG4gICAgfVxuXG4gICAgbmVlZE1iQ2xlYXJbci5EUkFHXSA9ICFuZWVkRHJhd1tyLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcblxuICAgIGlmIChuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIgfHwgbmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSA6IGRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gICAgICB2YXIgY2xlYXIgPSBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQ7XG4gICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKTtcblxuICAgICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgICByLmRyYXdDYWNoZWROb2Rlcyhjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSkge1xuICAgICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuRFJBR10gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLmRyYWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyLnNob3dGcHMgfHwgIWRyYXdPbmx5Tm9kZUxheWVyICYmIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG4gICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQpO1xuXG4gICAgICBpZiAoci5zZWxlY3Rpb25bNF0gPT0gMSAmJiAoci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZykpIHtcbiAgICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnKS52YWx1ZSAvIHpvb207XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG5cbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBzdHlsZS5jb3JlKCdhY3RpdmUtYmctc2l6ZScpLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcblxuICAgICAgaWYgKHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gTWF0aC5yb3VuZCh0aW1lVG9SZW5kZXIpO1xuICAgICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCcxIGZyYW1lID0gJyArIHRpbWVUb1JlbmRlciArICcgbXMgPSAnICsgZnBzICsgJyBmcHMnLCAwLCAyMCk7XG4gICAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIDMwLCAyNTAsIDIwKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAzMCwgMjUwICogTWF0aC5taW4oZnBzIC8gbWF4RnBzLCAxKSwgMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgICAgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG5cblxuICAgIGlmIChtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSkge1xuICAgICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgICB2YXIgdHh0Tm9kZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdO1xuICAgICAgdmFyIGN4dERyYWcgPSBkYXRhLmNvbnRleHRzW3IuRFJBR107XG4gICAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuXG4gICAgICB2YXIgZHJhd01vdGlvbkJsdXIgPSBmdW5jdGlvbiBkcmF3TW90aW9uQmx1cihjeHQsIHR4dCwgbmVlZENsZWFyKSB7XG4gICAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHB4ciA9IG1iUHhSYXRpbztcbiAgICAgICAgY3h0LmRyYXdJbWFnZSh0eHQsIC8vIGltZ1xuICAgICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsIC8vIHN3LCBzaFxuICAgICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgICAgZHJhd01vdGlvbkJsdXIoY3h0Tm9kZSwgdHh0Tm9kZSwgbmVlZE1iQ2xlYXJbci5OT0RFXSk7XG4gICAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWREcmF3W3IuRFJBR10gfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgICAgICBkcmF3TW90aW9uQmx1cihjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltyLkRSQUddKTtcbiAgICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gIXRleHR1cmVEcmF3O1xuICAgICAgICByLm1iRnJhbWVzID0gMDtcbiAgICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICAgIG5lZWREcmF3W3IuRFJBR10gPSB0cnVlO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlZENvbnRleHQpIHtcbiAgICAgIGN5LmVtaXQoJ3JlbmRlcicpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ1JwJDMgPSB7fTsgLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5cbiAgQ1JwJDMuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQubW92ZVRvKHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgQ1JwJDMuZHJhd1JvdW5kUG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcG9pbnRzLmxlbmd0aCAvIDQ7IF9pKyspIHtcbiAgICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChfaSA9PT0gMCkge1xuICAgICAgICBzb3VyY2VVdiA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlVXYgPSBfaSAqIDQgLSAyO1xuICAgICAgfVxuXG4gICAgICBkZXN0VXYgPSBfaSAqIDQgKyAyO1xuICAgICAgdmFyIHB4ID0geCArIGhhbGZXICogcG9pbnRzW19pICogNF07XG4gICAgICB2YXIgcHkgPSB5ICsgaGFsZkggKiBwb2ludHNbX2kgKiA0ICsgMV07XG4gICAgICB2YXIgY29zVGhldGEgPSAtcG9pbnRzW3NvdXJjZVV2XSAqIHBvaW50c1tkZXN0VXZdIC0gcG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBwb2ludHNbZGVzdFV2ICsgMV07XG4gICAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdl07XG4gICAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogcG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgICB2YXIgY3AxeCA9IHB4ICsgb2Zmc2V0ICogcG9pbnRzW2Rlc3RVdl07XG4gICAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgICBpZiAoX2kgPT09IDApIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oY3AweCwgY3AweSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhjcDB4LCBjcDB5KTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5hcmNUbyhweCwgcHksIGNwMXgsIGNwMXksIGNvcm5lclJhZGl1cyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTsgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcblxuXG4gIENScCQzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gICAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpOyAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcblxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG5cbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTsgLy8gQXJjIGZyb20gYm90dG9tIHRvIGxlZnQgc2lkZVxuXG4gICAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTsgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuXG4gICAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEpvaW4gbGluZVxuXG4gICAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgQ1JwJDMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0gLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuXG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkpO1xuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gICAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIENScCQzLmRyYXdDdXRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyTGVuZ3RoID0gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCk7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICAgIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIENScCQzLmRyYXdCYXJyZWxQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgeEJlZ2luID0geCAtIGhhbGZXaWR0aDtcbiAgICB2YXIgeEVuZCA9IHggKyBoYWxmV2lkdGg7XG4gICAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICAgIHZhciB5RW5kID0geSArIGhhbGZIZWlnaHQ7XG4gICAgdmFyIGJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgICB2YXIgaE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICB2YXIgY3RybFB0WE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdPZmZzZXQ7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0KTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luICsgd09mZnNldCwgeUVuZCk7XG4gICAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCwgeUVuZCAtIGhPZmZzZXQpO1xuICAgIGNvbnRleHQubGluZVRvKHhFbmQsIHlCZWdpbiArIGhPZmZzZXQpO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kIC0gd09mZnNldCwgeUJlZ2luKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW4pO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiwgeUJlZ2luICsgaE9mZnNldCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICB2YXIgc2luMCA9IE1hdGguc2luKDApO1xuICB2YXIgY29zMCA9IE1hdGguY29zKDApO1xuICB2YXIgc2luID0ge307XG4gIHZhciBjb3MgPSB7fTtcbiAgdmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcblxuICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbiAgfVxuXG4gIENScCQzLmRyYXdFbGxpcHNlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICAgIGNvbnRleHQuZWxsaXBzZShjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgICB2YXIgcncgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgcmggPSBoZWlnaHQgLyAyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgICAgeFBvcyA9IGNlbnRlclggLSBydyAqIHNpbltpXSAqIHNpbjAgKyBydyAqIGNvc1tpXSAqIGNvczA7XG4gICAgICAgIHlQb3MgPSBjZW50ZXJZICsgcmggKiBjb3NbaV0gKiBzaW4wICsgcmggKiBzaW5baV0gKiBjb3MwO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xuICB2YXIgQ1JwJDIgPSB7fTtcblxuICBDUnAkMi5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiAodywgaCkge1xuICAgIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgYnVmZmVyLndpZHRoID0gdztcbiAgICBidWZmZXIuaGVpZ2h0ID0gaDtcbiAgICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xuICB9O1xuXG4gIENScCQyLmJ1ZmZlckNhbnZhc0ltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5O1xuICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgdmFyIGJiID0gZWxlcy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogY3RyUmVjdFsyXTtcbiAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLmgpIDogY3RyUmVjdFszXTtcbiAgICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkgfHwgbnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpO1xuICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIHNjYWxlID0gMTtcblxuICAgIGlmIChvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcbiAgICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB9IGVsc2UgaWYgKHNwZWNkTWF4RGltcykge1xuICAgICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuXG4gICAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkpIHtcbiAgICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIkMShvcHRpb25zLm1heEhlaWdodCkpIHtcbiAgICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc2NhbGUgPSBNYXRoLm1pbihtYXhTY2FsZVcsIG1heFNjYWxlSCk7XG4gICAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIXNwZWNkTWF4RGltcykge1xuICAgICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICAgIGhlaWdodCAqPSBweFJhdGlvO1xuICAgICAgc2NhbGUgKj0gcHhSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgYnVmZkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgYnVmZkNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuXG4gICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG4gICAgICBidWZmQ3h0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgIHZhciB6c29ydGVkRWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZnVsbCkge1xuICAgICAgICAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLWJiLngxICogc2NhbGUsIC1iYi55MSAqIHNjYWxlKTtcbiAgICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgICBidWZmQ3h0LnRyYW5zbGF0ZShiYi54MSAqIHNjYWxlLCBiYi55MSAqIHNjYWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiBwYW4ueCAqIHNjYWxlLFxuICAgICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgc2NhbGUgKj0gY3kuem9vbSgpO1xuICAgICAgICBidWZmQ3h0LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KTtcbiAgICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtdHJhbnNsYXRpb24ueCwgLXRyYW5zbGF0aW9uLnkpO1xuICAgICAgfSAvLyBuZWVkIHRvIGZpbGwgYmcgYXQgZW5kIGxpa2UgdGhpcyBpbiBvcmRlciB0byBmaWxsIGNsZWFyZWQgdHJhbnNwYXJlbnQgcGl4ZWxzIGluIGpwZ3NcblxuXG4gICAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgICAgYnVmZkN4dC5maWxsU3R5bGUgPSBvcHRpb25zLmJnO1xuICAgICAgICBidWZmQ3h0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmQ2FudmFzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGI2NFRvQmxvYihiNjQsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICAgIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmZlVpbnQ4W2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZdLCB7XG4gICAgICB0eXBlOiBtaW1lVHlwZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYjY0VXJpVG9CNjQoYjY0dXJpKSB7XG4gICAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuICAgIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGdldEI2NFVyaSA9IGZ1bmN0aW9uIGdldEI2NFVyaSgpIHtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgIH07XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgICBjYXNlICdibG9iLXByb21pc2UnOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYGNhbnZhcy50b0Jsb2IoKWAgc2VudCBhIG51bGwgdmFsdWUgaW4gaXRzIGNhbGxiYWNrJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICByZXR1cm4gYjY0VG9CbG9iKGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKSwgbWltZVR5cGUpO1xuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpO1xuXG4gICAgICBjYXNlICdiYXNlNjR1cmknOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGdldEI2NFVyaSgpO1xuICAgIH1cbiAgfVxuXG4gIENScCQyLnBuZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvcG5nJyk7XG4gIH07XG5cbiAgQ1JwJDIuanBnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9qcGVnJyk7XG4gIH07XG5cbiAgdmFyIENScCQxID0ge307XG5cbiAgQ1JwJDEubm9kZVNoYXBlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3RWxsaXBzZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgICAgY2FzZSAncm91bmQtcG9seWdvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFBvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICAgIGNhc2UgJ3JvdW5kLXJlY3RhbmdsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGNhc2UgJ2N1dHJlY3RhbmdsZSc6XG4gICAgICBjYXNlICdjdXQtcmVjdGFuZ2xlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0N1dFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJzpcbiAgICAgIGNhc2UgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBjYXNlICdiYXJyZWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3QmFycmVsUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG4gIENScC5DQU5WQVNfTEFZRVJTID0gMzsgLy9cblxuICBDUnAuU0VMRUNUX0JPWCA9IDA7XG4gIENScC5EUkFHID0gMTtcbiAgQ1JwLk5PREUgPSAyO1xuICBDUnAuQlVGRkVSX0NPVU5UID0gMzsgLy9cblxuICBDUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuICBDUnAuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSA9IDE7XG4gIENScC5NT1RJT05CTFVSX0JVRkZFUl9EUkFHID0gMjtcblxuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHIuZGF0YSA9IHtcbiAgICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwLkJVRkZFUl9DT1VOVCksXG4gICAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKVxuICAgIH07XG4gICAgdmFyIHRhcEhsT2ZmQXR0ciA9ICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InO1xuICAgIHZhciB0YXBIbE9mZlN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBjb250YWluZXJTdHlsZS56SW5kZXggPSAnMCc7XG4gICAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmNhbnZhc0NvbnRhaW5lcik7XG4gICAgY29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICAgIHZhciBzdHlsZU1hcCA9IHtcbiAgICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICAgJy1tb3otdXNlci1zZWxlY3QnOiAnLW1vei1ub25lJyxcbiAgICAgICd1c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAnb3V0bGluZS1zdHlsZSc6ICdub25lJ1xuICAgIH07XG5cbiAgICBpZiAobXMoKSkge1xuICAgICAgc3R5bGVNYXBbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgICAgIHN0eWxlTWFwWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIE9iamVjdC5rZXlzKHN0eWxlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZVtrXSA9IHN0eWxlTWFwW2tdO1xuICAgICAgfSk7XG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBpKTtcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwLkNBTlZBU19MQVlFUlMgLSBpKTtcbiAgICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG4gICAgci5kYXRhLmNhbnZhc2VzW0NScC5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLk5PREUgKyAnLW5vZGUnKTtcbiAgICByLmRhdGEuY2FudmFzZXNbQ1JwLlNFTEVDVF9CT1hdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94Jyk7XG4gICAgci5kYXRhLmNhbnZhc2VzW0NScC5EUkFHXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICByLmRhdGEuYnVmZmVyQ29udGV4dHNbaV0gPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoLWkgLSAxKTtcbiAgICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICAgIH1cblxuICAgIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbiAgICB2YXIgZW1wdHlCYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIGdldEJveENlbnRlciA9IGZ1bmN0aW9uIGdldEJveENlbnRlcihiYikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGJiLngxICsgYmIueDIpIC8gMixcbiAgICAgICAgeTogKGJiLnkxICsgYmIueTIpIC8gMlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGdldENlbnRlck9mZnNldChiYikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogLWJiLncgLyAyLFxuICAgICAgICB5OiAtYmIuaCAvIDJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCA9IGZ1bmN0aW9uIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgICAgdmFyIHNhbWUgPSBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID09PSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgICAgcmV0dXJuICFzYW1lO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U3R5bGVLZXkgPSBmdW5jdGlvbiBnZXRTdHlsZUtleShlbGUpIHtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubm9kZUtleTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsU3R5bGVLZXk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTb3VyY2VMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsS2V5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5zb3VyY2VMYWJlbFN0eWxlS2V5O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGFyZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEtleShlbGUpIHtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUudGFyZ2V0TGFiZWxTdHlsZUtleTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdFbGVtZW50ID0gZnVuY3Rpb24gZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgZmFsc2UsIGZhbHNlLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdMYWJlbCA9IGZ1bmN0aW9uIGRyYXdMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ21haW4nLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdTb3VyY2VMYWJlbCA9IGZ1bmN0aW9uIGRyYXdTb3VyY2VMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3NvdXJjZScsIHVzZUVsZU9wYWNpdHkpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1RhcmdldExhYmVsID0gZnVuY3Rpb24gZHJhd1RhcmdldExhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAndGFyZ2V0JywgdXNlRWxlT3BhY2l0eSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbGVtZW50Qm94ID0gZnVuY3Rpb24gZ2V0RWxlbWVudEJveChlbGUpIHtcbiAgICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ib2R5Qm91bmRzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRMYWJlbEJveChlbGUpIHtcbiAgICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5tYWluIHx8IGVtcHR5QmI7XG4gICAgfTtcblxuICAgIHZhciBnZXRTb3VyY2VMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsQm94KGVsZSkge1xuICAgICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnNvdXJjZSB8fCBlbXB0eUJiO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGFyZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEJveChlbGUpIHtcbiAgICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy50YXJnZXQgfHwgZW1wdHlCYjtcbiAgICB9O1xuXG4gICAgdmFyIGlzTGFiZWxWaXNpYmxlQXRTY2FsZSA9IGZ1bmN0aW9uIGlzTGFiZWxWaXNpYmxlQXRTY2FsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pIHtcbiAgICAgIHJldHVybiBzY2FsZWRMYWJlbFNob3duO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25Qb2ludChlbGUpIHtcbiAgICAgIHJldHVybiBnZXRCb3hDZW50ZXIoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRleHRNYXJnaW4gPSBmdW5jdGlvbiBhZGRUZXh0TWFyZ2luKHByZWZpeCwgcHQsIGVsZSkge1xuICAgICAgdmFyIHByZSA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcHQueCArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlLFxuICAgICAgICB5OiBwdC55ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRSc1B0ID0gZnVuY3Rpb24gZ2V0UnNQdChlbGUsIHgsIHkpIHtcbiAgICAgIHZhciBycyA9IGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzW3hdLFxuICAgICAgICB5OiByc1t5XVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCcnLCBnZXRSc1B0KGVsZSwgJ2xhYmVsWCcsICdsYWJlbFknKSwgZWxlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCdzb3VyY2UnLCBnZXRSc1B0KGVsZSwgJ3NvdXJjZUxhYmVsWCcsICdzb3VyY2VMYWJlbFknKSwgZWxlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCd0YXJnZXQnLCBnZXRSc1B0KGVsZSwgJ3RhcmdldExhYmVsWCcsICd0YXJnZXRMYWJlbFknKSwgZWxlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRTb3VyY2VMYWJlbEJveChlbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRUYXJnZXRMYWJlbEJveChlbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgICAgdmFyIGJiID0gZ2V0TGFiZWxCb3goZWxlKTtcbiAgICAgIHZhciBwID0gZ2V0Q2VudGVyT2Zmc2V0KGdldExhYmVsQm94KGVsZSkpO1xuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgcC54ID0gLWJiLnc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHAueCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBwLnkgPSAtYmIuaDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHAueSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgdmFyIGVsZVR4ckNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgICAgZ2V0S2V5OiBnZXRTdHlsZUtleSxcbiAgICAgIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCxcbiAgICAgIGRyYXdFbGVtZW50OiBkcmF3RWxlbWVudCxcbiAgICAgIGdldEJvdW5kaW5nQm94OiBnZXRFbGVtZW50Qm94LFxuICAgICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgYWxsb3dFZGdlVHhyQ2FjaGluZzogZmFsc2UsXG4gICAgICBhbGxvd1BhcmVudFR4ckNhY2hpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIGxibFR4ckNhY2hlID0gci5kYXRhLmxibFR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgICAgZ2V0S2V5OiBnZXRMYWJlbEtleSxcbiAgICAgIGRyYXdFbGVtZW50OiBkcmF3TGFiZWwsXG4gICAgICBnZXRCb3VuZGluZ0JveDogZ2V0TGFiZWxCb3gsXG4gICAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gICAgfSk7XG4gICAgdmFyIHNsYlR4ckNhY2hlID0gci5kYXRhLnNsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgICAgZ2V0S2V5OiBnZXRTb3VyY2VMYWJlbEtleSxcbiAgICAgIGRyYXdFbGVtZW50OiBkcmF3U291cmNlTGFiZWwsXG4gICAgICBnZXRCb3VuZGluZ0JveDogZ2V0U291cmNlTGFiZWxCb3gsXG4gICAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gICAgfSk7XG4gICAgdmFyIHRsYlR4ckNhY2hlID0gci5kYXRhLnRsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgICAgZ2V0S2V5OiBnZXRUYXJnZXRMYWJlbEtleSxcbiAgICAgIGRyYXdFbGVtZW50OiBkcmF3VGFyZ2V0TGFiZWwsXG4gICAgICBnZXRCb3VuZGluZ0JveDogZ2V0VGFyZ2V0TGFiZWxCb3gsXG4gICAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gICAgfSk7XG4gICAgdmFyIGx5clR4ckNhY2hlID0gci5kYXRhLmx5clR4ckNhY2hlID0gbmV3IExheWVyZWRUZXh0dXJlQ2FjaGUocik7XG4gICAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uIGludmFsaWRhdGVUZXh0dXJlQ2FjaGVzKHdpbGxEcmF3LCBlbGVzKSB7XG4gICAgICAvLyBlYWNoIGNhY2hlIHNob3VsZCBjaGVjayBmb3Igc3ViLWtleSBkaWZmIHRvIHNlZSB0aGF0IHRoZSB1cGRhdGUgYWZmZWN0cyB0aGF0IGNhY2hlIHBhcnRpY3VsYXJseVxuICAgICAgZWxlVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgICAgbGJsVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgICAgc2xiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgICAgdGxiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpOyAvLyBhbnkgY2hhbmdlIGludmFsaWRhdGVzIHRoZSBsYXllcnNcblxuICAgICAgbHlyVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpOyAvLyB1cGRhdGUgdGhlIG9sZCBiZyB0aW1lc3RhbXAgc28gZGlmZnMgY2FuIGJlIGRvbmUgaW4gdGhlIGVsZSB0eHIgY2FjaGVzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3AgPSBlbGVzW19pXS5fcHJpdmF0ZTtcbiAgICAgICAgX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVmaW5lSW5MYXllcnMgPSBmdW5jdGlvbiByZWZpbmVJbkxheWVycyhyZXFzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbHlyVHhyQ2FjaGUuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50KHJlcXNbaV0uZWxlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgICBsYmxUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICAgIHNsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gICAgdGxiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgfVxuXG4gIENScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24gKGdyb3VwLCBib29sKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgc3dpdGNoIChncm91cCkge1xuICAgICAgY2FzZSAnZWxlcyc6XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuTk9ERV0gPSBib29sO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZHJhZyc6XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuRFJBR10gPSBib29sO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5TRUxFQ1RfQk9YXSA9IGJvb2w7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTsgLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcblxuXG4gIHZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgICBpZiAob24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICAgIH1cblxuICAgIHRoaXMucGF0aHNFbmFibGVkID0gb24gPyB0cnVlIDogZmFsc2U7XG4gIH07XG5cbiAgQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xuICB9O1xuXG4gIENScC5zZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCwgYm9vbCkge1xuICAgIGlmIChjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCAhPSBudWxsKSB7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIH1cbiAgfTtcblxuICBDUnAuZ2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICB9XG4gIH07XG5cbiAgQ1JwLm1ha2VPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBjYW52YXM7XG5cbiAgICBpZiAoKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihPZmZzY3JlZW5DYW52YXMpKSAhPT0gKFwidW5kZWZpbmVkXCIgKSkge1xuICAgICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG5cbiAgW0NScCRhLCBDUnAkOSwgQ1JwJDgsIENScCQ3LCBDUnAkNiwgQ1JwJDUsIENScCQ0LCBDUnAkMywgQ1JwJDIsIENScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChDUnAsIHByb3BzKTtcbiAgfSk7XG5cbiAgdmFyIHJlbmRlcmVyID0gW3tcbiAgICBuYW1lOiAnbnVsbCcsXG4gICAgaW1wbDogTnVsbFJlbmRlcmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFzZScsXG4gICAgaW1wbDogQlJcbiAgfSwge1xuICAgIG5hbWU6ICdjYW52YXMnLFxuICAgIGltcGw6IENSXG4gIH1dO1xuXG4gIHZhciBpbmNFeHRzID0gW3tcbiAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICBleHRlbnNpb25zOiBsYXlvdXRcbiAgfSwge1xuICAgIHR5cGU6ICdyZW5kZXJlcicsXG4gICAgZXh0ZW5zaW9uczogcmVuZGVyZXJcbiAgfV07XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBtb2R1bGVzIGZvciBleHRlbnNpb25zLCBpbmRleGVkIGJ5IG5hbWVcblxuICB2YXIgbW9kdWxlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHNldEV4dGVuc2lvbih0eXBlLCBuYW1lLCByZWdpc3RyYW50KSB7XG4gICAgdmFyIGV4dCA9IHJlZ2lzdHJhbnQ7XG5cbiAgICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiBvdmVycmlkZUVycihmaWVsZCkge1xuICAgICAgd2FybignQ2FuIG5vdCByZWdpc3RlciBgJyArIG5hbWUgKyAnYCBmb3IgYCcgKyB0eXBlICsgJ2Agc2luY2UgYCcgKyBmaWVsZCArICdgIGFscmVhZHkgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgYW5kIGNhbiBub3QgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvcmUnKSB7XG4gICAgICBpZiAoQ29yZS5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ29yZS5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbGxlY3Rpb24nKSB7XG4gICAgICBpZiAoQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xheW91dCcpIHtcbiAgICAgIC8vIGZpbGwgaW4gbWlzc2luZyBsYXlvdXQgZnVuY3Rpb25zIGluIHRoZSBwcm90b3R5cGVcbiAgICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZWdpc3RyYW50LmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIG1ha2Ugc3VyZSBsYXlvdXQgaGFzIF9wcml2YXRlIGZvciB1c2Ugdy8gc3RkIGFwaXMgbGlrZSAub24oKVxuXG4gICAgICAgIGlmICghcGxhaW5PYmplY3QodGhpcy5fcHJpdmF0ZSkpIHtcbiAgICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYW50LnByb3RvdHlwZSk7XG4gICAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG5cbiAgICAgICAgbGF5b3V0UHJvdG9bZm5OYW1lXSA9IGxheW91dFByb3RvW2ZuTmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgfSAvLyBlaXRoZXIgLnN0YXJ0KCkgb3IgLnJ1bigpIGlzIGRlZmluZWQsIHNvIGF1dG9nZW4gdGhlIG90aGVyXG5cblxuICAgICAgaWYgKGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1bikge1xuICAgICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnU3RvcCA9IHJlZ2lzdHJhbnQucHJvdG90eXBlLnN0b3A7XG5cbiAgICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuYW5pbWF0ZSkge1xuICAgICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgICAgaWYgKGFuaXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhbmlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZ1N0b3ApIHtcbiAgICAgICAgICByZWdTdG9wLmNhbGwodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGlmICghbGF5b3V0UHJvdG8uZGVzdHJveSkge1xuICAgICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsYXlvdXRQcm90by5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2V0Q3kgPSBmdW5jdGlvbiBnZXRDeShsYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIGxheW91dC5fcHJpdmF0ZS5jeTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlbWl0dGVyT3B0cyA9IHtcbiAgICAgICAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGxheW91dCwgZXZ0KSB7XG4gICAgICAgICAgZXZ0LmxheW91dCA9IGxheW91dDtcbiAgICAgICAgICBldnQuY3kgPSBnZXRDeShsYXlvdXQpO1xuICAgICAgICAgIGV2dC50YXJnZXQgPSBsYXlvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChsYXlvdXQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVuZChsYXlvdXRQcm90bywge1xuICAgICAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgICAgIHRoaXMuX3ByaXZhdGUuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRzLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICAgICAgICB9LFxuICAgICAgICBvbjogZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLm9uKGV2dCwgY2IpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBvbmU6IGZ1bmN0aW9uIG9uZShldnQsIGNiKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGNiKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2dCwgcGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldnQsIHBhcmFtcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKGxheW91dFByb3RvKTtcbiAgICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAvLyB1c2VyIHJlZ2lzdGVyZWQgcmVuZGVyZXJzIGluaGVyaXQgZnJvbSBiYXNlXG4gICAgICB2YXIgQmFzZVJlbmRlcmVyID0gZ2V0RXh0ZW5zaW9uKCdyZW5kZXJlcicsICdiYXNlJyk7XG4gICAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICAgIHZhciBSZWdpc3RyYW50UmVuZGVyZXIgPSByZWdpc3RyYW50O1xuICAgICAgdmFyIHJQcm90byA9IHJlZ2lzdHJhbnQucHJvdG90eXBlO1xuXG4gICAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIFJlZ2lzdHJhbnRSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHByb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBwTmFtZSBpbiBiUHJvdG8pIHtcbiAgICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvW3BOYW1lXSAhPSBudWxsO1xuXG4gICAgICAgIGlmIChleGlzdHNJblIpIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIocE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG9bcE5hbWVdID0gcFZhbDsgLy8gdGFrZSBpbXBsIGZyb20gYmFzZVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfcE5hbWUgaW4gclByb3RvKSB7XG4gICAgICAgIHByb3RvW19wTmFtZV0gPSByUHJvdG9bX3BOYW1lXTsgLy8gdGFrZSBpbXBsIGZyb20gcmVnaXN0cmFudFxuICAgICAgfVxuXG4gICAgICBiUHJvdG8uY2xpZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm90b1tuYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgZXh0ID0gUmVuZGVyZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnX19wcm90b19fJyB8fCB0eXBlID09PSAnY29uc3RydWN0b3InIHx8IHR5cGUgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAvLyB0byBhdm9pZCBwb3RlbnRpYWwgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgICAgcmV0dXJuIGVycm9yKHR5cGUgKyAnIGlzIGFuIGlsbGVnYWwgdHlwZSB0byBiZSByZWdpc3RlcmVkLCBwb3NzaWJseSBsZWFkIHRvIHByb3RvdHlwZSBwb2xsdXRpb25zJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbdHlwZSwgbmFtZV0sXG4gICAgICB2YWx1ZTogZXh0XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeHRlbnNpb24odHlwZSwgbmFtZSkge1xuICAgIHJldHVybiBnZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogW3R5cGUsIG5hbWVdXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSwgcmVnaXN0cmFudCkge1xuICAgIHJldHVybiBzZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogW3R5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWVdLFxuICAgICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIGdldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBleHRlbnNpb24gPSBmdW5jdGlvbiBleHRlbnNpb24oKSB7XG4gICAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIGFjY2VzcyBzeW50YXgnKTtcbiAgICB9XG4gIH07IC8vIGFsbG93cyBhIGNvcmUgaW5zdGFuY2UgdG8gYWNjZXNzIGV4dGVuc2lvbnMgaW50ZXJuYWxseVxuXG5cbiAgQ29yZS5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uOyAvLyBpbmNsdWRlZCBleHRlbnNpb25zXG5cbiAgaW5jRXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLmV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gICAgICBzZXRFeHRlbnNpb24oZ3JvdXAudHlwZSwgZXh0Lm5hbWUsIGV4dC5pbXBsKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gKHVzZWZ1bCBmb3IgaW5pdClcblxuICB2YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlc2hlZXQpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0eWxlc2hlZXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuICBzaGVldGZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnc3R5bGVzaGVldCc7XG4gIH07IC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbiAgc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzW2ldID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgcHJvcGVydGllczogW11cbiAgICB9O1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9OyAvLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcblxuXG4gIHNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgdmFyIG1hcCA9IG5hbWU7XG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BOYW1lc1tqXTtcbiAgICAgICAgdmFyIG1hcFZhbCA9IG1hcFtrZXldO1xuXG4gICAgICAgIGlmIChtYXBWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3AgPSBTdHlsZS5wcm9wZXJ0aWVzW2tleV0gfHwgU3R5bGUucHJvcGVydGllc1tkYXNoMmNhbWVsKGtleSldO1xuXG4gICAgICAgIGlmIChwcm9wID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IF9uYW1lLFxuICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzOyAvLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcblxuICBzaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoY3kpIHtcbiAgICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoY3kpO1xuICAgIHJldHVybiB0aGlzLmFwcGVuZFRvU3R5bGUoc3R5bGUpO1xuICB9OyAvLyBhcHBlbmQgYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCBvbiBhIHJlYWwgc3R5bGUgb2JqZWN0XG5cblxuICBzaGVldGZuLmFwcGVuZFRvU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpc1tpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgc3R5bGUuY3NzKHByb3AubmFtZSwgcHJvcC52YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIHZhciB2ZXJzaW9uID0gXCIzLjI0LjBcIjtcblxuICB2YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24gY3l0b3NjYXBlKG9wdGlvbnMpIHtcbiAgICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSAvLyBjcmVhdGUgaW5zdGFuY2VcblxuXG4gICAgaWYgKHBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IENvcmUob3B0aW9ucyk7XG4gICAgfSAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgICBlbHNlIGlmIChzdHJpbmcob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTsgLy8gZS5nLiBjeXRvc2NhcGUudXNlKCByZXF1aXJlKCdjeXRvc2NhcGUtZm9vJyksIGJhciApXG5cblxuICBjeXRvc2NhcGUudXNlID0gZnVuY3Rpb24gKGV4dCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJncyB0byBwYXNzIHRvIGV4dFxuXG4gICAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgICBleHQuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgY3l0b3NjYXBlLndhcm5pbmdzID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICByZXR1cm4gd2FybmluZ3MoYm9vbCk7XG4gIH07IC8vIHJlcGxhY2VkIGJ5IGJ1aWxkIHN5c3RlbVxuXG5cbiAgY3l0b3NjYXBlLnZlcnNpb24gPSB2ZXJzaW9uOyAvLyBleHBvc2UgcHVibGljIGFwaXMgKG1vc3RseSBmb3IgZXh0ZW5zaW9ucylcblxuICBjeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxuICByZXR1cm4gY3l0b3NjYXBlO1xuXG59KSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImN5dG9zY2FwZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2RlZmluZVByb3BlcnR5JDEiLCJ2YWx1ZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIkFycmF5IiwiaXNBcnJheSIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwiY2FsbCIsIm5leHQiLCJkb25lIiwicHVzaCIsImVyciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIndpbmRvdyQxIiwid2luZG93IiwibmF2aWdhdG9yIiwiZG9jdW1lbnQiLCJ0eXBlb2ZzdHIiLCJ0eXBlb2ZvYmoiLCJ0eXBlb2ZmbiIsInR5cGVvZmh0bWxlbGUiLCJIVE1MRWxlbWVudCIsImluc3RhbmNlU3RyIiwiaW5zdGFuY2VTdHJpbmciLCJmbiQ2Iiwic3RyaW5nIiwiZm4iLCJhcnJheSIsImVsZW1lbnRPckNvbGxlY3Rpb24iLCJwbGFpbk9iamVjdCIsIm9iamVjdCIsIm51bWJlciQxIiwibnVtYmVyIiwiaXNOYU4iLCJpbnRlZ2VyIiwiTWF0aCIsImZsb29yIiwiaHRtbEVsZW1lbnQiLCJ1bmRlZmluZWQiLCJlbGVtZW50IiwiY29sbGVjdGlvbiIsIl9wcml2YXRlIiwic2luZ2xlIiwiY29yZSIsInN0eWxlc2hlZXQiLCJldmVudCIsImVtcHR5U3RyaW5nIiwibWF0Y2giLCJkb21FbGVtZW50IiwiYm91bmRpbmdCb3giLCJ4MSIsIngyIiwieTEiLCJ5MiIsInByb21pc2UiLCJ0aGVuIiwibXMiLCJ1c2VyQWdlbnQiLCJtZW1vaXplJDEiLCJtZW1vaXplIiwia2V5Rm4iLCJhcmd1bWVudHMiLCJhcmdzIiwiam9pbiIsIm1lbW9pemVkRm4iLCJyZXQiLCJrIiwiYXBwbHkiLCJjYWNoZSIsImNhbWVsMmRhc2giLCJzdHIiLCJyZXBsYWNlIiwidiIsInRvTG93ZXJDYXNlIiwiZGFzaDJjYW1lbCIsInRvVXBwZXJDYXNlIiwicHJlcGVuZENhbWVsIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInJnYmEiLCJyZ2JhTm9CYWNrUmVmcyIsImhzbGEiLCJoc2xhTm9CYWNrUmVmcyIsImhleDMiLCJoZXg2IiwiYXNjZW5kaW5nIiwiYSIsImIiLCJkZXNjZW5kaW5nIiwiZXh0ZW5kIiwiYXNzaWduIiwiYmluZCIsInRndCIsImtleXMiLCJqIiwiaGV4MnR1cGxlIiwiaGV4Iiwic2hvcnRIZXgiLCJyIiwiZyIsImJhc2UiLCJwYXJzZUludCIsImhzbDJ0dXBsZSIsImhzbCIsImgiLCJzIiwibCIsImh1ZTJyZ2IiLCJwIiwicSIsInQiLCJtIiwiUmVnRXhwIiwiZXhlYyIsInBhcnNlRmxvYXQiLCJyb3VuZCIsInJnYjJ0dXBsZSIsInJnYiIsImlzUGN0IiwiY2hhbm5lbCIsImF0TGVhc3RPbmVJc1BjdCIsImFsbEFyZVBjdCIsImFscGhhIiwiY29sb3JuYW1lMnR1cGxlIiwiY29sb3IiLCJjb2xvcnMiLCJjb2xvcjJ0dXBsZSIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JleSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsInNldE1hcCIsIm9wdGlvbnMiLCJtYXAiLCJFcnJvciIsImdldE1hcCIsImlzT2JqZWN0IiwidHlwZSIsImlzT2JqZWN0XzEiLCJjb21tb25qc0dsb2JhbCIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZnJlZUdsb2JhbCIsIl9mcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJfcm9vdCIsIm5vdyIsIkRhdGUiLCJub3dfMSIsInJlV2hpdGVzcGFjZSIsInRyaW1tZWRFbmRJbmRleCIsImluZGV4IiwiX3RyaW1tZWRFbmRJbmRleCIsInJlVHJpbVN0YXJ0IiwiYmFzZVRyaW0iLCJfYmFzZVRyaW0iLCJTeW1ib2wkMSIsIl9TeW1ib2wiLCJvYmplY3RQcm90byQ1IiwiaGFzT3duUHJvcGVydHkkNCIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmckMSIsInN5bVRvU3RyaW5nVGFnJDEiLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJlIiwicmVzdWx0IiwiX2dldFJhd1RhZyIsIm9iamVjdFByb3RvJDQiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdFRvU3RyaW5nIiwiX29iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsIl9iYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwiaXNPYmplY3RMaWtlXzEiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsImlzU3ltYm9sXzEiLCJOQU4iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsInRvTnVtYmVyIiwib3RoZXIiLCJ2YWx1ZU9mIiwiaXNCaW5hcnkiLCJ0b051bWJlcl8xIiwiRlVOQ19FUlJPUl9URVhUJDEiLCJuYXRpdmVNYXgiLCJtYXgiLCJuYXRpdmVNaW4iLCJtaW4iLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJpbnZva2VGdW5jIiwidGltZSIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInNldFRpbWVvdXQiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWJvdW5jZV8xIiwicGVyZm9ybWFuY2UiLCJwbm93IiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwZXJmb3JtYW5jZU5vdyIsIkRFRkFVTFRfSEFTSF9TRUVEIiwiSyIsIkRFRkFVTFRfSEFTSF9TRUVEX0FMVCIsImhhc2hJdGVyYWJsZUludHMiLCJzZWVkIiwiaGFzaCIsImVudHJ5IiwiaGFzaEludCIsIm51bSIsImhhc2hJbnRBbHQiLCJjb21iaW5lSGFzaGVzIiwiaGFzaDEiLCJoYXNoMiIsImNvbWJpbmVIYXNoZXNBcnJheSIsImhhc2hlcyIsImhhc2hBcnJheXMiLCJoYXNoZXMxIiwiaGFzaGVzMiIsImhhc2hJbnRzQXJyYXkiLCJpbnRzIiwiaGFzaFN0cmluZyIsImNoYXJDb2RlQXQiLCJoYXNoU3RyaW5ncyIsImhhc2hTdHJpbmdzQXJyYXkiLCJzdHJzIiwid2FybmluZ3NFbmFibGVkIiwid2FyblN1cHBvcnRlZCIsImNvbnNvbGUiLCJ3YXJuIiwidHJhY2VTdXBwb3J0ZWQiLCJ0cmFjZSIsIk1BWF9JTlQkMSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ0cnVlaWZ5IiwiZmFsc2lmeSIsInplcm9pZnkiLCJub29wJDEiLCJub29wIiwiZXJyb3IiLCJtc2ciLCJ3YXJuaW5ncyIsImVuYWJsZWQiLCJsb2ciLCJjbG9uZSIsImNvcHkiLCJjb3B5QXJyYXkkMSIsImNvcHlBcnJheSIsInV1aWQiLCJyYW5kb20iLCJfc3RhdGljRW1wdHlPYmplY3QiLCJzdGF0aWNFbXB0eU9iamVjdCIsImRlZmF1bHRzJGciLCJkZWZhdWx0cyIsIl9kZWZhdWx0cyIsIm9wdHMiLCJmaWxsZWRPcHRzIiwib3B0VmFsIiwicmVtb3ZlRnJvbUFycmF5IiwiZWxlIiwib25lQ29weSIsInNwbGljZSIsImNsZWFyQXJyYXkiLCJvdGhlckFyciIsImVsIiwiZ2V0UHJlZml4ZWRQcm9wZXJ0eSIsInByb3BOYW1lIiwic2V0UHJlZml4ZWRQcm9wZXJ0eSIsIk9iamVjdE1hcCIsIl9vYmoiLCJzZXQiLCJ2YWwiLCJfZGVsZXRlIiwiY2xlYXIiLCJoYXMiLCJnZXQiLCJNYXAkMiIsIk1hcCIsInVuZGVmIiwiT2JqZWN0U2V0IiwiYXJyYXlPck9iamVjdFNldCIsImNyZWF0ZSIsInNpemUiLCJ0b0FycmF5IiwiYWRkIiwiX3RoaXMiLCJmaWx0ZXIiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJTZXQkMSIsIlNldCIsIkVsZW1lbnQiLCJjeSIsInBhcmFtcyIsInJlc3RvcmUiLCJncm91cCIsImRhdGEiLCJzb3VyY2UiLCJfcCIsInBvc2l0aW9uIiwieCIsInkiLCJhdXRvV2lkdGgiLCJhdXRvSGVpZ2h0IiwiYXV0b1BhZGRpbmciLCJjb21wb3VuZEJvdW5kc0NsZWFuIiwibGlzdGVuZXJzIiwic3R5bGUiLCJyc3R5bGUiLCJzdHlsZUN4dHMiLCJzdHlsZUtleXMiLCJyZW1vdmVkIiwic2VsZWN0ZWQiLCJzZWxlY3RhYmxlIiwibG9ja2VkIiwiZ3JhYmJlZCIsImdyYWJiYWJsZSIsInBhbm5hYmxlIiwiYWN0aXZlIiwiY2xhc3NlcyIsImFuaW1hdGlvbiIsImN1cnJlbnQiLCJxdWV1ZSIsInJzY3JhdGNoIiwic2NyYXRjaCIsImVkZ2VzIiwiY2hpbGRyZW4iLCJwYXJlbnQiLCJpc05vZGUiLCJ0cmF2ZXJzYWxDYWNoZSIsImJhY2tncm91bmRpbmciLCJiYkNhY2hlIiwiYmJDYWNoZVNoaWZ0IiwiYm9keUJvdW5kcyIsIm92ZXJsYXlCb3VuZHMiLCJsYWJlbEJvdW5kcyIsImFsbCIsIm1haW4iLCJhcnJvd0JvdW5kcyIsInJlbmRlcmVkUG9zaXRpb24iLCJycG9zIiwicGFuIiwiem9vbSIsInNwbGl0IiwiY2xzIiwiY3JlYXRlRW1pdHRlciIsImJ5cGFzcyIsImNzcyIsImRlZmluZVNlYXJjaCIsImJmcyIsImRmcyIsInNlYXJjaEZuIiwicm9vdHMiLCJkaXJlY3RlZCIsInZpc2l0IiwiUSIsImNvbm5lY3RlZE5vZGVzIiwiY29ubmVjdGVkQnkiLCJpZDJkZXB0aCIsIlYiLCJmb3VuZCIsIl90aGlzJGJ5R3JvdXAiLCJieUdyb3VwIiwibm9kZXMiLCJ2aSIsInZpSWQiLCJpZCIsInVuc2hpZnQiLCJfbG9vcCIsInNoaWZ0IiwicG9wIiwidklkIiwiZGVwdGgiLCJwcmV2RWRnZSIsInNyYyIsInByZXZOb2RlIiwic2FtZSIsInZ3RWRnZXMiLCJjb25uZWN0ZWRFZGdlcyIsIl9pMiIsInciLCJ3SWQiLCJfcmV0IiwiY29ubmVjdGVkRWxlcyIsIm5vZGUiLCJlZGdlIiwicGF0aCIsImVsZXNmbiR2IiwiYnJlYWR0aEZpcnN0U2VhcmNoIiwiZGVwdGhGaXJzdFNlYXJjaCIsImhlYXAkMSIsIkhlYXAiLCJkZWZhdWx0Q21wIiwiaGVhcGlmeSIsImhlYXBwb3AiLCJoZWFwcHVzaCIsImhlYXBwdXNocG9wIiwiaGVhcHJlcGxhY2UiLCJpbnNvcnQiLCJubGFyZ2VzdCIsIm5zbWFsbGVzdCIsInVwZGF0ZUl0ZW0iLCJfc2lmdGRvd24iLCJfc2lmdHVwIiwibG8iLCJoaSIsImNtcCIsIm1pZCIsImNvbmNhdCIsIml0ZW0iLCJsYXN0ZWx0IiwicmV0dXJuaXRlbSIsIl9yZWYiLCJfbGVuIiwiX3JlZjEiLCJfcmVzdWx0cyIsIl9yZXN1bHRzMSIsIl9qIiwicmV2ZXJzZSIsInBvcyIsImluZGV4T2YiLCJlbGVtIiwic29ydCIsImxvcyIsInN0YXJ0cG9zIiwibmV3aXRlbSIsInBhcmVudHBvcyIsImNoaWxkcG9zIiwiZW5kcG9zIiwicmlnaHRwb3MiLCJwdXNocG9wIiwicGVlayIsImNvbnRhaW5zIiwiZW1wdHkiLCJoZWFwIiwiaW5zZXJ0IiwidG9wIiwiZnJvbnQiLCJkaWprc3RyYURlZmF1bHRzIiwid2VpZ2h0IiwiZWxlc2ZuJHUiLCJkaWprc3RyYSIsIl9kaWprc3RyYURlZmF1bHRzIiwiZWxlcyIsIndlaWdodEZuIiwiZGlzdCIsInByZXYiLCJrbm93bkRpc3QiLCJ1bm1lcmdlQnkiLCJpc0xvb3AiLCJnZXREaXN0Iiwic2V0RGlzdCIsImQiLCJJbmZpbml0eSIsImRpc3RCZXR3ZWVuIiwidSIsInV2cyIsImVkZ2VzVG8iLCJlZGdlc1dpdGgiLCJpbnRlcnNlY3QiLCJzbWFsbGVzdERpc3RhbmNlIiwic21hbGxlc3RFZGdlIiwiX3dlaWdodCIsInNtYWxsZXRzRGlzdCIsInVpZCIsIm5laWdoYm9ycyIsIm5laWdoYm9yaG9vZCIsInZpZCIsInZEaXN0IiwiYWx0IiwiZGlzdGFuY2VUbyIsInBhdGhUbyIsIlMiLCJzcGF3biIsImVsZXNmbiR0Iiwia3J1c2thbCIsIm51bU5vZGVzIiwiZm9yZXN0IiwiQSIsImZpbmRTZXRJbmRleCIsInNldFVJbmRleCIsInNldFZJbmRleCIsInNldFUiLCJzZXRWIiwibWVyZ2UiLCJhU3RhckRlZmF1bHRzIiwiZ29hbCIsImhldXJpc3RpYyIsImVsZXNmbiRzIiwiYVN0YXIiLCJfYVN0YXJEZWZhdWx0cyIsInNpZCIsInRpZCIsImdTY29yZSIsImZTY29yZSIsImNsb3NlZFNldElkcyIsIm9wZW5TZXQiLCJvcGVuU2V0SWRzIiwiY2FtZUZyb20iLCJjYW1lRnJvbUVkZ2UiLCJhZGRUb09wZW5TZXQiLCJjTWluIiwiY01pbklkIiwicG9wRnJvbU9wZW5TZXQiLCJpc0luT3BlblNldCIsInN0ZXBzIiwicGF0aE5vZGUiLCJwYXRoTm9kZUlkIiwicGF0aEVkZ2UiLCJkaXN0YW5jZSIsImhhc0VsZW1lbnRXaXRoSWQiLCJ3U3JjIiwid1RndCIsIndpZCIsInRlbXBTY29yZSIsImZsb3lkV2Fyc2hhbGxEZWZhdWx0cyIsImVsZXNmbiRyIiwiZmxveWRXYXJzaGFsbCIsIl9mbG95ZFdhcnNoYWxsRGVmYXVsdCIsIk4iLCJOc3EiLCJhdEluZGV4IiwiZWRnZU5leHQiLCJzdCIsInRzIiwiaWsiLCJpaiIsImtqIiwiZ2V0QXJnRWxlIiwiaW5kZXhPZkFyZ0VsZSIsInJlcyIsInRvIiwiZnJvbU5vZGUiLCJiZWxsbWFuRm9yZERlZmF1bHRzIiwiZWxlc2ZuJHEiLCJiZWxsbWFuRm9yZCIsIl9iZWxsbWFuRm9yZERlZmF1bHRzIiwiaW5mb01hcCIsImhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUiLCJuZWdhdGl2ZVdlaWdodEN5Y2xlcyIsIm51bUVkZ2VzIiwiZ2V0SW5mbyIsImdldE5vZGVGcm9tVG8iLCIkIiwidGhpc1N0YXJ0IiwiZW5kIiwiX2dldEluZm8iLCJwcmVkIiwiaW5mbyIsInJlcGxhY2VkRWRnZSIsImNoZWNrRm9yRWRnZVJlcGxhY2VtZW50Iiwibm9kZTEiLCJub2RlMiIsImluZm8xIiwiaW5mbzIiLCJzcmNJbmZvIiwidGd0SW5mbyIsIm5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMiLCJfZWRnZSIsIl9zcmMiLCJfdGd0IiwiX3dlaWdodDIiLCJzcmNEaXN0IiwidGd0RGlzdCIsImZpbmROZWdhdGl2ZVdlaWdodEN5Y2xlcyIsIm5lZ2F0aXZlTm9kZXMiLCJudW1OZWdhdGl2ZU5vZGVzIiwic3RhcnQiLCJjeWNsZSIsIl9ub2RlIiwic21hbGxlc3RJZCIsInNtYWxsZXN0SW5kZXgiLCJjIiwiY3ljbGVJZCIsInNxcnQyIiwic3FydCIsImNvbGxhcHNlIiwiZWRnZUluZGV4Iiwibm9kZU1hcCIsInJlbWFpbmluZ0VkZ2VzIiwiZWRnZUluZm8iLCJzb3VyY2VJbiIsInRhcmdldEluIiwicGFydGl0aW9uMSIsInBhcnRpdGlvbjIiLCJuZXdFZGdlcyIsImNvbnRyYWN0VW50aWwiLCJtZXRhTm9kZU1hcCIsInNpemVMaW1pdCIsImVsZXNmbiRwIiwia2FyZ2VyU3RlaW4iLCJudW1JdGVyIiwiY2VpbCIsInBvdyIsIkxOMiIsInN0b3BTaXplIiwiZWRnZUluZGV4ZXMiLCJtaW5DdXRTaXplIiwibWluQ3V0RWRnZUluZGV4ZXMiLCJtaW5DdXROb2RlTWFwIiwibWV0YU5vZGVNYXAyIiwiY29weU5vZGVzTWFwIiwiX2kzIiwiaXRlciIsIl9pNCIsImVkZ2VzU3RhdGUiLCJlZGdlc1N0YXRlMiIsInJlczEiLCJyZXMyIiwiY3V0Iiwid2l0bmVzc05vZGVQYXJ0aXRpb24iLCJfaTUiLCJwYXJ0aXRpb25JZCIsImNvbnN0cnVjdENvbXBvbmVudCIsInN1YnNldCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJjb3B5UG9zaXRpb24iLCJtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiIsInJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uIiwiYXJyYXkycG9pbnQiLCJiZWdpbiIsImlzRmluaXRlIiwibWVhbiIsInRvdGFsIiwibWVkaWFuIiwiaW5jbHVkZUhvbGVzIiwib2ZmIiwiZGVnMnJhZCIsImRlZyIsIlBJIiwiZ2V0QW5nbGVGcm9tRGlzcCIsImRpc3BYIiwiZGlzcFkiLCJhdGFuMiIsImxvZzIiLCJzaWdudW0iLCJwMSIsInAyIiwic3FkaXN0IiwiZHgiLCJkeSIsImluUGxhY2VTdW1Ob3JtYWxpemUiLCJxYmV6aWVyQXQiLCJwMCIsInFiZXppZXJQdEF0IiwibGluZUF0IiwidmVjIiwidmVjRGlzdCIsIm5vcm1WZWMiLCJib3VuZCIsIm1ha2VCb3VuZGluZ0JveCIsImJiIiwiY29weUJvdW5kaW5nQm94IiwiY2xlYXJCb3VuZGluZ0JveCIsInVwZGF0ZUJvdW5kaW5nQm94IiwiYmIxIiwiYmIyIiwiZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50IiwiZXhwYW5kQm91bmRpbmdCb3giLCJwYWRkaW5nIiwiZXhwYW5kQm91bmRpbmdCb3hTaWRlcyIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIl9wYWRkaW5nIiwiYXNzaWduQm91bmRpbmdCb3giLCJib3VuZGluZ0JveGVzSW50ZXJzZWN0IiwiaW5Cb3VuZGluZ0JveCIsInBvaW50SW5Cb3VuZGluZ0JveCIsInB0IiwiYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94Iiwicm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lIiwibm9kZVgiLCJub2RlWSIsIndpZHRoIiwiaGVpZ2h0IiwiY29ybmVyUmFkaXVzIiwiZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMiLCJoYWxmV2lkdGgiLCJoYWxmSGVpZ2h0Iiwic3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyIsInRvcFN0YXJ0WCIsInRvcFN0YXJ0WSIsInRvcEVuZFgiLCJ0b3BFbmRZIiwiZmluaXRlTGluZXNJbnRlcnNlY3QiLCJyaWdodFN0YXJ0WCIsInJpZ2h0U3RhcnRZIiwicmlnaHRFbmRYIiwicmlnaHRFbmRZIiwiYm90dG9tU3RhcnRYIiwiYm90dG9tU3RhcnRZIiwiYm90dG9tRW5kWCIsImJvdHRvbUVuZFkiLCJsZWZ0U3RhcnRYIiwibGVmdFN0YXJ0WSIsImxlZnRFbmRYIiwibGVmdEVuZFkiLCJhcmNJbnRlcnNlY3Rpb25zIiwidG9wTGVmdENlbnRlclgiLCJ0b3BMZWZ0Q2VudGVyWSIsImludGVyc2VjdExpbmVDaXJjbGUiLCJ0b3BSaWdodENlbnRlclgiLCJ0b3BSaWdodENlbnRlclkiLCJib3R0b21SaWdodENlbnRlclgiLCJib3R0b21SaWdodENlbnRlclkiLCJib3R0b21MZWZ0Q2VudGVyWCIsImJvdHRvbUxlZnRDZW50ZXJZIiwiaW5MaW5lVmljaW5pdHkiLCJseDEiLCJseTEiLCJseDIiLCJseTIiLCJ0b2xlcmFuY2UiLCJpbkJlemllclZpY2luaXR5IiwieDMiLCJ5MyIsInNvbHZlUXVhZHJhdGljIiwic3FydFIiLCJkZW5vbSIsInJvb3QxIiwicm9vdDIiLCJzb2x2ZUN1YmljIiwiZXBzaWxvbiIsImRpc2NyaW1pbmFudCIsImR1bTEiLCJ0ZXJtMSIsInIxMyIsImFjb3MiLCJjb3MiLCJzcWRpc3RUb1F1YWRyYXRpY0JlemllciIsInplcm9UaHJlc2hvbGQiLCJhYnMiLCJtaW5EaXN0YW5jZVNxdWFyZWQiLCJjdXJYIiwiY3VyWSIsImRpc3RTcXVhcmVkIiwic3FkaXN0VG9GaW5pdGVMaW5lIiwib2Zmc2V0IiwibGluZSIsImxpbmVTcSIsImh5cFNxIiwiZG90UHJvZHVjdCIsImFkalNxIiwicG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzIiwicG9pbnRzIiwidXAiLCJwb2ludEluc2lkZVBvbHlnb24iLCJiYXNlUG9pbnRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJkaXJlY3Rpb24iLCJ0cmFuc2Zvcm1lZFBvaW50cyIsImFuZ2xlIiwiYXRhbiIsInNpbiIsImV4cGFuZGVkTGluZVNldCIsImV4cGFuZFBvbHlnb24iLCJqb2luTGluZXMiLCJwb2ludEluc2lkZVJvdW5kUG9seWdvbiIsImN1dFBvbHlnb25Qb2ludHMiLCJoYWxmVyIsImhhbGZIIiwiZ2V0Um91bmRQb2x5Z29uUmFkaXVzIiwic3F1YXJlZENvcm5lclJhZGl1cyIsInNvdXJjZVV2IiwiZGVzdFV2IiwicHgiLCJweSIsImNvc1RoZXRhIiwiY3AweCIsImNwMHkiLCJjcDF4IiwiY3AxeSIsIm9ydGh4Iiwib3J0aHkiLCJjb3NBbHBoYSIsImN4Iiwic3F1YXJlZERpc3RhbmNlIiwibGluZVNldCIsInZlcnRpY2VzIiwiY3VycmVudExpbmVTdGFydFgiLCJjdXJyZW50TGluZVN0YXJ0WSIsImN1cnJlbnRMaW5lRW5kWCIsImN1cnJlbnRMaW5lRW5kWSIsIm5leHRMaW5lU3RhcnRYIiwibmV4dExpbmVTdGFydFkiLCJuZXh0TGluZUVuZFgiLCJuZXh0TGluZUVuZFkiLCJpbnRlcnNlY3Rpb24iLCJwYWQiLCJjdXJyZW50UG9pbnRYIiwiY3VycmVudFBvaW50WSIsIm5leHRQb2ludFgiLCJuZXh0UG9pbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJvZmZzZXRMZW5ndGgiLCJub3JtYWxpemVkT2Zmc2V0WCIsIm5vcm1hbGl6ZWRPZmZzZXRZIiwiaW50ZXJzZWN0TGluZUVsbGlwc2UiLCJlbGxpcHNlV3JhZGl1cyIsImVsbGlwc2VIcmFkaXVzIiwibmV3TGVuZ3RoIiwibGVuUHJvcG9ydGlvbiIsImNoZWNrSW5FbGxpcHNlIiwicmFkaXVzIiwiZiIsInQxIiwidDIiLCJ0TWluIiwidE1heCIsImluUmFuZ2VQYXJhbXMiLCJuZWFySW50ZXJzZWN0aW9uWCIsIm5lYXJJbnRlcnNlY3Rpb25ZIiwiZmFySW50ZXJzZWN0aW9uWCIsImZhckludGVyc2VjdGlvblkiLCJtaWRPZlRocmVlIiwieDQiLCJ5NCIsImluZmluaXRlTGluZXMiLCJkeDEzIiwiZHgyMSIsImR4NDMiLCJkeTEzIiwiZHkyMSIsImR5NDMiLCJ1YV90IiwidWJfdCIsInVfYiIsInVhIiwidWIiLCJmbHB0VGhyZXNob2xkIiwiX21pbiIsIl9tYXgiLCJwb2x5Z29uSW50ZXJzZWN0TGluZSIsImludGVyc2VjdGlvbnMiLCJkb1RyYW5zZm9ybSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJuZXh0WCIsIm5leHRZIiwicm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSIsImxpbmVzIiwibG93ZXN0SW50ZXJzZWN0aW9uIiwibG93ZXN0U3F1YXJlZERpc3RhbmNlIiwic2hvcnRlbkludGVyc2VjdGlvbiIsImFtb3VudCIsImRpc3AiLCJsZW5SYXRpbyIsImdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSIsInNpZGVzIiwicm90YXRpb25SYWRpYW5zIiwiZ2VuZXJhdGVVbml0TmdvblBvaW50cyIsImZpdFBvbHlnb25Ub1NxdWFyZSIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJzeCIsInN5IiwiX2k2IiwiaW5jcmVtZW50Iiwic3RhcnRBbmdsZSIsImN1cnJlbnRBbmdsZSIsImdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCIsImJlemllclB0c1RvUXVhZENvZWZmIiwiZ2V0QmFycmVsQ3VydmVDb25zdGFudHMiLCJoZWlnaHRPZmZzZXQiLCJ3aWR0aE9mZnNldCIsImN0cmxQdE9mZnNldFBjdCIsInBhZ2VSYW5rRGVmYXVsdHMiLCJkYW1waW5nRmFjdG9yIiwicHJlY2lzaW9uIiwiaXRlcmF0aW9ucyIsImVsZXNmbiRvIiwicGFnZVJhbmsiLCJfcGFnZVJhbmtEZWZhdWx0cyIsIm51bU5vZGVzU3FkIiwibWF0cml4IiwiY29sdW1uU3VtIiwiYWRkaXRpb25hbFByb2IiLCJzcmNJZCIsInRndElkIiwiaW5kZXhPZklkIiwiX24yIiwiX24zIiwiZWlnZW52ZWN0b3IiLCJ0ZW1wIiwicHJldmlvdXMiLCJfajIiLCJfbjQiLCJkaWZmIiwiX2k3IiwiZGVsdGEiLCJyYW5rIiwiZGVmYXVsdHMkZiIsImVsZXNmbiRuIiwiZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQiLCJkZWdyZWVzIiwibWF4RGVncmVlIiwiY3VyckRlZ3JlZSIsImRlZ3JlZUNlbnRyYWxpdHkiLCJkZWdyZWUiLCJpbmRlZ3JlZXMiLCJvdXRkZWdyZWVzIiwibWF4SW5kZWdyZWUiLCJtYXhPdXRkZWdyZWUiLCJfY3VyckRlZ3JlZSIsImluZGVncmVlIiwib3V0ZGVncmVlIiwiY2FsbGluZ0VsZXMiLCJfb3B0aW9ucyIsImNvbm5FZGdlcyIsImluY29taW5nIiwib3V0Z29pbmciLCJrX2luIiwia19vdXQiLCJzX2luIiwic19vdXQiLCJkYyIsImRjbiIsImRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkIiwiZGVmYXVsdHMkZSIsImhhcm1vbmljIiwiZWxlc2ZuJG0iLCJjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZCIsImNsb3NlbmVzc2VzIiwibWF4Q2xvc2VuZXNzIiwiZnciLCJjdXJyQ2xvc2VuZXNzIiwibm9kZV9pIiwiY2xvc2VuZXNzIiwiY2xvc2VuZXNzQ2VudHJhbGl0eSIsIl9kZWZhdWx0czIiLCJ0b3RhbERpc3RhbmNlIiwiY2MiLCJjY24iLCJjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCIsImRlZmF1bHRzJGQiLCJlbGVzZm4kbCIsImJldHdlZW5uZXNzQ2VudHJhbGl0eSIsIndlaWdodGVkIiwiX0MiLCJDIiwib3V0Z29lcnMiLCJvcGVuTmVpZ2hib3Job29kIiwiUCIsIl92aWQiLCJfdiIsInZFbGUiLCJnZXRFbGVtZW50QnlJZCIsImVkZ2VXZWlnaHQiLCJfdyIsIl93MiIsIl92MiIsImJldHdlZW5uZXNzIiwiYmV0d2Vlbm5lc3NOb3JtYWxpemVkIiwiYmV0d2Vlbm5lc3NOb3JtYWxpc2VkIiwiYmMiLCJkZWZhdWx0cyRjIiwiZXhwYW5kRmFjdG9yIiwiaW5mbGF0ZUZhY3RvciIsIm11bHRGYWN0b3IiLCJtYXhJdGVyYXRpb25zIiwiYXR0cmlidXRlcyIsInNldE9wdGlvbnMkMyIsInNldE9wdGlvbnMiLCJnZXRTaW1pbGFyaXR5JDEiLCJnZXRTaW1pbGFyaXR5IiwiYWRkTG9vcHMiLCJNIiwibm9ybWFsaXplIiwic3VtIiwiY29sIiwicm93IiwiX3JvdyIsIm1tdWx0IiwiQiIsImV4cGFuZCIsIl9NIiwiaW5mbGF0ZSIsImhhc0NvbnZlcmdlZCIsIm4yIiwicm91bmRGYWN0b3IiLCJ2MSIsInYyIiwiYXNzaWduJDIiLCJjbHVzdGVycyIsImNsdXN0ZXIiLCJpc0R1cGxpY2F0ZSIsImMxIiwiYzIiLCJyZW1vdmVEdXBsaWNhdGVzIiwibWFya292Q2x1c3RlcmluZyIsImlkMnBvc2l0aW9uIiwic2ltIiwiaXNTdGlsbE1vdmluZyIsIm1hcmtvdkNsdXN0ZXJpbmckMSIsIm1jbCIsImlkZW50aXR5IiwiYWJzRGlmZiIsImFkZEFic0RpZmYiLCJhZGRTcXVhcmVkRGlmZiIsIm1heEFic0RpZmYiLCJjdXJyZW50TWF4IiwiZ2V0RGlzdGFuY2UiLCJnZXRQIiwiZ2V0USIsImluaXQiLCJwb3N0IiwiZGltIiwiZGlzdGFuY2VzIiwiZXVjbGlkZWFuIiwic3F1YXJlZEV1Y2xpZGVhbiIsIm1hbmhhdHRhbiIsImNsdXN0ZXJpbmdEaXN0YW5jZSIsIm1ldGhvZCIsIm5vZGVQIiwibm9kZVEiLCJpbXBsIiwiZGVmYXVsdHMkYiIsInNlbnNpdGl2aXR5VGhyZXNob2xkIiwidGVzdE1vZGUiLCJ0ZXN0Q2VudHJvaWRzIiwic2V0T3B0aW9ucyQyIiwiY2VudHJvaWQiLCJtb2RlIiwibm9Ob2RlUCIsInJhbmRvbUNlbnRyb2lkcyIsIm5kaW0iLCJjZW50cm9pZHMiLCJjbGFzc2lmeSIsImJ1aWxkQ2x1c3RlciIsImFzc2lnbm1lbnQiLCJoYXZlVmFsdWVzQ29udmVyZ2VkIiwiaGF2ZU1hdHJpY2VzQ29udmVyZ2VkIiwic2VlbkJlZm9yZSIsIm1lZG9pZHMiLCJyYW5kb21NZWRvaWRzIiwiZmluZENvc3QiLCJwb3RlbnRpYWxOZXdNZWRvaWQiLCJjb3N0Iiwia01lYW5zIiwibmV3Q2VudHJvaWQiLCJrTWVkb2lkcyIsImN1ckNvc3QiLCJtaW5Db3N0cyIsInVwZGF0ZUNlbnRyb2lkcyIsIlUiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIl9jIiwidXBkYXRlTWVtYmVyc2hpcCIsIl9VIiwiYXNzaWduJDEiLCJfYzIiLCJfYzMiLCJmdXp6eUNNZWFucyIsImRlZ3JlZU9mTWVtYmVyc2hpcCIsImtDbHVzdGVyaW5nIiwiZmNtIiwiZGVmYXVsdHMkYSIsImxpbmthZ2UiLCJ0aHJlc2hvbGQiLCJhZGREZW5kcm9ncmFtIiwiZGVuZHJvZ3JhbURlcHRoIiwibGlua2FnZUFsaWFzZXMiLCJzZXRPcHRpb25zJDEiLCJwcmVmZXJyZWRBbGlhcyIsIm1lcmdlQ2xvc2VzdCIsImRpc3RzIiwibWlucyIsIm1pbktleSIsImF0dHJzIiwibjEiLCJfZGlzdCIsIm1lcmdlZCIsImN1ciIsImtleTEiLCJrZXkyIiwiZ2V0QWxsQ2hpbGRyZW4iLCJidWlsZERlbmRyb2dyYW0iLCJsZWZ0U3RyIiwicmlnaHRTdHIiLCJidWlsZENsdXN0ZXJzRnJvbVRyZWUiLCJsZWF2ZXMiLCJoaWVyYXJjaGljYWxDbHVzdGVyaW5nIiwicmV0Q2x1c3RlcnMiLCJoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEiLCJoY2EiLCJkZWZhdWx0cyQ5IiwicHJlZmVyZW5jZSIsImRhbXBpbmciLCJtaW5JdGVyYXRpb25zIiwiZG1wIiwicHJlZiIsInZhbGlkUHJlZnMiLCJzb21lIiwiYXR0ciIsImdldFByZWZlcmVuY2UiLCJmaW5kRXhlbXBsYXJzIiwiUiIsImluZGljZXMiLCJhc3NpZ25DbHVzdGVycyIsImV4ZW1wbGFycyIsImVpIiwiX2VpIiwiaWkiLCJtYXhJIiwibWF4U3VtIiwiYWZmaW5pdHlQcm9wYWdhdGlvbiIsIm9sZCIsIlJwIiwic2UiLCJfaTgiLCJtYXgyIiwiQVMiLCJfaTkiLCJfajMiLCJfajQiLCJfaTEwIiwiRSIsIl9zdW0iLCJfaTExIiwiX2o1IiwiZXhlbXBsYXJzSW5kaWNlcyIsImNsdXN0ZXJJbmRpY2VzIiwiX2kxMiIsImNsdXN0ZXJJbmRleCIsImFmZmluaXR5UHJvcGFnYXRpb24kMSIsImFwIiwiaGllcmhvbHplckRlZmF1bHRzIiwiZWxlc2ZuJGsiLCJoaWVyaG9semVyIiwiX2hpZXJob2x6ZXJEZWZhdWx0cyIsImRmbGFnIiwib2RkSW4iLCJvZGRPdXQiLCJzdGFydFZlcnRleCIsImluZCIsIm91dGQiLCJkMSIsImQyIiwiaXNFZGdlIiwidHJhaWwiLCJ3YWxrIiwiY3VycmVudE5vZGUiLCJzdWJ0b3VyIiwiYWRqIiwiYWRqVGFpbCIsImFkakhlYWQiLCJob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkIiwiZWRnZUNvdW50Iiwic3RhY2siLCJ2aXNpdGVkRWRnZXMiLCJidWlsZENvbXBvbmVudCIsImN1dHNldCIsIm5vZGVJZCIsImN1dFZlcnRleCIsImJpY29ubmVjdGVkU2VhcmNoIiwibG93Iiwic291cmNlSWQiLCJ0YXJnZXRJZCIsIm90aGVyTm9kZUlkIiwiZWRnZUlkIiwiY3V0VmVydGljZXMiLCJob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEiLCJodGJjIiwiaHRiIiwiaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZENvbXBvbmVudHMiLCJ0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCIsInN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoIiwic291cmNlTm9kZUlkIiwiZXhwbG9yZWQiLCJ0YXJnZXROb2RlSWQiLCJjb21wb25lbnROb2RlcyIsImNvbXBvbmVudEVkZ2VzIiwiZGlmZmVyZW5jZSIsInRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDEiLCJ0c2MiLCJ0c2NjIiwidGFyamFuU3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzIiwiZWxlc2ZuJGoiLCJTVEFURV9QRU5ESU5HIiwiU1RBVEVfRlVMRklMTEVEIiwiU1RBVEVfUkVKRUNURUQiLCJhcGkiLCJleGVjdXRvciIsInN0YXRlIiwiZnVsZmlsbFZhbHVlIiwicmVqZWN0UmVhc29uIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwicHJveHkiLCJmdWxmaWxsIiwicmVqZWN0IiwiZGVsaXZlciIsImN1cnIiLCJyZXNvbHZlciIsImV4ZWN1dGUiLCJleGVjdXRlX2hhbmRsZXJzIiwiaGFuZGxlcnMiLCJzZXRJbW1lZGlhdGUiLCJjYiIsInJlc29sdmUiLCJyZXNvbHZlZCIsInBzIiwicmVzb2x2ZUFsbCIsInJlamVjdEFsbCIsInZhbHMiLCJkb25lQ291bnQiLCJpc1Byb21pc2UiLCJQcm9taXNlJDEiLCJQcm9taXNlIiwiQW5pbWF0aW9uIiwib3B0czIiLCJpc0NvcmUiLCJpc0VsZSIsImR1cmF0aW9uIiwic3RhcnRlZCIsInBsYXlpbmciLCJob29rZWQiLCJhcHBseWluZyIsInByb2dyZXNzIiwiY29tcGxldGVzIiwiZnJhbWVzIiwiY29tcGxldGUiLCJzdGFydFBvc2l0aW9uIiwic3RhcnRTdHlsZSIsImdldEFuaW1hdGlvblN0YXJ0U3R5bGUiLCJzdGFydFBhbiIsInN0YXJ0Wm9vbSIsImFuaWZuIiwiaG9vayIsInRBbmkiLCJhZGRUb0FuaW1hdGlvblBvb2wiLCJwbGF5Iiwic3RvcHBlZCIsInBhdXNlIiwic3RvcCIsInJld2luZCIsImZhc3Rmb3J3YXJkIiwid2FzUGxheWluZyIsImNvbXBsZXRlZCIsInN3YXAiLCJfcGEiLCJwcm9wIiwic3RhcnRTdHlsZVByb3AiLCJydW4iLCJydW5uaW5nIiwiZGVmaW5lJDMiLCJhbmltYXRlZCIsImFuaW1hdGVkSW1wbCIsInNlbGZJc0FycmF5TGlrZSIsInN0eWxlRW5hYmxlZCIsImNsZWFyUXVldWUiLCJjbGVhclF1ZXVlSW1wbCIsImRlbGF5IiwiZGVsYXlJbXBsIiwiYW5pbWF0ZSIsImRlbGF5QW5pbWF0aW9uIiwiZGVsYXlBbmltYXRpb25JbXBsIiwiYW5pbWF0aW9uSW1wbCIsInByb3BlcnRpZXMiLCJpc0VsZXMiLCJwcm9wZXJ0aWVzRW1wdHkiLCJnZXRQcm9wc0xpc3QiLCJwYW5CeSIsImN5UGFuIiwiY2VudGVyIiwiY2VudHJlIiwiY2VudGVyUGFuIiwiZ2V0Q2VudGVyUGFuIiwiZml0IiwiZml0VnAiLCJnZXRGaXRWaWV3cG9ydCIsInZwIiwiZ2V0Wm9vbWVkVmlld3BvcnQiLCJ6b29tZWQiLCJwYW5uZWQiLCJhbmltYXRlSW1wbCIsImFuaSIsInN0b3BJbXBsIiwianVtcFRvRW5kIiwiYW5pcyIsImFuaV9wIiwibm90aWZ5IiwiaXNBcnJheV8xIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiX2lzS2V5IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiaXNGdW5jdGlvbl8xIiwiY29yZUpzRGF0YSIsIl9jb3JlSnNEYXRhIiwibWFza1NyY0tleSIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJfaXNNYXNrZWQiLCJmdW5jUHJvdG8kMSIsImZ1bmNUb1N0cmluZyQxIiwidG9Tb3VyY2UiLCJfdG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byQzIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkkMyIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwiX2Jhc2VJc05hdGl2ZSIsImdldFZhbHVlJDEiLCJfZ2V0VmFsdWUiLCJnZXROYXRpdmUiLCJfZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiX25hdGl2ZUNyZWF0ZSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiX2hhc2hDbGVhciIsImhhc2hEZWxldGUiLCJfaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEJDEiLCJvYmplY3RQcm90byQyIiwiaGFzT3duUHJvcGVydHkkMiIsImhhc2hHZXQiLCJfaGFzaEdldCIsIm9iamVjdFByb3RvJDEiLCJoYXNPd25Qcm9wZXJ0eSQxIiwiaGFzaEhhcyIsIl9oYXNoSGFzIiwiSEFTSF9VTkRFRklORUQiLCJoYXNoU2V0IiwiX2hhc2hTZXQiLCJIYXNoIiwiZW50cmllcyIsIl9IYXNoIiwibGlzdENhY2hlQ2xlYXIiLCJfbGlzdENhY2hlQ2xlYXIiLCJlcSIsImVxXzEiLCJhc3NvY0luZGV4T2YiLCJfYXNzb2NJbmRleE9mIiwiYXJyYXlQcm90byIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsIl9saXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJfbGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwiX2xpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIl9saXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJfTGlzdENhY2hlIiwiTWFwJDEiLCJfTWFwIiwibWFwQ2FjaGVDbGVhciIsIl9tYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiX2lzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfZ2V0TWFwRGF0YSIsIm1hcENhY2hlRGVsZXRlIiwiX21hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJfbWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIl9tYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiX21hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJfTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplZCIsIkNhY2hlIiwibWVtb2l6ZV8xIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJfbWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiX2FycmF5TWFwIiwiSU5GSU5JVFkkMSIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJfYmFzZVRvU3RyaW5nIiwidG9TdHJpbmckMSIsInRvU3RyaW5nXzEiLCJjYXN0UGF0aCIsIl9jYXN0UGF0aCIsIklORklOSVRZIiwidG9LZXkiLCJfdG9LZXkiLCJiYXNlR2V0IiwiX2Jhc2VHZXQiLCJkZWZhdWx0VmFsdWUiLCJnZXRfMSIsIl9kZWZpbmVQcm9wZXJ0eSIsImJhc2VBc3NpZ25WYWx1ZSIsIl9iYXNlQXNzaWduVmFsdWUiLCJvYmplY3RQcm90byIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJfYXNzaWduVmFsdWUiLCJyZUlzVWludCIsImlzSW5kZXgiLCJfaXNJbmRleCIsImJhc2VTZXQiLCJjdXN0b21pemVyIiwibmVzdGVkIiwibmV3VmFsdWUiLCJfYmFzZVNldCIsInNldF8xIiwiX2NvcHlBcnJheSIsInRvUGF0aCIsInRvUGF0aF8xIiwiZGVmaW5lJDIiLCJmaWVsZCIsImJpbmRpbmdFdmVudCIsImFsbG93QmluZGluZyIsImFsbG93U2V0dGluZyIsImFsbG93R2V0dGluZyIsInNldHRpbmdFdmVudCIsInNldHRpbmdUcmlnZ2Vyc0V2ZW50IiwidHJpZ2dlckZuTmFtZSIsImltbXV0YWJsZUtleXMiLCJ1cGRhdGVTdHlsZSIsImJlZm9yZUdldCIsImJlZm9yZVNldCIsIm9uU2V0IiwiY2FuU2V0IiwiZGF0YUltcGwiLCJpc1BhdGhMaWtlIiwidmFsaWQiLCJjaGFuZ2UiLCJfdmFsaWQiLCJfZWxlIiwib24iLCJyZW1vdmVEYXRhIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlRGF0YUltcGwiLCJuYW1lcyIsImlfYSIsImxfYSIsIl9pX2EiLCJfbF9hIiwiX3ByaXZhdGVGaWVsZHMiLCJfa2V5cyIsIl9rZXkiLCJ2YWxpZEtleVRvRGVsZXRlIiwiZGVmaW5lJDEiLCJldmVudEFsaWFzZXNPbiIsInByb3RvIiwiYWRkTGlzdGVuZXIiLCJsaXN0ZW4iLCJ1bmxpc3RlbiIsInVuYmluZCIsInJlbW92ZUxpc3RlbmVyIiwidHJpZ2dlciIsImVtaXQiLCJwb24iLCJwcm9taXNlT24iLCJldmVudHMiLCJzZWxlY3RvciIsIm9mZkFyZ3MiLCJvbkFyZ3MiLCJlbGVzZm4kaSIsImVsZXNmbiRoIiwiX2NsYXNzZXMiLCJjaGFuZ2VkIiwiY2xhc3Nlc1NldCIsImVsZUNsYXNzZXMiLCJjaGFuZ2VkRWxlIiwiZWxlSGFzQ2xhc3MiLCJhZGRDbGFzcyIsInRvZ2dsZUNsYXNzIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJ0b2dnbGUiLCJ0b2dnbGVVbmRlZmQiLCJpbCIsImNoYW5nZWROb3ciLCJyZW1vdmVDbGFzcyIsImZsYXNoQ2xhc3MiLCJjbGFzc05hbWVzIiwidG9rZW5zIiwibWV0YUNoYXIiLCJjb21wYXJhdG9yT3AiLCJib29sT3AiLCJtZXRhIiwic2VwYXJhdG9yIiwiZGVzY2VuZGFudCIsImNoaWxkIiwic3ViamVjdCIsImRpcmVjdGVkRWRnZSIsInVuZGlyZWN0ZWRFZGdlIiwidmFyaWFibGUiLCJvcHMiLCJvcCIsIm5ld1F1ZXJ5IiwiY2hlY2tzIiwiVHlwZSIsIkdST1VQIiwiQ09MTEVDVElPTiIsIkZJTFRFUiIsIkRBVEFfQ09NUEFSRSIsIkRBVEFfRVhJU1QiLCJEQVRBX0JPT0wiLCJNRVRBX0NPTVBBUkUiLCJTVEFURSIsIklEIiwiQ0xBU1MiLCJVTkRJUkVDVEVEX0VER0UiLCJESVJFQ1RFRF9FREdFIiwiTk9ERV9TT1VSQ0UiLCJOT0RFX1RBUkdFVCIsIk5PREVfTkVJR0hCT1IiLCJDSElMRCIsIkRFU0NFTkRBTlQiLCJQQVJFTlQiLCJBTkNFU1RPUiIsIkNPTVBPVU5EX1NQTElUIiwiVFJVRSIsInN0YXRlU2VsZWN0b3JzIiwibWF0Y2hlcyIsInZpc2libGUiLCJpc1BhcmVudCIsImlzQ2hpbGRsZXNzIiwiaXNDaGlsZCIsImlzT3JwaGFuIiwiaXNTaW1wbGUiLCJsb29rdXAiLCJzZWxUb0ZuIiwic3RhdGVTZWxlY3Rvck1hdGNoZXMiLCJzZWwiLCJzdGF0ZVNlbGVjdG9yUmVnZXgiLCJjbGVhbk1ldGFDaGFycyIsIiQxIiwicmVwbGFjZUxhc3RRdWVyeSIsImV4YW1pbmluZ1F1ZXJ5IiwicmVwbGFjZW1lbnRRdWVyeSIsImV4cHJzIiwicXVlcnkiLCJyZWdleCIsInBvcHVsYXRlIiwiX3JlZjIiLCJfcmVmMyIsIl9yZWY0IiwiX3JlZjUiLCJfcmVmNiIsIl9yZWY3IiwiX3JlZjgiLCJfcmVmOSIsIl9yZWYxMCIsIl9yZWYxMSIsIl9yZWYxMiIsInZhbHVlSXNTdHJpbmciLCJvcGVyYXRvciIsIl9yZWYxMyIsIl9yZWYxNCIsIl9yZWYxNSIsIl9yZWYxNiIsImN1cnJlbnRTdWJqZWN0IiwiY29tcG91bmRDb3VudCIsImxhc3RRIiwibmV4dFF1ZXJ5IiwiZWRnZVF1ZXJ5Iiwic3JjVGd0USIsIl9zb3VyY2UiLCJfdGFyZ2V0Iiwibmhvb2RRIiwibmVpZ2hib3IiLCJwYXJlbnRDaGlsZFF1ZXJ5IiwiY29tcG91bmQiLCJfY2hpbGQiLCJfcGFyZW50IiwiX3BhcmVudDIiLCJfY2hpbGQyIiwicGNRQ2hlY2tzIiwiYW5jQ2hRdWVyeSIsImFuY2VzdG9yIiwiX2Rlc2NlbmRhbnQiLCJfYW5jZXN0b3IiLCJfYW5jZXN0b3IyIiwiX2Rlc2NlbmRhbnQyIiwiYWRRQ2hlY2tzIiwibW9kaWZpZXIiLCJ0b3BRIiwidG9wQ2hrIiwidG9wVHlwZSIsInJlZ2V4T2JqIiwiY29uc3VtZUV4cHIiLCJyZW1haW5pbmciLCJleHByIiwiY29uc3VtZWQiLCJjb25zdW1lV2hpdGVzcGFjZSIsInBhcnNlIiwiaW5wdXRUZXh0IiwiY3VycmVudFF1ZXJ5IiwiZXhwckluZm8iLCJ0b1N0cmluZ0NhY2hlIiwiY2xlYW4iLCJjbGVhblZhbCIsInNwYWNlIiwiY2hlY2tUb1N0cmluZyIsImNoZWNrIiwiX29wZXJhdG9yIiwiX2ZpZWxkIiwiX2ZpZWxkMiIsIl9vcGVyYXRvcjIiLCJfZmllbGQzIiwicXVlcnlUb1N0cmluZyIsImxocyIsInN1YiIsInJocyIsInJlZHVjZSIsImNoayIsInBhcnNlJDEiLCJ2YWxDbXAiLCJmaWVsZFZhbCIsImlzRmllbGRTdHIiLCJpc0ZpZWxkTnVtIiwiaXNWYWxTdHIiLCJmaWVsZFN0ciIsInZhbFN0ciIsImNhc2VJbnNlbnNpdGl2ZSIsIm5vdEV4cHIiLCJpc0luZXFDbXAiLCJib29sQ21wIiwiZXhpc3RDbXAiLCJkYXRhJDEiLCJtYXRjaGVzJDEiLCJldmVyeSIsInN0YXRlU2VsZWN0b3IiLCJxQSIsInFCIiwiaW5jb21lcnMiLCJhbmNlc3RvcnMiLCJkZXNjZW5kYW50cyIsInNlbGVjdG9yRnVuY3Rpb24iLCJ0ZXh0IiwibWF0Y2hpbmciLCJTZWxlY3RvciIsImFkZFF1ZXJ5IiwiaW52YWxpZCIsInNlbGZuIiwic2FtZVRleHQiLCJvdGhlclNlbCIsImVsZXNmbiRnIiwiYWxsQXJlIiwic2VsT2JqIiwiaXMiLCJ0aGlzTGVuZ3RoIiwiY29sbGVjdGlvbkxlbmd0aCIsImFueVNhbWUiLCJhbGxBcmVOZWlnaGJvcnMiLCJuaG9vZCIsImFsbEFyZU5laWdoYm91cnMiLCJlcXVhbCIsImVxdWFscyIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJzZWxlY3Rvck9yRWxlcyIsInRjaCIsImNoIiwiY2FjaGVIaXQiLCJlbGVzZm4kZiIsInBhcmVudHMiLCJub25lbXB0eSIsImNvbW1vbkFuY2VzdG9ycyIsIm9ycGhhbnMiLCJzdGRGaWx0ZXIiLCJub25vcnBoYW5zIiwiZWxlQ2hpbGRyZW4iLCJzaWJsaW5ncyIsIm5vdCIsImVsZW1lbnRzIiwiZm9yRWFjaENvbXBvdW5kIiwiaW5jbHVkZVNlbGYiLCJyZWN1cnNpdmVTdGVwIiwiZGlkIiwiaGFzQ29tcG91bmRzIiwiaGFzQ29tcG91bmROb2RlcyIsImFkZENoaWxkcmVuIiwiZm9yRWFjaERvd24iLCJhZGRQYXJlbnQiLCJmb3JFYWNoVXAiLCJhZGRQYXJlbnRBbmRDaGlsZHJlbiIsImZvckVhY2hVcEFuZERvd24iLCJmbiQ1IiwiZWxlc2ZuJGUiLCJyZW1vdmVTY3JhdGNoIiwicmVtb3ZlUnNjcmF0Y2giLCJyZW1vdmVBdHRyIiwiZWxlc2ZuJGQiLCJkZWZpbmVEZWdyZWVGdW5jdGlvbiIsImluY2x1ZGVMb29wcyIsImRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uIiwiZGVncmVlRm4iLCJtaW5EZWdyZWUiLCJtaW5JbmRlZ3JlZSIsIm1pbk91dGRlZ3JlZSIsInRvdGFsRGVncmVlIiwiZm4kNCIsImVsZXNmbiRjIiwiYmVmb3JlUG9zaXRpb25TZXQiLCJuZXdQb3MiLCJzaWxlbnQiLCJvbGRQb3MiLCJkaXJ0eUJvdW5kaW5nQm94Q2FjaGUiLCJwb3NpdGlvbkRlZiIsInZhbGlkS2V5cyIsInVwZGF0ZUNvbXBvdW5kQm91bmRzIiwiZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlIiwic2lsZW50UG9zaXRpb24iLCJwb3NpdGlvbnMiLCJfZm4iLCJzdGFydEJhdGNoIiwiX3BvcyIsImVuZEJhdGNoIiwic2lsZW50UG9zaXRpb25zIiwic2lsZW50U2hpZnQiLCJzZXR0aW5nIiwicmVsYXRpdmVQb3NpdGlvbiIsInBwb3MiLCJfZWxlMiIsImhhc1BhcmVudCIsInJlbGF0aXZlVG9QYXJlbnQiLCJvcmlnaW4iLCJfaGFzUGFyZW50IiwiX3JlbGF0aXZlVG9QYXJlbnQiLCJfb3JpZ2luIiwibW9kZWxQb3NpdGlvbiIsInBvaW50IiwibW9kZWxQb3NpdGlvbnMiLCJyZW5kZXJlZFBvaW50IiwicmVsYXRpdmVQb2ludCIsImZuJDMiLCJlbGVzZm4kYiIsInJlbmRlcmVkQm91bmRpbmdCb3giLCJlbWl0QW5kTm90aWZ5IiwiZm9yY2UiLCJiYXRjaGluZyIsInVwZGF0ZSIsImluY2x1ZGVMYWJlbHMiLCJwc3R5bGUiLCJwZlZhbHVlIiwiaW5jbHVkZU92ZXJsYXlzIiwidXNlQ2FjaGUiLCJjb21wdXRlQmlhc1ZhbHVlcyIsInByb3BEaWZmIiwicHJvcEJpYXMiLCJwcm9wQmlhc0NvbXBsZW1lbnQiLCJiaWFzRGlmZiIsImJpYXNDb21wbGVtZW50RGlmZiIsImJpYXNUb3RhbCIsImNvbXB1dGVQYWRkaW5nVmFsdWVzIiwicGFkZGluZ09iamVjdCIsInJlbGF0aXZlVG8iLCJ1bml0cyIsImxlZnRWYWwiLCJyaWdodFZhbCIsInRvcFZhbCIsImJvdHRvbVZhbCIsIndpZHRoQmlhc0RpZmZzIiwiZGlmZkxlZnQiLCJkaWZmUmlnaHQiLCJoZWlnaHRCaWFzRGlmZnMiLCJkaWZmVG9wIiwiZGlmZkJvdHRvbSIsIm5vbmluZiIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUJvdW5kc0Zyb21Cb3giLCJiMiIsInByZWZpeGVkUHJvcGVydHkiLCJ1cGRhdGVCb3VuZHNGcm9tQXJyb3ciLCJib3VuZHMiLCJoZWFkbGVzcyIsImhhbGZBclciLCJhcnJvd1dpZHRoIiwiYXJyb3dUeXBlIiwic3JjWCIsInNyY1kiLCJ0Z3RYIiwidGd0WSIsIm1pZFgiLCJtaWRZIiwiYmJzIiwidXBkYXRlQm91bmRzRnJvbUxhYmVsIiwicHJlZml4RGFzaCIsImxhYmVsIiwic3RyVmFsdWUiLCJoYWxpZ24iLCJ2YWxpZ24iLCJsYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJsYWJlbFgiLCJsYWJlbFkiLCJtYXJnaW5YIiwibWFyZ2luWSIsInJvdGF0aW9uIiwib3V0bGluZVdpZHRoIiwiYm9yZGVyV2lkdGgiLCJoYWxmQm9yZGVyV2lkdGgiLCJtYXJnaW5PZkVycm9yIiwibGgiLCJsdyIsImx3XzIiLCJsaF8yIiwiYmJQcmVmaXgiLCJpc0F1dG9yb3RhdGUiLCJpc1BmVmFsdWUiLCJ0aGV0YSIsInhvIiwieW8iLCJyb3RhdGUiLCJweDF5MSIsInB4MXkyIiwicHgyeTEiLCJweDJ5MiIsImJiUHJlZml4Um90IiwiYmJSb3QiLCJib3VuZGluZ0JveEltcGwiLCJleDEiLCJleDIiLCJleTEiLCJleTIiLCJtYW51YWxFeHBhbnNpb24iLCJpc0Rpc3BsYXllZCIsImRpc3BsYXllZCIsIm92ZXJsYXlPcGFjaXR5Iiwib3ZlcmxheVBhZGRpbmciLCJ1bmRlcmxheU9wYWNpdHkiLCJ1bmRlcmxheVBhZGRpbmciLCJpbmNsdWRlVW5kZXJsYXlzIiwid0hhbGYiLCJpbmNsdWRlTm9kZXMiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJpbmNsdWRlRWRnZXMiLCJjdXJ2ZVN0eWxlIiwiaHB0cyIsImhheXN0YWNrUHRzIiwiX3RlbXAiLCJwdHMiLCJiZXppZXJQdHMiLCJsaW5lUHRzIiwibjFwb3MiLCJuMnBvcyIsIl90ZW1wMiIsIl90ZW1wMyIsImdob3N0IiwiZ3giLCJneSIsImJiQm9keSIsImJiT3ZlcmxheSIsImJiTGFiZWxzIiwiaW5jbHVkZU1haW5MYWJlbHMiLCJpbmNsdWRlU291cmNlTGFiZWxzIiwiaW5jbHVkZVRhcmdldExhYmVscyIsImdldEtleSIsInRmIiwiaW5jdWRlTm9kZXMiLCJnZXRCb3VuZGluZ0JveFBvc0tleSIsImNhY2hlZEJvdW5kaW5nQm94SW1wbCIsImRlZkJiT3B0c0tleSIsInVzaW5nRGVmT3B0cyIsImN1cnJQb3NLZXkiLCJpc1Bvc0tleVNhbWUiLCJiYkNhY2hlUG9zS2V5IiwiaXNEaXJ0eSIsInN0eWxlRGlydHkiLCJuZWVkUmVjYWxjIiwicmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlIiwiZGVmQmJPcHRzIiwibWFpblJvdCIsInNvdXJjZVJvdCIsInRhcmdldFJvdCIsImZpbGxlZEJiT3B0cyIsImJvdW5kaW5nQm94QXQiLCJzdG9yZU9sZFBvcyIsImJiQXRPbGRQb3MiLCJnZXRPbGRQb3MiLCJib3VuZGluZ2JveCIsInJlbmRlcmVkQm91bmRpbmdib3giLCJmbiQyIiwiZWxlc2ZuJGEiLCJkZWZpbmVEaW1GbnMiLCJ1cHBlcmNhc2VOYW1lIiwiYXV0b05hbWUiLCJsYWJlbE5hbWUiLCJvdXRlck5hbWUiLCJ1cHBlcmNhc2VPdXRlck5hbWUiLCJkaW1JbXBsIiwib3V0ZXJEaW1JbXBsIiwiYm9yZGVyIiwicmVuZGVyZWREaW1JbXBsIiwicmVuZGVyZWRPdXRlckRpbUltcGwiLCJvZCIsInBhZGRlZEhlaWdodCIsInBhZGRlZFdpZHRoIiwid2lkdGhIZWlnaHQiLCJpZkVkZ2UiLCJnZXRWYWx1ZSIsImlmRWRnZVJlbmRlcmVkUG9zaXRpb24iLCJnZXRQb2ludCIsImlmRWRnZVJlbmRlcmVkUG9zaXRpb25zIiwiZ2V0UG9pbnRzIiwiY29udHJvbFBvaW50cyIsInJlbmRlcmVyIiwiZ2V0Q29udHJvbFBvaW50cyIsInNlZ21lbnRQb2ludHMiLCJnZXRTZWdtZW50UG9pbnRzIiwic291cmNlRW5kcG9pbnQiLCJnZXRTb3VyY2VFbmRwb2ludCIsInRhcmdldEVuZHBvaW50IiwiZ2V0VGFyZ2V0RW5kcG9pbnQiLCJtaWRwb2ludCIsImdldEVkZ2VNaWRwb2ludCIsIm11bHQiLCJyZW5kZXJlZE5hbWUiLCJzdWJzdHIiLCJlZGdlUG9pbnRzIiwic3BlYyIsInJOYW1lIiwiZGltZW5zaW9ucyIsIkV2ZW50IiwicmVjeWNsZSIsInJldHVybkZhbHNlIiwicmV0dXJuVHJ1ZSIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJwcmV2ZW50RGVmYXVsdCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvcmlnaW5hbEV2ZW50IiwibmFtZXNwYWNlIiwibGF5b3V0IiwidGltZVN0YW1wIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiZXZlbnRSZWdleCIsInVuaXZlcnNhbE5hbWVzcGFjZSIsImRlZmF1bHRzJDgiLCJxdWFsaWZpZXJDb21wYXJlIiwicTEiLCJxMiIsImV2ZW50TWF0Y2hlcyIsImFkZEV2ZW50RmllbGRzIiwiY2FsbGJhY2tDb250ZXh0IiwiY29udGV4dCIsImJlZm9yZUVtaXQiLCJhZnRlckVtaXQiLCJidWJibGUiLCJkZWZhdWx0c0tleXMiLCJlbXB0eU9wdHMiLCJFbWl0dGVyIiwiZW1pdHRpbmciLCJmb3JFYWNoRXZlbnQiLCJoYW5kbGVyIiwicXVhbGlmaWVyIiwiY29uZiIsImNvbmZPdmVycmlkZXMiLCJldmVudExpc3QiLCJldnQiLCJtYWtlRXZlbnRPYmoiLCJmb3JFYWNoRXZlbnRPYmoiLCJldmVudE9iaiIsIm9uZSIsImxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZXh0cmFQYXJhbXMiLCJtYW51YWxDYWxsYmFjayIsIm51bUxpc3RlbmVyc0JlZm9yZUVtaXQiLCJfbG9vcDIiLCJlbWl0dGVyT3B0aW9ucyQxIiwic2VsZWN0b3IxIiwic2VsZWN0b3IyIiwib25jZSIsIm9uY2VDb2xsZWN0aW9uIiwiYXJnU2VsZWN0b3IkMSIsImFyZ1NlbGVjdG9yIiwiYXJnIiwiZWxlc2ZuJDkiLCJlbWl0dGVyIiwiYXJnU2VsIiwiZWxlc2ZuJDgiLCJfZmlsdGVyIiwiZmlsdGVyRWxlcyIsImluY2x1ZGUiLCJ0b1JlbW92ZSIsInJlbW92ZSIsImFic29sdXRlQ29tcGxlbWVudCIsIm11dGFibGVFbGVtZW50cyIsImNvbDEiLCJjb2wyIiwiY29sMVNtYWxsZXIiLCJjb2xTIiwiY29sTCIsInhvciIsImluT3RoZXIiLCJib3RoIiwicmV0RWxlcyIsInRvQWRkIiwic3Bhd25TZWxmIiwidG9BZGRFbGUiLCJ1bm1lcmdlQXQiLCJ1bm1lcmdlZExhc3RFbGUiLCJsYXN0RWxlSSIsImxhc3RFbGUiLCJsYXN0RWxlSWQiLCJ1bm1lcmdlT25lIiwidW5tZXJnZSIsInRvUm1GbiIsIm1hcEZuIiwiaW5pdGlhbFZhbHVlIiwidmFsRm4iLCJtYXhFbGUiLCJtaW5FbGUiLCJmbiQxIiwidW5pb24iLCJvciIsInJlbGF0aXZlQ29tcGxlbWVudCIsInN1YnRyYWN0IiwiYW5kIiwic3ltbWV0cmljRGlmZmVyZW5jZSIsInN5bWRpZmYiLCJmbkZpbHRlciIsImZpbHRlckZuIiwiY29tcGxlbWVudCIsImFic2NvbXAiLCJlbGVzZm4kNyIsInpJbmRleFNvcnQiLCJnZXREZXB0aCIsInpEZXB0aCIsImRlcHRoRGlmZiIsImdldEVsZURlcHRoIiwiZWxlRGlmZiIsInpEaWZmIiwicG9vbEluZGV4IiwiZWxlc2ZuJDYiLCJ0aGlzU2l6ZSIsImZpcnN0IiwibGFzdCIsInNvcnRGbiIsInNvcnRlZCIsInNvcnRCeVpJbmRleCIsInNyY0RlcHRoIiwidGd0RGVwdGgiLCJlYWNoIiwiZGVmaW5lU3ltYm9sSXRlcmF0b3IiLCJ0eXBlb2ZVbmRlZiIsImlzSXRlcmF0b3JTdXBwb3J0ZWQiLCJnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zIiwibm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzIiwiZWxlc2ZuJDUiLCJsYXlvdXREaW1lbnNpb25zIiwiZGltcyIsInRha2VzVXBTcGFjZSIsImJiRGltIiwibGF5b3V0UG9zaXRpb25zIiwibGF5b3V0RWxlcyIsImdldE1lbW9pemVLZXkiLCJmbk1lbSIsImFuaW1hdGlvbnMiLCJjYWxjdWxhdGVTcGFjaW5nIiwic3BhY2luZyIsIm5vZGVzQmIiLCJzcGFjaW5nVmVjdG9yIiwidXNlU3BhY2luZ0ZhY3RvciIsInNwYWNpbmdGYWN0b3IiLCJzcGFjaW5nQmIiLCJnZXRGaW5hbFBvcyIsInRyYW5zZm9ybSIsImFuaW1hdGVOb2RlIiwiYW5pbWF0ZUZpbHRlciIsImFuaW1hdGlvbkR1cmF0aW9uIiwiZWFzaW5nIiwiYW5pbWF0aW9uRWFzaW5nIiwiZml0QW5pIiwiem9vbVBhbkFuaSIsInJlYWR5IiwibWFrZUxheW91dCIsImNyZWF0ZUxheW91dCIsInN0eWxlQ2FjaGUiLCJjYWNoZVN0eWxlRnVuY3Rpb24iLCJjYWNoZWRTdHlsZUZ1bmN0aW9uIiwiY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uIiwic2VsZkZuIiwiY2FjaGVkUHJvdG90eXBlU3R5bGVGdW5jdGlvbiIsImVsZXNmbiQ0IiwiZGlydHlTdHlsZUNhY2hlIiwiZGlydHkiLCJub3RpZnlSZW5kZXJlciIsImJFbGVzIiwiYmF0Y2hTdHlsZUVsZXMiLCJ1cGRhdGVkRWxlcyIsImNoYW5nZWRFbGVzIiwiY2xlYW5TdHlsZSIsInBhcnNlZFN0eWxlIiwicHJvcGVydHkiLCJpbmNsdWRlTm9uRGVmYXVsdCIsIm92ZXJyaWRkZW5TdHlsZSIsImdldERlZmF1bHRQcm9wZXJ0eSIsIm51bWVyaWNTdHlsZSIsIm51bWVyaWNTdHlsZVVuaXRzIiwicmVuZGVyZWRTdHlsZSIsImdldFJlbmRlcmVkU3R5bGUiLCJ1cGRhdGVUcmFuc2l0aW9ucyIsImFwcGx5QnlwYXNzIiwiZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlIiwiZ2V0UmF3U3R5bGUiLCJyZW1vdmVTdHlsZSIsInJlbW92ZUFsbEJ5cGFzc2VzIiwicmVtb3ZlQnlwYXNzZXMiLCJzaG93IiwiaGlkZSIsImVmZmVjdGl2ZU9wYWNpdHkiLCJwYXJlbnRPcGFjaXR5Iiwib3BhY2l0eSIsImNoZWNrQ29tcG91bmQiLCJwYXJlbnRPayIsImRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uIiwic3BlY3MiLCJvayIsImVkZ2VPa1ZpYU5vZGUiLCJlbGVUYWtlc1VwU3BhY2UiLCJlbGVJbnRlcmFjdGl2ZSIsInBhcmVudEludGVyYWN0aXZlIiwiaW50ZXJhY3RpdmUiLCJub25pbnRlcmFjdGl2ZSIsImVsZVZpc2libGUiLCJlZGdlVmlzaWJsZVZpYU5vZGUiLCJoaWRkZW4iLCJpc0J1bmRsZWRCZXppZXIiLCJyZW5kZXJlZENzcyIsInJlbW92ZUJ5cGFzcyIsInJlbW92ZUNzcyIsImVsZXNmbiQzIiwiZGVmaW5lU3dpdGNoRnVuY3Rpb24iLCJfaGFuZGxlciIsImFkZGxFdmVudHMiLCJhYmxlIiwiYWJsZUZpZWxkIiwib3ZlcnJpZGVBYmxlIiwiY2hhbmdlZENvbGwiLCJkZWZpbmVTd2l0Y2hTZXQiLCJvdmVycmlkZUZpZWxkIiwiYXV0b2xvY2siLCJhdXRvdW5ncmFiaWZ5IiwiYXV0b3Vuc2VsZWN0aWZ5IiwiZGVzZWxlY3QiLCJ1bnNlbGVjdCIsImluYWN0aXZlIiwiZWxlc2ZuJDIiLCJkZWZpbmVEYWdFeHRyZW1pdHkiLCJkYWdFeHRyZW1pdHlJbXBsIiwiZGlzcXVhbGlmaWVkIiwibm9JbmNvbWluZ0VkZ2VzIiwibm9PdXRnb2luZ0VkZ2VzIiwiZGVmaW5lRGFnT25lSG9wIiwib0VsZXMiLCJkZWZpbmVEYWdBbGxIb3BzIiwic0VsZXMiLCJzRWxlc0lkcyIsIm5ld05leHQiLCJuaWQiLCJjbGVhclRyYXZlcnNhbENhY2hlIiwic3VjY2Vzc29ycyIsInByZWRlY2Vzc29ycyIsIm90aGVyTm9kZSIsImNsb3NlZE5laWdoYm9yaG9vZCIsIm5laWdoYm91cmhvb2QiLCJjbG9zZWROZWlnaGJvdXJob29kIiwib3Blbk5laWdoYm91cmhvb2QiLCJzb3VyY2VJbXBsIiwidGFyZ2V0SW1wbCIsInNvdXJjZXMiLCJkZWZpbmVTb3VyY2VGdW5jdGlvbiIsInRhcmdldHMiLCJkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiIsInRoaXNJc1NyYyIsImVkZ2VzV2l0aEltcGwiLCJvdGhlck5vZGVzIiwiZWRnZURhdGEiLCJ0aGlzVG9PdGhlciIsIm90aGVyVG9UaGlzIiwiZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyIiwidGhpc0lzVGd0IiwicGFyYWxsZWxFZGdlcyIsImRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbiIsImNvZGlyZWN0ZWRFZGdlcyIsImNvZGlyZWN0ZWQiLCJwYXJhbGxlbEVkZ2VzSW1wbCIsImVkZ2UxIiwiZWRnZTFfcCIsInNyYzEiLCJzcmNpZDEiLCJ0Z3RpZDEiLCJzcmNFZGdlczEiLCJlZGdlMiIsImVkZ2UyZGF0YSIsInRndGlkMiIsInNyY2lkMiIsIm9wcGRpcmVjdGVkIiwidmlzaXRlZCIsInVudmlzaXRlZCIsInZpc2l0SW5Db21wb25lbnQiLCJjbXB0IiwiY29tcG9uZW50c09mIiwiQ29sbGVjdGlvbiIsInVuaXF1ZSIsImNyZWF0ZWRFbGVtZW50cyIsImVsZXNJZHMiLCJqc29uIiwiX2RhdGEiLCJfbCIsImVsZW1lbnQkMSIsImxhenlNYXAiLCJyZWJ1aWxkTWFwIiwiZWxlc2ZuJDEiLCIkaWQiLCJfZGF0YTIiLCJtb3ZlIiwibmV3UGFyZW50VmFsU3BlY2QiLCJjaGVja1N3aXRjaCIsInRydWVGbk5hbWUiLCJmYWxzZUZuTmFtZSIsIm9ial9rIiwianNvbnMiLCJlbGVzQXJyIiwiYWRkVG9Qb29sIiwiY3lfcCIsInJlbW92ZUZyb21FbGVtZW50cyIsIl9kYXRhMyIsImZpZWxkcyIsImZpZWxkc0xlbmd0aCIsImJhZFNvdXJjZU9yVGFyZ2V0IiwiX2RhdGE0IiwicGFyZW50SWQiLCJzcGVjaWZpZWRQYXJlbnQiLCJzZWxmQXNQYXJlbnQiLCJyZXN0b3JlZCIsIl9lbGUzIiwidG9VcGRhdGVTdHlsZSIsImluc2lkZSIsInJlbW92ZUZyb21Qb29sIiwiZWxlc1RvUmVtb3ZlIiwiZWxlc1RvUmVtb3ZlSWRzIiwiYWRkQ29ubmVjdGVkRWRnZXMiLCJhbHJlYWR5QWRkZWQiLCJyZW1vdmVFZGdlUmVmIiwicmVtb3ZlUGFyYWxsZWxSZWYiLCJwbGxFZGdlIiwiYWx0ZXJlZFBhcmVudHMiLCJpZHMiLCJyZW1vdmVDaGlsZFJlZiIsInBpZCIsIl9lbGU0IiwicGxsRWRnZXMiLCJlbGVzU3RpbGxJbnNpZGUiLCJfZWxlNSIsInJlbW92ZWRFbGVtZW50cyIsIl9lbGU2Iiwic3RydWN0IiwibW9kaWZ5UG9vbCIsInNyY0V4aXN0cyIsInRndEV4aXN0cyIsImJhdGNoIiwiX2RhdGE1IiwicGFyZW50RXhpc3RzIiwicGlkVG9Bc3NpZ24iLCJ1cGRhdGVkIiwiX2RhdGE2IiwiY29yZWZuJDkiLCJfanNvbnMiLCJlbGVzQnlHcm91cCIsIl9qc29uczIiLCJncnMiLCJlbGVzQXJyYXkiLCJqbCIsIl9qc29uIiwiZ2VuZXJhdGVDdWJpY0JlemllciIsIm1YMSIsIm1ZMSIsIm1YMiIsIm1ZMiIsIk5FV1RPTl9JVEVSQVRJT05TIiwiTkVXVE9OX01JTl9TTE9QRSIsIlNVQkRJVklTSU9OX1BSRUNJU0lPTiIsIlNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImZsb2F0MzJBcnJheVN1cHBvcnRlZCIsIkZsb2F0MzJBcnJheSIsIm1TYW1wbGVWYWx1ZXMiLCJhQTEiLCJhQTIiLCJjYWxjQmV6aWVyIiwiYVQiLCJnZXRTbG9wZSIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYVgiLCJhR3Vlc3NUIiwiY3VycmVudFNsb3BlIiwiY2FsY1NhbXBsZVZhbHVlcyIsImJpbmFyeVN1YmRpdmlkZSIsImFBIiwiYUIiLCJjdXJyZW50VCIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwiX3ByZWNvbXB1dGVkIiwicHJlY29tcHV0ZSIsImdlbmVyYXRlU3ByaW5nUks0Iiwic3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUiLCJ0ZW5zaW9uIiwiZnJpY3Rpb24iLCJzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUiLCJpbml0aWFsU3RhdGUiLCJkdCIsImRlcml2YXRpdmUiLCJkdiIsInNwcmluZ0ludGVncmF0ZVN0YXRlIiwiZHhkdCIsImR2ZHQiLCJzcHJpbmdSSzRGYWN0b3J5IiwiaW5pdFN0YXRlIiwidGltZV9sYXBzZWQiLCJEVCIsImhhdmVfZHVyYXRpb24iLCJsYXN0X3N0YXRlIiwicGVyY2VudENvbXBsZXRlIiwiY3ViaWNCZXppZXIiLCJiZXppZXIiLCJwZXJjZW50IiwiZWFzaW5ncyIsImxpbmVhciIsInNwcmluZyIsImdldEVhc2VkVmFsdWUiLCJlYXNpbmdGbiIsInJvdW5kVmFsdWUiLCJlYXNlIiwic3RhcnRQcm9wIiwiZW5kUHJvcCIsInByb3BTcGVjIiwiZWFzZWRBcnIiLCJzaSIsInN0ZXAkMSIsInBFYXNpbmciLCJzdGFydFRpbWUiLCJlYXNpbmdJbXBsIiwiZWFzaW5nVmFscyIsImVhc2luZ1Byb3AiLCJzdGFydFBvcyIsImVuZFBvcyIsImVuZFBhbiIsImFuaW1hdGluZ1BhbiIsImVuZFpvb20iLCJhbmltYXRpbmdab29tIiwibWluWm9vbSIsIm1heFpvb20iLCJfbmFtZSIsImVhc2VkVmFsIiwib3ZlcnJpZGVCeXBhc3MiLCJzdGFydEFuaW1hdGlvbiIsInN0ZXBBbGwiLCJhbmlFbGVzIiwiZG9uZUVsZXMiLCJzdGVwT25lIiwicmFuQW5pcyIsImNhbGxiYWNrcyIsIl9jYWxsYmFja3MiLCJzdGVwIiwicmFuRWxlQW5pIiwiaGFuZGxlZFRoaXNFbGUiLCJyYW5Db3JlQW5pIiwiY29yZWZuJDgiLCJzdG9wQW5pbWF0aW9uTG9vcCIsImFuaW1hdGlvbnNSdW5uaW5nIiwic3RhcnRBbmltYXRpb25Mb29wIiwiaGVhZGxlc3NTdGVwIiwiYW5pbWF0aW9uU3RlcCIsImJlZm9yZVJlbmRlciIsInJlbmRlcmVyQW5pbWF0aW9uU3RlcCIsIndpbGxEcmF3IiwiYmVmb3JlUmVuZGVyUHJpb3JpdGllcyIsImVtaXR0ZXJPcHRpb25zIiwiZWxlc2ZuIiwiY29yZWZuJDciLCJwbmciLCJqcGciLCJiZyIsImpwZWciLCJjb3JlZm4kNiIsIkxheW91dCIsImV4dGVuc2lvbiIsImNvcmVmbiQ1IiwiZXZlbnROYW1lIiwiZXZlbnRFbGVzIiwiYmF0Y2hOb3RpZmljYXRpb25zIiwibm90aWZpY2F0aW9uc0VuYWJsZWQiLCJkZXN0cm95ZWQiLCJub3RpZmljYXRpb25zIiwiYm9vbCIsIm5vTm90aWZpY2F0aW9ucyIsImJhdGNoQ291bnQiLCJiYXRjaERhdGEiLCJyZW5kZXJlckRlZmF1bHRzIiwiaGlkZUVkZ2VzT25WaWV3cG9ydCIsInRleHR1cmVPblZpZXdwb3J0IiwibW90aW9uQmx1ciIsIm1vdGlvbkJsdXJPcGFjaXR5IiwicGl4ZWxSYXRpbyIsImRlc2t0b3BUYXBUaHJlc2hvbGQiLCJ0b3VjaFRhcFRocmVzaG9sZCIsIndoZWVsU2Vuc2l0aXZpdHkiLCJkZWJ1ZyIsInNob3dGcHMiLCJjb3JlZm4kNCIsInJlbmRlclRvIiwicHhSYXRpbyIsImZvcmNlUmVuZGVyIiwicmVzaXplIiwiaW52YWxpZGF0ZVNpemUiLCJpbml0UmVuZGVyZXIiLCJSZW5kZXJlclByb3RvIiwick9wdHMiLCJkZXN0cm95UmVuZGVyZXIiLCJkb21FbGUiLCJjb250YWluZXIiLCJfY3lyZWciLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJvblJlbmRlciIsIm9mZlJlbmRlciIsImludmFsaWRhdGVEaW1lbnNpb25zIiwiY29yZWZuJDMiLCJzdHlmbiQ4IiwiRkFMU0UiLCJpZSIsImN4dE1ldGEiLCJnZXRDb250ZXh0TWV0YSIsImN4dFN0eWxlIiwiZ2V0Q29udGV4dFN0eWxlIiwiYXBwIiwiYXBwbHlDb250ZXh0U3R5bGUiLCJhcHBsaWVkSW5pdFN0eWxlIiwiZGlmZlByb3BzIiwiaGludHNEaWZmIiwidXBkYXRlU3R5bGVIaW50cyIsImdldFByb3BlcnRpZXNEaWZmIiwib2xkQ3h0S2V5IiwibmV3Q3h0S2V5IiwicHJvcERpZmZzIiwiZHVhbEN4dEtleSIsImNhY2hlZFZhbCIsImFkZGVkUHJvcCIsImN4dCIsIm9sZEhhc0N4dCIsIm5ld0hhc0N4dCIsImN4dEhhc0RpZmZlZCIsImN4dEhhc01hcHBlZFByb3BzIiwibWFwcGVkUHJvcGVydGllcyIsImxhdGVyQ3h0T3ZlcnJpZGVzIiwibGF0ZXJDeHQiLCJoYXNMYXRlckN4dCIsImN4dEtleSIsInByZXZLZXkiLCJzdHlsZUN4dEtleSIsImNvbnRleHRTZWxlY3Rvck1hdGNoZXMiLCJkaWZmUHJvcE5hbWVzIiwiY3h0U3R5bGVzIiwiY29udGV4dFN0eWxlcyIsImhhc0N4dCIsInJldERpZmZQcm9wcyIsInR5cGVzIiwiZGlmZlByb3BOYW1lIiwiY3h0UHJvcCIsImVsZVByb3AiLCJkZWxldGVCeXBhc3NlZCIsIm1hcHBlZCIsIm1hcHBpbmciLCJmblZhbHVlIiwicHJldkZuVmFsdWUiLCJyZXREaWZmUHJvcCIsImFwcGx5UGFyc2VkUHJvcGVydHkiLCJieXBhc3NlZCIsInByb3BOYW1lcyIsInByb3BlcnR5R3JvdXBOYW1lcyIsInByb3BHcktleXMiLCJwcm9wZXJ0eUdyb3VwS2V5cyIsInByb3BIYXNoIiwic2VlZEtleSIsImdldFByb3BlcnRpZXNIYXNoIiwib2xkU3R5bGVLZXkiLCJzdHlsZUtleSIsIm92ZXJyaWRkZW5TdHlsZXMiLCJncktleSIsInVwZGF0ZUdyS2V5MSIsInVwZGF0ZUdyS2V5MiIsInVwZGF0ZUdyS2V5IiwidXBkYXRlR3JLZXlXU3RyIiwic3RyVmFsIiwiY2xlYW5OdW0iLCJwYXJzZWRQcm9wIiwicHJvcEluZm8iLCJfZ3JLZXkiLCJncm91cEtleSIsIm5vcm1hbGl6ZWROdW1iZXJWYWwiLCJoYXNoT3ZlcnJpZGUiLCJudW1iZXJWYWwiLCJlbnVtcyIsImhhdmVOb3JtTnVtIiwiaGF2ZVVuaXRlZE51bSIsImhhdmVOdW0iLCJtdWx0aXBsZSIsIl9ncktleTIiLCJnckhhc2giLCJzayIsImxhYmVsRGltc0tleSIsImxhYmVsRGltZW5zaW9ucyIsImxhYmVsS2V5cyIsImxhYmVsS2V5IiwibGFiZWxTdHlsZUtleSIsImNvbW1vbkxhYmVsIiwic291cmNlTGFiZWxLZXlzIiwic291cmNlTGFiZWxLZXkiLCJzb3VyY2VMYWJlbFN0eWxlS2V5IiwidGFyZ2V0TGFiZWxLZXlzIiwidGFyZ2V0TGFiZWxLZXkiLCJ0YXJnZXRMYWJlbFN0eWxlS2V5IiwiX3Akc3R5bGVLZXlzIiwibm9kZUJvZHkiLCJub2RlQm9yZGVyIiwiYmFja2dyb3VuZEltYWdlIiwicGllIiwibm9kZUtleXMiLCJub2RlS2V5IiwiaGFzUGllIiwiY2xlYXJTdHlsZUhpbnRzIiwiZmxhdFByb3AiLCJwcm9wSXNCeXBhc3MiLCJvcmlnUHJvcCIsIm9yaWdQcm9wSXNCeXBhc3MiLCJmbGF0UHJvcE1hcHBpbmciLCJnZXRWYWwiLCJjaGVja1RyaWdnZXJzIiwiZnJvbVZhbCIsInRvVmFsIiwiZGVsZXRlQnlwYXNzIiwicHJpbnRNYXBwaW5nRXJyIiwibWFwRGF0YSIsImZpZWxkV2lkdGgiLCJmaWVsZE1heCIsImZpZWxkTWluIiwicjEiLCJ2YWx1ZU1pbiIsInIyIiwidmFsdWVNYXgiLCJnMSIsImcyIiwiYjEiLCJhMSIsImEyIiwiY2xyIiwiY2FsY1ZhbHVlIiwiX2ZpZWxkcyIsIl9maWVsZFZhbCIsImZuUmV0VmFsIiwiY2xlYW5FbGVtZW50cyIsImtlZXBCeXBhc3NlcyIsImFueVByZXYiLCJzdHlQcm9wIiwiZGlmZlByb3AiLCJwcmV2UHJvcCIsImZyb21Qcm9wIiwidG9Qcm9wIiwiaW5pdFZhbCIsImluaXREdCIsInRyYW5zaXRpb25pbmciLCJjaGVja1RyaWdnZXIiLCJmcm9tVmFsdWUiLCJ0b1ZhbHVlIiwiZ2V0VHJpZ2dlciIsIm9uVHJpZ2dlciIsInRyaWdnZXJDaGVjayIsImNoZWNrWk9yZGVyVHJpZ2dlciIsInRyaWdnZXJzWk9yZGVyIiwiY2hlY2tCb3VuZHNUcmlnZ2VyIiwidHJpZ2dlcnNCb3VuZHMiLCJ0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzIiwic3R5Zm4kNyIsImlzQnlwYXNzIiwiX3BhcnNlZFByb3AiLCJzcGVjaWZpZWRQcm9wcyIsIl9uYW1lMiIsIl92YWx1ZSIsIl9wYXJzZWRQcm9wMiIsIl9wcm9wIiwiaXNDb2xvciIsImlzTXVsdGkiLCJtdXRpcGxlIiwib2xkVmFsdWUiLCJwcm9wZXJ0eU5hbWVzIiwic3R5Zm4kNiIsImdldEVtU2l6ZUluUGl4ZWxzIiwiY29udGFpbmVyQ3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJzdHlmbiQ1IiwiaXNSZW5kZXJlZFZhbCIsImdldEluZGV4ZWRTdHlsZSIsInN1YnByb3BlcnR5IiwiYWxpYXMiLCJwb2ludHNUbyIsInN0eWxlUHJvcCIsImdldFJlbmRlcmVkVmFsdWUiLCJnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyIsImlzQXJyYXlWYWx1ZSIsImhhdmVVbml0cyIsImFuaVByb3BzIiwiYW5pUHJvcCIsInByb3BzT2JqIiwiZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoIiwiY2hWYWwiLCJzdHlmbiQ0IiwiYXBwZW5kRnJvbUpzb24iLCJmcm9tSnNvbiIsInJlc2V0VG9EZWZhdWx0IiwiZGVmYXVsdExlbmd0aCIsInN0eWZuJDMiLCJhcHBlbmRGcm9tU3RyaW5nIiwic2VsQW5kQmxvY2tTdHIiLCJibG9ja1JlbSIsInByb3BBbmRWYWxTdHIiLCJyZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmciLCJyZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSIsIm5vdGhpbmdMZWZ0VG9QYXJzZSIsInNlbEFuZEJsb2NrIiwic2VsZWN0b3JTdHIiLCJibG9ja1N0ciIsImludmFsaWRCbG9jayIsIl9ub3RoaW5nTGVmdFRvUGFyc2UiLCJwcm9wQW5kVmFsIiwicHJvcFN0ciIsImZyb21TdHJpbmciLCJzdHlmbiQyIiwiaGV4MyQxIiwiaGV4NiQxIiwibWFwQXJnIiwidXJsUmVnZXhlcyIsImltcGxpY2l0VW5pdHMiLCJwZXJjZW50YWdlcyIsInplcm9PbmVOdW1iZXIiLCJ1bml0bGVzcyIsInplcm9PbmVOdW1iZXJzIiwibk9uZU9uZU51bWJlciIsIm5vbk5lZ2F0aXZlSW50Iiwibm9kZVNpemUiLCJudW1iZXJzIiwicG9zaXRpdmVOdW1iZXIiLCJzdHJpY3RNaW4iLCJiaWRpcmVjdGlvbmFsU2l6ZSIsImJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50IiwiYWxsb3dQZXJjZW50IiwiYmlkaXJlY3Rpb25hbFNpemVzIiwic2l6ZU1heWJlUGVyY2VudCIsImF4aXNEaXJlY3Rpb24iLCJwYWRkaW5nUmVsYXRpdmVUbyIsImJnV0giLCJiZ1BvcyIsImJnUmVsYXRpdmVUbyIsImJnUmVwZWF0IiwiYmdGaXQiLCJiZ0Nyb3NzT3JpZ2luIiwiYmdDbGlwIiwiYmdDb250YWlubWVudCIsImZpbGwiLCJib29scyIsImxpbmVTdHlsZSIsImxpbmVDYXAiLCJib3JkZXJTdHlsZSIsImZvbnRGYW1pbHkiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwidGV4dERlY29yYXRpb24iLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dFdyYXAiLCJ0ZXh0T3ZlcmZsb3dXcmFwIiwidGV4dEJhY2tncm91bmRTaGFwZSIsIm5vZGVTaGFwZSIsIm92ZXJsYXlTaGFwZSIsImNvbXBvdW5kSW5jbHVkZUxhYmVscyIsImFycm93U2hhcGUiLCJhcnJvd0ZpbGwiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsInpDb21wb3VuZERlcHRoIiwiekluZGV4Q29tcGFyZSIsImp1c3RpZmljYXRpb24iLCJsYXlvdXREYXRhIiwibWFwTGF5b3V0RGF0YSIsIm1hcFNjcmF0Y2giLCJ1cmwiLCJyZWdleGVzIiwic2luZ2xlUmVnZXhNYXRjaFZhbHVlIiwidXJscyIsInByb3BMaXN0IiwidGV4dFJvdGF0aW9uIiwicG9seWdvblBvaW50TGlzdCIsImV2ZW5NdWx0aXBsZSIsImVkZ2VEaXN0YW5jZXMiLCJlZGdlRW5kcG9pbnQiLCJzaW5nbGVFbnVtIiwidmFsaWRhdGUiLCJ2YWxBcnIiLCJ1bml0c0FyciIsImdyYWRpZW50RGlyZWN0aW9uIiwiYm91bmRzRXhwYW5zaW9uIiwiemVyb05vblplcm8iLCJ2YWwxIiwidmFsMiIsImFueSIsImVtcHR5Tm9uRW1wdHkiLCJzdHIxIiwic3RyMiIsImVtcHR5MSIsImVtcHR5MiIsIm1haW5MYWJlbCIsInNvdXJjZUxhYmVsIiwidGFyZ2V0TGFiZWwiLCJiZWhhdmlvciIsIm92ZXJsYXkiLCJ1bmRlcmxheSIsInRyYW5zaXRpb24iLCJub2RlU2l6ZUhhc2hPdmVycmlkZSIsImVkZ2VMaW5lIiwicGllQmFja2dyb3VuZE4iLCJlZGdlQXJyb3ciLCJhcnJvd1ByZWZpeGVzIiwicHJvcEdyb3VwcyIsInByb3BlcnR5R3JvdXBzIiwicHJvcEdyb3VwTmFtZXMiLCJwcm9wR3JvdXBLZXlzIiwiYWxpYXNlcyIsInBvaW50c1RvUHJvcCIsImFsaWFzUHJvcCIsImdldERlZmF1bHRQcm9wZXJ0aWVzIiwiZGVmYXVsdFByb3BlcnRpZXMiLCJyYXdQcm9wcyIsInBhcnNlZFByb3BzIiwiYWRkRGVmYXVsdFN0eWxlc2hlZXQiLCJzdHlmbiQxIiwicHJvcElzRmxhdCIsInBhcnNlSW1wbFdhcm4iLCJmbGF0S2V5IiwiYnlwYXNzS2V5IiwidmFsdWVLZXkiLCJhcmdIYXNoIiwicHJvcENhY2hlIiwicGFyc2VJbXBsIiwicGFzc2VkVmFsdWUiLCJ0cmltIiwiX21hcHBlZCIsInBmVmFsQXJyIiwiaGFzRW51bSIsImNoZWNrRW51bXMiLCJlbiIsInVuaXRzUmVnZXgiLCJzdHJpY3RNYXgiLCJwcm9wc1N0ciIsInByb3BzU3BsaXQiLCJ0dXBsZSIsImVudW1Qcm9wIiwiU3R5bGUiLCJjb3JlU3R5bGUiLCJzdHlmbiIsImVsZV9wIiwibWFwVmFsIiwiY3NzUnVsZSIsImN1cnJlbnRTZWxlY3RvcklzQ29yZSIsImFwcGVuZCIsImFwcGVuZFRvU3R5bGUiLCJjb3JlZm4kMiIsIm5ld1N0eWxlIiwic2V0U3R5bGUiLCJnZW5lcmF0ZVN0eWxlIiwiZGVmYXVsdFNlbGVjdGlvblR5cGUiLCJjb3JlZm4kMSIsInNlbGVjdGlvblR5cGUiLCJzZWxUeXBlIiwicGFubmluZ0VuYWJsZWQiLCJ1c2VyUGFubmluZ0VuYWJsZWQiLCJ6b29taW5nRW5hYmxlZCIsInVzZXJab29taW5nRW5hYmxlZCIsImJveFNlbGVjdGlvbkVuYWJsZWQiLCJhcmcwIiwidmlld3BvcnRTdGF0ZSIsImJiZSIsInpvb21SYW5nZSIsImN1cnJlbnRQYW4iLCJjdXJyZW50Wm9vbSIsImJhaWwiLCJsZXZlbCIsInBhbjEiLCJ6b29tMSIsInpvb20yIiwicGFuMiIsInZpZXdwb3J0Iiwiem9vbURlZmQiLCJwYW5EZWZkIiwiem9vbUZhaWxlZCIsInBhbkZhaWxlZCIsInoiLCJjYW5jZWxPbkZhaWxlZFpvb20iLCJyZXNldCIsInNpemVDYWNoZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZXh0ZW50IiwicmIiLCJyZW5kZXJlZEV4dGVudCIsIm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUiLCJfaW50IiwiYXV0b2xvY2tOb2RlcyIsImF1dG91bmdyYWJpZnlOb2RlcyIsIkNvcmUiLCJyZWciLCJkZXN0cm95IiwicmVhZGllcyIsImhlYWQiLCJkZWZWYWwiLCJkZWYiLCJhbHRWYWwiLCJsb2FkRXh0RGF0YSIsImV4dERhdGEiLCJhbnlJc1Byb21pc2UiLCJyZW5kZXJlck9wdGlvbnMiLCJzZXRFbGVzQW5kTGF5b3V0Iiwib25sb2FkIiwib25kb25lIiwib2xkRWxlcyIsImxheW91dE9wdHMiLCJ0aGVucyIsImluaXRTdHlsZSIsImluaXRFbGVzIiwiY29yZWZuIiwiaXNSZWFkeSIsImlzSGVhZGxlc3MiLCJtb3VudCIsInVubW91bnQiLCJnZXRGcmVzaFJlZiIsImlkSW5Kc29uIiwidXBkYXRlRWxlcyIsImdyIiwidG9Nb2QiLCJfdG9Nb2QkX2kiLCJwYXJlbnRzVG9SZW1vdmUiLCJmbGF0IiwiZGVmYXVsdHMkNyIsImNpcmNsZSIsImdyaWQiLCJhdm9pZE92ZXJsYXAiLCJkZXB0aFNvcnQiLCJkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMiLCJtYXhpbWFsIiwiYWN5Y2xpYyIsInNldEluZm8iLCJCcmVhZHRoRmlyc3RMYXlvdXQiLCJncmFwaCIsIm1heGltYWxBZGp1c3RtZW50cyIsInJvb3RzQXJyYXkiLCJjb21wIiwiY29tcFJvb3RzIiwiZGVwdGhzIiwiZm91bmRCeUJmcyIsImFkZFRvRGVwdGgiLCJjaGFuZ2VEZXB0aCIsIm5ld0RlcHRoIiwicE5vZGUiLCJvcnBoYW5Ob2RlcyIsImFzc2lnbkRlcHRoc0F0IiwiYXNzaWduRGVwdGhzIiwiYWRqdXN0TWF4aW1hbGx5Iiwic2hpZnRlZCIsImVJbmZvIiwibWF4RGVwdGgiLCJpbmNtciIsImlJbmZvIiwiZW5xdWV1ZSIsImRlcXVldWUiLCJkaWRTaGlmdCIsIm1pbkRpc3RhbmNlIiwibmJiIiwiY2FjaGVkV2VpZ2h0ZWRQZXJjZW50IiwiZ2V0V2VpZ2h0ZWRQZXJjZW50IiwiZWxlRGVwdGgiLCJzYW1wbGVzIiwiYmYiLCJuRGVwdGgiLCJhcGN0IiwiYnBjdCIsIm9ycGhhbkRlcHRoIiwiYmlnZ2VzdERlcHRoU2l6ZSIsIm1heERlcHRoU2l6ZSIsImdldFBvc2l0aW9uIiwiX2dldEluZm8yIiwiZGVwdGhTaXplIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwicmFkaXVzU3RlcFNpemUiLCJlcG9zIiwiZGVmYXVsdHMkNiIsInN3ZWVwIiwiY2xvY2t3aXNlIiwiQ2lyY2xlTGF5b3V0IiwiY291bnRlcmNsb2Nrd2lzZSIsImRUaGV0YSIsImRjb3MiLCJkc2luIiwick1pbiIsImdldFBvcyIsInJ4IiwicnkiLCJkZWZhdWx0cyQ1IiwiZXF1aWRpc3RhbnQiLCJtaW5Ob2RlU3BhY2luZyIsImNvbmNlbnRyaWMiLCJsZXZlbFdpZHRoIiwiQ29uY2VudHJpY0xheW91dCIsIm5vZGVWYWx1ZXMiLCJtYXhOb2RlU2l6ZSIsImxldmVscyIsImN1cnJlbnRMZXZlbCIsIm1pbkRpc3QiLCJmaXJzdEx2bEhhc011bHRpIiwibWF4UiIsInJTdGVwIiwickRlbHRhTWF4IiwiX3IiLCJfbGV2ZWwiLCJyRGVsdGEiLCJfbGV2ZWwyIiwiX2xldmVsMyIsIl9kVGhldGEiLCJfcjIiLCJfdmFsIiwiREVCVUciLCJkZWZhdWx0cyQ0IiwiYW5pbWF0aW9uVGhyZXNob2xkIiwicmVmcmVzaCIsInJhbmRvbWl6ZSIsImNvbXBvbmVudFNwYWNpbmciLCJub2RlUmVwdWxzaW9uIiwibm9kZU92ZXJsYXAiLCJpZGVhbEVkZ2VMZW5ndGgiLCJlZGdlRWxhc3RpY2l0eSIsIm5lc3RpbmdGYWN0b3IiLCJncmF2aXR5IiwiaW5pdGlhbFRlbXAiLCJjb29saW5nRmFjdG9yIiwibWluVGVtcCIsIkNvc2VMYXlvdXQiLCJsYXlvdXRJbmZvIiwiY3JlYXRlTGF5b3V0SW5mbyIsInByaW50TGF5b3V0SW5mbyIsInJhbmRvbWl6ZVBvc2l0aW9ucyIsInJlZnJlc2hQb3NpdGlvbnMiLCJtYWluTG9vcCIsInRlbXBlcmF0dXJlIiwiZ2V0U2NhbGVkUG9zIiwiZ2V0U2NhbGVJbkJvdW5kc0ZuIiwibG9vcFJldCIsImZyYW1lIiwic2VwYXJhdGVDb21wb25lbnRzIiwidGhyZWFkIiwiaXNDb21wb3VuZCIsImxheW91dE5vZGVzIiwiaWRUb0luZGV4IiwiZ3JhcGhTZXQiLCJpbmRleFRvR3JhcGgiLCJsYXlvdXRFZGdlcyIsImVkZ2VTaXplIiwiaWQyY21wdElkIiwidGVtcE5vZGUiLCJpc0xvY2tlZCIsImNtcHRJZCIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInBhZExlZnQiLCJwYWRSaWdodCIsInBhZFRvcCIsInBhZEJvdHRvbSIsInRlbXBHcmFwaCIsInBfaWQiLCJub2RlX2lkIiwibm9kZV9peCIsInRlbXBFZGdlIiwiaWRlYWxMZW5ndGgiLCJlbGFzdGljaXR5Iiwic291cmNlSXgiLCJ0YXJnZXRJeCIsInNvdXJjZUdyYXBoIiwidGFyZ2V0R3JhcGgiLCJsY2EiLCJmaW5kTENBIiwibGNhR3JhcGgiLCJmaW5kTENBX2F1eCIsImNvdW50IiwiZ3JhcGhJeCIsIm5vZGVJeCIsImNoaWxkR3JhcGhJeCIsImNvc2VCQiIsImxub2RlIiwicGN0WCIsInBjdFkiLCJfc3RlcCIsImNhbGN1bGF0ZU5vZGVGb3JjZXMiLCJjYWxjdWxhdGVFZGdlRm9yY2VzIiwiY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyIsInByb3BhZ2F0ZUZvcmNlcyIsInVwZGF0ZVBvc2l0aW9ucyIsInJhbmRvbURpc3RhbmNlIiwiY21wdElkMSIsImNtcHRJZDIiLCJkaXJlY3Rpb25YIiwiZGlyZWN0aW9uWSIsIm1heFJhbmREaXN0Iiwib3ZlcmxhcCIsIm5vZGVzT3ZlcmxhcCIsImZvcmNlWCIsImZvcmNlWSIsInBvaW50MSIsImZpbmRDbGlwcGluZ1BvaW50IiwicG9pbnQyIiwiZGlzdGFuY2VTcXIiLCJkWCIsImRZIiwib3ZlcmxhcFgiLCJvdmVybGFwWSIsIlgiLCJZIiwiSCIsIlciLCJkaXJTbG9wZSIsIm5vZGVTbG9wZSIsImx4IiwibHkiLCJkaXN0VGhyZXNob2xkIiwiZngiLCJmeSIsIm5vZGVJbmRleCIsIm9mZlgiLCJvZmZZIiwiY2hpbGROb2RlIiwidGVtcEZvcmNlIiwibGltaXRGb3JjZSIsInVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyIsImZsYWciLCJjaWQiLCJ0b3RhbEEiLCJ1c2VkVyIsInJvd0giLCJtYXhSb3dXIiwiZGVmYXVsdHMkMyIsImF2b2lkT3ZlcmxhcFBhZGRpbmciLCJjb25kZW5zZSIsInJvd3MiLCJjb2xzIiwiR3JpZExheW91dCIsImNlbGxzIiwic3BsaXRzIiwic21hbGwiLCJsYXJnZSIsIm9Sb3dzIiwib0NvbHMiLCJjb2x1bW5zIiwic20iLCJsZyIsIl9zbSIsIl9sZyIsImNlbGxXaWR0aCIsImNlbGxIZWlnaHQiLCJjZWxsVXNlZCIsInVzZWQiLCJ1c2UiLCJtb3ZlVG9OZXh0Q2VsbCIsImlkMm1hblBvcyIsInJjUG9zIiwiZGVmYXVsdHMkMiIsIk51bGxMYXlvdXQiLCJkZWZhdWx0cyQxIiwiUHJlc2V0TGF5b3V0IiwicG9zSXNGbiIsIlJhbmRvbUxheW91dCIsIk51bGxSZW5kZXJlciIsInRocm93SW1nRXJyIiwiQlJwJGYiLCJhcnJvd1NoYXBlV2lkdGgiLCJyZWdpc3RlckFycm93U2hhcGVzIiwiYXJyb3dTaGFwZXMiLCJiYkNvbGxpZGUiLCJ0cmFuc2xhdGlvbiIsImVkZ2VXaWR0aCIsInhSb3RhdGVkIiwieVJvdGF0ZWQiLCJ4U2NhbGVkIiwieVNjYWxlZCIsInhUcmFuc2xhdGVkIiwieVRyYW5zbGF0ZWQiLCJ0cmFuc2Zvcm1Qb2ludHMiLCJyZXRQdHMiLCJwb2ludHNUb0FyciIsInN0YW5kYXJkR2FwIiwiZGVmaW5lQXJyb3dTaGFwZSIsImRlZm4iLCJjb2xsaWRlIiwicm91Z2hDb2xsaWRlIiwiZHJhdyIsImFycm93U2hhcGVJbXBsIiwiZ2FwIiwiY29udHJvbFBvaW50IiwicHRzVHJhbnMiLCJjdHJsUHQiLCJjdHJsUHRUcmFucyIsInBvaW50c1RlZSIsInRyaVB0cyIsInRlZVB0cyIsInBvaW50c1RyIiwiY2lyY2xlSW5zaWRlIiwiZ2V0QXJyb3dXaWR0aCIsImJhc2VDcm9zc0xpbmVQdHMiLCJjcm9zc0xpbmVQdHMiLCJzaGlmdEZhY3RvciIsInkwIiwiQlJwJGUiLCJwcm9qZWN0SW50b1ZpZXdwb3J0IiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRzIiwiZmluZENvbnRhaW5lckNsaWVudENvb3JkcyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzY2FsZSIsImNvbnRhaW5lckJCIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInN0eWxlVmFsdWUiLCJwYWRkaW5nSG9yIiwicGFkZGluZ1ZlciIsImJvcmRlckhvciIsInVuc2NhbGVkVyIsInVuc2NhbGVkSCIsImludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSIsImZpbmROZWFyZXN0RWxlbWVudCIsImludGVyYWN0aXZlRWxlbWVudHNPbmx5IiwiaXNUb3VjaCIsImZpbmROZWFyZXN0RWxlbWVudHMiLCJnZXRDYWNoZWRaU29ydGVkRWxlcyIsIm5lYXIiLCJlZGdlVGhyZXNob2xkIiwibm9kZVRocmVzaG9sZCIsImxhYmVsVGhyZXNob2xkIiwibWluU3FEaXN0IiwibmVhckVkZ2UiLCJuZWFyTm9kZSIsImFkZEVsZSIsInNxRGlzdCIsImNoZWNrTm9kZSIsImh3IiwiaGgiLCJzaGFwZSIsIm5vZGVTaGFwZXMiLCJnZXROb2RlU2hhcGUiLCJjaGVja1BvaW50IiwiY2hlY2tFZGdlIiwicnMiLCJzdHlsZVdpZHRoIiwid2lkdGhTcSIsIndpZHRoMiIsImVkZ2VUeXBlIiwiYWxscHRzIiwiYXJTaXplIiwiYXJyb3dzIiwiYXJyb3dTdGFydFgiLCJhcnJvd1N0YXJ0WSIsInNyY0Fycm93QW5nbGUiLCJhcnJvd0VuZFgiLCJhcnJvd0VuZFkiLCJ0Z3RBcnJvd0FuZ2xlIiwibWlkc3JjQXJyb3dBbmdsZSIsIm1pZHRndEFycm93QW5nbGUiLCJhciIsInByZXByb3AiLCJwcmUiLCJjaGVja0xhYmVsIiwidGgiLCJldmVudHNFbmFibGVkIiwib3giLCJveSIsImdldEFsbEluQm94IiwiYm94IiwieDFjIiwieDJjIiwieTFjIiwieTJjIiwiYm94QmIiLCJub2RlQmIiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImFsbEluc2lkZSIsIkJScCRkIiwiY2FsY3VsYXRlQXJyb3dBbmdsZXMiLCJpc0hheXN0YWNrIiwiaXNCZXppZXIiLCJpc011bHRpYmV6aWVyIiwiaXNTZWdtZW50cyIsImlzU2VsZiIsInNlZ3B0cyIsImJYIiwiYlkiLCJpMiIsImkxIiwiaTMiLCJjcHRzIiwiY3RybHB0cyIsImJwMHgiLCJicDB5IiwiYnAxeCIsImJwMXkiLCJpYyIsIm1pZERpc3BYIiwibWlkRGlzcFkiLCJnZXRBcnJvd0hlaWdodCIsImFycm93V2lkdGhDYWNoZSIsIkJScCRjIiwiZmluZEhheXN0YWNrUG9pbnRzIiwiaGF5c3RhY2siLCJzcmNQb3MiLCJ0Z3RQb3MiLCJzcmNXIiwidGd0VyIsInNyY0giLCJ0Z3RIIiwiaGFsZlJhZGl1cyIsInN0b3JlRWRnZVByb2plY3Rpb25zIiwicmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyIsImNhbGN1bGF0ZUxhYmVsQW5nbGVzIiwiZmluZFNlZ21lbnRzUG9pbnRzIiwicGFpckluZm8iLCJwb3NQdHMiLCJpbnRlcnNlY3Rpb25QdHMiLCJ2ZWN0b3JOb3JtSW52ZXJzZSIsInNlZ21lbnRXcyIsInNlZ21lbnREcyIsInNlZ21lbnRzTiIsIncxIiwidzIiLCJtaWRwdFB0cyIsImFkanVzdGVkTWlkcHQiLCJmaW5kTG9vcFBvaW50cyIsImVkZ2VJc1VuYnVuZGxlZCIsImRpckNvdW50cyIsImN0cmxwdERpc3RzIiwiY3RybHB0RGlzdCIsImxvb3BEaXIiLCJsb29wU3dwIiwic3RlcFNpemUiLCJsb29wRGlzdCIsImxvb3BBbmdsZSIsIm91dEFuZ2xlIiwiaW5BbmdsZSIsIlN0cmluZyIsImZpbmRDb21wb3VuZExvb3BQb2ludHMiLCJsb29wVyIsImxvb3BhUG9zIiwibG9vcGJQb3MiLCJsb29wUG9zIiwibWluQ29tcG91bmRTdHJldGNoIiwiY29tcG91bmRTdHJldGNoQSIsImNvbXBvdW5kU3RyZXRjaEIiLCJmaW5kU3RyYWlnaHRFZGdlUG9pbnRzIiwiZmluZEJlemllclBvaW50cyIsImVkZ2VJc1N3YXBwZWQiLCJjdHJscHRXcyIsImJlemllck4iLCJjdHJscHRXZWlnaHQiLCJtdWx0aSIsIm5vcm1jdHJscHREaXN0IiwibWFuY3RybHB0RGlzdCIsInNpZ24iLCJkaXN0YW5jZUZyb21NaWRwb2ludCIsImZpbmRUYXhpUG9pbnRzIiwiVkVSVElDQUwiLCJIT1JJWk9OVEFMIiwiTEVGVFdBUkQiLCJSSUdIVFdBUkQiLCJET1dOV0FSRCIsIlVQV0FSRCIsIkFVVE8iLCJkSW5jbHVkZXNOb2RlQm9keSIsInRheGlEaXIiLCJyYXdUYXhpRGlyIiwidGF4aVR1cm4iLCJ0dXJuSXNQZXJjZW50IiwidGF4aVR1cm5QZlZhbCIsInR1cm5Jc05lZ2F0aXZlIiwibWluRCIsImR3IiwiZGgiLCJwZHgiLCJwZHkiLCJzdWJEV0giLCJkeHkiLCJkd2giLCJpc0V4cGxpY2l0RGlyIiwiaXNWZXJ0IiwicGwiLCJzZ25MIiwiZm9yY2VkRGlyIiwiZ2V0SXNUb29DbG9zZSIsImlzVG9vQ2xvc2VTcmMiLCJpc1Rvb0Nsb3NlVGd0IiwiaXNUb29DbG9zZSIsImxTaGFwZUluc2lkZVNyYyIsImxTaGFwZUluc2lkZVRndCIsIl9sU2hhcGVJbnNpZGVTcmMiLCJfbFNoYXBlSW5zaWRlVGd0IiwiX3kiLCJfeCIsIl94MiIsIl94MyIsIl95MiIsIl95MyIsIl95NCIsIl94NCIsIl94NSIsIl94NiIsIl95NSIsIl95NiIsInRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMiLCJzcmNTaGFwZSIsInRndFNoYXBlIiwiYmFkU3RhcnQiLCJiYWRBU3RhcnQiLCJiYWRFbmQiLCJiYWRBRW5kIiwibWluQ3BBRGlzdEZhY3RvciIsImFycm93VyIsIm1pbkNwQURpc3QiLCJzdGFydEFDcERpc3QiLCJjbG9zZVN0YXJ0QUNwIiwiZW5kQUNwRGlzdCIsImNsb3NlRW5kQUNwIiwib3ZlcmxhcHBpbmciLCJjcEQiLCJjcEwiLCJjcE0iLCJjcFByb2oiLCJzcmNDdHJsUHRJbnRuIiwiaW50ZXJzZWN0TGluZSIsIl9jcEQiLCJfY3BMIiwiX2NwTSIsIl9yYWRpdXMiLCJfY3BQcm9qIiwidGd0Q3RybFB0SW50biIsImZpbmRFbmRwb2ludHMiLCJzdG9yZUFsbHB0cyIsIm10IiwiY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmciLCJsb2dnZWRFcnIiLCJmaW5kRWRnZUNvbnRyb2xQb2ludHMiLCJoYXNoVGFibGUiLCJwYWlySWQiLCJtYXAyIiwicGFpcklkcyIsImhheXN0YWNrRWRnZXMiLCJlZGdlSXNCZXppZXIiLCJzcmNJbmRleCIsInRndEluZGV4IiwidGFibGVFbnRyeSIsImhhc1VuYnVuZGxlZCIsImhhc0JlemllciIsInN3YXBwZWRwYWlySW5mbyIsImZpcnN0RWRnZSIsIl9jdXJ2ZVN0eWxlIiwiX2VkZ2VJc1VuYnVuZGxlZCIsImNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24iLCJzcmNPdXRzaWRlIiwic3JjSW50biIsInRndE91dHNpZGUiLCJ0Z3RJbnRuIiwidmVjdG9yIiwidmVjdG9yTm9ybSIsInBhc3NlZFBhaXJJbmZvIiwiZ2V0UHRzIiwiQlJwJGIiLCJtYW51YWxFbmRwdFRvUHgiLCJucG9zIiwidGd0QXJTaGFwZSIsInNyY0FyU2hhcGUiLCJldCIsInRheGkiLCJzZWdtZW50cyIsImhhc0VuZHB0cyIsIm92ZXJyaWRlRW5kcHRzIiwic3JjTWFuRW5kcHQiLCJzcmNNYW5FbmRwdFZhbCIsInRndE1hbkVuZHB0IiwidGd0TWFuRW5kcHRWYWwiLCJwMV9pIiwicDJfaSIsImNwU3RhcnQiLCJjcEVuZCIsInNyY0Fycm93RnJvbVB0IiwidGd0QXJyb3dGcm9tUHQiLCJ0cnMiLCJsdzIiLCJsaDIiLCJ2YSIsImhhIiwibGFiZWxJbnRlcnNlY3QiLCJyZWZQdCIsImludFNxZGlzdCIsImxhYkludFNxZGlzdCIsImxhYkludDJTcURpc3QiLCJhcnJvd0VuZCIsImVkZ2VFbmQiLCJzcnMiLCJfbHciLCJfbGgiLCJfbHgiLCJfbHkiLCJfbHcyIiwiX2xoMiIsIl92YSIsIl9oYSIsIl9sYWJlbEludGVyc2VjdCIsIl9yZWZQdCIsIl9pbnRTcWRpc3QiLCJfbGFiSW50U3FkaXN0IiwiX21pblNxRGlzdCIsIl9sYWJJbnQyU3FEaXN0IiwiYXJyb3dTdGFydCIsImVkZ2VTdGFydCIsImJhZExpbmUiLCJCUnAkYSIsInB1c2hCZXppZXJQdHMiLCJxYmV6aWVyQXQkMSIsInAzIiwiYnB0cyIsImJlemllclByb2pQY3RzIiwibHB0cyIsInJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zIiwiQlJwJDkiLCJyZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24iLCJjb250ZW50IiwidGV4dFgiLCJ0ZXh0WSIsIm5vZGVXaWR0aCIsIm5vZGVIZWlnaHQiLCJub2RlUG9zIiwidGV4dEhhbGlnbiIsInRleHRWYWxpZ24iLCJhcHBseUxhYmVsRGltZW5zaW9ucyIsImxpbmVBbmdsZUZyb21EZWx0YSIsImxpbmVBbmdsZSIsImJlemllckFuZ2xlIiwidDAiLCJscDAiLCJscDEiLCJzZXRScyIsIm1pZEFuZ2xlIiwiY3JlYXRlQ29udHJvbFBvaW50SW5mbyIsInN0YXJ0RGlzdCIsIm5Qcm9qcyIsImFkZFNlZ21lbnQiLCJjcCIsInByZXZTZWdtZW50Iiwic2VnbWVudCIsInByZXZDcCIsImNhbGN1bGF0ZUVuZFByb2plY3Rpb24iLCJpc1NyYyIsImNwcyIsInRvdGFsRGlzdCIsIl9jcCIsIl9zZWciLCJsYXN0U2VnIiwic2VnIiwidFNlZ21lbnQiLCJzZWdEdCIsImRpIiwiZDAiLCJwRCIsIl90IiwiYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyIsImdldExhYmVsVGV4dCIsImxhYmVsRGltcyIsImNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyIsImxpbmVIZWlnaHQiLCJudW1MaW5lcyIsIm5vcm1QZXJMaW5lSGVpZ2h0IiwibGFiZWxMaW5lSGVpZ2h0IiwicGZkIiwid3JhcFN0eWxlIiwiendzcCIsIm1heFciLCJvdmVyZmxvdyIsIm92ZXJmbG93QW55Iiwid3JhcHBlZExpbmVzIiwid29yZHNSZWdleCIsIndvcmRTZXBhcmF0b3IiLCJsaW5lRGltcyIsImxpbmVXIiwicHJvY2Vzc2VkTGluZSIsIndvcmRzIiwic3VibGluZSIsIndvcmQiLCJ0ZXN0TGluZSIsInRlc3REaW1zIiwidGVzdFciLCJfbWF4VyIsImVsbGlwc2l6ZWQiLCJlbGxpcHNpcyIsImluY0xhc3RDaCIsIndpZHRoV2l0aE5leHRDaCIsImdldExhYmVsSnVzdGlmaWNhdGlvbiIsImNhY2hlS2V5IiwibGFiZWxEaW1DYWNoZSIsImV4aXN0aW5nVmFsIiwiZlN0eWxlIiwiZmFtaWx5IiwiY2FudmFzIiwibGFiZWxDYWxjQ2FudmFzIiwiYzJkIiwibGFiZWxDYWxjQ2FudmFzQ29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0IiwiZHMiLCJ6SW5kZXgiLCJwb2ludGVyRXZlbnRzIiwiZm9udCIsIm1ldHJpY3MiLCJtZWFzdXJlVGV4dCIsImNhbGN1bGF0ZUxhYmVsQW5nbGUiLCJyb3QiLCJyb3RTdHIiLCJsYWJlbEF1dG9BbmdsZSIsImxhYmVsQW5nbGUiLCJzb3VyY2VMYWJlbEFuZ2xlIiwidGFyZ2V0TGFiZWxBbmdsZSIsIkJScCQ4IiwiVE9PX1NNQUxMX0NVVF9SRUNUIiwid2FybmVkQ3V0UmVjdCIsIm1ha2VQb2x5Z29uIiwiQlJwJDciLCJyZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzIiwiZWxlc1RvVXBkYXRlIiwiZGlydHlTdHlsZUNhY2hlcyIsImNsZWFuQ29ubmVjdGVkIiwiYmluZGVyIiwib25EaXJ0eUJvdW5kcyIsIm9uRGlydHlTdHlsZSIsInVwZGF0ZUVsZUNhbGNzIiwiZm5zIiwib25VcGRhdGVFbGVDYWxjc0ZucyIsImZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlIiwiZWxlQ2FsY3MiLCJvblVwZGF0ZUVsZUNhbGNzIiwiaXNDbGVhbkNvbm5lY3RlZCIsIl9wMiIsIl9yc3R5bGUiLCJub2RlVyIsIm5vZGVIIiwiX3AzIiwiX3JzdHlsZTIiLCJCUnAkNiIsInVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzIiwiY2FjaGVkWlNvcnRlZEVsZXMiLCJkcmFnIiwibm9uZHJhZyIsImdyYWJUYXJnZXRzIiwiaW5EcmFnTGF5ZXIiLCJpbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMiLCJmb3JjZVJlY2FsYyIsIkJScCQ1IiwiQlJwJDQiLCJnZXRDYWNoZWRJbWFnZSIsImNyb3NzT3JpZ2luIiwib25Mb2FkIiwiaW1hZ2VDYWNoZSIsImltYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkltYWdlIiwiZGF0YVVyaVByZWZpeCIsImlzRGF0YVVyaSIsIkJScCQzIiwicmVnaXN0ZXJCaW5kaW5nIiwidXNlQ2FwdHVyZSIsInRndElzRG9tIiwiYm9keSIsInN1cHBvcnRzUGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZSIsImNhcHR1cmUiLCJwYXNzaXZlIiwiYmluZGluZ3MiLCJub2RlSXNEcmFnZ2FibGUiLCJub2RlSXNHcmFiYmFibGUiLCJsb2FkIiwiaXNTZWxlY3RlZCIsInRyaWdnZXJFdmVudHMiLCJpc011bHRTZWxLZXlEb3duIiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsbG93UGFubmluZ1Bhc3N0aHJvdWdoIiwiZG93biIsImRvd25zIiwiYWxsb3dQYXNzdGhyb3VnaCIsInNldEdyYWJiZWQiLCJzZXRGcmVlZCIsInNldEluRHJhZ0xheWVyIiwic2V0T3V0RHJhZ0xheWVyIiwic2V0R3JhYlRhcmdldCIsImlzR3JhYlRhcmdldCIsInJlbW92ZUdyYWJUYXJnZXQiLCJhZGRUb0RyYWdMaXN0IiwibGlzdCIsImFkZFRvTGlzdCIsImxpc3RIYXNFbGUiLCJhZGREZXNjZW5kYW50c1RvRHJhZyIsImlubmVyTm9kZXMiLCJhZGROb2Rlc1RvRHJhZyIsInVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyIiwiYWRkTm9kZVRvRHJhZyIsImZyZWVEcmFnZ2VkRWxlbWVudHMiLCJncmFiYmVkRWxlcyIsImJsdXJBY3RpdmVEb21FbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJoYXZlTXV0YXRpb25zQXBpIiwiTXV0YXRpb25PYnNlcnZlciIsImhhdmVSZXNpemVPYnNlcnZlckFwaSIsIlJlc2l6ZU9ic2VydmVyIiwicmVtb3ZlT2JzZXJ2ZXIiLCJtdXRucyIsIm11dG4iLCJyTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJyTm9kZSIsInBhcmVudE5vZGUiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwib25SZXNpemUiLCJzdHlsZU9ic2VydmVyIiwicmVzaXplT2JzZXJ2ZXIiLCJpbnZhbGlkYXRlQ29vcmRzIiwiaW5Cb3hTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJldmVudEluQ29udGFpbmVyIiwiY29udGFpbmVyUGFnZUNvb3JkcyIsInRvdWNoZXMiLCJhdExlYXN0T25lUG9zSW5zaWRlIiwidFBhcmVudCIsImNvbnRhaW5lcklzVGFyZ2V0IiwibW91c2Vkb3duSGFuZGxlciIsImhvdmVyRGF0YSIsIndoaWNoIiwiZ3BvcyIsInNlbGVjdCIsIm5lYXJzIiwiZHJhZ2dlZEVsZW1lbnRzIiwiZHJhZ0RhdGEiLCJwb3NzaWJsZURyYWdFbGVtZW50cyIsIm1kb3duUG9zIiwibWRvd25HUG9zIiwiY2hlY2tGb3JUYXBob2xkIiwidGFwaG9sZENhbmNlbGxlZCIsInRhcGhvbGRUaW1lb3V0IiwidGFwaG9sZER1cmF0aW9uIiwiY3h0U3RhcnRlZCIsImN4dEV2dCIsImFjdGl2YXRlIiwiZG93blRpbWUiLCJnZXRUaW1lIiwiY3h0RHJhZ2dlZCIsIm1ha2VFdmVudCIsInRyaWdnZXJHcmFiIiwic2VsZWN0ZWROb2RlcyIsInJlZHJhd0hpbnQiLCJiZ0FjdGl2ZVBvc2lzdGlvbiIsInJlZHJhdyIsIm1vdXNlbW92ZUhhbmRsZXIiLCJkcmFnZ2luZ0VsZXMiLCJkcmFnZ2luZyIsInNlbGVjdGluZyIsImlzT3ZlclRocmVzaG9sZERyYWciLCJkeDIiLCJkeTIiLCJkaXN0MiIsImRlc2t0b3BUYXBUaHJlc2hvbGQyIiwibXVsdFNlbEtleURvd24iLCJ1cGRhdGVEcmFnRGVsdGEiLCJkcmFnRGVsdGEiLCJnb0ludG9Cb3hNb2RlIiwiY3h0T3ZlciIsImRlbHRhUCIsImp1c3RTdGFydGVkUGFuIiwibWRQb3MiLCJkcmFnZ2VkIiwidW5hY3RpdmF0ZSIsImRpZERyYWciLCJqdXN0U3RhcnRlZERyYWciLCJ0b3RhbFNoaWZ0IiwiY2xpY2tUaW1lb3V0IiwiZGlkRG91YmxlQ2xpY2siLCJwcmV2Q2xpY2tUaW1lU3RhbXAiLCJtb3VzZXVwSGFuZGxlciIsImN4dFRhcCIsImVsZVdvdWxkQmVTZWxlY3RlZCIsImRvd25XYXNHcmFiYmVkIiwid2hlZWxIYW5kbGVyIiwic2Nyb2xsaW5nUGFnZSIsIndoZWVsWm9vbWluZyIsIndoZWVsVGltZW91dCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsIm5lZWRzV2hlZWxGaXgiLCJkZWx0YU1vZGUiLCJuZXdab29tIiwiZ2VzdHVyZVN0YXJ0Wm9vbSIsInNjcm9sbEhhbmRsZXIiLCJzY3JvbGxpbmdQYWdlVGltZW91dCIsImdlc3R1cmVTdGFydEhhbmRsZXIiLCJoYXNUb3VjaFN0YXJ0ZWQiLCJtb3VzZU91dEhhbmRsZXIiLCJtb3VzZU92ZXJIYW5kbGVyIiwiZjF4MSIsImYxeTEiLCJmMngxIiwiZjJ5MSIsImRpc3RhbmNlMSIsImRpc3RhbmNlMVNxIiwiY2VudGVyMSIsIm1vZGVsQ2VudGVyMSIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwidHdvRmluZ2Vyc1N0YXJ0SW5zaWRlIiwiZGlzdGFuY2VTcSIsInRvdWNoc3RhcnRIYW5kbGVyIiwidG91Y2hEYXRhIiwiZWFybGllciIsInNpbmdsZVRvdWNoTW92ZWQiLCJ0b3VjaERyYWdFbGVzIiwiY3h0RGlzdFRocmVzaG9sZCIsImN4dERpc3RUaHJlc2hvbGRTcSIsIm5lYXIxIiwibmVhcjIiLCJzdGFydHMiLCJkcmFnZ2VkRWxlcyIsInNpbmdsZVRvdWNoU3RhcnRUaW1lIiwicGluY2hpbmciLCJzUG9zIiwidG91Y2gwIiwic3RhcnRHUG9zaXRpb24iLCJ0b3VjaG1vdmVIYW5kbGVyIiwic3RhcnRHUG9zIiwidG91Y2hUYXBUaHJlc2hvbGQyIiwiZjF4MiIsImYxeTIiLCJmMngyIiwiZjJ5MiIsImRpc3RhbmNlMlNxIiwiZmFjdG9yU3EiLCJkaXN0VGhyZXNob2xkU3EiLCJmYWN0b3JUaHJlc2hvbGQiLCJmYWN0b3JUaHJlc2hvbGRTcSIsImxhc3RUaHJlZVRvdWNoIiwiZGlkU2VsZWN0IiwiZGVfcCIsIl9zdGFydCIsImRpc3RhbmNlMiIsImZhY3RvciIsImRmMXgiLCJkZjF5IiwiZGYyeCIsImRmMnkiLCJ0eCIsInR5IiwiY3RyeCIsImN0cnkiLCJzd2lwZVBhbm5pbmciLCJ0b3VjaGNhbmNlbEhhbmRsZXIiLCJ0b3VjaGVuZEhhbmRsZXIiLCJkaWREb3VibGVUb3VjaCIsInRvdWNoVGltZW91dCIsInByZXZUb3VjaFRpbWVTdGFtcCIsImN0eFRhcGVuZCIsImN0eFRhcCIsInN0YXJ0V2FzR3JhYmJlZCIsInJkaXN0MiIsIlRvdWNoRXZlbnQiLCJwb2ludGVycyIsIm1ha2VUb3VjaCIsImlkZW50aWZpZXIiLCJwb2ludGVySWQiLCJwYWdlWCIsInBhZ2VZIiwicmFkaXVzWCIsInJhZGl1c1kiLCJzY3JlZW5YIiwic2NyZWVuWSIsIm1ha2VQb2ludGVyIiwidG91Y2giLCJhZGRQb2ludGVyIiwicmVtb3ZlUG9pbnRlciIsInVwZGF0ZVBvaW50ZXIiLCJhZGRUb3VjaGVzVG9FdmVudCIsInBvaW50ZXJJc01vdXNlIiwicG9pbnRlclR5cGUiLCJCUnAkMiIsImdlbmVyYXRlUG9seWdvbiIsIm5vZGVTaGFwZUltcGwiLCJnZW5lcmF0ZUVsbGlwc2UiLCJnZW5lcmF0ZVJvdW5kUG9seWdvbiIsImFsbFBvaW50cyIsInNvdXJjZUluZGV4IiwiZGVzdEluZGV4IiwieERlc3QiLCJ5RGVzdCIsIm5vcm0iLCJnZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlIiwiZGlhbSIsImdlbmVyYXRlQ3V0UmVjdGFuZ2xlIiwiY29ybmVyTGVuZ3RoIiwiZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyIsImNsIiwieEJlZ2luIiwieEVuZCIsInlCZWdpbiIsInlFbmQiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21SaWdodCIsImJvdHRvbUxlZnQiLCJjUHRzIiwiY3V0VHJpYW5nbGVQdHMiLCJnZW5lcmF0ZUJhcnJlbCIsImJQdHMiLCJnZW5lcmF0ZUJhcnJlbEJlemllclB0cyIsImFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMiLCJtMCIsIm0xIiwibTIiLCJjdXJ2ZUNvbnN0YW50cyIsImhPZmZzZXQiLCJ3T2Zmc2V0IiwiY3RybFB0WE9mZnNldCIsImlzVG9wIiwiaXNCb3R0b20iLCJiYXJyZWxDdXJ2ZVB0cyIsImdldEN1cnZlVCIsImN1cnZlUHRzIiwieDAiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwiY29lZmYiLCJ2YWxpZFJvb3RzIiwiY3VydmVSZWdpb25zIiwiY29ybmVyIiwiY29ybmVyUHRzIiwiYmV6WSIsImdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUiLCJ0b3BJbnRlcnNlY3Rpb25zIiwicmVnaXN0ZXJOb2RlU2hhcGVzIiwiZGlhbW9uZFBvaW50cyIsInN0YXI1UG9pbnRzIiwib3V0ZXJQb2ludHMiLCJpbm5lclBvaW50cyIsImlubmVyUmFkaXVzIiwidGFnUG9pbnRzIiwiQlJwJDEiLCJ0aW1lVG9SZW5kZXIiLCJyZWRyYXdUb3RhbFRpbWUiLCJyZWRyYXdDb3VudCIsImF2ZXJhZ2VSZWRyYXdUaW1lIiwibGFzdFJlZHJhd1RpbWUiLCJsYXN0RHJhd1RpbWUiLCJyZXF1ZXN0ZWRGcmFtZSIsInJlbmRlck9wdGlvbnMiLCJwcmlvcml0eSIsImNicyIsImJlZm9yZVJlbmRlckNhbGxiYWNrcyIsInN0YXJ0UmVuZGVyTG9vcCIsInJlbmRlckxvb3BTdGFydGVkIiwicmVuZGVyRm4iLCJyZXF1ZXN0VGltZSIsInNraXBGcmFtZSIsInJlbmRlciIsImVuZFRpbWUiLCJCYXNlUmVuZGVyZXIiLCJCUiIsIkJScCIsImNsaWVudEZ1bmN0aW9ucyIsImN0ciIsInN0eWxlc2hlZXRJZCIsInN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzIiwiaW5uZXJIVE1MIiwiaW5zZXJ0QmVmb3JlIiwiY29tcHV0ZWRTdHlsZSIsInRyaWdnZXJNb2RlIiwiaW5pdGlhbFBhbiIsInJlZHJhd3MiLCJtb3Rpb25CbHVyRW5hYmxlZCIsImZvcmNlZFBpeGVsUmF0aW8iLCJtb3Rpb25CbHVyVHJhbnNwYXJlbmN5IiwibW90aW9uQmx1clB4UmF0aW8iLCJtYlB4UkJsdXJyeSIsIm1pbk1iTG93UXVhbEZyYW1lcyIsImZ1bGxRdWFsaXR5TWIiLCJjbGVhcmVkRm9yTW90aW9uQmx1ciIsImVsZVR4ckRlcSIsImx5clR4ckRlcSIsImx5clR4clNraXAiLCJtYXRjaENhbnZhc1NpemUiLCJiaW5kaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJsYWJlbENhbGNEaXYiLCJmdWxsRnBzVGltZSIsImRlZnMiLCJzZXR1cERlcXVldWVpbmciLCJzZXR1cERlcXVldWVpbmdJbXBsIiwiZGVxdWV1ZWluZ1NldHVwIiwicXVldWVSZWRyYXciLCJkZXFSZWRyYXdUaHJlc2hvbGQiLCJmcmFtZVN0YXJ0VGltZSIsImF2Z1JlbmRlclRpbWUiLCJyZW5kZXJUaW1lIiwiZGVxZCIsImdldFBpeGVsUmF0aW8iLCJmcmFtZUR1cmF0aW9uIiwidGltZUF2YWlsYWJsZSIsImRlcUZhc3RDb3N0IiwiZGVxQ29zdCIsImRlcUF2Z0Nvc3QiLCJkZXFOb0RyYXdDb3N0IiwidGhpc0RlcWQiLCJkZXEiLCJvbkRlcWQiLCJzaG91bGRSZWRyYXciLCJFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwIiwiZG9lc0VsZUludmFsaWRhdGVLZXkiLCJpZHNCeUtleSIsImtleUZvcklkIiwiY2FjaGVzQnlMdmwiLCJsdmxzIiwiZ2V0SWRzRm9yIiwiYWRkSWRGb3JLZXkiLCJkZWxldGVJZEZvcktleSIsImdldE51bWJlck9mSWRzRm9yS2V5IiwidXBkYXRlS2V5TWFwcGluZ0ZvciIsImN1cnJLZXkiLCJkZWxldGVLZXlNYXBwaW5nRm9yIiwia2V5SGFzQ2hhbmdlZEZvciIsIm5ld0tleSIsImlzSW52YWxpZCIsImdldENhY2hlc0F0IiwibHZsIiwiY2FjaGVzIiwiZ2V0Q2FjaGUiLCJnZXRGb3JDYWNoZWRLZXkiLCJoYXNDYWNoZSIsInNldENhY2hlIiwiZGVsZXRlQ2FjaGUiLCJpbnZhbGlkYXRlS2V5IiwiaW52YWxpZGF0ZSIsImVudGlyZUtleUludmFsaWRhdGVkIiwibWluVHhySCIsInR4clN0ZXBIIiwibWluTHZsJDEiLCJtYXhMdmwkMSIsIm1heFpvb20kMSIsImVsZVR4clNwYWNpbmciLCJkZWZUeHJXaWR0aCIsIm1heFR4clciLCJtYXhUeHJIIiwibWluVXRpbGl0eSIsIm1heEZ1bGxuZXNzIiwibWF4RnVsbG5lc3NDaGVja3MiLCJkZXFDb3N0JDEiLCJkZXFBdmdDb3N0JDEiLCJkZXFOb0RyYXdDb3N0JDEiLCJkZXFGYXN0Q29zdCQxIiwiZGVxUmVkcmF3VGhyZXNob2xkJDEiLCJtYXhEZXFTaXplJDEiLCJnZXRUeHJSZWFzb25zIiwiZG93bnNjYWxlIiwiaGlnaFF1YWxpdHkiLCJpbml0RGVmYXVsdHMiLCJkcmF3RWxlbWVudCIsImdldEJvdW5kaW5nQm94IiwiZ2V0Um90YXRpb25Qb2ludCIsImdldFJvdGF0aW9uT2Zmc2V0IiwiaXNWaXNpYmxlIiwiYWxsb3dFZGdlVHhyQ2FjaGluZyIsImFsbG93UGFyZW50VHhyQ2FjaGluZyIsIkVsZW1lbnRUZXh0dXJlQ2FjaGUiLCJpbml0T3B0aW9ucyIsIm9uRGVxdWV1ZXMiLCJFVENwIiwicmVhc29ucyIsImdldFRleHR1cmVRdWV1ZSIsInR4ckgiLCJlbGVJbWdDYWNoZXMiLCJnZXRSZXRpcmVkVGV4dHVyZVF1ZXVlIiwicnR4dHJRcyIsInJldGlyZWQiLCJydHh0clEiLCJnZXRFbGVtZW50UXVldWUiLCJlbGVDYWNoZVF1ZXVlIiwicmVxcyIsImdldEVsZW1lbnRLZXlUb1F1ZXVlIiwiazJxIiwiZWxlS2V5VG9DYWNoZVF1ZXVlIiwiZ2V0RWxlbWVudCIsInJlYXNvbiIsImVsZVNjYWxlZEgiLCJlbGVTY2FsZWRXIiwic2NhbGVkTGFiZWxTaG93biIsImVsZVRleHRCaWdnZXJUaGFuTWluIiwiZWxlQ2FjaGUiLCJpbnZhbGlkYXRlZCIsInRleHR1cmUiLCJpbnZhbGlkYXRlZFdpZHRoIiwidHhyUSIsInR4ciIsImFkZE5ld1R4ciIsInJlY3ljbGVUZXh0dXJlIiwiYWRkVGV4dHVyZSIsInVzZWRXaWR0aCIsInNjYWxhYmxlRnJvbSIsIm90aGVyQ2FjaGUiLCJkZXFpbmciLCJoaWdoUXVhbGl0eVJlcSIsImRvd25zY2FsZVJlcSIsImhpZ2hlckNhY2hlIiwib25lVXBDYWNoZSIsImRyYXdJbWFnZSIsInNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsInF1ZXVlRWxlbWVudCIsImxvd2VyQ2FjaGUiLCJfbDIiLCJ0cmFuc2xhdGUiLCJlbGVDYWNoZXMiLCJjaGVja1RleHR1cmVGdWxsbmVzcyIsImludmFsaWRhdGVFbGVtZW50cyIsImludmFsaWRhdGVFbGVtZW50Iiwibm9PdGhlckVsZXNVc2VDYWNoZSIsIl9jYWNoZSIsImNoZWNrVGV4dHVyZVV0aWxpdHkiLCJyZW1vdmVGcm9tUXVldWUiLCJyZXRpcmVUZXh0dXJlIiwiZnVsbG5lc3NDaGVja3MiLCJtaW5XIiwibWFrZU9mZnNjcmVlbkNhbnZhcyIsImV4aXN0aW5nUmVxIiwicmVxIiwiZGVxdWV1ZWQiLCJjYWNoZUV4aXN0cyIsIm9uRGVxdWV1ZSIsIm9mZkRlcXVldWUiLCJkZWZOdW1MYXllcnMiLCJtaW5MdmwiLCJtYXhMdmwiLCJyZWZpbmVFbGVEZWJvdW5jZVRpbWUiLCJtYXhEZXFTaXplIiwiaW52YWxpZFRocmVzaG9sZCIsIm1heExheWVyQXJlYSIsInVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyIsIkxheWVyZWRUZXh0dXJlQ2FjaGUiLCJsYXllcnNCeUxldmVsIiwiZmlyc3RHZXQiLCJsYXN0SW52YWxpZGF0aW9uVGltZSIsInNraXBwaW5nIiwiZWxlVHhyRGVxcyIsInNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQiLCJyZWZpbmVFbGVtZW50VGV4dHVyZXMiLCJxU29ydCIsImxheWVyc1F1ZXVlIiwiTFRDcCIsImxheWVySWRQb29sIiwiTUFYX0lOVCIsIm1ha2VMYXllciIsImxheWVyIiwiZWxlc1F1ZXVlIiwiZ2V0TGF5ZXJzIiwidmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmciLCJsYXllcnNCeUx2bCIsImxheWVycyIsImx2bENvbXBsZXRlIiwibGV2ZWxJc0NvbXBsZXRlIiwidG1wTGF5ZXJzIiwiY2hlY2tUZW1wTGV2ZWxzIiwiY2FuVXNlQXNUbXBMdmwiLCJjaGVja0x2bHMiLCJkaXIiLCJnZXRCYiIsImFmdGVyIiwiYXJlYSIsIm1heEVsZXNQZXJMYXllciIsImFsbG93TGF6eVF1ZXVlaW5nIiwiaW1nTGF5ZXJDYWNoZXMiLCJleGlzdGluZ0xheWVyIiwicXVldWVMYXllciIsImRyYXdFbGVJbkxheWVyIiwiZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsIiwic2V0SW1nU21vb3RoaW5nIiwiZHJhd0NhY2hlZEVsZW1lbnQiLCJudW1FbGVzSW5MYXllcnMiLCJpbnZhbGlkYXRlTGF5ZXIiLCJ1cGRhdGVFbGVtZW50c0luTGF5ZXJzIiwiaGF2ZUxheWVycyIsImludmFsQXNzb2NMYXllcnMiLCJyZXBsYWNlbWVudCIsInJlZmluZUVhY2hFbGUiLCJyTHlyIiwicmVwbGFjZXMiLCJlbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQiLCJlbGVzUSIsImhhc0lkIiwiZWxlRGVxcyIsImFwcGx5TGF5ZXJSZXBsYWNlbWVudCIsInJlcXVlc3RSZWRyYXciLCJsYXllcnNJbkxldmVsIiwicmVwbGFjZWQiLCJDUnAkYSIsInBvbHlnb24iLCJsaW5lVG8iLCJ0cmlhbmdsZUJhY2tjdXJ2ZSIsImZpcnN0UHQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwidHJpYW5nbGVUZWUiLCJ0cmlhbmdsZVBvaW50cyIsInRlZVBvaW50cyIsImJlZ2luUGF0aCIsImZpcnN0VGVlUHQiLCJtb3ZlVG8iLCJjbG9zZVBhdGgiLCJjaXJjbGVUcmlhbmdsZSIsImFyYyIsImZpcnN0VHJQdCIsIkNScCQ5Iiwic2hpZnRUb09yaWdpbldpdGhCYiIsInNob3dMYWJlbCIsInNob3dPdmVybGF5Iiwic2hvd09wYWNpdHkiLCJkcmF3Tm9kZSIsImRyYXdFZGdlIiwiZHJhd0VsZW1lbnRPdmVybGF5IiwiZHJhd05vZGVPdmVybGF5IiwiZHJhd0VkZ2VPdmVybGF5IiwiZHJhd0VsZW1lbnRVbmRlcmxheSIsImRyYXdOb2RlVW5kZXJsYXkiLCJkcmF3RWRnZVVuZGVybGF5IiwiZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uIiwiZWxlVHhyQ2FjaGUiLCJnZXRSb3RhdGlvbiIsImdldE9wYWNpdHkiLCJzbW9vdGgiLCJyb3RQdCIsImdldEltZ1Ntb290aGluZyIsIm9sZEdsb2JhbEFscGhhIiwiZ2xvYmFsQWxwaGEiLCJnZXRaZXJvUm90YXRpb24iLCJnZXRMYWJlbFJvdGF0aW9uIiwiZ2V0VGV4dEFuZ2xlIiwiZ2V0U291cmNlTGFiZWxSb3RhdGlvbiIsImdldFRhcmdldExhYmVsUm90YXRpb24iLCJnZXRUZXh0T3BhY2l0eSIsInJlcXVlc3RIaWdoUXVhbGl0eSIsIl9yJGRhdGEiLCJsYmxUeHJDYWNoZSIsInNsYlR4ckNhY2hlIiwidGxiVHhyQ2FjaGUiLCJkcmF3RWxlbWVudHMiLCJkcmF3Q2FjaGVkRWxlbWVudHMiLCJkcmF3Q2FjaGVkTm9kZXMiLCJkcmF3TGF5ZXJlZEVsZW1lbnRzIiwibHlyVHhyQ2FjaGUiLCJDUnAkOCIsImRyYXdMYWJlbCIsInNob3VsZERyYXdPdmVybGF5Iiwic2hvdWxkRHJhd09wYWNpdHkiLCJsaW5lT3BhY2l0eSIsImVmZmVjdGl2ZUxpbmVPcGFjaXR5IiwiZWZmZWN0aXZlQXJyb3dPcGFjaXR5IiwiZHJhd0xpbmUiLCJzdHJva2VPcGFjaXR5IiwiZWxlU3Ryb2tlU3R5bGUiLCJkcmF3RWRnZVRyaWFuZ2xlUGF0aCIsImxpbmVXaWR0aCIsImRyYXdFZGdlUGF0aCIsImRyYXdPdmVybGF5IiwiZHJhd1VuZGVybGF5IiwiZHJhd0Fycm93cyIsImFycm93T3BhY2l0eSIsImRyYXdBcnJvd2hlYWRzIiwiZHJhd1RleHQiLCJkcmF3RWxlbWVudFRleHQiLCJsaW5lSm9pbiIsImdob3N0T3BhY2l0eSIsImVmZmVjdGl2ZUdob3N0T3BhY2l0eSIsImRyYXdFZGdlT3ZlcmxheVVuZGVybGF5Iiwib3ZlcmxheU9yVW5kZXJsYXkiLCJpbmNsdWRlcyIsInVzZVBhdGhzIiwiY29sb3JTdHJva2VTdHlsZSIsImNhbnZhc0N4dCIsInBhdGhDYWNoZUhpdCIsImxpbmVEYXNoUGF0dGVybiIsImxpbmVEYXNoT2Zmc2V0IiwicGF0aENhY2hlS2V5Iiwia2V5TWF0Y2hlcyIsInBhdGhDYWNoZSIsIlBhdGgyRCIsInNldExpbmVEYXNoIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJub3JtYWwiLCJ0cmlhbmdsZUhlYWQiLCJkcmF3QXJyb3doZWFkIiwiYXJyb3dDbGVhckZpbGwiLCJlZGdlT3BhY2l0eSIsImdjbyIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImNvbG9yRmlsbFN0eWxlIiwiZHJhd0Fycm93U2hhcGUiLCJjYW52YXNDb250ZXh0Iiwic2hhcGVJbXBsIiwiYXJyb3dQYXRoQ2FjaGUiLCJjYWNoZWRQYXRoIiwibWF0Y2hFZGdlV2lkdGgiLCJDUnAkNyIsInNhZmVEcmF3SW1hZ2UiLCJpbWciLCJpeCIsIml5IiwiaXciLCJpaCIsImRyYXdJbnNjcmliZWRJbWFnZSIsIm5vZGVPcGFjaXR5Iiwic3R5bGVPYmoiLCJyZXBlYXQiLCJwYWRkaW5nWDIiLCJub2RlVFciLCJub2RlVEgiLCJjbGlwIiwic2hvdWxkQ2xpcCIsImltZ09wYWNpdHkiLCJpbWdXIiwiY2FjaGVkVyIsImltZ0giLCJjYWNoZWRIIiwiYXBwZW5kQ2hpbGQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInBvc1hVbml0cyIsInBvc1hQZlZhbCIsIm9mZlhVbml0cyIsIm9mZlhQZlZhbCIsInBvc1lVbml0cyIsInBvc1lQZlZhbCIsIm9mZllVbml0cyIsIm9mZllQZlZhbCIsImdBbHBoYSIsInNtb290aGluZ0VuYWJsZWQiLCJpc1Ntb290aGluZ1N3aXRjaGVkIiwic2F2ZSIsImNyZWF0ZVBhdHRlcm4iLCJDUnAkNiIsImNvbXB1dGVkU2l6ZSIsIm1pblNpemUiLCJ1c2VFbGVPcGFjaXR5IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiX2xhYmVsIiwic3JjTGFiZWwiLCJ0Z3RMYWJlbCIsImFwcGx5Um90YXRpb24iLCJnZXRGb250Q2FjaGUiLCJmb250Q2FjaGVzIiwic2V0dXBUZXh0U3R5bGUiLCJsYWJlbFN0eWxlIiwibGFiZWxTaXplIiwibGFiZWxGYW1pbHkiLCJsYWJlbFdlaWdodCIsIm91dGxpbmVPcGFjaXR5Iiwib3V0bGluZUNvbG9yIiwicm91bmRSZWN0IiwiY3R4IiwicGRhc2giLCJ0ZXh0QW5nbGUiLCJvcmdUZXh0WCIsIm9yZ1RleHRZIiwidGV4dFciLCJ0ZXh0SCIsImJhY2tncm91bmRPcGFjaXR5IiwiYm9yZGVyT3BhY2l0eSIsInRleHRCb3JkZXJXaWR0aCIsImJhY2tncm91bmRQYWRkaW5nIiwiYmdYIiwiYmdZIiwiYmdXIiwiYmdIIiwidGV4dEZpbGwiLCJ0ZXh0QmFja2dyb3VuZENvbG9yIiwic3R5bGVTaGFwZSIsImZpbGxSZWN0IiwidGV4dFN0cm9rZSIsInRleHRMaW5lV2lkdGgiLCJ0ZXh0Qm9yZGVyQ29sb3IiLCJ0ZXh0Qm9yZGVyU3R5bGUiLCJzdHJva2VSZWN0Iiwid2hpdGVXaWR0aCIsImhhbGZUZXh0VyIsInN0cm9rZVRleHQiLCJmaWxsVGV4dCIsIkNScCQ1IiwiZWxlT3BhY2l0eSIsImJnSW1nUHJvcCIsInVybERlZmluZWQiLCJudW1JbWFnZXMiLCJkZWZkIiwiYmdJbWdDcm9zc09yaWdpbiIsImJhY2tncm91bmRUaW1lc3RhbXAiLCJkYXJrbmVzcyIsImJnT3BhY2l0eSIsImJvcmRlckNvbG9yIiwic2V0dXBTaGFwZUNvbG9yIiwiYmdPcHkiLCJlbGVGaWxsU3R5bGUiLCJzZXR1cEJvcmRlckNvbG9yIiwiYmRyT3B5Iiwic2hhcGVQdHMiLCJub2RlUGF0aENhY2hlIiwiZHJhd1NoYXBlIiwiZHJhd0ltYWdlcyIsInByZXZCZ2luZyIsInRvdGFsQ29tcGxldGVkIiwiZHJhd1BpZSIsInJlZHJhd1NoYXBlIiwicGllT3BhY2l0eSIsImRhcmtlbiIsImRhcmtlbk9wYWNpdHkiLCJkcmF3Qm9yZGVyIiwiZWZmR2hvc3RPcGFjaXR5IiwiZHJhd05vZGVPdmVybGF5VW5kZXJsYXkiLCJjeVN0eWxlIiwicGllU2l6ZSIsImxhc3RQZXJjZW50IiwiYW5nbGVTdGFydCIsImFuZ2xlRGVsdGEiLCJhbmdsZUVuZCIsIkNScCQ0IiwibW90aW9uQmx1ckRlbGF5IiwiY29udGV4dHMiLCJiYWNraW5nU3RvcmUiLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJwYWludENhY2hlIiwicGFpbnRDYWNoZXMiLCJuZWVkVG9DcmVhdGVDYWNoZSIsImNyZWF0ZUdyYWRpZW50U3R5bGVGb3IiLCJzaGFwZVN0eWxlTmFtZSIsImdyYWRpZW50U3R5bGUiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsIl9lbmQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsIl93aWR0aCIsIl9oZWlnaHQiLCJoYXNQb3NpdGlvbnMiLCJhZGRDb2xvclN0b3AiLCJncmFkaWVudEZpbGxTdHlsZSIsImJhY2tncm91bmRGaWxsIiwiYmFja2dyb3VuZENvbG9yIiwiZ3JhZGllbnRTdHJva2VTdHlsZSIsImxpbmVGaWxsIiwibGluZUNvbG9yIiwibWJQeFJhdGlvIiwiYnVmZmVyQ2FudmFzZXMiLCJNT1RJT05CTFVSX0JVRkZFUl9OT0RFIiwiTU9USU9OQkxVUl9CVUZGRVJfRFJBRyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzQ29udGFpbmVyIiwiQ0FOVkFTX0xBWUVSUyIsImNhbnZhc2VzIiwiQlVGRkVSX0NPVU5UIiwidGV4dHVyZU11bHQiLCJURVhUVVJFX0JVRkZFUiIsImZvcmNlZENvbnRleHQiLCJmb3JjZWRab29tIiwiZm9yY2VkUGFuIiwiZHJhd0FsbExheWVycyIsImZvcmNlZFB4UmF0aW8iLCJkcmF3T25seU5vZGVMYXllciIsIm5lZWREcmF3IiwiY2FudmFzTmVlZHNSZWRyYXciLCJ0ZXh0dXJlRHJhdyIsImluTm9kZURyYWdHZXN0dXJlIiwibW90aW9uQmx1ckZhZGVFZmZlY3QiLCJwcmV2UHhSYXRpbyIsIm1vdGlvbkJsdXJUaW1lb3V0IiwibWJGcmFtZXMiLCJjbGVhcmluZ01vdGlvbkJsdXIiLCJ0ZXh0dXJlRHJhd0xhc3RGcmFtZSIsIk5PREUiLCJTRUxFQ1RfQk9YIiwiZWZmZWN0aXZlWm9vbSIsImVmZmVjdGl2ZVBhbiIsInByZXZWcCIsInByZXZWaWV3cG9ydCIsInZpZXdwb3J0SXNEaWZmIiwibWJjbGVhciIsInNldENvbnRleHRUcmFuc2Zvcm0iLCJlUGFuIiwiZVpvb20iLCJidWZmZXJDb250ZXh0cyIsInRleHR1cmVDYWNoZSIsIm1wYW4iLCJEUkFHIiwib3V0c2lkZUJnQ29sb3IiLCJvdXRzaWRlQmdPcGFjaXR5IiwidnBNYW5pcCIsImhpZGVFZGdlcyIsIm5lZWRNYkNsZWFyIiwidXNlQnVmZmVyIiwiZHJhd0RlYnVnUG9pbnRzIiwiZnBzIiwibWF4RnBzIiwiY3h0Tm9kZSIsInR4dE5vZGUiLCJjeHREcmFnIiwidHh0RHJhZyIsImRyYXdNb3Rpb25CbHVyIiwidHh0IiwibmVlZENsZWFyIiwicHhyIiwibW90aW9uQmx1ckNsZWFyZWQiLCJDUnAkMyIsImRyYXdQb2x5Z29uUGF0aCIsImRyYXdSb3VuZFBvbHlnb25QYXRoIiwiYXJjVG8iLCJkcmF3Um91bmRSZWN0YW5nbGVQYXRoIiwiZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aCIsImRyYXdDdXRSZWN0YW5nbGVQYXRoIiwiZHJhd0JhcnJlbFBhdGgiLCJiYXJyZWxDdXJ2ZUNvbnN0YW50cyIsInNpbjAiLCJjb3MwIiwiZWxsaXBzZVN0ZXBTaXplIiwiZHJhd0VsbGlwc2VQYXRoIiwiZWxsaXBzZSIsInhQb3MiLCJ5UG9zIiwicnciLCJyaCIsIkNScCQyIiwiY3JlYXRlQnVmZmVyIiwiYnVmZmVyIiwiYnVmZmVyQ2FudmFzSW1hZ2UiLCJjdHJSZWN0IiwiZnVsbCIsInNwZWNkTWF4RGltcyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWF4U2NhbGVXIiwibWF4U2NhbGVIIiwiYnVmZkNhbnZhcyIsImJ1ZmZDeHQiLCJ6c29ydGVkRWxlcyIsImI2NFRvQmxvYiIsImI2NCIsIm1pbWVUeXBlIiwiYnl0ZXMiLCJhdG9iIiwiYnVmZiIsIkFycmF5QnVmZmVyIiwiYnVmZlVpbnQ4IiwiVWludDhBcnJheSIsIkJsb2IiLCJiNjRVcmlUb0I2NCIsImI2NHVyaSIsIm91dHB1dCIsImdldEI2NFVyaSIsInRvRGF0YVVSTCIsInF1YWxpdHkiLCJ0b0Jsb2IiLCJibG9iIiwiQ1JwJDEiLCJDUiIsIkNhbnZhc1JlbmRlcmVyIiwiQ1JwIiwidGFwSGxPZmZBdHRyIiwidGFwSGxPZmZTdHlsZSIsImNvbnRhaW5lclN0eWxlIiwic3R5bGVNYXAiLCJzZXRBdHRyaWJ1dGUiLCJ0b3BDYW52YXMiLCJwYXRoc0VuYWJsZWQiLCJlbXB0eUJiIiwiZ2V0Qm94Q2VudGVyIiwiZ2V0Q2VudGVyT2Zmc2V0IiwiYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQiLCJvbGRCYWNrZ3JvdW5kVGltZXN0YW1wIiwiZ2V0U3R5bGVLZXkiLCJnZXRMYWJlbEtleSIsImdldFNvdXJjZUxhYmVsS2V5IiwiZ2V0VGFyZ2V0TGFiZWxLZXkiLCJkcmF3U291cmNlTGFiZWwiLCJkcmF3VGFyZ2V0TGFiZWwiLCJnZXRFbGVtZW50Qm94IiwiZ2V0TGFiZWxCb3giLCJnZXRTb3VyY2VMYWJlbEJveCIsImdldFRhcmdldExhYmVsQm94IiwiaXNMYWJlbFZpc2libGVBdFNjYWxlIiwiZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQiLCJhZGRUZXh0TWFyZ2luIiwiZ2V0UnNQdCIsImdldExhYmVsUm90YXRpb25Qb2ludCIsImdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCIsImdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCIsImdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCIsImdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQiLCJnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0IiwiZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCIsImludmFsaWRhdGVUZXh0dXJlQ2FjaGVzIiwicmVmaW5lSW5MYXllcnMiLCJwYXRoc0ltcGxkIiwicGF0aDJkRW5hYmxlZCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwiaW5jRXh0cyIsImV4dGVuc2lvbnMiLCJtb2R1bGVzIiwic2V0RXh0ZW5zaW9uIiwicmVnaXN0cmFudCIsImV4dCIsIm92ZXJyaWRlRXJyIiwibGF5b3V0UHJvdG8iLCJvcHRMYXlvdXRGbnMiLCJmbk5hbWUiLCJyZWdTdG9wIiwiZ2V0Q3kiLCJlbWl0dGVyT3B0cyIsImdldEV4dGVuc2lvbiIsImJQcm90byIsIlJlZ2lzdHJhbnRSZW5kZXJlciIsInJQcm90byIsIlJlbmRlcmVyIiwicE5hbWUiLCJwVmFsIiwiZXhpc3RzSW5SIiwiX3BOYW1lIiwic2V0TW9kdWxlIiwibW9kdWxlVHlwZSIsIm1vZHVsZU5hbWUiLCJnZXRNb2R1bGUiLCJTdHlsZXNoZWV0Iiwic2hlZXRmbiIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape/dist/cytoscape.umd.js\n");

/***/ })

};
;
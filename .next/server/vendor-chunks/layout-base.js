"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/layout-base";
exports.ids = ["vendor-chunks/layout-base"];
exports.modules = {

/***/ "(ssr)/./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_577__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_577__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_577__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_577__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_577__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_577__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_577__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_577__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_577__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_577__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_577__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_577__(__nested_webpack_require_577__.s = 26);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LayoutConstants() {}\n            /**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */ LayoutConstants.QUALITY = 1;\n            /**\r\n * Default parameters\r\n */ LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n            LayoutConstants.DEFAULT_INCREMENTAL = false;\n            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n            // -----------------------------------------------------------------------------\n            // Section: General other constants\n            // -----------------------------------------------------------------------------\n            /*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */ LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n            /*\r\n * Whether to consider labels in node dimensions or not\r\n */ LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_SIZE = 40;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n            /*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */ LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n            /*\r\n * Minimum length that an edge should take during layout\r\n */ LayoutConstants.MIN_EDGE_LENGTH = 1;\n            /*\r\n * World boundaries that layout operates on\r\n */ LayoutConstants.WORLD_BOUNDARY = 1000000;\n            /*\r\n * World boundaries that random positioning can be performed with\r\n */ LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n            /*\r\n * Coordinates of the world center\r\n */ LayoutConstants.WORLD_CENTER_X = 1200;\n            LayoutConstants.WORLD_CENTER_Y = 900;\n            module1.exports = LayoutConstants;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_5702__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_5702__(2);\n            var IGeometry = __nested_webpack_require_5702__(8);\n            var IMath = __nested_webpack_require_5702__(9);\n            function LEdge(source, target, vEdge) {\n                LGraphObject.call(this, vEdge);\n                this.isOverlapingSourceAndTarget = false;\n                this.vGraphObject = vEdge;\n                this.bendpoints = [];\n                this.source = source;\n                this.target = target;\n            }\n            LEdge.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LEdge[prop] = LGraphObject[prop];\n            }\n            LEdge.prototype.getSource = function() {\n                return this.source;\n            };\n            LEdge.prototype.getTarget = function() {\n                return this.target;\n            };\n            LEdge.prototype.isInterGraph = function() {\n                return this.isInterGraph;\n            };\n            LEdge.prototype.getLength = function() {\n                return this.length;\n            };\n            LEdge.prototype.isOverlapingSourceAndTarget = function() {\n                return this.isOverlapingSourceAndTarget;\n            };\n            LEdge.prototype.getBendpoints = function() {\n                return this.bendpoints;\n            };\n            LEdge.prototype.getLca = function() {\n                return this.lca;\n            };\n            LEdge.prototype.getSourceInLca = function() {\n                return this.sourceInLca;\n            };\n            LEdge.prototype.getTargetInLca = function() {\n                return this.targetInLca;\n            };\n            LEdge.prototype.getOtherEnd = function(node) {\n                if (this.source === node) {\n                    return this.target;\n                } else if (this.target === node) {\n                    return this.source;\n                } else {\n                    throw \"Node is not incident with this edge\";\n                }\n            };\n            LEdge.prototype.getOtherEndInGraph = function(node, graph) {\n                var otherEnd = this.getOtherEnd(node);\n                var root = graph.getGraphManager().getRoot();\n                while(true){\n                    if (otherEnd.getOwner() == graph) {\n                        return otherEnd;\n                    }\n                    if (otherEnd.getOwner() == root) {\n                        break;\n                    }\n                    otherEnd = otherEnd.getOwner().getParent();\n                }\n                return null;\n            };\n            LEdge.prototype.updateLength = function() {\n                var clipPointCoordinates = new Array(4);\n                this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n                if (!this.isOverlapingSourceAndTarget) {\n                    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n                    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n                    if (Math.abs(this.lengthX) < 1.0) {\n                        this.lengthX = IMath.sign(this.lengthX);\n                    }\n                    if (Math.abs(this.lengthY) < 1.0) {\n                        this.lengthY = IMath.sign(this.lengthY);\n                    }\n                    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n                }\n            };\n            LEdge.prototype.updateLengthSimple = function() {\n                this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n                this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n                if (Math.abs(this.lengthX) < 1.0) {\n                    this.lengthX = IMath.sign(this.lengthX);\n                }\n                if (Math.abs(this.lengthY) < 1.0) {\n                    this.lengthY = IMath.sign(this.lengthY);\n                }\n                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n            };\n            module1.exports = LEdge;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LGraphObject(vGraphObject) {\n                this.vGraphObject = vGraphObject;\n            }\n            module1.exports = LGraphObject;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10242__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_10242__(2);\n            var Integer = __nested_webpack_require_10242__(10);\n            var RectangleD = __nested_webpack_require_10242__(13);\n            var LayoutConstants = __nested_webpack_require_10242__(0);\n            var RandomSeed = __nested_webpack_require_10242__(16);\n            var PointD = __nested_webpack_require_10242__(4);\n            function LNode(gm, loc, size, vNode) {\n                //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n                if (size == null && vNode == null) {\n                    vNode = loc;\n                }\n                LGraphObject.call(this, vNode);\n                //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n                if (gm.graphManager != null) gm = gm.graphManager;\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.inclusionTreeDepth = Integer.MAX_VALUE;\n                this.vGraphObject = vNode;\n                this.edges = [];\n                this.graphManager = gm;\n                if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n                else this.rect = new RectangleD();\n            }\n            LNode.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LNode[prop] = LGraphObject[prop];\n            }\n            LNode.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LNode.prototype.getChild = function() {\n                return this.child;\n            };\n            LNode.prototype.getOwner = function() {\n                //  if (this.owner != null) {\n                //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n                //      throw \"assert failed\";\n                //    }\n                //  }\n                return this.owner;\n            };\n            LNode.prototype.getWidth = function() {\n                return this.rect.width;\n            };\n            LNode.prototype.setWidth = function(width) {\n                this.rect.width = width;\n            };\n            LNode.prototype.getHeight = function() {\n                return this.rect.height;\n            };\n            LNode.prototype.setHeight = function(height) {\n                this.rect.height = height;\n            };\n            LNode.prototype.getCenterX = function() {\n                return this.rect.x + this.rect.width / 2;\n            };\n            LNode.prototype.getCenterY = function() {\n                return this.rect.y + this.rect.height / 2;\n            };\n            LNode.prototype.getCenter = function() {\n                return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n            };\n            LNode.prototype.getLocation = function() {\n                return new PointD(this.rect.x, this.rect.y);\n            };\n            LNode.prototype.getRect = function() {\n                return this.rect;\n            };\n            LNode.prototype.getDiagonal = function() {\n                return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n            };\n            /**\n * This method returns half the diagonal length of this node.\n */ LNode.prototype.getHalfTheDiagonal = function() {\n                return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n            };\n            LNode.prototype.setRect = function(upperLeft, dimension) {\n                this.rect.x = upperLeft.x;\n                this.rect.y = upperLeft.y;\n                this.rect.width = dimension.width;\n                this.rect.height = dimension.height;\n            };\n            LNode.prototype.setCenter = function(cx, cy) {\n                this.rect.x = cx - this.rect.width / 2;\n                this.rect.y = cy - this.rect.height / 2;\n            };\n            LNode.prototype.setLocation = function(x, y) {\n                this.rect.x = x;\n                this.rect.y = y;\n            };\n            LNode.prototype.moveBy = function(dx, dy) {\n                this.rect.x += dx;\n                this.rect.y += dy;\n            };\n            LNode.prototype.getEdgeListToNode = function(to) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.target == to) {\n                        if (edge.source != self) throw \"Incorrect edge source!\";\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getEdgesBetween = function(other) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n                    if (edge.target == other || edge.source == other) {\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getNeighborsList = function() {\n                var neighbors = new Set();\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.source == self) {\n                        neighbors.add(edge.target);\n                    } else {\n                        if (edge.target != self) {\n                            throw \"Incorrect incidency!\";\n                        }\n                        neighbors.add(edge.source);\n                    }\n                });\n                return neighbors;\n            };\n            LNode.prototype.withChildren = function() {\n                var withNeighborsList = new Set();\n                var childNode;\n                var children;\n                withNeighborsList.add(this);\n                if (this.child != null) {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        children = childNode.withChildren();\n                        children.forEach(function(node) {\n                            withNeighborsList.add(node);\n                        });\n                    }\n                }\n                return withNeighborsList;\n            };\n            LNode.prototype.getNoOfChildren = function() {\n                var noOfChildren = 0;\n                var childNode;\n                if (this.child == null) {\n                    noOfChildren = 1;\n                } else {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        noOfChildren += childNode.getNoOfChildren();\n                    }\n                }\n                if (noOfChildren == 0) {\n                    noOfChildren = 1;\n                }\n                return noOfChildren;\n            };\n            LNode.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LNode.prototype.calcEstimatedSize = function() {\n                if (this.child == null) {\n                    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n                } else {\n                    this.estimatedSize = this.child.calcEstimatedSize();\n                    this.rect.width = this.estimatedSize;\n                    this.rect.height = this.estimatedSize;\n                    return this.estimatedSize;\n                }\n            };\n            LNode.prototype.scatter = function() {\n                var randomCenterX;\n                var randomCenterY;\n                var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n                var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n                this.rect.x = randomCenterX;\n                this.rect.y = randomCenterY;\n            };\n            LNode.prototype.updateBounds = function() {\n                if (this.getChild() == null) {\n                    throw \"assert failed\";\n                }\n                if (this.getChild().getNodes().length != 0) {\n                    // wrap the children nodes by re-arranging the boundaries\n                    var childGraph = this.getChild();\n                    childGraph.updateBounds(true);\n                    this.rect.x = childGraph.getLeft();\n                    this.rect.y = childGraph.getTop();\n                    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n                    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n                    // Update compound bounds considering its label properties    \n                    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                        var width = childGraph.getRight() - childGraph.getLeft();\n                        var height = childGraph.getBottom() - childGraph.getTop();\n                        if (this.labelWidth > width) {\n                            this.rect.x -= (this.labelWidth - width) / 2;\n                            this.setWidth(this.labelWidth);\n                        }\n                        if (this.labelHeight > height) {\n                            if (this.labelPos == \"center\") {\n                                this.rect.y -= (this.labelHeight - height) / 2;\n                            } else if (this.labelPos == \"top\") {\n                                this.rect.y -= this.labelHeight - height;\n                            }\n                            this.setHeight(this.labelHeight);\n                        }\n                    }\n                }\n            };\n            LNode.prototype.getInclusionTreeDepth = function() {\n                if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.inclusionTreeDepth;\n            };\n            LNode.prototype.transform = function(trans) {\n                var left = this.rect.x;\n                if (left > LayoutConstants.WORLD_BOUNDARY) {\n                    left = LayoutConstants.WORLD_BOUNDARY;\n                } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n                    left = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var top = this.rect.y;\n                if (top > LayoutConstants.WORLD_BOUNDARY) {\n                    top = LayoutConstants.WORLD_BOUNDARY;\n                } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n                    top = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var leftTop = new PointD(left, top);\n                var vLeftTop = trans.inverseTransformPoint(leftTop);\n                this.setLocation(vLeftTop.x, vLeftTop.y);\n            };\n            LNode.prototype.getLeft = function() {\n                return this.rect.x;\n            };\n            LNode.prototype.getRight = function() {\n                return this.rect.x + this.rect.width;\n            };\n            LNode.prototype.getTop = function() {\n                return this.rect.y;\n            };\n            LNode.prototype.getBottom = function() {\n                return this.rect.y + this.rect.height;\n            };\n            LNode.prototype.getParent = function() {\n                if (this.owner == null) {\n                    return null;\n                }\n                return this.owner.getParent();\n            };\n            module1.exports = LNode;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function PointD(x, y) {\n                if (x == null && y == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else {\n                    this.x = x;\n                    this.y = y;\n                }\n            }\n            PointD.prototype.getX = function() {\n                return this.x;\n            };\n            PointD.prototype.getY = function() {\n                return this.y;\n            };\n            PointD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            PointD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            PointD.prototype.getDifference = function(pt) {\n                return new DimensionD(this.x - pt.x, this.y - pt.y);\n            };\n            PointD.prototype.getCopy = function() {\n                return new PointD(this.x, this.y);\n            };\n            PointD.prototype.translate = function(dim) {\n                this.x += dim.width;\n                this.y += dim.height;\n                return this;\n            };\n            module1.exports = PointD;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_23748__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_23748__(2);\n            var Integer = __nested_webpack_require_23748__(10);\n            var LayoutConstants = __nested_webpack_require_23748__(0);\n            var LGraphManager = __nested_webpack_require_23748__(6);\n            var LNode = __nested_webpack_require_23748__(3);\n            var LEdge = __nested_webpack_require_23748__(1);\n            var RectangleD = __nested_webpack_require_23748__(13);\n            var Point1 = __nested_webpack_require_23748__(12);\n            var LinkedList = __nested_webpack_require_23748__(11);\n            function LGraph(parent, obj2, vGraph) {\n                LGraphObject.call(this, vGraph);\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n                this.edges = [];\n                this.nodes = [];\n                this.isConnected = false;\n                this.parent = parent;\n                if (obj2 != null && obj2 instanceof LGraphManager) {\n                    this.graphManager = obj2;\n                } else if (obj2 != null && obj2 instanceof Layout) {\n                    this.graphManager = obj2.graphManager;\n                }\n            }\n            LGraph.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LGraph[prop] = LGraphObject[prop];\n            }\n            LGraph.prototype.getNodes = function() {\n                return this.nodes;\n            };\n            LGraph.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LGraph.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            LGraph.prototype.getParent = function() {\n                return this.parent;\n            };\n            LGraph.prototype.getLeft = function() {\n                return this.left;\n            };\n            LGraph.prototype.getRight = function() {\n                return this.right;\n            };\n            LGraph.prototype.getTop = function() {\n                return this.top;\n            };\n            LGraph.prototype.getBottom = function() {\n                return this.bottom;\n            };\n            LGraph.prototype.isConnected = function() {\n                return this.isConnected;\n            };\n            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {\n                if (sourceNode == null && targetNode == null) {\n                    var newNode = obj1;\n                    if (this.graphManager == null) {\n                        throw \"Graph has no graph mgr!\";\n                    }\n                    if (this.getNodes().indexOf(newNode) > -1) {\n                        throw \"Node already in graph!\";\n                    }\n                    newNode.owner = this;\n                    this.getNodes().push(newNode);\n                    return newNode;\n                } else {\n                    var newEdge = obj1;\n                    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n                        throw \"Source or target not in graph!\";\n                    }\n                    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n                        throw \"Both owners must be this graph!\";\n                    }\n                    if (sourceNode.owner != targetNode.owner) {\n                        return null;\n                    }\n                    // set source and target\n                    newEdge.source = sourceNode;\n                    newEdge.target = targetNode;\n                    // set as intra-graph edge\n                    newEdge.isInterGraph = false;\n                    // add to graph edge list\n                    this.getEdges().push(newEdge);\n                    // add to incidency lists\n                    sourceNode.edges.push(newEdge);\n                    if (targetNode != sourceNode) {\n                        targetNode.edges.push(newEdge);\n                    }\n                    return newEdge;\n                }\n            };\n            LGraph.prototype.remove = function(obj) {\n                var node = obj;\n                if (obj instanceof LNode) {\n                    if (node == null) {\n                        throw \"Node is null!\";\n                    }\n                    if (!(node.owner != null && node.owner == this)) {\n                        throw \"Owner graph is invalid!\";\n                    }\n                    if (this.graphManager == null) {\n                        throw \"Owner graph manager is invalid!\";\n                    }\n                    // remove incident edges first (make a copy to do it safely)\n                    var edgesToBeRemoved = node.edges.slice();\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        if (edge.isInterGraph) {\n                            this.graphManager.remove(edge);\n                        } else {\n                            edge.source.owner.remove(edge);\n                        }\n                    }\n                    // now the node itself\n                    var index = this.nodes.indexOf(node);\n                    if (index == -1) {\n                        throw \"Node not in owner node list!\";\n                    }\n                    this.nodes.splice(index, 1);\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n                        throw \"Source and/or target owner is invalid!\";\n                    }\n                    var sourceIndex = edge.source.edges.indexOf(edge);\n                    var targetIndex = edge.target.edges.indexOf(edge);\n                    if (!(sourceIndex > -1 && targetIndex > -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    edge.source.edges.splice(sourceIndex, 1);\n                    if (edge.target != edge.source) {\n                        edge.target.edges.splice(targetIndex, 1);\n                    }\n                    var index = edge.source.owner.getEdges().indexOf(edge);\n                    if (index == -1) {\n                        throw \"Not in owner's edge list!\";\n                    }\n                    edge.source.owner.getEdges().splice(index, 1);\n                }\n            };\n            LGraph.prototype.updateLeftTop = function() {\n                var top = Integer.MAX_VALUE;\n                var left = Integer.MAX_VALUE;\n                var nodeTop;\n                var nodeLeft;\n                var margin;\n                var nodes = this.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeTop = lNode.getTop();\n                    nodeLeft = lNode.getLeft();\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                }\n                // Do we have any nodes in this graph?\n                if (top == Integer.MAX_VALUE) {\n                    return null;\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = left - margin;\n                this.top = top - margin;\n                // Apply the margins and return the result\n                return new Point1(this.left, this.top);\n            };\n            LGraph.prototype.updateBounds = function(recursive) {\n                // calculate bounds\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var margin;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    if (recursive && lNode.child != null) {\n                        lNode.updateBounds();\n                    }\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                if (left == Integer.MAX_VALUE) {\n                    this.left = this.parent.getLeft();\n                    this.right = this.parent.getRight();\n                    this.top = this.parent.getTop();\n                    this.bottom = this.parent.getBottom();\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = boundingRect.x - margin;\n                this.right = boundingRect.x + boundingRect.width + margin;\n                this.top = boundingRect.y - margin;\n                this.bottom = boundingRect.y + boundingRect.height + margin;\n            };\n            LGraph.calculateBounds = function(nodes) {\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                return boundingRect;\n            };\n            LGraph.prototype.getInclusionTreeDepth = function() {\n                if (this == this.graphManager.getRoot()) {\n                    return 1;\n                } else {\n                    return this.parent.getInclusionTreeDepth();\n                }\n            };\n            LGraph.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.calcEstimatedSize = function() {\n                var size = 0;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    size += lNode.calcEstimatedSize();\n                }\n                if (size == 0) {\n                    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n                } else {\n                    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.updateConnected = function() {\n                var self = this;\n                if (this.nodes.length == 0) {\n                    this.isConnected = true;\n                    return;\n                }\n                var queue = new LinkedList();\n                var visited = new Set();\n                var currentNode = this.nodes[0];\n                var neighborEdges;\n                var currentNeighbor;\n                var childrenOfNode = currentNode.withChildren();\n                childrenOfNode.forEach(function(node) {\n                    queue.push(node);\n                    visited.add(node);\n                });\n                while(queue.length !== 0){\n                    currentNode = queue.shift();\n                    // Traverse all neighbors of this node\n                    neighborEdges = currentNode.getEdges();\n                    var size = neighborEdges.length;\n                    for(var i = 0; i < size; i++){\n                        var neighborEdge = neighborEdges[i];\n                        currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n                        // Add unvisited neighbors to the list to visit\n                        if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n                            var childrenOfNeighbor = currentNeighbor.withChildren();\n                            childrenOfNeighbor.forEach(function(node) {\n                                queue.push(node);\n                                visited.add(node);\n                            });\n                        }\n                    }\n                }\n                this.isConnected = false;\n                if (visited.size >= this.nodes.length) {\n                    var noOfVisitedInThisGraph = 0;\n                    visited.forEach(function(visitedNode) {\n                        if (visitedNode.owner == self) {\n                            noOfVisitedInThisGraph++;\n                        }\n                    });\n                    if (noOfVisitedInThisGraph == this.nodes.length) {\n                        this.isConnected = true;\n                    }\n                }\n            };\n            module1.exports = LGraph;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_38884__) {\n            \"use strict\";\n            var LGraph;\n            var LEdge = __nested_webpack_require_38884__(1);\n            function LGraphManager(layout) {\n                LGraph = __nested_webpack_require_38884__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n                this.layout = layout;\n                this.graphs = [];\n                this.edges = [];\n            }\n            LGraphManager.prototype.addRoot = function() {\n                var ngraph = this.layout.newGraph();\n                var nnode = this.layout.newNode(null);\n                var root = this.add(ngraph, nnode);\n                this.setRootGraph(root);\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {\n                //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n                if (newEdge == null && sourceNode == null && targetNode == null) {\n                    if (newGraph == null) {\n                        throw \"Graph is null!\";\n                    }\n                    if (parentNode == null) {\n                        throw \"Parent node is null!\";\n                    }\n                    if (this.graphs.indexOf(newGraph) > -1) {\n                        throw \"Graph already in this graph mgr!\";\n                    }\n                    this.graphs.push(newGraph);\n                    if (newGraph.parent != null) {\n                        throw \"Already has a parent!\";\n                    }\n                    if (parentNode.child != null) {\n                        throw \"Already has a child!\";\n                    }\n                    newGraph.parent = parentNode;\n                    parentNode.child = newGraph;\n                    return newGraph;\n                } else {\n                    //change the order of the parameters\n                    targetNode = newEdge;\n                    sourceNode = parentNode;\n                    newEdge = newGraph;\n                    var sourceGraph = sourceNode.getOwner();\n                    var targetGraph = targetNode.getOwner();\n                    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n                        throw \"Source not in this graph mgr!\";\n                    }\n                    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n                        throw \"Target not in this graph mgr!\";\n                    }\n                    if (sourceGraph == targetGraph) {\n                        newEdge.isInterGraph = false;\n                        return sourceGraph.add(newEdge, sourceNode, targetNode);\n                    } else {\n                        newEdge.isInterGraph = true;\n                        // set source and target\n                        newEdge.source = sourceNode;\n                        newEdge.target = targetNode;\n                        // add edge to inter-graph edge list\n                        if (this.edges.indexOf(newEdge) > -1) {\n                            throw \"Edge already in inter-graph edge list!\";\n                        }\n                        this.edges.push(newEdge);\n                        // add edge to source and target incidency lists\n                        if (!(newEdge.source != null && newEdge.target != null)) {\n                            throw \"Edge source and/or target is null!\";\n                        }\n                        if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n                            throw \"Edge already in source and/or target incidency list!\";\n                        }\n                        newEdge.source.edges.push(newEdge);\n                        newEdge.target.edges.push(newEdge);\n                        return newEdge;\n                    }\n                }\n            };\n            LGraphManager.prototype.remove = function(lObj) {\n                if (lObj instanceof LGraph) {\n                    var graph = lObj;\n                    if (graph.getGraphManager() != this) {\n                        throw \"Graph not in this graph mgr\";\n                    }\n                    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n                        throw \"Invalid parent node!\";\n                    }\n                    // first the edges (make a copy to do it safely)\n                    var edgesToBeRemoved = [];\n                    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        graph.remove(edge);\n                    }\n                    // then the nodes (make a copy to do it safely)\n                    var nodesToBeRemoved = [];\n                    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n                    var node;\n                    s = nodesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        node = nodesToBeRemoved[i];\n                        graph.remove(node);\n                    }\n                    // check if graph is the root\n                    if (graph == this.rootGraph) {\n                        this.setRootGraph(null);\n                    }\n                    // now remove the graph itself\n                    var index = this.graphs.indexOf(graph);\n                    this.graphs.splice(index, 1);\n                    // also reset the parent of the graph\n                    graph.parent = null;\n                } else if (lObj instanceof LEdge) {\n                    edge = lObj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!edge.isInterGraph) {\n                        throw \"Not an inter-graph edge!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    // remove edge from source and target nodes' incidency lists\n                    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    var index = edge.source.edges.indexOf(edge);\n                    edge.source.edges.splice(index, 1);\n                    index = edge.target.edges.indexOf(edge);\n                    edge.target.edges.splice(index, 1);\n                    // remove edge from owner graph manager's inter-graph edge list\n                    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n                        throw \"Edge owner graph or owner graph manager is null!\";\n                    }\n                    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n                        throw \"Not in owner graph manager's edge list!\";\n                    }\n                    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n                    edge.source.owner.getGraphManager().edges.splice(index, 1);\n                }\n            };\n            LGraphManager.prototype.updateBounds = function() {\n                this.rootGraph.updateBounds(true);\n            };\n            LGraphManager.prototype.getGraphs = function() {\n                return this.graphs;\n            };\n            LGraphManager.prototype.getAllNodes = function() {\n                if (this.allNodes == null) {\n                    var nodeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < s; i++){\n                        nodeList = nodeList.concat(graphs[i].getNodes());\n                    }\n                    this.allNodes = nodeList;\n                }\n                return this.allNodes;\n            };\n            LGraphManager.prototype.resetAllNodes = function() {\n                this.allNodes = null;\n            };\n            LGraphManager.prototype.resetAllEdges = function() {\n                this.allEdges = null;\n            };\n            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {\n                this.allNodesToApplyGravitation = null;\n            };\n            LGraphManager.prototype.getAllEdges = function() {\n                if (this.allEdges == null) {\n                    var edgeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < graphs.length; i++){\n                        edgeList = edgeList.concat(graphs[i].getEdges());\n                    }\n                    edgeList = edgeList.concat(this.edges);\n                    this.allEdges = edgeList;\n                }\n                return this.allEdges;\n            };\n            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {\n                return this.allNodesToApplyGravitation;\n            };\n            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {\n                if (this.allNodesToApplyGravitation != null) {\n                    throw \"assert failed\";\n                }\n                this.allNodesToApplyGravitation = nodeList;\n            };\n            LGraphManager.prototype.getRoot = function() {\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.setRootGraph = function(graph) {\n                if (graph.getGraphManager() != this) {\n                    throw \"Root not in this graph mgr!\";\n                }\n                this.rootGraph = graph;\n                // root graph must have a root node associated with it for convenience\n                if (graph.parent == null) {\n                    graph.parent = this.layout.newNode(\"Root node\");\n                }\n            };\n            LGraphManager.prototype.getLayout = function() {\n                return this.layout;\n            };\n            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {\n                if (!(firstNode != null && secondNode != null)) {\n                    throw \"assert failed\";\n                }\n                if (firstNode == secondNode) {\n                    return true;\n                }\n                // Is second node an ancestor of the first one?\n                var ownerGraph = firstNode.getOwner();\n                var parentNode;\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == secondNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                // Is first node an ancestor of the second one?\n                ownerGraph = secondNode.getOwner();\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == firstNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                return false;\n            };\n            LGraphManager.prototype.calcLowestCommonAncestors = function() {\n                var edge;\n                var sourceNode;\n                var targetNode;\n                var sourceAncestorGraph;\n                var targetAncestorGraph;\n                var edges = this.getAllEdges();\n                var s = edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = edges[i];\n                    sourceNode = edge.source;\n                    targetNode = edge.target;\n                    edge.lca = null;\n                    edge.sourceInLca = sourceNode;\n                    edge.targetInLca = targetNode;\n                    if (sourceNode == targetNode) {\n                        edge.lca = sourceNode.getOwner();\n                        continue;\n                    }\n                    sourceAncestorGraph = sourceNode.getOwner();\n                    while(edge.lca == null){\n                        edge.targetInLca = targetNode;\n                        targetAncestorGraph = targetNode.getOwner();\n                        while(edge.lca == null){\n                            if (targetAncestorGraph == sourceAncestorGraph) {\n                                edge.lca = targetAncestorGraph;\n                                break;\n                            }\n                            if (targetAncestorGraph == this.rootGraph) {\n                                break;\n                            }\n                            if (edge.lca != null) {\n                                throw \"assert failed\";\n                            }\n                            edge.targetInLca = targetAncestorGraph.getParent();\n                            targetAncestorGraph = edge.targetInLca.getOwner();\n                        }\n                        if (sourceAncestorGraph == this.rootGraph) {\n                            break;\n                        }\n                        if (edge.lca == null) {\n                            edge.sourceInLca = sourceAncestorGraph.getParent();\n                            sourceAncestorGraph = edge.sourceInLca.getOwner();\n                        }\n                    }\n                    if (edge.lca == null) {\n                        throw \"assert failed\";\n                    }\n                }\n            };\n            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {\n                if (firstNode == secondNode) {\n                    return firstNode.getOwner();\n                }\n                var firstOwnerGraph = firstNode.getOwner();\n                do {\n                    if (firstOwnerGraph == null) {\n                        break;\n                    }\n                    var secondOwnerGraph = secondNode.getOwner();\n                    do {\n                        if (secondOwnerGraph == null) {\n                            break;\n                        }\n                        if (secondOwnerGraph == firstOwnerGraph) {\n                            return secondOwnerGraph;\n                        }\n                        secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n                    }while (true);\n                    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n                }while (true);\n                return firstOwnerGraph;\n            };\n            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {\n                if (graph == null && depth == null) {\n                    graph = this.rootGraph;\n                    depth = 1;\n                }\n                var node;\n                var nodes = graph.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    node = nodes[i];\n                    node.inclusionTreeDepth = depth;\n                    if (node.child != null) {\n                        this.calcInclusionTreeDepths(node.child, depth + 1);\n                    }\n                }\n            };\n            LGraphManager.prototype.includesInvalidEdge = function() {\n                var edge;\n                var s = this.edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = this.edges[i];\n                    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            module1.exports = LGraphManager;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_55318__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_55318__(0);\n            function FDLayoutConstants() {}\n            //FDLayoutConstants inherits static props in LayoutConstants\n            for(var prop in LayoutConstants){\n                FDLayoutConstants[prop] = LayoutConstants[prop];\n            }\n            FDLayoutConstants.MAX_ITERATIONS = 2500;\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n            FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n            module1.exports = FDLayoutConstants;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_57265__) {\n            \"use strict\";\n            /**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var Point1 = __nested_webpack_require_57265__(12);\n            function IGeometry() {}\n            /**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */ IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {\n                if (!rectA.intersects(rectB)) {\n                    throw \"assert failed\";\n                }\n                var directions = new Array(2);\n                this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n                overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n                overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n                // update the overlapping amounts for the following cases:\n                if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n                    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */ overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n                } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n                    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */ overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n                }\n                if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n                    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */ overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n                } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n                    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */ overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n                }\n                // find slope of the line passes two centers\n                var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n                // if centers are overlapped\n                if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n                    // assume the slope is 1 (45 degree)\n                    slope = 1.0;\n                }\n                var moveByY = slope * overlapAmount[0];\n                var moveByX = overlapAmount[1] / slope;\n                if (overlapAmount[0] < moveByX) {\n                    moveByX = overlapAmount[0];\n                } else {\n                    moveByY = overlapAmount[1];\n                }\n                // return half the amount so that if each rectangle is moved by these\n                // amounts in opposite directions, overlap will be resolved\n                overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n                overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n            };\n            /**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */ IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {\n                if (rectA.getCenterX() < rectB.getCenterX()) {\n                    directions[0] = -1;\n                } else {\n                    directions[0] = 1;\n                }\n                if (rectA.getCenterY() < rectB.getCenterY()) {\n                    directions[1] = -1;\n                } else {\n                    directions[1] = 1;\n                }\n            };\n            /**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */ IGeometry.getIntersection2 = function(rectA, rectB, result) {\n                //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n                var p1x = rectA.getCenterX();\n                var p1y = rectA.getCenterY();\n                var p2x = rectB.getCenterX();\n                var p2y = rectB.getCenterY();\n                //if two rectangles intersect, then clipping points are centers\n                if (rectA.intersects(rectB)) {\n                    result[0] = p1x;\n                    result[1] = p1y;\n                    result[2] = p2x;\n                    result[3] = p2y;\n                    return true;\n                }\n                //variables for rectA\n                var topLeftAx = rectA.getX();\n                var topLeftAy = rectA.getY();\n                var topRightAx = rectA.getRight();\n                var bottomLeftAx = rectA.getX();\n                var bottomLeftAy = rectA.getBottom();\n                var bottomRightAx = rectA.getRight();\n                var halfWidthA = rectA.getWidthHalf();\n                var halfHeightA = rectA.getHeightHalf();\n                //variables for rectB\n                var topLeftBx = rectB.getX();\n                var topLeftBy = rectB.getY();\n                var topRightBx = rectB.getRight();\n                var bottomLeftBx = rectB.getX();\n                var bottomLeftBy = rectB.getBottom();\n                var bottomRightBx = rectB.getRight();\n                var halfWidthB = rectB.getWidthHalf();\n                var halfHeightB = rectB.getHeightHalf();\n                //flag whether clipping points are found\n                var clipPointAFound = false;\n                var clipPointBFound = false;\n                // line is vertical\n                if (p1x === p2x) {\n                    if (p1y > p2y) {\n                        result[0] = p1x;\n                        result[1] = topLeftAy;\n                        result[2] = p2x;\n                        result[3] = bottomLeftBy;\n                        return false;\n                    } else if (p1y < p2y) {\n                        result[0] = p1x;\n                        result[1] = bottomLeftAy;\n                        result[2] = p2x;\n                        result[3] = topLeftBy;\n                        return false;\n                    } else {\n                    //not line, return null;\n                    }\n                } else if (p1y === p2y) {\n                    if (p1x > p2x) {\n                        result[0] = topLeftAx;\n                        result[1] = p1y;\n                        result[2] = topRightBx;\n                        result[3] = p2y;\n                        return false;\n                    } else if (p1x < p2x) {\n                        result[0] = topRightAx;\n                        result[1] = p1y;\n                        result[2] = topLeftBx;\n                        result[3] = p2y;\n                        return false;\n                    } else {\n                    //not valid line, return null;\n                    }\n                } else {\n                    //slopes of rectA's and rectB's diagonals\n                    var slopeA = rectA.height / rectA.width;\n                    var slopeB = rectB.height / rectB.width;\n                    //slope of line between center of rectA and center of rectB\n                    var slopePrime = (p2y - p1y) / (p2x - p1x);\n                    var cardinalDirectionA = void 0;\n                    var cardinalDirectionB = void 0;\n                    var tempPointAx = void 0;\n                    var tempPointAy = void 0;\n                    var tempPointBx = void 0;\n                    var tempPointBy = void 0;\n                    //determine whether clipping point is the corner of nodeA\n                    if (-slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = bottomLeftAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = topRightAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        }\n                    } else if (slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = topLeftAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = bottomRightAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        }\n                    }\n                    //determine whether clipping point is the corner of nodeB\n                    if (-slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = bottomLeftBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = topRightBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        }\n                    } else if (slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = topLeftBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = bottomRightBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        }\n                    }\n                    //if both clipping points are corners\n                    if (clipPointAFound && clipPointBFound) {\n                        return false;\n                    }\n                    //determine Cardinal Direction of rectangles\n                    if (p1x > p2x) {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n                        }\n                    } else {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n                        }\n                    }\n                    //calculate clipping Point if it is not found before\n                    if (!clipPointAFound) {\n                        switch(cardinalDirectionA){\n                            case 1:\n                                tempPointAy = topLeftAy;\n                                tempPointAx = p1x + -halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 2:\n                                tempPointAx = bottomRightAx;\n                                tempPointAy = p1y + halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 3:\n                                tempPointAy = bottomLeftAy;\n                                tempPointAx = p1x + halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 4:\n                                tempPointAx = bottomLeftAx;\n                                tempPointAy = p1y + -halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                        }\n                    }\n                    if (!clipPointBFound) {\n                        switch(cardinalDirectionB){\n                            case 1:\n                                tempPointBy = topLeftBy;\n                                tempPointBx = p2x + -halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 2:\n                                tempPointBx = bottomRightBx;\n                                tempPointBy = p2y + halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 3:\n                                tempPointBy = bottomLeftBy;\n                                tempPointBx = p2x + halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 4:\n                                tempPointBx = bottomLeftBx;\n                                tempPointBy = p2y + -halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                        }\n                    }\n                }\n                return false;\n            };\n            /**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */ IGeometry.getCardinalDirection = function(slope, slopePrime, line) {\n                if (slope > slopePrime) {\n                    return line;\n                } else {\n                    return 1 + line % 4;\n                }\n            };\n            /**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */ IGeometry.getIntersection = function(s1, s2, f1, f2) {\n                if (f2 == null) {\n                    return this.getIntersection2(s1, s2, f1);\n                }\n                var x1 = s1.x;\n                var y1 = s1.y;\n                var x2 = s2.x;\n                var y2 = s2.y;\n                var x3 = f1.x;\n                var y3 = f1.y;\n                var x4 = f2.x;\n                var y4 = f2.y;\n                var x = void 0, y = void 0; // intersection point\n                var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0; // coefficients of line eqns.\n                var denom = void 0;\n                a1 = y2 - y1;\n                b1 = x1 - x2;\n                c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n                a2 = y4 - y3;\n                b2 = x3 - x4;\n                c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n                denom = a1 * b2 - a2 * b1;\n                if (denom === 0) {\n                    return null;\n                }\n                x = (b1 * c2 - b2 * c1) / denom;\n                y = (a2 * c1 - a1 * c2) / denom;\n                return new Point1(x, y);\n            };\n            /**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */ IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {\n                var C_angle = void 0;\n                if (Cx !== Nx) {\n                    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n                    if (Nx < Cx) {\n                        C_angle += Math.PI;\n                    } else if (Ny < Cy) {\n                        C_angle += this.TWO_PI;\n                    }\n                } else if (Ny < Cy) {\n                    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n                } else {\n                    C_angle = this.HALF_PI; // 90 degrees\n                }\n                return C_angle;\n            };\n            /**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */ IGeometry.doIntersect = function(p1, p2, p3, p4) {\n                var a = p1.x;\n                var b = p1.y;\n                var c = p2.x;\n                var d = p2.y;\n                var p = p3.x;\n                var q = p3.y;\n                var r = p4.x;\n                var s = p4.y;\n                var det = (c - a) * (s - q) - (r - p) * (d - b);\n                if (det === 0) {\n                    return false;\n                } else {\n                    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n                    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n                    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Class Constants\n            // -----------------------------------------------------------------------------\n            /**\n * Some useful pre-calculated constants\n */ IGeometry.HALF_PI = 0.5 * Math.PI;\n            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n            IGeometry.TWO_PI = 2.0 * Math.PI;\n            IGeometry.THREE_PI = 3.0 * Math.PI;\n            module1.exports = IGeometry;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function IMath() {}\n            /**\n * This method returns the sign of the input value.\n */ IMath.sign = function(value) {\n                if (value > 0) {\n                    return 1;\n                } else if (value < 0) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            };\n            IMath.floor = function(value) {\n                return value < 0 ? Math.ceil(value) : Math.floor(value);\n            };\n            IMath.ceil = function(value) {\n                return value < 0 ? Math.floor(value) : Math.ceil(value);\n            };\n            module1.exports = IMath;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Integer() {}\n            Integer.MAX_VALUE = 2147483647;\n            Integer.MIN_VALUE = -2147483648;\n            module1.exports = Integer;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var nodeFrom = function nodeFrom(value) {\n                return {\n                    value: value,\n                    next: null,\n                    prev: null\n                };\n            };\n            var add = function add(prev, node, next, list) {\n                if (prev !== null) {\n                    prev.next = node;\n                } else {\n                    list.head = node;\n                }\n                if (next !== null) {\n                    next.prev = node;\n                } else {\n                    list.tail = node;\n                }\n                node.prev = prev;\n                node.next = next;\n                list.length++;\n                return node;\n            };\n            var _remove = function _remove(node, list) {\n                var prev = node.prev, next = node.next;\n                if (prev !== null) {\n                    prev.next = next;\n                } else {\n                    list.head = next;\n                }\n                if (next !== null) {\n                    next.prev = prev;\n                } else {\n                    list.tail = prev;\n                }\n                node.prev = node.next = null;\n                list.length--;\n                return node;\n            };\n            var LinkedList = function() {\n                function LinkedList(vals) {\n                    var _this = this;\n                    _classCallCheck(this, LinkedList);\n                    this.length = 0;\n                    this.head = null;\n                    this.tail = null;\n                    if (vals != null) {\n                        vals.forEach(function(v) {\n                            return _this.push(v);\n                        });\n                    }\n                }\n                _createClass(LinkedList, [\n                    {\n                        key: \"size\",\n                        value: function size() {\n                            return this.length;\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(val, otherNode) {\n                            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertAfter\",\n                        value: function insertAfter(val, otherNode) {\n                            return add(otherNode, nodeFrom(val), otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeBefore\",\n                        value: function insertNodeBefore(newNode, otherNode) {\n                            return add(otherNode.prev, newNode, otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeAfter\",\n                        value: function insertNodeAfter(newNode, otherNode) {\n                            return add(otherNode, newNode, otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"push\",\n                        value: function push(val) {\n                            return add(this.tail, nodeFrom(val), null, this);\n                        }\n                    },\n                    {\n                        key: \"unshift\",\n                        value: function unshift(val) {\n                            return add(null, nodeFrom(val), this.head, this);\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove(node) {\n                            return _remove(node, this);\n                        }\n                    },\n                    {\n                        key: \"pop\",\n                        value: function pop() {\n                            return _remove(this.tail, this).value;\n                        }\n                    },\n                    {\n                        key: \"popNode\",\n                        value: function popNode() {\n                            return _remove(this.tail, this);\n                        }\n                    },\n                    {\n                        key: \"shift\",\n                        value: function shift() {\n                            return _remove(this.head, this).value;\n                        }\n                    },\n                    {\n                        key: \"shiftNode\",\n                        value: function shiftNode() {\n                            return _remove(this.head, this);\n                        }\n                    },\n                    {\n                        key: \"get_object_at\",\n                        value: function get_object_at(index) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                return current.value;\n                            }\n                        }\n                    },\n                    {\n                        key: \"set_object_at\",\n                        value: function set_object_at(index, value) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                current.value = value;\n                            }\n                        }\n                    }\n                ]);\n                return LinkedList;\n            }();\n            module1.exports = LinkedList;\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */ function Point1(x, y, p) {\n                this.x = null;\n                this.y = null;\n                if (x == null && y == null && p == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    this.x = x;\n                    this.y = y;\n                } else if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.x = p.x;\n                    this.y = p.y;\n                }\n            }\n            Point1.prototype.getX = function() {\n                return this.x;\n            };\n            Point1.prototype.getY = function() {\n                return this.y;\n            };\n            Point1.prototype.getLocation = function() {\n                return new Point1(this.x, this.y);\n            };\n            Point1.prototype.setLocation = function(x, y, p) {\n                if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.setLocation(p.x, p.y);\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    //if both parameters are integer just move (x,y) location\n                    if (parseInt(x) == x && parseInt(y) == y) {\n                        this.move(x, y);\n                    } else {\n                        this.x = Math.floor(x + 0.5);\n                        this.y = Math.floor(y + 0.5);\n                    }\n                }\n            };\n            Point1.prototype.move = function(x, y) {\n                this.x = x;\n                this.y = y;\n            };\n            Point1.prototype.translate = function(dx, dy) {\n                this.x += dx;\n                this.y += dy;\n            };\n            Point1.prototype.equals = function(obj) {\n                if (obj.constructor.name == \"Point\") {\n                    var pt = obj;\n                    return this.x == pt.x && this.y == pt.y;\n                }\n                return this == obj;\n            };\n            Point1.prototype.toString = function() {\n                return new Point1().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n            };\n            module1.exports = Point1;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RectangleD(x, y, width, height) {\n                this.x = 0;\n                this.y = 0;\n                this.width = 0;\n                this.height = 0;\n                if (x != null && y != null && width != null && height != null) {\n                    this.x = x;\n                    this.y = y;\n                    this.width = width;\n                    this.height = height;\n                }\n            }\n            RectangleD.prototype.getX = function() {\n                return this.x;\n            };\n            RectangleD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            RectangleD.prototype.getY = function() {\n                return this.y;\n            };\n            RectangleD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            RectangleD.prototype.getWidth = function() {\n                return this.width;\n            };\n            RectangleD.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            RectangleD.prototype.getHeight = function() {\n                return this.height;\n            };\n            RectangleD.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            RectangleD.prototype.getRight = function() {\n                return this.x + this.width;\n            };\n            RectangleD.prototype.getBottom = function() {\n                return this.y + this.height;\n            };\n            RectangleD.prototype.intersects = function(a) {\n                if (this.getRight() < a.x) {\n                    return false;\n                }\n                if (this.getBottom() < a.y) {\n                    return false;\n                }\n                if (a.getRight() < this.x) {\n                    return false;\n                }\n                if (a.getBottom() < this.y) {\n                    return false;\n                }\n                return true;\n            };\n            RectangleD.prototype.getCenterX = function() {\n                return this.x + this.width / 2;\n            };\n            RectangleD.prototype.getMinX = function() {\n                return this.getX();\n            };\n            RectangleD.prototype.getMaxX = function() {\n                return this.getX() + this.width;\n            };\n            RectangleD.prototype.getCenterY = function() {\n                return this.y + this.height / 2;\n            };\n            RectangleD.prototype.getMinY = function() {\n                return this.getY();\n            };\n            RectangleD.prototype.getMaxY = function() {\n                return this.getY() + this.height;\n            };\n            RectangleD.prototype.getWidthHalf = function() {\n                return this.width / 2;\n            };\n            RectangleD.prototype.getHeightHalf = function() {\n                return this.height / 2;\n            };\n            module1.exports = RectangleD;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            function UniqueIDGeneretor() {}\n            UniqueIDGeneretor.lastID = 0;\n            UniqueIDGeneretor.createID = function(obj) {\n                if (UniqueIDGeneretor.isPrimitive(obj)) {\n                    return obj;\n                }\n                if (obj.uniqueID != null) {\n                    return obj.uniqueID;\n                }\n                obj.uniqueID = UniqueIDGeneretor.getString();\n                UniqueIDGeneretor.lastID++;\n                return obj.uniqueID;\n            };\n            UniqueIDGeneretor.getString = function(id) {\n                if (id == null) id = UniqueIDGeneretor.lastID;\n                return \"Object#\" + id + \"\";\n            };\n            UniqueIDGeneretor.isPrimitive = function(arg) {\n                var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n                return arg == null || type != \"object\" && type != \"function\";\n            };\n            module1.exports = UniqueIDGeneretor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_92042__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var LayoutConstants = __nested_webpack_require_92042__(0);\n            var LGraphManager = __nested_webpack_require_92042__(6);\n            var LNode = __nested_webpack_require_92042__(3);\n            var LEdge = __nested_webpack_require_92042__(1);\n            var LGraph = __nested_webpack_require_92042__(5);\n            var PointD = __nested_webpack_require_92042__(4);\n            var Transform = __nested_webpack_require_92042__(17);\n            var Emitter = __nested_webpack_require_92042__(27);\n            function Layout1(isRemoteUse) {\n                Emitter.call(this);\n                //Layout Quality: 0:draft, 1:default, 2:proof\n                this.layoutQuality = LayoutConstants.QUALITY;\n                //Whether layout should create bendpoints as needed or not\n                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                //Whether layout should be incremental or not\n                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                //Whether we animate from before to after layout node positions\n                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                //Whether we animate the layout process or not\n                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                //Number iterations that should be done between two successive animations\n                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */ this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */ this.edgeToDummyNodes = new Map();\n                this.graphManager = new LGraphManager(this);\n                this.isLayoutFinished = false;\n                this.isSubLayout = false;\n                this.isRemoteUse = false;\n                if (isRemoteUse != null) {\n                    this.isRemoteUse = isRemoteUse;\n                }\n            }\n            Layout1.RANDOM_SEED = 1;\n            Layout1.prototype = Object.create(Emitter.prototype);\n            Layout1.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            Layout1.prototype.getAllNodes = function() {\n                return this.graphManager.getAllNodes();\n            };\n            Layout1.prototype.getAllEdges = function() {\n                return this.graphManager.getAllEdges();\n            };\n            Layout1.prototype.getAllNodesToApplyGravitation = function() {\n                return this.graphManager.getAllNodesToApplyGravitation();\n            };\n            Layout1.prototype.newGraphManager = function() {\n                var gm = new LGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            Layout1.prototype.newGraph = function(vGraph) {\n                return new LGraph(null, this.graphManager, vGraph);\n            };\n            Layout1.prototype.newNode = function(vNode) {\n                return new LNode(this.graphManager, vNode);\n            };\n            Layout1.prototype.newEdge = function(vEdge) {\n                return new LEdge(null, null, vEdge);\n            };\n            Layout1.prototype.checkLayoutSuccess = function() {\n                return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n            };\n            Layout1.prototype.runLayout = function() {\n                this.isLayoutFinished = false;\n                if (this.tilingPreLayout) {\n                    this.tilingPreLayout();\n                }\n                this.initParameters();\n                var isLayoutSuccessfull;\n                if (this.checkLayoutSuccess()) {\n                    isLayoutSuccessfull = false;\n                } else {\n                    isLayoutSuccessfull = this.layout();\n                }\n                if (LayoutConstants.ANIMATE === \"during\") {\n                    // If this is a 'during' layout animation. Layout is not finished yet. \n                    // We need to perform these in index.js when layout is really finished.\n                    return false;\n                }\n                if (isLayoutSuccessfull) {\n                    if (!this.isSubLayout) {\n                        this.doPostLayout();\n                    }\n                }\n                if (this.tilingPostLayout) {\n                    this.tilingPostLayout();\n                }\n                this.isLayoutFinished = true;\n                return isLayoutSuccessfull;\n            };\n            /**\r\n * This method performs the operations required after layout.\r\n */ Layout1.prototype.doPostLayout = function() {\n                //assert !isSubLayout : \"Should not be called on sub-layout!\";\n                // Propagate geometric changes to v-level objects\n                if (!this.incremental) {\n                    this.transform();\n                }\n                this.update();\n            };\n            /**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */ Layout1.prototype.update2 = function() {\n                // update bend points\n                if (this.createBendsAsNeeded) {\n                    this.createBendpointsFromDummyNodes();\n                    // reset all edges, since the topology has changed\n                    this.graphManager.resetAllEdges();\n                }\n                // perform edge, node and root updates if layout is not called\n                // remotely\n                if (!this.isRemoteUse) {\n                    // update all edges\n                    var edge;\n                    var allEdges = this.graphManager.getAllEdges();\n                    for(var i = 0; i < allEdges.length; i++){\n                        edge = allEdges[i];\n                    //      this.update(edge);\n                    }\n                    // recursively update nodes\n                    var node;\n                    var nodes = this.graphManager.getRoot().getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                    //      this.update(node);\n                    }\n                    // update root graph\n                    this.update(this.graphManager.getRoot());\n                }\n            };\n            Layout1.prototype.update = function(obj) {\n                if (obj == null) {\n                    this.update2();\n                } else if (obj instanceof LNode) {\n                    var node = obj;\n                    if (node.getChild() != null) {\n                        // since node is compound, recursively update child nodes\n                        var nodes = node.getChild().getNodes();\n                        for(var i = 0; i < nodes.length; i++){\n                            update(nodes[i]);\n                        }\n                    }\n                    // if the l-level node is associated with a v-level graph object,\n                    // then it is assumed that the v-level node implements the\n                    // interface Updatable.\n                    if (node.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vNode = node.vGraphObject;\n                        // call the update method of the interface\n                        vNode.update(node);\n                    }\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    // if the l-level edge is associated with a v-level graph object,\n                    // then it is assumed that the v-level edge implements the\n                    // interface Updatable.\n                    if (edge.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vEdge = edge.vGraphObject;\n                        // call the update method of the interface\n                        vEdge.update(edge);\n                    }\n                } else if (obj instanceof LGraph) {\n                    var graph = obj;\n                    // if the l-level graph is associated with a v-level graph object,\n                    // then it is assumed that the v-level object implements the\n                    // interface Updatable.\n                    if (graph.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vGraph = graph.vGraphObject;\n                        // call the update method of the interface\n                        vGraph.update(graph);\n                    }\n                }\n            };\n            /**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */ Layout1.prototype.initParameters = function() {\n                if (!this.isSubLayout) {\n                    this.layoutQuality = LayoutConstants.QUALITY;\n                    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                }\n                if (this.animationDuringLayout) {\n                    this.animationOnLayout = false;\n                }\n            };\n            Layout1.prototype.transform = function(newLeftTop) {\n                if (newLeftTop == undefined) {\n                    this.transform(new PointD(0, 0));\n                } else {\n                    // create a transformation object (from Eclipse to layout). When an\n                    // inverse transform is applied, we get upper-left coordinate of the\n                    // drawing or the root graph at given input coordinate (some margins\n                    // already included in calculation of left-top).\n                    var trans = new Transform();\n                    var leftTop = this.graphManager.getRoot().updateLeftTop();\n                    if (leftTop != null) {\n                        trans.setWorldOrgX(newLeftTop.x);\n                        trans.setWorldOrgY(newLeftTop.y);\n                        trans.setDeviceOrgX(leftTop.x);\n                        trans.setDeviceOrgY(leftTop.y);\n                        var nodes = this.getAllNodes();\n                        var node;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            node.transform(trans);\n                        }\n                    }\n                }\n            };\n            Layout1.prototype.positionNodesRandomly = function(graph) {\n                if (graph == undefined) {\n                    //assert !this.incremental;\n                    this.positionNodesRandomly(this.getGraphManager().getRoot());\n                    this.getGraphManager().getRoot().updateBounds(true);\n                } else {\n                    var lNode;\n                    var childGraph;\n                    var nodes = graph.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        lNode = nodes[i];\n                        childGraph = lNode.getChild();\n                        if (childGraph == null) {\n                            lNode.scatter();\n                        } else if (childGraph.getNodes().length == 0) {\n                            lNode.scatter();\n                        } else {\n                            this.positionNodesRandomly(childGraph);\n                            lNode.updateBounds();\n                        }\n                    }\n                }\n            };\n            /**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */ Layout1.prototype.getFlatForest = function() {\n                var flatForest = [];\n                var isForest = true;\n                // Quick reference for all nodes in the graph manager associated with\n                // this layout. The list should not be changed.\n                var allNodes = this.graphManager.getRoot().getNodes();\n                // First be sure that the graph is flat\n                var isFlat = true;\n                for(var i = 0; i < allNodes.length; i++){\n                    if (allNodes[i].getChild() != null) {\n                        isFlat = false;\n                    }\n                }\n                // Return empty forest if the graph is not flat.\n                if (!isFlat) {\n                    return flatForest;\n                }\n                // Run BFS for each component of the graph.\n                var visited = new Set();\n                var toBeVisited = [];\n                var parents = new Map();\n                var unProcessedNodes = [];\n                unProcessedNodes = unProcessedNodes.concat(allNodes);\n                // Each iteration of this loop finds a component of the graph and\n                // decides whether it is a tree or not. If it is a tree, adds it to the\n                // forest and continued with the next component.\n                while(unProcessedNodes.length > 0 && isForest){\n                    toBeVisited.push(unProcessedNodes[0]);\n                    // Start the BFS. Each iteration of this loop visits a node in a\n                    // BFS manner.\n                    while(toBeVisited.length > 0 && isForest){\n                        //pool operation\n                        var currentNode = toBeVisited[0];\n                        toBeVisited.splice(0, 1);\n                        visited.add(currentNode);\n                        // Traverse all neighbors of this node\n                        var neighborEdges = currentNode.getEdges();\n                        for(var i = 0; i < neighborEdges.length; i++){\n                            var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n                            // If BFS is not growing from this neighbor.\n                            if (parents.get(currentNode) != currentNeighbor) {\n                                // We haven't previously visited this neighbor.\n                                if (!visited.has(currentNeighbor)) {\n                                    toBeVisited.push(currentNeighbor);\n                                    parents.set(currentNeighbor, currentNode);\n                                } else {\n                                    isForest = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // The graph contains a component that is not a tree. Empty\n                    // previously found trees. The method will end.\n                    if (!isForest) {\n                        flatForest = [];\n                    } else {\n                        var temp = [].concat(_toConsumableArray(visited));\n                        flatForest.push(temp);\n                        //flatForest = flatForest.concat(temp);\n                        //unProcessedNodes.removeAll(visited);\n                        for(var i = 0; i < temp.length; i++){\n                            var value = temp[i];\n                            var index = unProcessedNodes.indexOf(value);\n                            if (index > -1) {\n                                unProcessedNodes.splice(index, 1);\n                            }\n                        }\n                        visited = new Set();\n                        parents = new Map();\n                    }\n                }\n                return flatForest;\n            };\n            /**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */ Layout1.prototype.createDummyNodesForBendpoints = function(edge) {\n                var dummyNodes = [];\n                var prev = edge.source;\n                var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n                for(var i = 0; i < edge.bendpoints.length; i++){\n                    // create new dummy node\n                    var dummyNode = this.newNode(null);\n                    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n                    graph.add(dummyNode);\n                    // create new dummy edge between prev and dummy node\n                    var dummyEdge = this.newEdge(null);\n                    this.graphManager.add(dummyEdge, prev, dummyNode);\n                    dummyNodes.add(dummyNode);\n                    prev = dummyNode;\n                }\n                var dummyEdge = this.newEdge(null);\n                this.graphManager.add(dummyEdge, prev, edge.target);\n                this.edgeToDummyNodes.set(edge, dummyNodes);\n                // remove real edge from graph manager if it is inter-graph\n                if (edge.isInterGraph()) {\n                    this.graphManager.remove(edge);\n                } else {\n                    graph.remove(edge);\n                }\n                return dummyNodes;\n            };\n            /**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */ Layout1.prototype.createBendpointsFromDummyNodes = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n                for(var k = 0; k < edges.length; k++){\n                    var lEdge = edges[k];\n                    if (lEdge.bendpoints.length > 0) {\n                        var path = this.edgeToDummyNodes.get(lEdge);\n                        for(var i = 0; i < path.length; i++){\n                            var dummyNode = path[i];\n                            var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n                            // update bendpoint's location according to dummy node\n                            var ebp = lEdge.bendpoints.get(i);\n                            ebp.x = p.x;\n                            ebp.y = p.y;\n                            // remove the dummy node, dummy edges incident with this\n                            // dummy node is also removed (within the remove method)\n                            dummyNode.getOwner().remove(dummyNode);\n                        }\n                        // add the real edge to graph\n                        this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n                    }\n                }\n            };\n            Layout1.transform = function(sliderValue, defaultValue, minDiv, maxMul) {\n                if (minDiv != undefined && maxMul != undefined) {\n                    var value = defaultValue;\n                    if (sliderValue <= 50) {\n                        var minValue = defaultValue / minDiv;\n                        value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n                    } else {\n                        var maxValue = defaultValue * maxMul;\n                        value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n                    }\n                    return value;\n                } else {\n                    var a, b;\n                    if (sliderValue <= 50) {\n                        a = 9.0 * defaultValue / 500.0;\n                        b = defaultValue / 10.0;\n                    } else {\n                        a = 9.0 * defaultValue / 50.0;\n                        b = -8 * defaultValue;\n                    }\n                    return a * sliderValue + b;\n                }\n            };\n            /**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */ Layout1.findCenterOfTree = function(nodes) {\n                var list = [];\n                list = list.concat(nodes);\n                var removedNodes = [];\n                var remainingDegrees = new Map();\n                var foundCenter = false;\n                var centerNode = null;\n                if (list.length == 1 || list.length == 2) {\n                    foundCenter = true;\n                    centerNode = list[0];\n                }\n                for(var i = 0; i < list.length; i++){\n                    var node = list[i];\n                    var degree = node.getNeighborsList().size;\n                    remainingDegrees.set(node, node.getNeighborsList().size);\n                    if (degree == 1) {\n                        removedNodes.push(node);\n                    }\n                }\n                var tempList = [];\n                tempList = tempList.concat(removedNodes);\n                while(!foundCenter){\n                    var tempList2 = [];\n                    tempList2 = tempList2.concat(tempList);\n                    tempList = [];\n                    for(var i = 0; i < list.length; i++){\n                        var node = list[i];\n                        var index = list.indexOf(node);\n                        if (index >= 0) {\n                            list.splice(index, 1);\n                        }\n                        var neighbours = node.getNeighborsList();\n                        neighbours.forEach(function(neighbour) {\n                            if (removedNodes.indexOf(neighbour) < 0) {\n                                var otherDegree = remainingDegrees.get(neighbour);\n                                var newDegree = otherDegree - 1;\n                                if (newDegree == 1) {\n                                    tempList.push(neighbour);\n                                }\n                                remainingDegrees.set(neighbour, newDegree);\n                            }\n                        });\n                    }\n                    removedNodes = removedNodes.concat(tempList);\n                    if (list.length == 1 || list.length == 2) {\n                        foundCenter = true;\n                        centerNode = list[0];\n                    }\n                }\n                return centerNode;\n            };\n            /**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */ Layout1.prototype.setGraphManager = function(gm) {\n                this.graphManager = gm;\n            };\n            module1.exports = Layout1;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RandomSeed() {}\n            // adapted from: https://stackoverflow.com/a/19303725\n            RandomSeed.seed = 1;\n            RandomSeed.x = 0;\n            RandomSeed.nextDouble = function() {\n                RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n                return RandomSeed.x - Math.floor(RandomSeed.x);\n            };\n            module1.exports = RandomSeed;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_116346__) {\n            \"use strict\";\n            var PointD = __nested_webpack_require_116346__(4);\n            function Transform(x, y) {\n                this.lworldOrgX = 0.0;\n                this.lworldOrgY = 0.0;\n                this.ldeviceOrgX = 0.0;\n                this.ldeviceOrgY = 0.0;\n                this.lworldExtX = 1.0;\n                this.lworldExtY = 1.0;\n                this.ldeviceExtX = 1.0;\n                this.ldeviceExtY = 1.0;\n            }\n            Transform.prototype.getWorldOrgX = function() {\n                return this.lworldOrgX;\n            };\n            Transform.prototype.setWorldOrgX = function(wox) {\n                this.lworldOrgX = wox;\n            };\n            Transform.prototype.getWorldOrgY = function() {\n                return this.lworldOrgY;\n            };\n            Transform.prototype.setWorldOrgY = function(woy) {\n                this.lworldOrgY = woy;\n            };\n            Transform.prototype.getWorldExtX = function() {\n                return this.lworldExtX;\n            };\n            Transform.prototype.setWorldExtX = function(wex) {\n                this.lworldExtX = wex;\n            };\n            Transform.prototype.getWorldExtY = function() {\n                return this.lworldExtY;\n            };\n            Transform.prototype.setWorldExtY = function(wey) {\n                this.lworldExtY = wey;\n            };\n            /* Device related */ Transform.prototype.getDeviceOrgX = function() {\n                return this.ldeviceOrgX;\n            };\n            Transform.prototype.setDeviceOrgX = function(dox) {\n                this.ldeviceOrgX = dox;\n            };\n            Transform.prototype.getDeviceOrgY = function() {\n                return this.ldeviceOrgY;\n            };\n            Transform.prototype.setDeviceOrgY = function(doy) {\n                this.ldeviceOrgY = doy;\n            };\n            Transform.prototype.getDeviceExtX = function() {\n                return this.ldeviceExtX;\n            };\n            Transform.prototype.setDeviceExtX = function(dex) {\n                this.ldeviceExtX = dex;\n            };\n            Transform.prototype.getDeviceExtY = function() {\n                return this.ldeviceExtY;\n            };\n            Transform.prototype.setDeviceExtY = function(dey) {\n                this.ldeviceExtY = dey;\n            };\n            Transform.prototype.transformX = function(x) {\n                var xDevice = 0.0;\n                var worldExtX = this.lworldExtX;\n                if (worldExtX != 0.0) {\n                    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n                }\n                return xDevice;\n            };\n            Transform.prototype.transformY = function(y) {\n                var yDevice = 0.0;\n                var worldExtY = this.lworldExtY;\n                if (worldExtY != 0.0) {\n                    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n                }\n                return yDevice;\n            };\n            Transform.prototype.inverseTransformX = function(x) {\n                var xWorld = 0.0;\n                var deviceExtX = this.ldeviceExtX;\n                if (deviceExtX != 0.0) {\n                    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n                }\n                return xWorld;\n            };\n            Transform.prototype.inverseTransformY = function(y) {\n                var yWorld = 0.0;\n                var deviceExtY = this.ldeviceExtY;\n                if (deviceExtY != 0.0) {\n                    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n                }\n                return yWorld;\n            };\n            Transform.prototype.inverseTransformPoint = function(inPoint) {\n                var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n                return outPoint;\n            };\n            module1.exports = Transform;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_120470__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var Layout1 = __nested_webpack_require_120470__(15);\n            var FDLayoutConstants = __nested_webpack_require_120470__(7);\n            var LayoutConstants = __nested_webpack_require_120470__(0);\n            var IGeometry = __nested_webpack_require_120470__(8);\n            var IMath = __nested_webpack_require_120470__(9);\n            function FDLayout() {\n                Layout1.call(this);\n                this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n                this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.totalDisplacement = 0.0;\n                this.oldTotalDisplacement = 0.0;\n                this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n            }\n            FDLayout.prototype = Object.create(Layout1.prototype);\n            for(var prop in Layout1){\n                FDLayout[prop] = Layout1[prop];\n            }\n            FDLayout.prototype.initParameters = function() {\n                Layout1.prototype.initParameters.call(this, arguments);\n                this.totalIterations = 0;\n                this.notAnimatedIterations = 0;\n                this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n                this.grid = [];\n            };\n            FDLayout.prototype.calcIdealEdgeLengths = function() {\n                var edge;\n                var lcaDepth;\n                var source;\n                var target;\n                var sizeOfSourceInLca;\n                var sizeOfTargetInLca;\n                var allEdges = this.getGraphManager().getAllEdges();\n                for(var i = 0; i < allEdges.length; i++){\n                    edge = allEdges[i];\n                    edge.idealLength = this.idealEdgeLength;\n                    if (edge.isInterGraph) {\n                        source = edge.getSource();\n                        target = edge.getTarget();\n                        sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n                        sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n                        if (this.useSmartIdealEdgeLengthCalculation) {\n                            edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n                        }\n                        lcaDepth = edge.getLca().getInclusionTreeDepth();\n                        edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n                    }\n                }\n            };\n            FDLayout.prototype.initSpringEmbedder = function() {\n                var s = this.getAllNodes().length;\n                if (this.incremental) {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    }\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n                } else {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    } else {\n                        this.coolingFactor = 1.0;\n                    }\n                    this.initialCoolingFactor = this.coolingFactor;\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n                }\n                this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n                this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n                this.repulsionRange = this.calcRepulsionRange();\n            };\n            FDLayout.prototype.calcSpringForces = function() {\n                var lEdges = this.getAllEdges();\n                var edge;\n                for(var i = 0; i < lEdges.length; i++){\n                    edge = lEdges[i];\n                    this.calcSpringForce(edge, edge.idealLength);\n                }\n            };\n            FDLayout.prototype.calcRepulsionForces = function() {\n                var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var i, j;\n                var nodeA, nodeB;\n                var lNodes = this.getAllNodes();\n                var processedNodeSet;\n                if (this.useFRGridVariant) {\n                    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n                        this.updateGrid();\n                    }\n                    processedNodeSet = new Set();\n                    // calculate repulsion forces between each nodes and its surrounding\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                        processedNodeSet.add(nodeA);\n                    }\n                } else {\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        for(j = i + 1; j < lNodes.length; j++){\n                            nodeB = lNodes[j];\n                            // If both nodes are not members of the same graph, skip.\n                            if (nodeA.getOwner() != nodeB.getOwner()) {\n                                continue;\n                            }\n                            this.calcRepulsionForce(nodeA, nodeB);\n                        }\n                    }\n                }\n            };\n            FDLayout.prototype.calcGravitationalForces = function() {\n                var node;\n                var lNodes = this.getAllNodesToApplyGravitation();\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    this.calcGravitationalForce(node);\n                }\n            };\n            FDLayout.prototype.moveNodes = function() {\n                var lNodes = this.getAllNodes();\n                var node;\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    node.move();\n                }\n            };\n            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {\n                var sourceNode = edge.getSource();\n                var targetNode = edge.getTarget();\n                var length;\n                var springForce;\n                var springForceX;\n                var springForceY;\n                // Update edge length\n                if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n                    edge.updateLengthSimple();\n                } else {\n                    edge.updateLength();\n                    if (edge.isOverlapingSourceAndTarget) {\n                        return;\n                    }\n                }\n                length = edge.getLength();\n                if (length == 0) return;\n                // Calculate spring forces\n                springForce = this.springConstant * (length - idealLength);\n                // Project force onto x and y axes\n                springForceX = springForce * (edge.lengthX / length);\n                springForceY = springForce * (edge.lengthY / length);\n                // Apply forces on the end nodes\n                sourceNode.springForceX += springForceX;\n                sourceNode.springForceY += springForceY;\n                targetNode.springForceX -= springForceX;\n                targetNode.springForceY -= springForceY;\n            };\n            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {\n                var rectA = nodeA.getRect();\n                var rectB = nodeB.getRect();\n                var overlapAmount = new Array(2);\n                var clipPoints = new Array(4);\n                var distanceX;\n                var distanceY;\n                var distanceSquared;\n                var distance;\n                var repulsionForce;\n                var repulsionForceX;\n                var repulsionForceY;\n                if (rectA.intersects(rectB)) {\n                    // calculate separation amount in x and y directions\n                    IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n                    repulsionForceX = 2 * overlapAmount[0];\n                    repulsionForceY = 2 * overlapAmount[1];\n                    var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n                    // Apply forces on the two nodes\n                    nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n                    nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n                    nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n                    nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n                } else {\n                    // calculate distance\n                    if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {\n                        distanceX = rectB.getCenterX() - rectA.getCenterX();\n                        distanceY = rectB.getCenterY() - rectA.getCenterY();\n                    } else {\n                        IGeometry.getIntersection(rectA, rectB, clipPoints);\n                        distanceX = clipPoints[2] - clipPoints[0];\n                        distanceY = clipPoints[3] - clipPoints[1];\n                    }\n                    // No repulsion range. FR grid variant should take care of this.\n                    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    distanceSquared = distanceX * distanceX + distanceY * distanceY;\n                    distance = Math.sqrt(distanceSquared);\n                    repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n                    // Project force onto x and y axes\n                    repulsionForceX = repulsionForce * distanceX / distance;\n                    repulsionForceY = repulsionForce * distanceY / distance;\n                    // Apply forces on the two nodes    \n                    nodeA.repulsionForceX -= repulsionForceX;\n                    nodeA.repulsionForceY -= repulsionForceY;\n                    nodeB.repulsionForceX += repulsionForceX;\n                    nodeB.repulsionForceY += repulsionForceY;\n                }\n            };\n            FDLayout.prototype.calcGravitationalForce = function(node) {\n                var ownerGraph;\n                var ownerCenterX;\n                var ownerCenterY;\n                var distanceX;\n                var distanceY;\n                var absDistanceX;\n                var absDistanceY;\n                var estimatedSize;\n                ownerGraph = node.getOwner();\n                ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n                ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n                distanceX = node.getCenterX() - ownerCenterX;\n                distanceY = node.getCenterY() - ownerCenterY;\n                absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n                absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n                if (node.getOwner() == this.graphManager.getRoot()) {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX;\n                        node.gravitationForceY = -this.gravityConstant * distanceY;\n                    }\n                } else {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n                        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n                    }\n                }\n            };\n            FDLayout.prototype.isConverged = function() {\n                var converged;\n                var oscilating = false;\n                if (this.totalIterations > this.maxIterations / 3) {\n                    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n                }\n                converged = this.totalDisplacement < this.totalDisplacementThreshold;\n                this.oldTotalDisplacement = this.totalDisplacement;\n                return converged || oscilating;\n            };\n            FDLayout.prototype.animate = function() {\n                if (this.animationDuringLayout && !this.isSubLayout) {\n                    if (this.notAnimatedIterations == this.animationPeriod) {\n                        this.update();\n                        this.notAnimatedIterations = 0;\n                    } else {\n                        this.notAnimatedIterations++;\n                    }\n                }\n            };\n            //This method calculates the number of children (weight) for all nodes\n            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {\n                var node;\n                var allNodes = this.graphManager.getAllNodes();\n                for(var i = 0; i < allNodes.length; i++){\n                    node = allNodes[i];\n                    node.noOfChildren = node.getNoOfChildren();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: FR-Grid Variant Repulsion Force Calculation\n            // -----------------------------------------------------------------------------\n            FDLayout.prototype.calcGrid = function(graph) {\n                var sizeX = 0;\n                var sizeY = 0;\n                sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n                sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n                var grid = new Array(sizeX);\n                for(var i = 0; i < sizeX; i++){\n                    grid[i] = new Array(sizeY);\n                }\n                for(var i = 0; i < sizeX; i++){\n                    for(var j = 0; j < sizeY; j++){\n                        grid[i][j] = new Array();\n                    }\n                }\n                return grid;\n            };\n            FDLayout.prototype.addNodeToGrid = function(v, left, top) {\n                var startX = 0;\n                var finishX = 0;\n                var startY = 0;\n                var finishY = 0;\n                startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n                finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n                startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n                finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n                for(var i = startX; i <= finishX; i++){\n                    for(var j = startY; j <= finishY; j++){\n                        this.grid[i][j].push(v);\n                        v.setGridCoordinates(startX, finishX, startY, finishY);\n                    }\n                }\n            };\n            FDLayout.prototype.updateGrid = function() {\n                var i;\n                var nodeA;\n                var lNodes = this.getAllNodes();\n                this.grid = this.calcGrid(this.graphManager.getRoot());\n                // put all nodes to proper grid cells\n                for(i = 0; i < lNodes.length; i++){\n                    nodeA = lNodes[i];\n                    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n                }\n            };\n            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n                    var surrounding = new Set();\n                    nodeA.surrounding = new Array();\n                    var nodeB;\n                    var grid = this.grid;\n                    for(var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++){\n                        for(var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++){\n                            if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                                for(var k = 0; k < grid[i][j].length; k++){\n                                    nodeB = grid[i][j][k];\n                                    // If both nodes are not members of the same graph, \n                                    // or both nodes are the same, skip.\n                                    if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                                        continue;\n                                    }\n                                    // check if the repulsion force between\n                                    // nodeA and nodeB has already been calculated\n                                    if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                                        var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                                        var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n                                        // if the distance between nodeA and nodeB \n                                        // is less then calculation range\n                                        if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                                            //then add nodeB to surrounding of nodeA\n                                            surrounding.add(nodeB);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n                }\n                for(i = 0; i < nodeA.surrounding.length; i++){\n                    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n                }\n            };\n            FDLayout.prototype.calcRepulsionRange = function() {\n                return 0.0;\n            };\n            module1.exports = FDLayout;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_141943__) {\n            \"use strict\";\n            var LEdge = __nested_webpack_require_141943__(1);\n            var FDLayoutConstants = __nested_webpack_require_141943__(7);\n            function FDLayoutEdge(source, target, vEdge) {\n                LEdge.call(this, source, target, vEdge);\n                this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            }\n            FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n            for(var prop in LEdge){\n                FDLayoutEdge[prop] = LEdge[prop];\n            }\n            module1.exports = FDLayoutEdge;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_142585__) {\n            \"use strict\";\n            var LNode = __nested_webpack_require_142585__(3);\n            function FDLayoutNode(gm, loc, size, vNode) {\n                // alternative constructor is handled inside LNode\n                LNode.call(this, gm, loc, size, vNode);\n                //Spring, repulsion and gravitational forces acting on this node\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                //Amount by which this node is to be moved in this iteration\n                this.displacementX = 0;\n                this.displacementY = 0;\n                //Start and finish grid coordinates that this node is fallen into\n                this.startX = 0;\n                this.finishX = 0;\n                this.startY = 0;\n                this.finishY = 0;\n                //Geometric neighbors of this node\n                this.surrounding = [];\n            }\n            FDLayoutNode.prototype = Object.create(LNode.prototype);\n            for(var prop in LNode){\n                FDLayoutNode[prop] = LNode[prop];\n            }\n            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {\n                this.startX = _startX;\n                this.finishX = _finishX;\n                this.startY = _startY;\n                this.finishY = _finishY;\n            };\n            module1.exports = FDLayoutNode;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function DimensionD1(width, height) {\n                this.width = 0;\n                this.height = 0;\n                if (width !== null && height !== null) {\n                    this.height = height;\n                    this.width = width;\n                }\n            }\n            DimensionD1.prototype.getWidth = function() {\n                return this.width;\n            };\n            DimensionD1.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            DimensionD1.prototype.getHeight = function() {\n                return this.height;\n            };\n            DimensionD1.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            module1.exports = DimensionD1;\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_145128__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_145128__(14);\n            function HashMap() {\n                this.map = {};\n                this.keys = [];\n            }\n            HashMap.prototype.put = function(key, value) {\n                var theId = UniqueIDGeneretor.createID(key);\n                if (!this.contains(theId)) {\n                    this.map[theId] = value;\n                    this.keys.push(key);\n                }\n            };\n            HashMap.prototype.contains = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[key] != null;\n            };\n            HashMap.prototype.get = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[theId];\n            };\n            HashMap.prototype.keySet = function() {\n                return this.keys;\n            };\n            module1.exports = HashMap;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_146187__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_146187__(14);\n            function HashSet() {\n                this.set = {};\n            }\n            ;\n            HashSet.prototype.add = function(obj) {\n                var theId = UniqueIDGeneretor.createID(obj);\n                if (!this.contains(theId)) this.set[theId] = obj;\n            };\n            HashSet.prototype.remove = function(obj) {\n                delete this.set[UniqueIDGeneretor.createID(obj)];\n            };\n            HashSet.prototype.clear = function() {\n                this.set = {};\n            };\n            HashSet.prototype.contains = function(obj) {\n                return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n            };\n            HashSet.prototype.isEmpty = function() {\n                return this.size() === 0;\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            //concats this.set to the given list\n            HashSet.prototype.addAllTo = function(list) {\n                var keys = Object.keys(this.set);\n                var length = keys.length;\n                for(var i = 0; i < length; i++){\n                    list.push(this.set[keys[i]]);\n                }\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAll = function(list) {\n                var s = list.length;\n                for(var i = 0; i < s; i++){\n                    var v = list[i];\n                    this.add(v);\n                }\n            };\n            module1.exports = HashSet;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_147985__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var LinkedList = __nested_webpack_require_147985__(11);\n            var Quicksort = function() {\n                function Quicksort(A, compareFunction) {\n                    _classCallCheck(this, Quicksort);\n                    if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n                    var length = void 0;\n                    if (A instanceof LinkedList) length = A.size();\n                    else length = A.length;\n                    this._quicksort(A, 0, length - 1);\n                }\n                _createClass(Quicksort, [\n                    {\n                        key: \"_quicksort\",\n                        value: function _quicksort(A, p, r) {\n                            if (p < r) {\n                                var q = this._partition(A, p, r);\n                                this._quicksort(A, p, q);\n                                this._quicksort(A, q + 1, r);\n                            }\n                        }\n                    },\n                    {\n                        key: \"_partition\",\n                        value: function _partition(A, p, r) {\n                            var x = this._get(A, p);\n                            var i = p;\n                            var j = r;\n                            while(true){\n                                while(this.compareFunction(x, this._get(A, j))){\n                                    j--;\n                                }\n                                while(this.compareFunction(this._get(A, i), x)){\n                                    i++;\n                                }\n                                if (i < j) {\n                                    this._swap(A, i, j);\n                                    i++;\n                                    j--;\n                                } else return j;\n                            }\n                        }\n                    },\n                    {\n                        key: \"_get\",\n                        value: function _get(object, index) {\n                            if (object instanceof LinkedList) return object.get_object_at(index);\n                            else return object[index];\n                        }\n                    },\n                    {\n                        key: \"_set\",\n                        value: function _set(object, index, value) {\n                            if (object instanceof LinkedList) object.set_object_at(index, value);\n                            else object[index] = value;\n                        }\n                    },\n                    {\n                        key: \"_swap\",\n                        value: function _swap(A, i, j) {\n                            var temp = this._get(A, i);\n                            this._set(A, i, this._get(A, j));\n                            this._set(A, j, temp);\n                        }\n                    },\n                    {\n                        key: \"_defaultCompareFunction\",\n                        value: function _defaultCompareFunction(a, b) {\n                            return b > a;\n                        }\n                    }\n                ]);\n                return Quicksort;\n            }();\n            module1.exports = Quicksort;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */ var NeedlemanWunsch = function() {\n                function NeedlemanWunsch(sequence1, sequence2) {\n                    var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n                    var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n                    _classCallCheck(this, NeedlemanWunsch);\n                    this.sequence1 = sequence1;\n                    this.sequence2 = sequence2;\n                    this.match_score = match_score;\n                    this.mismatch_penalty = mismatch_penalty;\n                    this.gap_penalty = gap_penalty;\n                    // Just the remove redundancy\n                    this.iMax = sequence1.length + 1;\n                    this.jMax = sequence2.length + 1;\n                    // Grid matrix of scores\n                    this.grid = new Array(this.iMax);\n                    for(var i = 0; i < this.iMax; i++){\n                        this.grid[i] = new Array(this.jMax);\n                        for(var j = 0; j < this.jMax; j++){\n                            this.grid[i][j] = 0;\n                        }\n                    }\n                    // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n                    this.tracebackGrid = new Array(this.iMax);\n                    for(var _i = 0; _i < this.iMax; _i++){\n                        this.tracebackGrid[_i] = new Array(this.jMax);\n                        for(var _j = 0; _j < this.jMax; _j++){\n                            this.tracebackGrid[_i][_j] = [\n                                null,\n                                null,\n                                null\n                            ];\n                        }\n                    }\n                    // The aligned sequences (return multiple possibilities)\n                    this.alignments = [];\n                    // Final alignment score\n                    this.score = -1;\n                    // Calculate scores and tracebacks\n                    this.computeGrids();\n                }\n                _createClass(NeedlemanWunsch, [\n                    {\n                        key: \"getScore\",\n                        value: function getScore() {\n                            return this.score;\n                        }\n                    },\n                    {\n                        key: \"getAlignments\",\n                        value: function getAlignments() {\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"computeGrids\",\n                        value: function computeGrids() {\n                            // Fill in the first row\n                            for(var j = 1; j < this.jMax; j++){\n                                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                                this.tracebackGrid[0][j] = [\n                                    false,\n                                    false,\n                                    true\n                                ];\n                            }\n                            // Fill in the first column\n                            for(var i = 1; i < this.iMax; i++){\n                                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                                this.tracebackGrid[i][0] = [\n                                    false,\n                                    true,\n                                    false\n                                ];\n                            }\n                            // Fill the rest of the grid\n                            for(var _i2 = 1; _i2 < this.iMax; _i2++){\n                                for(var _j2 = 1; _j2 < this.jMax; _j2++){\n                                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                                    var diag = void 0;\n                                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;\n                                    else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n                                    // If there exists multiple max values, capture them for multiple paths\n                                    var maxOf = [\n                                        diag,\n                                        up,\n                                        left\n                                    ];\n                                    var indices = this.arrayAllMaxIndexes(maxOf);\n                                    // Update Grids\n                                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                                    this.tracebackGrid[_i2][_j2] = [\n                                        indices.includes(0),\n                                        indices.includes(1),\n                                        indices.includes(2)\n                                    ];\n                                }\n                            }\n                            // Update alignment score\n                            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n                        }\n                    },\n                    {\n                        key: \"alignmentTraceback\",\n                        value: function alignmentTraceback() {\n                            var inProcessAlignments = [];\n                            inProcessAlignments.push({\n                                pos: [\n                                    this.sequence1.length,\n                                    this.sequence2.length\n                                ],\n                                seq1: \"\",\n                                seq2: \"\"\n                            });\n                            while(inProcessAlignments[0]){\n                                var current = inProcessAlignments[0];\n                                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n                                if (directions[0]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (directions[1]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1]\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: \"-\" + current.seq2\n                                    });\n                                }\n                                if (directions[2]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0],\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: \"-\" + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                                    sequence1: current.seq1,\n                                    sequence2: current.seq2\n                                });\n                                inProcessAlignments.shift();\n                            }\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"getAllIndexes\",\n                        value: function getAllIndexes(arr, val) {\n                            var indexes = [], i = -1;\n                            while((i = arr.indexOf(val, i + 1)) !== -1){\n                                indexes.push(i);\n                            }\n                            return indexes;\n                        }\n                    },\n                    {\n                        key: \"arrayAllMaxIndexes\",\n                        value: function arrayAllMaxIndexes(array) {\n                            return this.getAllIndexes(array, Math.max.apply(null, array));\n                        }\n                    }\n                ]);\n                return NeedlemanWunsch;\n            }();\n            module1.exports = NeedlemanWunsch;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_163821__) {\n            \"use strict\";\n            var layoutBase = function layoutBase() {\n                return;\n            };\n            layoutBase.FDLayout = __nested_webpack_require_163821__(18);\n            layoutBase.FDLayoutConstants = __nested_webpack_require_163821__(7);\n            layoutBase.FDLayoutEdge = __nested_webpack_require_163821__(19);\n            layoutBase.FDLayoutNode = __nested_webpack_require_163821__(20);\n            layoutBase.DimensionD = __nested_webpack_require_163821__(21);\n            layoutBase.HashMap = __nested_webpack_require_163821__(22);\n            layoutBase.HashSet = __nested_webpack_require_163821__(23);\n            layoutBase.IGeometry = __nested_webpack_require_163821__(8);\n            layoutBase.IMath = __nested_webpack_require_163821__(9);\n            layoutBase.Integer = __nested_webpack_require_163821__(10);\n            layoutBase.Point = __nested_webpack_require_163821__(12);\n            layoutBase.PointD = __nested_webpack_require_163821__(4);\n            layoutBase.RandomSeed = __nested_webpack_require_163821__(16);\n            layoutBase.RectangleD = __nested_webpack_require_163821__(13);\n            layoutBase.Transform = __nested_webpack_require_163821__(17);\n            layoutBase.UniqueIDGeneretor = __nested_webpack_require_163821__(14);\n            layoutBase.Quicksort = __nested_webpack_require_163821__(24);\n            layoutBase.LinkedList = __nested_webpack_require_163821__(11);\n            layoutBase.LGraphObject = __nested_webpack_require_163821__(2);\n            layoutBase.LGraph = __nested_webpack_require_163821__(5);\n            layoutBase.LEdge = __nested_webpack_require_163821__(1);\n            layoutBase.LGraphManager = __nested_webpack_require_163821__(6);\n            layoutBase.LNode = __nested_webpack_require_163821__(3);\n            layoutBase.Layout = __nested_webpack_require_163821__(15);\n            layoutBase.LayoutConstants = __nested_webpack_require_163821__(0);\n            layoutBase.NeedlemanWunsch = __nested_webpack_require_163821__(25);\n            module1.exports = layoutBase;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Emitter() {\n                this.listeners = [];\n            }\n            var p = Emitter.prototype;\n            p.addListener = function(event, callback) {\n                this.listeners.push({\n                    event: event,\n                    callback: callback\n                });\n            };\n            p.removeListener = function(event, callback) {\n                for(var i = this.listeners.length; i >= 0; i--){\n                    var l = this.listeners[i];\n                    if (l.event === event && l.callback === callback) {\n                        this.listeners.splice(i, 1);\n                    }\n                }\n            };\n            p.emit = function(event, data) {\n                for(var i = 0; i < this.listeners.length; i++){\n                    var l = this.listeners[i];\n                    if (event === l.event) {\n                        l.callback(data);\n                    }\n                }\n            };\n            module1.exports = Emitter;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0Q7U0FDYixFQUsyQkE7QUFDakMsR0FBRyxRQUFNO0lBQ1QsT0FBZ0IsTUFBSCxHQUFJLFNBQVNLLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNQLE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU0ksZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNVCxTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS0ksT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1QsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVNLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLTCxRQUFPUSxDQUFDLEdBQUc7WUFDdEIsTUFBTSxHQUNOLE1BQU0sR0FBSyxtQ0FBbUM7WUFDOUMsTUFBTSxHQUFLLE9BQU9SLFFB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QUNiO2dCQUNGO1lBQ0Y7WUFFQXZ0QixRQUFPRCxPQUFPLEdBQUdrZDtRQUVqQixHQUFHLEdBQUc7S0FDSTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGNoYXQvLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanM/YTVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExheW91dENvbnN0YW50cygpIHt9XG5cbi8qKlxyXG4gKiBMYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAxO1xuXG4vKipcclxuICogRGVmYXVsdCBwYXJhbWV0ZXJzXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQgPSB0cnVlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0QgPSA1MDtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gZmFsc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBHZW5lcmFsIG90aGVyIGNvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXHJcbiAqIE1hcmdpbnMgb2YgYSBncmFwaCB0byBiZSBhcHBsaWVkIG9uIGJvdWRpbmcgcmVjdGFuZ2xlIG9mIGl0cyBjb250ZW50cy4gV2VcclxuICogYXNzdW1lIG1hcmdpbnMgb24gYWxsIGZvdXIgc2lkZXMgdG8gYmUgdW5pZm9ybS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU4gPSAxNTtcblxuLypcclxuICogV2hldGhlciB0byBjb25zaWRlciBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zIG9yIG5vdFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBmYWxzZTtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9IQUxGX1NJWkUgPSBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSAvIDI7XG5cbi8qXHJcbiAqIEVtcHR5IGNvbXBvdW5kIG5vZGUgc2l6ZS4gV2hlbiBhIGNvbXBvdW5kIG5vZGUgaXMgZW1wdHksIGl0cyBib3RoXHJcbiAqIGRpbWVuc2lvbnMgc2hvdWxkIGJlIG9mIHRoaXMgdmFsdWUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBNaW5pbXVtIGxlbmd0aCB0aGF0IGFuIGVkZ2Ugc2hvdWxkIHRha2UgZHVyaW5nIGxheW91dFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgbGF5b3V0IG9wZXJhdGVzIG9uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZID0gMTAwMDAwMDtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IHJhbmRvbSBwb3NpdGlvbmluZyBjYW4gYmUgcGVyZm9ybWVkIHdpdGhcclxuICovXG5MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSAvIDEwMDA7XG5cbi8qXHJcbiAqIENvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBjZW50ZXJcclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggPSAxMjAwO1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZID0gOTAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBMRWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkVkZ2UpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZmFsc2U7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkVkZ2U7XG4gIHRoaXMuYmVuZHBvaW50cyA9IFtdO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbkxFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExFZGdlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2U7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNJbnRlckdyYXBoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0ludGVyR3JhcGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0QmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYmVuZHBvaW50cztcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2VJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlSW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0SW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldEluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc291cmNlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiTm9kZSBpcyBub3QgaW5jaWRlbnQgd2l0aCB0aGlzIGVkZ2VcIjtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kSW5HcmFwaCA9IGZ1bmN0aW9uIChub2RlLCBncmFwaCkge1xuICB2YXIgb3RoZXJFbmQgPSB0aGlzLmdldE90aGVyRW5kKG5vZGUpO1xuICB2YXIgcm9vdCA9IGdyYXBoLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IGdyYXBoKSB7XG4gICAgICByZXR1cm4gb3RoZXJFbmQ7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgb3RoZXJFbmQgPSBvdGhlckVuZC5nZXRPd25lcigpLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xpcFBvaW50Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBJR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uKHRoaXMudGFyZ2V0LmdldFJlY3QoKSwgdGhpcy5zb3VyY2UuZ2V0UmVjdCgpLCBjbGlwUG9pbnRDb29yZGluYXRlcyk7XG5cbiAgaWYgKCF0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzBdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMl07XG4gICAgdGhpcy5sZW5ndGhZID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMV0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1szXTtcblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoU2ltcGxlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlbmd0aFggPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJYKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJYKCk7XG4gIHRoaXMubGVuZ3RoWSA9IHRoaXMudGFyZ2V0LmdldENlbnRlclkoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclkoKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMR3JhcGhPYmplY3QodkdyYXBoT2JqZWN0KSB7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkdyYXBoT2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBSYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gTE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAxIDogTE5vZGUoTEdyYXBoTWFuYWdlciBnbSwgUG9pbnQgbG9jLCBEaW1lbnNpb24gc2l6ZSwgT2JqZWN0IHZOb2RlKVxuICBpZiAoc2l6ZSA9PSBudWxsICYmIHZOb2RlID09IG51bGwpIHtcbiAgICB2Tm9kZSA9IGxvYztcbiAgfVxuXG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZOb2RlKTtcblxuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDIgOiBMTm9kZShMYXlvdXQgbGF5b3V0LCBPYmplY3Qgdk5vZGUpXG4gIGlmIChnbS5ncmFwaE1hbmFnZXIgIT0gbnVsbCkgZ20gPSBnbS5ncmFwaE1hbmFnZXI7XG5cbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdk5vZGU7XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcblxuICBpZiAoc2l6ZSAhPSBudWxsICYmIGxvYyAhPSBudWxsKSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRChsb2MueCwgbG9jLnksIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtlbHNlIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKCk7XG59XG5cbkxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMTm9kZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0T3duZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vICBpZiAodGhpcy5vd25lciAhPSBudWxsKSB7XG4gIC8vICAgIGlmICghKHRoaXMub3duZXIgPT0gbnVsbCB8fCB0aGlzLm93bmVyLmdldE5vZGVzKCkuaW5kZXhPZih0aGlzKSA+IC0xKSkge1xuICAvLyAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAvLyAgICB9XG4gIC8vICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy5yZWN0LndpZHRoID0gd2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMiwgdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMik7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXREaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaGFsZiB0aGUgZGlhZ29uYWwgbGVuZ3RoIG9mIHRoaXMgbm9kZS5cbiAqL1xuTE5vZGUucHJvdG90eXBlLmdldEhhbGZUaGVEaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCArIHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCkgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFJlY3QgPSBmdW5jdGlvbiAodXBwZXJMZWZ0LCBkaW1lbnNpb24pIHtcbiAgdGhpcy5yZWN0LnggPSB1cHBlckxlZnQueDtcbiAgdGhpcy5yZWN0LnkgPSB1cHBlckxlZnQueTtcbiAgdGhpcy5yZWN0LndpZHRoID0gZGltZW5zaW9uLndpZHRoO1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY3gsIGN5KSB7XG4gIHRoaXMucmVjdC54ID0gY3ggLSB0aGlzLnJlY3Qud2lkdGggLyAyO1xuICB0aGlzLnJlY3QueSA9IGN5IC0gdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnJlY3QueCA9IHg7XG4gIHRoaXMucmVjdC55ID0geTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIHRoaXMucmVjdC54ICs9IGR4O1xuICB0aGlzLnJlY3QueSArPSBkeTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlTGlzdFRvTm9kZSA9IGZ1bmN0aW9uICh0bykge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSB0bykge1xuICAgICAgaWYgKGVkZ2Uuc291cmNlICE9IHNlbGYpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIVwiO1xuXG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzQmV0d2VlbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmICghKGVkZ2Uuc291cmNlID09IHNlbGYgfHwgZWRnZS50YXJnZXQgPT0gc2VsZikpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXRcIjtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSBvdGhlciB8fCBlZGdlLnNvdXJjZSA9PSBvdGhlcikge1xuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROZWlnaGJvcnNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmVpZ2hib3JzID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS5zb3VyY2UgPT0gc2VsZikge1xuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlZGdlLnRhcmdldCAhPSBzZWxmKSB7XG4gICAgICAgIHRocm93IFwiSW5jb3JyZWN0IGluY2lkZW5jeSFcIjtcbiAgICAgIH1cblxuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLndpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdpdGhOZWlnaGJvcnNMaXN0ID0gbmV3IFNldCgpO1xuICB2YXIgY2hpbGROb2RlO1xuICB2YXIgY2hpbGRyZW47XG5cbiAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKHRoaXMpO1xuXG4gIGlmICh0aGlzLmNoaWxkICE9IG51bGwpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkTm9kZS53aXRoQ2hpbGRyZW4oKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpdGhOZWlnaGJvcnNMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5vT2ZDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vT2ZDaGlsZHJlbiA9IDA7XG4gIHZhciBjaGlsZE5vZGU7XG5cbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBub09mQ2hpbGRyZW4gKz0gY2hpbGROb2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub09mQ2hpbGRyZW4gPT0gMCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG5vT2ZDaGlsZHJlbjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5jYWxjRXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemUgPSAodGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCkgLyAyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuY2hpbGQuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgICB0aGlzLnJlY3Qud2lkdGggPSB0aGlzLmVzdGltYXRlZFNpemU7XG4gICAgdGhpcy5yZWN0LmhlaWdodCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zY2F0dGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmFuZG9tQ2VudGVyWDtcbiAgdmFyIHJhbmRvbUNlbnRlclk7XG5cbiAgdmFyIG1pblggPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhYID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclggPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhYIC0gbWluWCkgKyBtaW5YO1xuXG4gIHZhciBtaW5ZID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WSA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WSAtIG1pblkpICsgbWluWTtcblxuICB0aGlzLnJlY3QueCA9IHJhbmRvbUNlbnRlclg7XG4gIHRoaXMucmVjdC55ID0gcmFuZG9tQ2VudGVyWTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIGlmICh0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKS5sZW5ndGggIT0gMCkge1xuICAgIC8vIHdyYXAgdGhlIGNoaWxkcmVuIG5vZGVzIGJ5IHJlLWFycmFuZ2luZyB0aGUgYm91bmRhcmllc1xuICAgIHZhciBjaGlsZEdyYXBoID0gdGhpcy5nZXRDaGlsZCgpO1xuICAgIGNoaWxkR3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xuXG4gICAgdGhpcy5yZWN0LnggPSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICB0aGlzLnJlY3QueSA9IGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICB0aGlzLnNldFdpZHRoKGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpKTtcbiAgICB0aGlzLnNldEhlaWdodChjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKSk7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzICAgIFxuICAgIGlmIChMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgICAgdmFyIGhlaWdodCA9IGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgdGhpcy5yZWN0LnggLT0gKHRoaXMubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxQb3MgPT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIHRoaXMucmVjdC55IC09ICh0aGlzLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvcyA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gdGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEhlaWdodCh0aGlzLmxhYmVsSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmluY2x1c2lvblRyZWVEZXB0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlY3QueDtcblxuICBpZiAobGVmdCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAobGVmdCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciB0b3AgPSB0aGlzLnJlY3QueTtcblxuICBpZiAodG9wID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKHRvcCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIGxlZnRUb3AgPSBuZXcgUG9pbnREKGxlZnQsIHRvcCk7XG4gIHZhciB2TGVmdFRvcCA9IHRyYW5zLmludmVyc2VUcmFuc2Zvcm1Qb2ludChsZWZ0VG9wKTtcblxuICB0aGlzLnNldExvY2F0aW9uKHZMZWZ0VG9wLngsIHZMZWZ0VG9wLnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm93bmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyLmdldFBhcmVudCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMTm9kZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFBvaW50RCh4LCB5KSB7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxufVxuXG5Qb2ludEQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgdGhpcy55ID0geTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwdCkge1xuICByZXR1cm4gbmV3IERpbWVuc2lvbkQodGhpcy54IC0gcHQueCwgdGhpcy55IC0gcHQueSk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMueCwgdGhpcy55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGRpbSkge1xuICB0aGlzLnggKz0gZGltLndpZHRoO1xuICB0aGlzLnkgKz0gZGltLmhlaWdodDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50RDtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5mdW5jdGlvbiBMR3JhcGgocGFyZW50LCBvYmoyLCB2R3JhcGgpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkdyYXBoKTtcbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMubWFyZ2luID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMubm9kZXMgPSBbXTtcbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMR3JhcGhNYW5hZ2VyKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyO1xuICB9IGVsc2UgaWYgKG9iajIgIT0gbnVsbCAmJiBvYmoyIGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyLmdyYXBoTWFuYWdlcjtcbiAgfVxufVxuXG5MR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExHcmFwaFtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXM7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZWZ0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmlnaHQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9wO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJvdHRvbTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqMSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICBpZiAoc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIHZhciBuZXdOb2RlID0gb2JqMTtcbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBoYXMgbm8gZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXROb2RlcygpLmluZGV4T2YobmV3Tm9kZSkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJOb2RlIGFscmVhZHkgaW4gZ3JhcGghXCI7XG4gICAgfVxuICAgIG5ld05vZGUub3duZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2V0Tm9kZXMoKS5wdXNoKG5ld05vZGUpO1xuXG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld0VkZ2UgPSBvYmoxO1xuICAgIGlmICghKHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKHNvdXJjZU5vZGUpID4gLTEgJiYgdGhpcy5nZXROb2RlcygpLmluZGV4T2YodGFyZ2V0Tm9kZSkgPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIG9yIHRhcmdldCBub3QgaW4gZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKCEoc291cmNlTm9kZS5vd25lciA9PSB0YXJnZXROb2RlLm93bmVyICYmIHNvdXJjZU5vZGUub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiQm90aCBvd25lcnMgbXVzdCBiZSB0aGlzIGdyYXBoIVwiO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VOb2RlLm93bmVyICE9IHRhcmdldE5vZGUub3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICBuZXdFZGdlLnRhcmdldCA9IHRhcmdldE5vZGU7XG5cbiAgICAvLyBzZXQgYXMgaW50cmEtZ3JhcGggZWRnZVxuICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG5cbiAgICAvLyBhZGQgdG8gZ3JhcGggZWRnZSBsaXN0XG4gICAgdGhpcy5nZXRFZGdlcygpLnB1c2gobmV3RWRnZSk7XG5cbiAgICAvLyBhZGQgdG8gaW5jaWRlbmN5IGxpc3RzXG4gICAgc291cmNlTm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgaWYgKHRhcmdldE5vZGUgIT0gc291cmNlTm9kZSkge1xuICAgICAgdGFyZ2V0Tm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdFZGdlO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIG5vZGUgPSBvYmo7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiTm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShub2RlLm93bmVyICE9IG51bGwgJiYgbm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBpcyBpbnZhbGlkIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBtYW5hZ2VyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBpbmNpZGVudCBlZGdlcyBmaXJzdCAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBlZGdlc1RvQmVSZW1vdmVkID0gbm9kZS5lZGdlcy5zbGljZSgpO1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuXG4gICAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5zb3VyY2Uub3duZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyB0aGUgbm9kZSBpdHNlbGZcbiAgICB2YXIgaW5kZXggPSB0aGlzLm5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgbm90IGluIG93bmVyIG5vZGUgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2UudGFyZ2V0Lm93bmVyICE9IG51bGwgJiYgZWRnZS5zb3VyY2Uub3duZXIgPT0gdGhpcyAmJiBlZGdlLnRhcmdldC5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBvd25lciBpcyBpbnZhbGlkIVwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoIShzb3VyY2VJbmRleCA+IC0xICYmIHRhcmdldEluZGV4ID4gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKHNvdXJjZUluZGV4LCAxKTtcblxuICAgIGlmIChlZGdlLnRhcmdldCAhPSBlZGdlLnNvdXJjZSkge1xuICAgICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vdCBpbiBvd25lcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlTGVmdFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbWFyZ2luO1xuXG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gRG8gd2UgaGF2ZSBhbnkgbm9kZXMgaW4gdGhpcyBncmFwaD9cbiAgaWYgKHRvcCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gbGVmdCAtIG1hcmdpbjtcbiAgdGhpcy50b3AgPSB0b3AgLSBtYXJnaW47XG5cbiAgLy8gQXBwbHkgdGhlIG1hcmdpbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChyZWN1cnNpdmUpIHtcbiAgLy8gY2FsY3VsYXRlIGJvdW5kc1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAocmVjdXJzaXZlICYmIGxOb2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIGxOb2RlLnVwZGF0ZUJvdW5kcygpO1xuICAgIH1cbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIGlmIChsZWZ0ID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5wYXJlbnQuZ2V0TGVmdCgpO1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnBhcmVudC5nZXRSaWdodCgpO1xuICAgIHRoaXMudG9wID0gdGhpcy5wYXJlbnQuZ2V0VG9wKCk7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLnBhcmVudC5nZXRCb3R0b20oKTtcbiAgfVxuXG4gIGlmIChub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdCAhPSB1bmRlZmluZWQpIHtcbiAgICBtYXJnaW4gPSBub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgfVxuXG4gIHRoaXMubGVmdCA9IGJvdW5kaW5nUmVjdC54IC0gbWFyZ2luO1xuICB0aGlzLnJpZ2h0ID0gYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggKyBtYXJnaW47XG4gIHRoaXMudG9wID0gYm91bmRpbmdSZWN0LnkgLSBtYXJnaW47XG4gIHRoaXMuYm90dG9tID0gYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgbWFyZ2luO1xufTtcblxuTEdyYXBoLmNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG5cbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG5cbiAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0SW5jbHVzaW9uVHJlZURlcHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcyA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgc2l6ZSArPSBsTm9kZS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB9XG5cbiAgaWYgKHNpemUgPT0gMCkge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IExheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gc2l6ZSAvIE1hdGguc3FydCh0aGlzLm5vZGVzLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5ub2Rlc1swXTtcbiAgdmFyIG5laWdoYm9yRWRnZXM7XG4gIHZhciBjdXJyZW50TmVpZ2hib3I7XG4gIHZhciBjaGlsZHJlbk9mTm9kZSA9IGN1cnJlbnROb2RlLndpdGhDaGlsZHJlbigpO1xuICBjaGlsZHJlbk9mTm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcXVldWUucHVzaChub2RlKTtcbiAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcblxuICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG4gICAgdmFyIHNpemUgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIG5laWdoYm9yRWRnZSA9IG5laWdoYm9yRWRnZXNbaV07XG4gICAgICBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2UuZ2V0T3RoZXJFbmRJbkdyYXBoKGN1cnJlbnROb2RlLCB0aGlzKTtcblxuICAgICAgLy8gQWRkIHVudmlzaXRlZCBuZWlnaGJvcnMgdG8gdGhlIGxpc3QgdG8gdmlzaXRcbiAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5PZk5laWdoYm9yID0gY3VycmVudE5laWdoYm9yLndpdGhDaGlsZHJlbigpO1xuXG4gICAgICAgIGNoaWxkcmVuT2ZOZWlnaGJvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIGlmICh2aXNpdGVkLnNpemUgPj0gdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgbm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9IDA7XG5cbiAgICB2aXNpdGVkLmZvckVhY2goZnVuY3Rpb24gKHZpc2l0ZWROb2RlKSB7XG4gICAgICBpZiAodmlzaXRlZE5vZGUub3duZXIgPT0gc2VsZikge1xuICAgICAgICBub09mVmlzaXRlZEluVGhpc0dyYXBoKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGg7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiBMR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpOyAvLyBJdCBtYXkgYmUgYmV0dGVyIHRvIGluaXRpbGl6ZSB0aGlzIG91dCBvZiB0aGlzIGZ1bmN0aW9uIGJ1dCBpdCBnaXZlcyBhbiBlcnJvciAoUmlnaHQtaGFuZCBzaWRlIG9mICdpbnN0YW5jZW9mJyBpcyBub3QgY2FsbGFibGUpIG5vdy5cbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG5cbiAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xufVxuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5hZGRSb290ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmdyYXBoID0gdGhpcy5sYXlvdXQubmV3R3JhcGgoKTtcbiAgdmFyIG5ub2RlID0gdGhpcy5sYXlvdXQubmV3Tm9kZShudWxsKTtcbiAgdmFyIHJvb3QgPSB0aGlzLmFkZChuZ3JhcGgsIG5ub2RlKTtcbiAgdGhpcy5zZXRSb290R3JhcGgocm9vdCk7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdHcmFwaCwgcGFyZW50Tm9kZSwgbmV3RWRnZSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICAvL3RoZXJlIGFyZSBqdXN0IDIgcGFyYW1ldGVycyBhcmUgcGFzc2VkIHRoZW4gaXQgYWRkcyBhbiBMR3JhcGggZWxzZSBpdCBhZGRzIGFuIExFZGdlXG4gIGlmIChuZXdFZGdlID09IG51bGwgJiYgc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIGlmIChuZXdHcmFwaCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiUGFyZW50IG5vZGUgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGhzLmluZGV4T2YobmV3R3JhcGgpID4gLTEpIHtcbiAgICAgIHRocm93IFwiR3JhcGggYWxyZWFkeSBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBocy5wdXNoKG5ld0dyYXBoKTtcblxuICAgIGlmIChuZXdHcmFwaC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIHBhcmVudCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIGNoaWxkIVwiO1xuICAgIH1cblxuICAgIG5ld0dyYXBoLnBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5jaGlsZCA9IG5ld0dyYXBoO1xuXG4gICAgcmV0dXJuIG5ld0dyYXBoO1xuICB9IGVsc2Uge1xuICAgIC8vY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgcGFyYW1ldGVyc1xuICAgIHRhcmdldE5vZGUgPSBuZXdFZGdlO1xuICAgIHNvdXJjZU5vZGUgPSBwYXJlbnROb2RlO1xuICAgIG5ld0VkZ2UgPSBuZXdHcmFwaDtcbiAgICB2YXIgc291cmNlR3JhcGggPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgdmFyIHRhcmdldEdyYXBoID0gdGFyZ2V0Tm9kZS5nZXRPd25lcigpO1xuXG4gICAgaWYgKCEoc291cmNlR3JhcGggIT0gbnVsbCAmJiBzb3VyY2VHcmFwaC5nZXRHcmFwaE1hbmFnZXIoKSA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAoISh0YXJnZXRHcmFwaCAhPSBudWxsICYmIHRhcmdldEdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlRhcmdldCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZUdyYXBoID09IHRhcmdldEdyYXBoKSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHNvdXJjZUdyYXBoLmFkZChuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSB0cnVlO1xuXG4gICAgICAvLyBzZXQgc291cmNlIGFuZCB0YXJnZXRcbiAgICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gaW50ZXItZ3JhcGggZWRnZSBsaXN0XG4gICAgICBpZiAodGhpcy5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIGFscmVhZHkgaW4gaW50ZXItZ3JhcGggZWRnZSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIC8vIGFkZCBlZGdlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IGluY2lkZW5jeSBsaXN0c1xuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBuZXdFZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA9PSAtMSAmJiBuZXdFZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBzb3VyY2UgYW5kL29yIHRhcmdldCBpbmNpZGVuY3kgbGlzdCFcIjtcbiAgICAgIH1cblxuICAgICAgbmV3RWRnZS5zb3VyY2UuZWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxPYmopIHtcbiAgaWYgKGxPYmogaW5zdGFuY2VvZiBMR3JhcGgpIHtcbiAgICB2YXIgZ3JhcGggPSBsT2JqO1xuICAgIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIG5vdCBpbiB0aGlzIGdyYXBoIG1nclwiO1xuICAgIH1cbiAgICBpZiAoIShncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCB8fCBncmFwaC5wYXJlbnQgIT0gbnVsbCAmJiBncmFwaC5wYXJlbnQuZ3JhcGhNYW5hZ2VyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgcGFyZW50IG5vZGUhXCI7XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgdGhlIGVkZ2VzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIGVkZ2VzVG9CZVJlbW92ZWQgPSBlZGdlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXRFZGdlcygpKTtcblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICAgIC8vIHRoZW4gdGhlIG5vZGVzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIG5vZGVzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIG5vZGVzVG9CZVJlbW92ZWQgPSBub2Rlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcblxuICAgIHZhciBub2RlO1xuICAgIHMgPSBub2Rlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZ3JhcGggaXMgdGhlIHJvb3RcbiAgICBpZiAoZ3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgIHRoaXMuc2V0Um9vdEdyYXBoKG51bGwpO1xuICAgIH1cblxuICAgIC8vIG5vdyByZW1vdmUgdGhlIGdyYXBoIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMuZ3JhcGhzLmluZGV4T2YoZ3JhcGgpO1xuICAgIHRoaXMuZ3JhcGhzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyBhbHNvIHJlc2V0IHRoZSBwYXJlbnQgb2YgdGhlIGdyYXBoXG4gICAgZ3JhcGgucGFyZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChsT2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICBlZGdlID0gbE9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCFlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgdGhyb3cgXCJOb3QgYW4gaW50ZXItZ3JhcGggZWRnZSFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMnIGluY2lkZW5jeSBsaXN0c1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKSAhPSAtMSAmJiBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBkb2Vzbid0IGtub3cgdGhpcyBlZGdlIVwiO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gb3duZXIgZ3JhcGggbWFuYWdlcidzIGludGVyLWdyYXBoIGVkZ2UgbGlzdFxuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2Uub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKSAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJFZGdlIG93bmVyIGdyYXBoIG9yIG93bmVyIGdyYXBoIG1hbmFnZXIgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyIGdyYXBoIG1hbmFnZXIncyBlZGdlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEdyYXBocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzID09IG51bGwpIHtcbiAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIG5vZGVMaXN0ID0gbm9kZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgdGhpcy5hbGxOb2RlcyA9IG5vZGVMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2RlcyA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbEVkZ2VzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbEVkZ2VzID09IG51bGwpIHtcbiAgICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXRFZGdlcygpKTtcbiAgICB9XG5cbiAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdCh0aGlzLmVkZ2VzKTtcblxuICAgIHRoaXMuYWxsRWRnZXMgPSBlZGdlTGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcy5hbGxFZGdlcztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbjtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKG5vZGVMaXN0KSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uICE9IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBub2RlTGlzdDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldFJvb3RHcmFwaCA9IGZ1bmN0aW9uIChncmFwaCkge1xuICBpZiAoZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gdGhpcykge1xuICAgIHRocm93IFwiUm9vdCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gIH1cblxuICB0aGlzLnJvb3RHcmFwaCA9IGdyYXBoO1xuICAvLyByb290IGdyYXBoIG11c3QgaGF2ZSBhIHJvb3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXQgZm9yIGNvbnZlbmllbmNlXG4gIGlmIChncmFwaC5wYXJlbnQgPT0gbnVsbCkge1xuICAgIGdyYXBoLnBhcmVudCA9IHRoaXMubGF5b3V0Lm5ld05vZGUoXCJSb290IG5vZGVcIik7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaXNPbmVBbmNlc3Rvck9mT3RoZXIgPSBmdW5jdGlvbiAoZmlyc3ROb2RlLCBzZWNvbmROb2RlKSB7XG4gIGlmICghKGZpcnN0Tm9kZSAhPSBudWxsICYmIHNlY29uZE5vZGUgIT0gbnVsbCkpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIGlmIChmaXJzdE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElzIHNlY29uZCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBmaXJzdCBvbmU/XG4gIHZhciBvd25lckdyYXBoID0gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcbiAgLy8gSXMgZmlyc3Qgbm9kZSBhbiBhbmNlc3RvciBvZiB0aGUgc2Vjb25kIG9uZT9cbiAgb3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgcGFyZW50Tm9kZSA9IG93bmVyR3JhcGguZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBmaXJzdE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIHNvdXJjZU5vZGU7XG4gIHZhciB0YXJnZXROb2RlO1xuICB2YXIgc291cmNlQW5jZXN0b3JHcmFwaDtcbiAgdmFyIHRhcmdldEFuY2VzdG9yR3JhcGg7XG5cbiAgdmFyIGVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgcyA9IGVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBzb3VyY2VOb2RlID0gZWRnZS5zb3VyY2U7XG4gICAgdGFyZ2V0Tm9kZSA9IGVkZ2UudGFyZ2V0O1xuICAgIGVkZ2UubGNhID0gbnVsbDtcbiAgICBlZGdlLnNvdXJjZUluTGNhID0gc291cmNlTm9kZTtcbiAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcblxuICAgIGlmIChzb3VyY2VOb2RlID09IHRhcmdldE5vZGUpIHtcbiAgICAgIGVkZ2UubGNhID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc291cmNlQW5jZXN0b3JHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcblxuICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcbiAgICAgIHRhcmdldEFuY2VzdG9yR3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHNvdXJjZUFuY2VzdG9yR3JhcGgpIHtcbiAgICAgICAgICBlZGdlLmxjYSA9IHRhcmdldEFuY2VzdG9yR3JhcGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0QW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UubGNhICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaC5nZXRQYXJlbnQoKTtcbiAgICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IGVkZ2UudGFyZ2V0SW5MY2EuZ2V0T3duZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUFuY2VzdG9yR3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gZWRnZS5zb3VyY2VJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuICB9XG4gIHZhciBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgaWYgKGZpcnN0T3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmROb2RlLmdldE93bmVyKCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBmaXJzdE93bmVyR3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZE93bmVyR3JhcGg7XG4gICAgICB9XG4gICAgICBzZWNvbmRPd25lckdyYXBoID0gc2Vjb25kT3duZXJHcmFwaC5nZXRQYXJlbnQoKS5nZXRPd25lcigpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgZmlyc3RPd25lckdyYXBoID0gZmlyc3RPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmaXJzdE93bmVyR3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyA9IGZ1bmN0aW9uIChncmFwaCwgZGVwdGgpIHtcbiAgaWYgKGdyYXBoID09IG51bGwgJiYgZGVwdGggPT0gbnVsbCkge1xuICAgIGdyYXBoID0gdGhpcy5yb290R3JhcGg7XG4gICAgZGVwdGggPSAxO1xuICB9XG4gIHZhciBub2RlO1xuXG4gIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlLmluY2x1c2lvblRyZWVEZXB0aCA9IGRlcHRoO1xuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyhub2RlLmNoaWxkLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaW5jbHVkZXNJbnZhbGlkRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG5cbiAgdmFyIHMgPSB0aGlzLmVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblxuICAgIGlmICh0aGlzLmlzT25lQW5jZXN0b3JPZk90aGVyKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gRkRMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vL0ZETGF5b3V0Q29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gTGF5b3V0Q29uc3RhbnRzKSB7XG4gIEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdID0gTGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5GRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IDI1MDA7XG5cbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gMC40NTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gNDUwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gMC40O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gMS4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDMuODtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSAxLjU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT04gPSB0cnVlO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IDAuMztcbkZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IgPSAwLjMzO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUID0gMTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCA9IDUwMDA7XG5GRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwgPSAxMDAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCAqIDM7XG5GRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCA9IDEwMDtcbkZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSAwLjE7XG5GRExheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBtYWludGFpbnMgYSBsaXN0IG9mIHN0YXRpYyBnZW9tZXRyeSByZWxhdGVkIHV0aWxpdHkgbWV0aG9kcy5cbiAqXG4gKlxuICogQ29weXJpZ2h0OiBpLVZpcyBSZXNlYXJjaCBHcm91cCwgQmlsa2VudCBVbml2ZXJzaXR5LCAyMDA3IC0gcHJlc2VudFxuICovXG5cbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5mdW5jdGlvbiBJR2VvbWV0cnkoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgKmhhbGYqIHRoZSBhbW91bnQgaW4geCBhbmQgeSBkaXJlY3Rpb25zIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgbmVlZGVkIHRvIHNlcGFyYXRlIHRoZW0ga2VlcGluZyB0aGVpciByZXNwZWN0aXZlXG4gKiBwb3NpdGlvbmluZywgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgYXJyYXkuIEFuIGlucHV0XG4gKiBzZXBhcmF0aW9uIGJ1ZmZlciBhZGRlZCB0byB0aGUgYW1vdW50IGluIGJvdGggZGlyZWN0aW9ucy4gV2UgYXNzdW1lIHRoYXRcbiAqIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBpbnRlcnNlY3QuXG4gKi9cbklHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIHNlcGFyYXRpb25CdWZmZXIpIHtcbiAgaWYgKCFyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdmFyIGRpcmVjdGlvbnMgPSBuZXcgQXJyYXkoMik7XG5cbiAgdGhpcy5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyhyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpO1xuXG4gIG92ZXJsYXBBbW91bnRbMF0gPSBNYXRoLm1pbihyZWN0QS5nZXRSaWdodCgpLCByZWN0Qi5nZXRSaWdodCgpKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xuICBvdmVybGFwQW1vdW50WzFdID0gTWF0aC5taW4ocmVjdEEuZ2V0Qm90dG9tKCksIHJlY3RCLmdldEJvdHRvbSgpKSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xuXG4gIC8vIHVwZGF0ZSB0aGUgb3ZlcmxhcHBpbmcgYW1vdW50cyBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgaWYgKHJlY3RBLmdldFgoKSA8PSByZWN0Qi5nZXRYKCkgJiYgcmVjdEEuZ2V0UmlnaHQoKSA+PSByZWN0Qi5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjE6XG4gICAgKlxuICAgICogcmVjdEFcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RCXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RCLmdldFgoKSAtIHJlY3RBLmdldFgoKSwgcmVjdEEuZ2V0UmlnaHQoKSAtIHJlY3RCLmdldFJpZ2h0KCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFgoKSA8PSByZWN0QS5nZXRYKCkgJiYgcmVjdEIuZ2V0UmlnaHQoKSA+PSByZWN0QS5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjI6XG4gICAgKlxuICAgICogcmVjdEJcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RBXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RBLmdldFgoKSAtIHJlY3RCLmdldFgoKSwgcmVjdEIuZ2V0UmlnaHQoKSAtIHJlY3RBLmdldFJpZ2h0KCkpO1xuICB9XG4gIGlmIChyZWN0QS5nZXRZKCkgPD0gcmVjdEIuZ2V0WSgpICYmIHJlY3RBLmdldEJvdHRvbSgpID49IHJlY3RCLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjE6XG4gICAgICogICAgICAgICAgX19fX19fX18gcmVjdEFcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19fICByZWN0QlxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19ffFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgICpcbiAgICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RCLmdldFkoKSAtIHJlY3RBLmdldFkoKSwgcmVjdEEuZ2V0Qm90dG9tKCkgLSByZWN0Qi5nZXRCb3R0b20oKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WSgpIDw9IHJlY3RBLmdldFkoKSAmJiByZWN0Qi5nZXRCb3R0b20oKSA+PSByZWN0QS5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4yOlxuICAgICogICAgICAgICAgX19fX19fX18gcmVjdEJcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgIF9fX19fX3xfX19fICByZWN0QVxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgIF9fX19fX3xfX19ffFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgKlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0QS5nZXRZKCkgLSByZWN0Qi5nZXRZKCksIHJlY3RCLmdldEJvdHRvbSgpIC0gcmVjdEEuZ2V0Qm90dG9tKCkpO1xuICB9XG5cbiAgLy8gZmluZCBzbG9wZSBvZiB0aGUgbGluZSBwYXNzZXMgdHdvIGNlbnRlcnNcbiAgdmFyIHNsb3BlID0gTWF0aC5hYnMoKHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKSkgLyAocmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpKSk7XG4gIC8vIGlmIGNlbnRlcnMgYXJlIG92ZXJsYXBwZWRcbiAgaWYgKHJlY3RCLmdldENlbnRlclkoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWSgpICYmIHJlY3RCLmdldENlbnRlclgoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWCgpKSB7XG4gICAgLy8gYXNzdW1lIHRoZSBzbG9wZSBpcyAxICg0NSBkZWdyZWUpXG4gICAgc2xvcGUgPSAxLjA7XG4gIH1cblxuICB2YXIgbW92ZUJ5WSA9IHNsb3BlICogb3ZlcmxhcEFtb3VudFswXTtcbiAgdmFyIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzFdIC8gc2xvcGU7XG4gIGlmIChvdmVybGFwQW1vdW50WzBdIDwgbW92ZUJ5WCkge1xuICAgIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzBdO1xuICB9IGVsc2Uge1xuICAgIG1vdmVCeVkgPSBvdmVybGFwQW1vdW50WzFdO1xuICB9XG4gIC8vIHJldHVybiBoYWxmIHRoZSBhbW91bnQgc28gdGhhdCBpZiBlYWNoIHJlY3RhbmdsZSBpcyBtb3ZlZCBieSB0aGVzZVxuICAvLyBhbW91bnRzIGluIG9wcG9zaXRlIGRpcmVjdGlvbnMsIG92ZXJsYXAgd2lsbCBiZSByZXNvbHZlZFxuICBvdmVybGFwQW1vdW50WzBdID0gLTEgKiBkaXJlY3Rpb25zWzBdICogKG1vdmVCeVggLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSAtMSAqIGRpcmVjdGlvbnNbMV0gKiAobW92ZUJ5WSAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGVjaWRlcyB0aGUgc2VwYXJhdGlvbiBkaXJlY3Rpb24gb2Ygb3ZlcmxhcHBpbmcgbm9kZXNcbiAqXG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyBsZWZ0XG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyByaWdodFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgdXBcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIGRvd25cbiAqL1xuSUdlb21ldHJ5LmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucykge1xuICBpZiAocmVjdEEuZ2V0Q2VudGVyWCgpIDwgcmVjdEIuZ2V0Q2VudGVyWCgpKSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAxO1xuICB9XG5cbiAgaWYgKHJlY3RBLmdldENlbnRlclkoKSA8IHJlY3RCLmdldENlbnRlclkoKSkge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gKGNsaXBwaW5nKSBwb2ludHMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyB3aXRoIGxpbmUgc2VnbWVudCBkZWZpbmVkIGJ5IHRoZSBjZW50ZXJzIG9mIHRoZXNlIHR3b1xuICogcmVjdGFuZ2xlcy4gVGhlIGNsaXBwaW5nIHBvaW50cyBhcmUgc2F2ZWQgaW4gdGhlIGlucHV0IGRvdWJsZSBhcnJheSBhbmRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZSB0d28gcmVjdGFuZ2xlcyBvdmVybGFwIGlzIHJldHVybmVkLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uMiA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIHJlc3VsdCkge1xuICAvL3Jlc3VsdFswLTFdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEEsIHJlc3VsdFsyLTNdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEJcbiAgdmFyIHAxeCA9IHJlY3RBLmdldENlbnRlclgoKTtcbiAgdmFyIHAxeSA9IHJlY3RBLmdldENlbnRlclkoKTtcbiAgdmFyIHAyeCA9IHJlY3RCLmdldENlbnRlclgoKTtcbiAgdmFyIHAyeSA9IHJlY3RCLmdldENlbnRlclkoKTtcblxuICAvL2lmIHR3byByZWN0YW5nbGVzIGludGVyc2VjdCwgdGhlbiBjbGlwcGluZyBwb2ludHMgYXJlIGNlbnRlcnNcbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgcmVzdWx0WzBdID0gcDF4O1xuICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QVxuICB2YXIgdG9wTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEF5ID0gcmVjdEEuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QXkgPSByZWN0QS5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQSA9IHJlY3RBLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEEgPSByZWN0QS5nZXRIZWlnaHRIYWxmKCk7XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QlxuICB2YXIgdG9wTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEJ5ID0gcmVjdEIuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QnkgPSByZWN0Qi5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQiA9IHJlY3RCLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEIgPSByZWN0Qi5nZXRIZWlnaHRIYWxmKCk7XG5cbiAgLy9mbGFnIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnRzIGFyZSBmb3VuZFxuICB2YXIgY2xpcFBvaW50QUZvdW5kID0gZmFsc2U7XG4gIHZhciBjbGlwUG9pbnRCRm91bmQgPSBmYWxzZTtcblxuICAvLyBsaW5lIGlzIHZlcnRpY2FsXG4gIGlmIChwMXggPT09IHAyeCkge1xuICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHAxeSA8IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gbGluZSBpcyBob3Jpem9udGFsXG4gIGVsc2UgaWYgKHAxeSA9PT0gcDJ5KSB7XG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocDF4IDwgcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm90IHZhbGlkIGxpbmUsIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL3Nsb3BlcyBvZiByZWN0QSdzIGFuZCByZWN0QidzIGRpYWdvbmFsc1xuICAgICAgdmFyIHNsb3BlQSA9IHJlY3RBLmhlaWdodCAvIHJlY3RBLndpZHRoO1xuICAgICAgdmFyIHNsb3BlQiA9IHJlY3RCLmhlaWdodCAvIHJlY3RCLndpZHRoO1xuXG4gICAgICAvL3Nsb3BlIG9mIGxpbmUgYmV0d2VlbiBjZW50ZXIgb2YgcmVjdEEgYW5kIGNlbnRlciBvZiByZWN0QlxuICAgICAgdmFyIHNsb3BlUHJpbWUgPSAocDJ5IC0gcDF5KSAvIChwMnggLSBwMXgpO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHZvaWQgMDtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkIgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXkgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnkgPSB2b2lkIDA7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQVxuICAgICAgaWYgKC1zbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVCXG4gICAgICBpZiAoLXNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2lmIGJvdGggY2xpcHBpbmcgcG9pbnRzIGFyZSBjb3JuZXJzXG4gICAgICBpZiAoY2xpcFBvaW50QUZvdW5kICYmIGNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIENhcmRpbmFsIERpcmVjdGlvbiBvZiByZWN0YW5nbGVzXG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2NhbGN1bGF0ZSBjbGlwcGluZyBQb2ludCBpZiBpdCBpcyBub3QgZm91bmQgYmVmb3JlXG4gICAgICBpZiAoIWNsaXBQb2ludEFGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gdG9wTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyAtaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIGhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgLWhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gdG9wTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyAtaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIGhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgLWhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaW4gd2hpY2ggY2FyZGluYWwgZGlyZWN0aW9uIGRvZXMgaW5wdXQgcG9pbnQgc3RheXNcbiAqIDE6IE5vcnRoXG4gKiAyOiBFYXN0XG4gKiAzOiBTb3V0aFxuICogNDogV2VzdFxuICovXG5JR2VvbWV0cnkuZ2V0Q2FyZGluYWxEaXJlY3Rpb24gPSBmdW5jdGlvbiAoc2xvcGUsIHNsb3BlUHJpbWUsIGxpbmUpIHtcbiAgaWYgKHNsb3BlID4gc2xvcGVQcmltZSkge1xuICAgIHJldHVybiBsaW5lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxICsgbGluZSAlIDQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgZGVmaW5lZCBieVxuICogcG9pbnQgcGFpcnMgKHMxLHMyKSBhbmQgKGYxLGYyKS5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChzMSwgczIsIGYxLCBmMikge1xuICBpZiAoZjIgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbjIoczEsIHMyLCBmMSk7XG4gIH1cblxuICB2YXIgeDEgPSBzMS54O1xuICB2YXIgeTEgPSBzMS55O1xuICB2YXIgeDIgPSBzMi54O1xuICB2YXIgeTIgPSBzMi55O1xuICB2YXIgeDMgPSBmMS54O1xuICB2YXIgeTMgPSBmMS55O1xuICB2YXIgeDQgPSBmMi54O1xuICB2YXIgeTQgPSBmMi55O1xuICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgIHkgPSB2b2lkIDA7IC8vIGludGVyc2VjdGlvbiBwb2ludFxuICB2YXIgYTEgPSB2b2lkIDAsXG4gICAgICBhMiA9IHZvaWQgMCxcbiAgICAgIGIxID0gdm9pZCAwLFxuICAgICAgYjIgPSB2b2lkIDAsXG4gICAgICBjMSA9IHZvaWQgMCxcbiAgICAgIGMyID0gdm9pZCAwOyAvLyBjb2VmZmljaWVudHMgb2YgbGluZSBlcW5zLlxuICB2YXIgZGVub20gPSB2b2lkIDA7XG5cbiAgYTEgPSB5MiAtIHkxO1xuICBiMSA9IHgxIC0geDI7XG4gIGMxID0geDIgKiB5MSAtIHgxICogeTI7IC8vIHsgYTEqeCArIGIxKnkgKyBjMSA9IDAgaXMgbGluZSAxIH1cblxuICBhMiA9IHk0IC0geTM7XG4gIGIyID0geDMgLSB4NDtcbiAgYzIgPSB4NCAqIHkzIC0geDMgKiB5NDsgLy8geyBhMip4ICsgYjIqeSArIGMyID0gMCBpcyBsaW5lIDIgfVxuXG4gIGRlbm9tID0gYTEgKiBiMiAtIGEyICogYjE7XG5cbiAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB4ID0gKGIxICogYzIgLSBiMiAqIGMxKSAvIGRlbm9tO1xuICB5ID0gKGEyICogYzEgLSBhMSAqIGMyKSAvIGRlbm9tO1xuXG4gIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yIGZyb20gdGhlICsgeC1heGlzXG4gKiBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uIChjb21wYXRpYmxlIHcvIEphdmEgY29vcmRpbmF0ZSBzeXN0ZW0hKS5cbiAqL1xuSUdlb21ldHJ5LmFuZ2xlT2ZWZWN0b3IgPSBmdW5jdGlvbiAoQ3gsIEN5LCBOeCwgTnkpIHtcbiAgdmFyIENfYW5nbGUgPSB2b2lkIDA7XG5cbiAgaWYgKEN4ICE9PSBOeCkge1xuICAgIENfYW5nbGUgPSBNYXRoLmF0YW4oKE55IC0gQ3kpIC8gKE54IC0gQ3gpKTtcblxuICAgIGlmIChOeCA8IEN4KSB7XG4gICAgICBDX2FuZ2xlICs9IE1hdGguUEk7XG4gICAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgICBDX2FuZ2xlICs9IHRoaXMuVFdPX1BJO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuT05FX0FORF9IQUxGX1BJOyAvLyAyNzAgZGVncmVlc1xuICB9IGVsc2Uge1xuICAgIENfYW5nbGUgPSB0aGlzLkhBTEZfUEk7IC8vIDkwIGRlZ3JlZXNcbiAgfVxuXG4gIHJldHVybiBDX2FuZ2xlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdHdvIGxpbmUgc2VnbWVudHMgKG9uZSB3aXRoIHBvaW50XG4gKiBwMSBhbmQgcDIsIHRoZSBvdGhlciB3aXRoIHBvaW50IHAzIGFuZCBwNCkgaW50ZXJzZWN0IGF0IGEgcG9pbnQgb3RoZXJcbiAqIHRoYW4gdGhlc2UgcG9pbnRzLlxuICovXG5JR2VvbWV0cnkuZG9JbnRlcnNlY3QgPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIGEgPSBwMS54O1xuICB2YXIgYiA9IHAxLnk7XG4gIHZhciBjID0gcDIueDtcbiAgdmFyIGQgPSBwMi55O1xuICB2YXIgcCA9IHAzLng7XG4gIHZhciBxID0gcDMueTtcbiAgdmFyIHIgPSBwNC54O1xuICB2YXIgcyA9IHA0Lnk7XG4gIHZhciBkZXQgPSAoYyAtIGEpICogKHMgLSBxKSAtIChyIC0gcCkgKiAoZCAtIGIpO1xuXG4gIGlmIChkZXQgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhbWJkYSA9ICgocyAtIHEpICogKHIgLSBhKSArIChwIC0gcikgKiAocyAtIGIpKSAvIGRldDtcbiAgICB2YXIgZ2FtbWEgPSAoKGIgLSBkKSAqIChyIC0gYSkgKyAoYyAtIGEpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgcmV0dXJuIDAgPCBsYW1iZGEgJiYgbGFtYmRhIDwgMSAmJiAwIDwgZ2FtbWEgJiYgZ2FtbWEgPCAxO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogQ2xhc3MgQ29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTb21lIHVzZWZ1bCBwcmUtY2FsY3VsYXRlZCBjb25zdGFudHNcbiAqL1xuSUdlb21ldHJ5LkhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuSUdlb21ldHJ5Lk9ORV9BTkRfSEFMRl9QSSA9IDEuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuVFdPX1BJID0gMi4wICogTWF0aC5QSTtcbklHZW9tZXRyeS5USFJFRV9QSSA9IDMuMCAqIE1hdGguUEk7XG5cbm1vZHVsZS5leHBvcnRzID0gSUdlb21ldHJ5O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSU1hdGgoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgdGhlIGlucHV0IHZhbHVlLlxuICovXG5JTWF0aC5zaWduID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbklNYXRoLmZsb29yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XG59O1xuXG5JTWF0aC5jZWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmZsb29yKHZhbHVlKSA6IE1hdGguY2VpbCh2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElNYXRoO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIEludGVnZXIoKSB7fVxuXG5JbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG5JbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXI7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG5vZGVGcm9tID0gZnVuY3Rpb24gbm9kZUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsIH07XG59O1xuXG52YXIgYWRkID0gZnVuY3Rpb24gYWRkKHByZXYsIG5vZGUsIG5leHQsIGxpc3QpIHtcbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5vZGU7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gbm9kZTtcbiAgfVxuXG4gIG5vZGUucHJldiA9IHByZXY7XG4gIG5vZGUubmV4dCA9IG5leHQ7XG5cbiAgbGlzdC5sZW5ndGgrKztcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBfcmVtb3ZlID0gZnVuY3Rpb24gX3JlbW92ZShub2RlLCBsaXN0KSB7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2LFxuICAgICAgbmV4dCA9IG5vZGUubmV4dDtcblxuXG4gIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIGxpc3QudGFpbCA9IHByZXY7XG4gIH1cblxuICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuXG4gIGxpc3QubGVuZ3RoLS07XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGlua2VkTGlzdCh2YWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rZWRMaXN0KTtcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICBpZiAodmFscyAhPSBudWxsKSB7XG4gICAgICB2YWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnB1c2godik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlua2VkTGlzdCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBub2RlRnJvbSh2YWwpLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBZnRlcih2YWwsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlQmVmb3JlKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUucHJldiwgbmV3Tm9kZSwgb3RoZXJOb2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVBZnRlcihuZXdOb2RlLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLCBuZXdOb2RlLCBvdGhlck5vZGUubmV4dCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2YWwpIHtcbiAgICAgIHJldHVybiBhZGQodGhpcy50YWlsLCBub2RlRnJvbSh2YWwpLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHZhbCkge1xuICAgICAgcmV0dXJuIGFkZChudWxsLCBub2RlRnJvbSh2YWwpLCB0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKG5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BOb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnROb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy5oZWFkLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfb2JqZWN0X2F0KGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldF9vYmplY3RfYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X29iamVjdF9hdChpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkTGlzdDtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxyXG4gKlRoaXMgY2xhc3MgaXMgdGhlIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvaW50LmphdmEgY2xhc3MgaW4gamRrXHJcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSwgcCkge1xuICB0aGlzLnggPSBudWxsO1xuICB0aGlzLnkgPSBudWxsO1xuICBpZiAoeCA9PSBudWxsICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgcCA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9IGVsc2UgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnggPSBwLng7XG4gICAgdGhpcy55ID0gcC55O1xuICB9XG59XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHksIHApIHtcbiAgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnNldExvY2F0aW9uKHAueCwgcC55KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICAvL2lmIGJvdGggcGFyYW1ldGVycyBhcmUgaW50ZWdlciBqdXN0IG1vdmUgKHgseSkgbG9jYXRpb25cbiAgICBpZiAocGFyc2VJbnQoeCkgPT0geCAmJiBwYXJzZUludCh5KSA9PSB5KSB7XG4gICAgICB0aGlzLm1vdmUoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoeCArIDAuNSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKHkgKyAwLjUpO1xuICAgIH1cbiAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy54ICs9IGR4O1xuICB0aGlzLnkgKz0gZHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJQb2ludFwiKSB7XG4gICAgdmFyIHB0ID0gb2JqO1xuICAgIHJldHVybiB0aGlzLnggPT0gcHQueCAmJiB0aGlzLnkgPT0gcHQueTtcbiAgfVxuICByZXR1cm4gdGhpcyA9PSBvYmo7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoKS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJbeD1cIiArIHRoaXMueCArIFwiLHk9XCIgKyB0aGlzLnkgKyBcIl1cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUmVjdGFuZ2xlRCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMueCA9IDA7XG4gIHRoaXMueSA9IDA7XG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbn1cblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGEpIHtcbiAgaWYgKHRoaXMuZ2V0UmlnaHQoKSA8IGEueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmdldEJvdHRvbSgpIDwgYS55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0UmlnaHQoKSA8IHRoaXMueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLmdldEJvdHRvbSgpIDwgdGhpcy55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkgKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKSArIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGhIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHRIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQgLyAyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVEO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gVW5pcXVlSURHZW5lcmV0b3IoKSB7fVxuXG5VbmlxdWVJREdlbmVyZXRvci5sYXN0SUQgPSAwO1xuXG5VbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKFVuaXF1ZUlER2VuZXJldG9yLmlzUHJpbWl0aXZlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmoudW5pcXVlSUQgIT0gbnVsbCkge1xuICAgIHJldHVybiBvYmoudW5pcXVlSUQ7XG4gIH1cbiAgb2JqLnVuaXF1ZUlEID0gVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nKCk7XG4gIFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCsrO1xuICByZXR1cm4gb2JqLnVuaXF1ZUlEO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChpZCA9PSBudWxsKSBpZCA9IFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRDtcbiAgcmV0dXJuIFwiT2JqZWN0I1wiICsgaWQgKyBcIlwiO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGFyZyk7XG4gIHJldHVybiBhcmcgPT0gbnVsbCB8fCB0eXBlICE9IFwib2JqZWN0XCIgJiYgdHlwZSAhPSBcImZ1bmN0aW9uXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXF1ZUlER2VuZXJldG9yO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmZ1bmN0aW9uIExheW91dChpc1JlbW90ZVVzZSkge1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgLy9MYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXG4gIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAvL1doZXRoZXIgbGF5b3V0IHNob3VsZCBjcmVhdGUgYmVuZHBvaW50cyBhcyBuZWVkZWQgb3Igbm90XG4gIHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGJlIGluY3JlbWVudGFsIG9yIG5vdFxuICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gIC8vV2hldGhlciB3ZSBhbmltYXRlIGZyb20gYmVmb3JlIHRvIGFmdGVyIGxheW91dCBub2RlIHBvc2l0aW9uc1xuICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgdGhlIGxheW91dCBwcm9jZXNzIG9yIG5vdFxuICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAvL051bWJlciBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIGRvbmUgYmV0d2VlbiB0d28gc3VjY2Vzc2l2ZSBhbmltYXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgLyoqXHJcbiAgICogV2hldGhlciBvciBub3QgbGVhZiBub2RlcyAobm9uLWNvbXBvdW5kIG5vZGVzKSBhcmUgb2YgdW5pZm9ybSBzaXplcy4gV2hlblxyXG4gICAqIHRoZXkgYXJlLCBib3RoIHNwcmluZyBhbmQgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIHR3byBsZWFmIG5vZGVzIGNhbiBiZVxyXG4gICAqIGNhbGN1bGF0ZWQgd2l0aG91dCB0aGUgZXhwZW5zaXZlIGNsaXBwaW5nIHBvaW50IGNhbGN1bGF0aW9ucywgcmVzdWx0aW5nXHJcbiAgICogaW4gbWFqb3Igc3BlZWQtdXAuXHJcbiAgICovXG4gIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgLyoqXHJcbiAgICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGlvbiBvZiBiZW5kcG9pbnRzIGJ5IHVzaW5nIGR1bW15IG5vZGVzIGFuZCBlZGdlcy5cclxuICAgKiBNYXBzIGFuIExFZGdlIHRvIGl0cyBkdW1teSBiZW5kcG9pbnQgcGF0aC5cclxuICAgKi9cbiAgdGhpcy5lZGdlVG9EdW1teU5vZGVzID0gbmV3IE1hcCgpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcbiAgdGhpcy5pc1N1YkxheW91dCA9IGZhbHNlO1xuICB0aGlzLmlzUmVtb3RlVXNlID0gZmFsc2U7XG5cbiAgaWYgKGlzUmVtb3RlVXNlICE9IG51bGwpIHtcbiAgICB0aGlzLmlzUmVtb3RlVXNlID0gaXNSZW1vdGVVc2U7XG4gIH1cbn1cblxuTGF5b3V0LlJBTkRPTV9TRUVEID0gMTtcblxuTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRW1pdHRlci5wcm90b3R5cGUpO1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IExHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3Tm9kZSA9IGZ1bmN0aW9uICh2Tm9kZSkge1xuICByZXR1cm4gbmV3IExOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyLCB2Tm9kZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBMRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmNoZWNrTGF5b3V0U3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSA9PSBudWxsIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpLmxlbmd0aCA9PSAwIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmluY2x1ZGVzSW52YWxpZEVkZ2UoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUucnVuTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcblxuICBpZiAodGhpcy50aWxpbmdQcmVMYXlvdXQpIHtcbiAgICB0aGlzLnRpbGluZ1ByZUxheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pbml0UGFyYW1ldGVycygpO1xuICB2YXIgaXNMYXlvdXRTdWNjZXNzZnVsbDtcblxuICBpZiAodGhpcy5jaGVja0xheW91dFN1Y2Nlc3MoKSkge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0xheW91dFN1Y2Nlc3NmdWxsID0gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGlmIChMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgJ2R1cmluZycgbGF5b3V0IGFuaW1hdGlvbi4gTGF5b3V0IGlzIG5vdCBmaW5pc2hlZCB5ZXQuIFxuICAgIC8vIFdlIG5lZWQgdG8gcGVyZm9ybSB0aGVzZSBpbiBpbmRleC5qcyB3aGVuIGxheW91dCBpcyByZWFsbHkgZmluaXNoZWQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTGF5b3V0U3VjY2Vzc2Z1bGwpIHtcbiAgICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICAgIHRoaXMuZG9Qb3N0TGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudGlsaW5nUG9zdExheW91dCkge1xuICAgIHRoaXMudGlsaW5nUG9zdExheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gdHJ1ZTtcblxuICByZXR1cm4gaXNMYXlvdXRTdWNjZXNzZnVsbDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgb3BlcmF0aW9ucyByZXF1aXJlZCBhZnRlciBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5kb1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vYXNzZXJ0ICFpc1N1YkxheW91dCA6IFwiU2hvdWxkIG5vdCBiZSBjYWxsZWQgb24gc3ViLWxheW91dCFcIjtcbiAgLy8gUHJvcGFnYXRlIGdlb21ldHJpYyBjaGFuZ2VzIHRvIHYtbGV2ZWwgb2JqZWN0c1xuICBpZiAoIXRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIHRhcmdldCBncmFwaCBhY2NvcmRpbmcgdG9cclxuICogY2FsY3VsYXRlZCBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUyID0gZnVuY3Rpb24gKCkge1xuICAvLyB1cGRhdGUgYmVuZCBwb2ludHNcbiAgaWYgKHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzKCk7XG5cbiAgICAvLyByZXNldCBhbGwgZWRnZXMsIHNpbmNlIHRoZSB0b3BvbG9neSBoYXMgY2hhbmdlZFxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIC8vIHBlcmZvcm0gZWRnZSwgbm9kZSBhbmQgcm9vdCB1cGRhdGVzIGlmIGxheW91dCBpcyBub3QgY2FsbGVkXG4gIC8vIHJlbW90ZWx5XG4gIGlmICghdGhpcy5pc1JlbW90ZVVzZSkge1xuICAgIC8vIHVwZGF0ZSBhbGwgZWRnZXNcbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgIC8vICAgICAgdGhpcy51cGRhdGUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIG5vZGVzXG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcm9vdCBncmFwaFxuICAgIHRoaXMudXBkYXRlKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICB0aGlzLnVwZGF0ZTIoKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIHZhciBub2RlID0gb2JqO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgLy8gc2luY2Ugbm9kZSBpcyBjb21wb3VuZCwgcmVjdXJzaXZlbHkgdXBkYXRlIGNoaWxkIG5vZGVzXG4gICAgICB2YXIgbm9kZXMgPSBub2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBub2RlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG5vZGUgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuICAgIGlmIChub2RlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdk5vZGUgPSBub2RlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2Tm9kZS51cGRhdGUobm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgdmFyIGVkZ2UgPSBvYmo7XG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgZWRnZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBlZGdlIGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cblxuICAgIGlmIChlZGdlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkVkZ2UgPSBlZGdlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2RWRnZS51cGRhdGUoZWRnZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBncmFwaCBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBvYmplY3QgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGdyYXBoLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkdyYXBoID0gZ3JhcGgudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZHcmFwaC51cGRhdGUoZ3JhcGgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGFsbCBsYXlvdXQgcGFyYW1ldGVycyB0byBkZWZhdWx0IHZhbHVlc1xyXG4gKiBkZXRlcm1pbmVkIGF0IGNvbXBpbGUgdGltZS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICB0aGlzLmxheW91dFF1YWxpdHkgPSBMYXlvdXRDb25zdGFudHMuUVVBTElUWTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAgIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gICAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgICB0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVM7XG4gIH1cblxuICBpZiAodGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gZmFsc2U7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG5ld0xlZnRUb3ApIHtcbiAgaWYgKG5ld0xlZnRUb3AgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RCgwLCAwKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgdHJhbnNmb3JtYXRpb24gb2JqZWN0IChmcm9tIEVjbGlwc2UgdG8gbGF5b3V0KS4gV2hlbiBhblxuICAgIC8vIGludmVyc2UgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHdlIGdldCB1cHBlci1sZWZ0IGNvb3JkaW5hdGUgb2YgdGhlXG4gICAgLy8gZHJhd2luZyBvciB0aGUgcm9vdCBncmFwaCBhdCBnaXZlbiBpbnB1dCBjb29yZGluYXRlIChzb21lIG1hcmdpbnNcbiAgICAvLyBhbHJlYWR5IGluY2x1ZGVkIGluIGNhbGN1bGF0aW9uIG9mIGxlZnQtdG9wKS5cblxuICAgIHZhciB0cmFucyA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB2YXIgbGVmdFRvcCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS51cGRhdGVMZWZ0VG9wKCk7XG5cbiAgICBpZiAobGVmdFRvcCAhPSBudWxsKSB7XG4gICAgICB0cmFucy5zZXRXb3JsZE9yZ1gobmV3TGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWShuZXdMZWZ0VG9wLnkpO1xuXG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdYKGxlZnRUb3AueCk7XG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdZKGxlZnRUb3AueSk7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS50cmFuc2Zvcm0odHJhbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFuZG9tbHkgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICBpZiAoZ3JhcGggPT0gdW5kZWZpbmVkKSB7XG4gICAgLy9hc3NlcnQgIXRoaXMuaW5jcmVtZW50YWw7XG4gICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkodGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkpO1xuICAgIHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbE5vZGU7XG4gICAgdmFyIGNoaWxkR3JhcGg7XG5cbiAgICB2YXIgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxOb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZEdyYXBoID0gbE5vZGUuZ2V0Q2hpbGQoKTtcblxuICAgICAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkR3JhcGguZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seShjaGlsZEdyYXBoKTtcbiAgICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2YgdHJlZXMgd2hlcmUgZWFjaCB0cmVlIGlzIHJlcHJlc2VudGVkIGFzIGFcclxuICogbGlzdCBvZiBsLW5vZGVzLiBUaGUgbWV0aG9kIHJldHVybnMgYSBsaXN0IG9mIHNpemUgMCB3aGVuOlxyXG4gKiAtIFRoZSBncmFwaCBpcyBub3QgZmxhdCBvclxyXG4gKiAtIE9uZSBvZiB0aGUgY29tcG9uZW50KHMpIG9mIHRoZSBncmFwaCBpcyBub3QgYSB0cmVlLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuZ2V0RmxhdEZvcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZsYXRGb3Jlc3QgPSBbXTtcbiAgdmFyIGlzRm9yZXN0ID0gdHJ1ZTtcblxuICAvLyBRdWljayByZWZlcmVuY2UgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbWFuYWdlciBhc3NvY2lhdGVkIHdpdGhcbiAgLy8gdGhpcyBsYXlvdXQuIFRoZSBsaXN0IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG5cbiAgLy8gRmlyc3QgYmUgc3VyZSB0aGF0IHRoZSBncmFwaCBpcyBmbGF0XG4gIHZhciBpc0ZsYXQgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYWxsTm9kZXNbaV0uZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICBpc0ZsYXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gZW1wdHkgZm9yZXN0IGlmIHRoZSBncmFwaCBpcyBub3QgZmxhdC5cbiAgaWYgKCFpc0ZsYXQpIHtcbiAgICByZXR1cm4gZmxhdEZvcmVzdDtcbiAgfVxuXG4gIC8vIFJ1biBCRlMgZm9yIGVhY2ggY29tcG9uZW50IG9mIHRoZSBncmFwaC5cblxuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHRvQmVWaXNpdGVkID0gW107XG4gIHZhciBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICB2YXIgdW5Qcm9jZXNzZWROb2RlcyA9IFtdO1xuXG4gIHVuUHJvY2Vzc2VkTm9kZXMgPSB1blByb2Nlc3NlZE5vZGVzLmNvbmNhdChhbGxOb2Rlcyk7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24gb2YgdGhpcyBsb29wIGZpbmRzIGEgY29tcG9uZW50IG9mIHRoZSBncmFwaCBhbmRcbiAgLy8gZGVjaWRlcyB3aGV0aGVyIGl0IGlzIGEgdHJlZSBvciBub3QuIElmIGl0IGlzIGEgdHJlZSwgYWRkcyBpdCB0byB0aGVcbiAgLy8gZm9yZXN0IGFuZCBjb250aW51ZWQgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQuXG5cbiAgd2hpbGUgKHVuUHJvY2Vzc2VkTm9kZXMubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgIHRvQmVWaXNpdGVkLnB1c2godW5Qcm9jZXNzZWROb2Rlc1swXSk7XG5cbiAgICAvLyBTdGFydCB0aGUgQkZTLiBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgdmlzaXRzIGEgbm9kZSBpbiBhXG4gICAgLy8gQkZTIG1hbm5lci5cbiAgICB3aGlsZSAodG9CZVZpc2l0ZWQubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgICAgLy9wb29sIG9wZXJhdGlvblxuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdG9CZVZpc2l0ZWRbMF07XG4gICAgICB0b0JlVmlzaXRlZC5zcGxpY2UoMCwgMSk7XG4gICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlc1tpXS5nZXRPdGhlckVuZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgLy8gSWYgQkZTIGlzIG5vdCBncm93aW5nIGZyb20gdGhpcyBuZWlnaGJvci5cbiAgICAgICAgaWYgKHBhcmVudHMuZ2V0KGN1cnJlbnROb2RlKSAhPSBjdXJyZW50TmVpZ2hib3IpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlbid0IHByZXZpb3VzbHkgdmlzaXRlZCB0aGlzIG5laWdoYm9yLlxuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICAgICAgdG9CZVZpc2l0ZWQucHVzaChjdXJyZW50TmVpZ2hib3IpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VycmVudE5laWdoYm9yLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IgYW5kXG4gICAgICAgICAgLy8gdGhpcyBuZWlnaGJvciBpcyBub3QgcGFyZW50IG9mIGN1cnJlbnROb2RlLCBnaXZlblxuICAgICAgICAgIC8vIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHRyZWUsIGhlbmNlXG4gICAgICAgICAgLy8gaXQgaXMgbm90IGEgZm9yZXN0LlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpc0ZvcmVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBncmFwaCBjb250YWlucyBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCBhIHRyZWUuIEVtcHR5XG4gICAgLy8gcHJldmlvdXNseSBmb3VuZCB0cmVlcy4gVGhlIG1ldGhvZCB3aWxsIGVuZC5cbiAgICBpZiAoIWlzRm9yZXN0KSB7XG4gICAgICBmbGF0Rm9yZXN0ID0gW107XG4gICAgfVxuICAgIC8vIFNhdmUgY3VycmVudGx5IHZpc2l0ZWQgbm9kZXMgYXMgYSB0cmVlIGluIG91ciBmb3Jlc3QuIFJlc2V0XG4gICAgLy8gdmlzaXRlZCBhbmQgcGFyZW50cyBsaXN0cy4gQ29udGludWUgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQgb2ZcbiAgICAvLyB0aGUgZ3JhcGgsIGlmIGFueS5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRlbXAgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZpc2l0ZWQpKTtcbiAgICAgICAgZmxhdEZvcmVzdC5wdXNoKHRlbXApO1xuICAgICAgICAvL2ZsYXRGb3Jlc3QgPSBmbGF0Rm9yZXN0LmNvbmNhdCh0ZW1wKTtcbiAgICAgICAgLy91blByb2Nlc3NlZE5vZGVzLnJlbW92ZUFsbCh2aXNpdGVkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGVtcFtpXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB1blByb2Nlc3NlZE5vZGVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB1blByb2Nlc3NlZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmxhdEZvcmVzdDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGR1bW15IG5vZGVzIChhbiBsLWxldmVsIG5vZGUgd2l0aCBtaW5pbWFsIGRpbWVuc2lvbnMpXHJcbiAqIGZvciB0aGUgZ2l2ZW4gZWRnZSAob25lIHBlciBiZW5kcG9pbnQpLiBUaGUgZXhpc3RpbmcgbC1sZXZlbCBzdHJ1Y3R1cmVcclxuICogaXMgdXBkYXRlZCBhY2NvcmRpbmdseS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIGR1bW15Tm9kZXMgPSBbXTtcbiAgdmFyIHByZXYgPSBlZGdlLnNvdXJjZTtcblxuICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2UuYmVuZHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGNyZWF0ZSBuZXcgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teU5vZGUgPSB0aGlzLm5ld05vZGUobnVsbCk7XG4gICAgZHVtbXlOb2RlLnNldFJlY3QobmV3IFBvaW50KDAsIDApLCBuZXcgRGltZW5zaW9uKDEsIDEpKTtcblxuICAgIGdyYXBoLmFkZChkdW1teU5vZGUpO1xuXG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBlZGdlIGJldHdlZW4gcHJldiBhbmQgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZHVtbXlOb2RlKTtcblxuICAgIGR1bW15Tm9kZXMuYWRkKGR1bW15Tm9kZSk7XG4gICAgcHJldiA9IGR1bW15Tm9kZTtcbiAgfVxuXG4gIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChkdW1teUVkZ2UsIHByZXYsIGVkZ2UudGFyZ2V0KTtcblxuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuc2V0KGVkZ2UsIGR1bW15Tm9kZXMpO1xuXG4gIC8vIHJlbW92ZSByZWFsIGVkZ2UgZnJvbSBncmFwaCBtYW5hZ2VyIGlmIGl0IGlzIGludGVyLWdyYXBoXG4gIGlmIChlZGdlLmlzSW50ZXJHcmFwaCgpKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICB9XG4gIC8vIGVsc2UsIHJlbW92ZSB0aGUgZWRnZSBmcm9tIHRoZSBjdXJyZW50IGdyYXBoXG4gIGVsc2Uge1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICByZXR1cm4gZHVtbXlOb2Rlcztcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGJlbmRwb2ludHMgZm9yIGVkZ2VzIGZyb20gdGhlIGR1bW15IG5vZGVzXHJcbiAqIGF0IGwtbGV2ZWwuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICBlZGdlcyA9IGVkZ2VzLmNvbmNhdCh0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpKTtcbiAgZWRnZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5rZXlzKCkpKS5jb25jYXQoZWRnZXMpO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgZWRnZXMubGVuZ3RoOyBrKyspIHtcbiAgICB2YXIgbEVkZ2UgPSBlZGdlc1trXTtcblxuICAgIGlmIChsRWRnZS5iZW5kcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5lZGdlVG9EdW1teU5vZGVzLmdldChsRWRnZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZHVtbXlOb2RlID0gcGF0aFtpXTtcbiAgICAgICAgdmFyIHAgPSBuZXcgUG9pbnREKGR1bW15Tm9kZS5nZXRDZW50ZXJYKCksIGR1bW15Tm9kZS5nZXRDZW50ZXJZKCkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBiZW5kcG9pbnQncyBsb2NhdGlvbiBhY2NvcmRpbmcgdG8gZHVtbXkgbm9kZVxuICAgICAgICB2YXIgZWJwID0gbEVkZ2UuYmVuZHBvaW50cy5nZXQoaSk7XG4gICAgICAgIGVicC54ID0gcC54O1xuICAgICAgICBlYnAueSA9IHAueTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGR1bW15IG5vZGUsIGR1bW15IGVkZ2VzIGluY2lkZW50IHdpdGggdGhpc1xuICAgICAgICAvLyBkdW1teSBub2RlIGlzIGFsc28gcmVtb3ZlZCAod2l0aGluIHRoZSByZW1vdmUgbWV0aG9kKVxuICAgICAgICBkdW1teU5vZGUuZ2V0T3duZXIoKS5yZW1vdmUoZHVtbXlOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSByZWFsIGVkZ2UgdG8gZ3JhcGhcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChsRWRnZSwgbEVkZ2Uuc291cmNlLCBsRWRnZS50YXJnZXQpO1xuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzbGlkZXJWYWx1ZSwgZGVmYXVsdFZhbHVlLCBtaW5EaXYsIG1heE11bCkge1xuICBpZiAobWluRGl2ICE9IHVuZGVmaW5lZCAmJiBtYXhNdWwgIT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKHNsaWRlclZhbHVlIDw9IDUwKSB7XG4gICAgICB2YXIgbWluVmFsdWUgPSBkZWZhdWx0VmFsdWUgLyBtaW5EaXY7XG4gICAgICB2YWx1ZSAtPSAoZGVmYXVsdFZhbHVlIC0gbWluVmFsdWUpIC8gNTAgKiAoNTAgLSBzbGlkZXJWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IGRlZmF1bHRWYWx1ZSAqIG1heE11bDtcbiAgICAgIHZhbHVlICs9IChtYXhWYWx1ZSAtIGRlZmF1bHRWYWx1ZSkgLyA1MCAqIChzbGlkZXJWYWx1ZSAtIDUwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEsIGI7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MDAuMDtcbiAgICAgIGIgPSBkZWZhdWx0VmFsdWUgLyAxMC4wO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gOS4wICogZGVmYXVsdFZhbHVlIC8gNTAuMDtcbiAgICAgIGIgPSAtOCAqIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIHNsaWRlclZhbHVlICsgYjtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIG5vZGVzLCBhc3N1bWluZ1xyXG4gKiB0aGF0IHRoZSBnaXZlbiBub2RlcyBmb3JtIGEgdHJlZSBpbiB0aGVtc2VsdmVzLlxyXG4gKi9cbkxheW91dC5maW5kQ2VudGVyT2ZUcmVlID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGxpc3QgPSBsaXN0LmNvbmNhdChub2Rlcyk7XG5cbiAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICB2YXIgcmVtYWluaW5nRGVncmVlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGZvdW5kQ2VudGVyID0gZmFsc2U7XG4gIHZhciBjZW50ZXJOb2RlID0gbnVsbDtcblxuICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgIGNlbnRlck5vZGUgPSBsaXN0WzBdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuICAgIHZhciBkZWdyZWUgPSBub2RlLmdldE5laWdoYm9yc0xpc3QoKS5zaXplO1xuICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5vZGUsIG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemUpO1xuXG4gICAgaWYgKGRlZ3JlZSA9PSAxKSB7XG4gICAgICByZW1vdmVkTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGVtcExpc3QgPSBbXTtcbiAgdGVtcExpc3QgPSB0ZW1wTGlzdC5jb25jYXQocmVtb3ZlZE5vZGVzKTtcblxuICB3aGlsZSAoIWZvdW5kQ2VudGVyKSB7XG4gICAgdmFyIHRlbXBMaXN0MiA9IFtdO1xuICAgIHRlbXBMaXN0MiA9IHRlbXBMaXN0Mi5jb25jYXQodGVtcExpc3QpO1xuICAgIHRlbXBMaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbGlzdFtpXTtcblxuICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3VycyA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpO1xuXG4gICAgICBuZWlnaGJvdXJzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm91cikge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmluZGV4T2YobmVpZ2hib3VyKSA8IDApIHtcbiAgICAgICAgICB2YXIgb3RoZXJEZWdyZWUgPSByZW1haW5pbmdEZWdyZWVzLmdldChuZWlnaGJvdXIpO1xuICAgICAgICAgIHZhciBuZXdEZWdyZWUgPSBvdGhlckRlZ3JlZSAtIDE7XG5cbiAgICAgICAgICBpZiAobmV3RGVncmVlID09IDEpIHtcbiAgICAgICAgICAgIHRlbXBMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1haW5pbmdEZWdyZWVzLnNldChuZWlnaGJvdXIsIG5ld0RlZ3JlZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2Rlcy5jb25jYXQodGVtcExpc3QpO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDEgfHwgbGlzdC5sZW5ndGggPT0gMikge1xuICAgICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNlbnRlck5vZGU7XG59O1xuXG4vKipcclxuICogRHVyaW5nIHRoZSBjb2Fyc2VuaW5nIHByb2Nlc3MsIHRoaXMgbGF5b3V0IG1heSBiZSByZWZlcmVuY2VkIGJ5IHR3byBncmFwaCBtYW5hZ2Vyc1xyXG4gKiB0aGlzIHNldHRlciBmdW5jdGlvbiBncmFudHMgYWNjZXNzIHRvIGNoYW5nZSB0aGUgY3VycmVudGx5IGJlaW5nIHVzZWQgZ3JhcGggbWFuYWdlclxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuc2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKGdtKSB7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSYW5kb21TZWVkKCkge31cbi8vIGFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5MzAzNzI1XG5SYW5kb21TZWVkLnNlZWQgPSAxO1xuUmFuZG9tU2VlZC54ID0gMDtcblxuUmFuZG9tU2VlZC5uZXh0RG91YmxlID0gZnVuY3Rpb24gKCkge1xuICBSYW5kb21TZWVkLnggPSBNYXRoLnNpbihSYW5kb21TZWVkLnNlZWQrKykgKiAxMDAwMDtcbiAgcmV0dXJuIFJhbmRvbVNlZWQueCAtIE1hdGguZmxvb3IoUmFuZG9tU2VlZC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tU2VlZDtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtKHgsIHkpIHtcbiAgdGhpcy5sd29ybGRPcmdYID0gMC4wO1xuICB0aGlzLmx3b3JsZE9yZ1kgPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1ggPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1kgPSAwLjA7XG4gIHRoaXMubHdvcmxkRXh0WCA9IDEuMDtcbiAgdGhpcy5sd29ybGRFeHRZID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRYID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRZID0gMS4wO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKHdveCkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSB3b3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKHdveSkge1xuICB0aGlzLmx3b3JsZE9yZ1kgPSB3b3k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKHdleCkge1xuICB0aGlzLmx3b3JsZEV4dFggPSB3ZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKHdleSkge1xuICB0aGlzLmx3b3JsZEV4dFkgPSB3ZXk7XG59O1xuXG4vKiBEZXZpY2UgcmVsYXRlZCAqL1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdYID0gZnVuY3Rpb24gKGRveCkge1xuICB0aGlzLmxkZXZpY2VPcmdYID0gZG94O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlT3JnWSA9IGZ1bmN0aW9uIChkb3kpIHtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IGRveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFggPSBmdW5jdGlvbiAoZGV4KSB7XG4gIHRoaXMubGRldmljZUV4dFggPSBkZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZUV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VFeHRZID0gZnVuY3Rpb24gKGRleSkge1xuICB0aGlzLmxkZXZpY2VFeHRZID0gZGV5O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1YID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHhEZXZpY2UgPSAwLjA7XG4gIHZhciB3b3JsZEV4dFggPSB0aGlzLmx3b3JsZEV4dFg7XG4gIGlmICh3b3JsZEV4dFggIT0gMC4wKSB7XG4gICAgeERldmljZSA9IHRoaXMubGRldmljZU9yZ1ggKyAoeCAtIHRoaXMubHdvcmxkT3JnWCkgKiB0aGlzLmxkZXZpY2VFeHRYIC8gd29ybGRFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhEZXZpY2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeURldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WSA9IHRoaXMubHdvcmxkRXh0WTtcbiAgaWYgKHdvcmxkRXh0WSAhPSAwLjApIHtcbiAgICB5RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWSArICh5IC0gdGhpcy5sd29ybGRPcmdZKSAqIHRoaXMubGRldmljZUV4dFkgLyB3b3JsZEV4dFk7XG4gIH1cblxuICByZXR1cm4geURldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeFdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WCA9IHRoaXMubGRldmljZUV4dFg7XG4gIGlmIChkZXZpY2VFeHRYICE9IDAuMCkge1xuICAgIHhXb3JsZCA9IHRoaXMubHdvcmxkT3JnWCArICh4IC0gdGhpcy5sZGV2aWNlT3JnWCkgKiB0aGlzLmx3b3JsZEV4dFggLyBkZXZpY2VFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeVdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WSA9IHRoaXMubGRldmljZUV4dFk7XG4gIGlmIChkZXZpY2VFeHRZICE9IDAuMCkge1xuICAgIHlXb3JsZCA9IHRoaXMubHdvcmxkT3JnWSArICh5IC0gdGhpcy5sZGV2aWNlT3JnWSkgKiB0aGlzLmx3b3JsZEV4dFkgLyBkZXZpY2VFeHRZO1xuICB9XG4gIHJldHVybiB5V29ybGQ7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uIChpblBvaW50KSB7XG4gIHZhciBvdXRQb2ludCA9IG5ldyBQb2ludEQodGhpcy5pbnZlcnNlVHJhbnNmb3JtWChpblBvaW50LngpLCB0aGlzLmludmVyc2VUcmFuc2Zvcm1ZKGluUG9pbnQueSkpO1xuICByZXR1cm4gb3V0UG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBGRExheW91dCgpIHtcbiAgTGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgdGhpcy5zcHJpbmdDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xuICB0aGlzLnJlcHVsc2lvbkNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgPSAzLjAgKiBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAwO1xuICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlM7XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTGF5b3V0KSB7XG4gIEZETGF5b3V0W3Byb3BdID0gTGF5b3V0W3Byb3BdO1xufVxuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG90YWxJdGVyYXRpb25zID0gMDtcbiAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuXG4gIHRoaXMudXNlRlJHcmlkVmFyaWFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTjtcblxuICB0aGlzLmdyaWQgPSBbXTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjSWRlYWxFZGdlTGVuZ3RocyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBsY2FEZXB0aDtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNpemVPZlNvdXJjZUluTGNhO1xuICB2YXIgc2l6ZU9mVGFyZ2V0SW5MY2E7XG5cbiAgdmFyIGFsbEVkZ2VzID0gdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRBbGxFZGdlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgZWRnZS5pZGVhbExlbmd0aCA9IHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xuXG4gICAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdGFyZ2V0ID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICAgICAgc2l6ZU9mU291cmNlSW5MY2EgPSBlZGdlLmdldFNvdXJjZUluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuICAgICAgc2l6ZU9mVGFyZ2V0SW5MY2EgPSBlZGdlLmdldFRhcmdldEluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuXG4gICAgICBpZiAodGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uKSB7XG4gICAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gc2l6ZU9mU291cmNlSW5MY2EgKyBzaXplT2ZUYXJnZXRJbkxjYSAtIDIgKiBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRTtcbiAgICAgIH1cblxuICAgICAgbGNhRGVwdGggPSBlZGdlLmdldExjYSgpLmdldEluY2x1c2lvblRyZWVEZXB0aCgpO1xuXG4gICAgICBlZGdlLmlkZWFsTGVuZ3RoICs9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKiBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SICogKHNvdXJjZS5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSArIHRhcmdldC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSAtIDIgKiBsY2FEZXB0aCk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBzID0gdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcbiAgaWYgKHRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICBpZiAocyA+IEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgodGhpcy5jb29saW5nRmFjdG9yICogRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiwgdGhpcy5jb29saW5nRmFjdG9yIC0gKHMgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIC8gKEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgKiB0aGlzLmNvb2xpbmdGYWN0b3IgKiAoMSAtIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IpKTtcbiAgICB9XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMO1xuICB9IGVsc2Uge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heChGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCAxLjAgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSAxLjA7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSB0aGlzLmNvb2xpbmdGYWN0b3I7XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UO1xuICB9XG5cbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gTWF0aC5tYXgodGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aCAqIDUsIHRoaXMubWF4SXRlcmF0aW9ucyk7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCA9IHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSAqIHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG5cbiAgdGhpcy5yZXB1bHNpb25SYW5nZSA9IHRoaXMuY2FsY1JlcHVsc2lvblJhbmdlKCk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxFZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIGVkZ2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gbEVkZ2VzW2ldO1xuXG4gICAgdGhpcy5jYWxjU3ByaW5nRm9yY2UoZWRnZSwgZWRnZS5pZGVhbExlbmd0aCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaSwgajtcbiAgdmFyIG5vZGVBLCBub2RlQjtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHByb2Nlc3NlZE5vZGVTZXQ7XG5cbiAgaWYgKHRoaXMudXNlRlJHcmlkVmFyaWFudCkge1xuICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIHByb2Nlc3NlZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGVhY2ggbm9kZXMgYW5kIGl0cyBzdXJyb3VuZGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgICAgdGhpcy5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVTZXQuYWRkKG5vZGVBKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5vZGVCID0gbE5vZGVzW2pdO1xuXG4gICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBza2lwLlxuICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlKG5vZGUpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUubW92ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgbm9kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2UgPSBmdW5jdGlvbiAoZWRnZSwgaWRlYWxMZW5ndGgpIHtcbiAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLmdldFNvdXJjZSgpO1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgdmFyIGxlbmd0aDtcbiAgdmFyIHNwcmluZ0ZvcmNlO1xuICB2YXIgc3ByaW5nRm9yY2VYO1xuICB2YXIgc3ByaW5nRm9yY2VZO1xuXG4gIC8vIFVwZGF0ZSBlZGdlIGxlbmd0aFxuICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBzb3VyY2VOb2RlLmdldENoaWxkKCkgPT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoU2ltcGxlKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGgoKTtcblxuICAgIGlmIChlZGdlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCA9IGVkZ2UuZ2V0TGVuZ3RoKCk7XG5cbiAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIHNwcmluZyBmb3JjZXNcbiAgc3ByaW5nRm9yY2UgPSB0aGlzLnNwcmluZ0NvbnN0YW50ICogKGxlbmd0aCAtIGlkZWFsTGVuZ3RoKTtcblxuICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gIHNwcmluZ0ZvcmNlWCA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWCAvIGxlbmd0aCk7XG4gIHNwcmluZ0ZvcmNlWSA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWSAvIGxlbmd0aCk7XG5cbiAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSBlbmQgbm9kZXNcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVggKz0gc3ByaW5nRm9yY2VYO1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWSArPSBzcHJpbmdGb3JjZVk7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VYIC09IHNwcmluZ0ZvcmNlWDtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVkgLT0gc3ByaW5nRm9yY2VZO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZSA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgdmFyIHJlY3RBID0gbm9kZUEuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEIgPSBub2RlQi5nZXRSZWN0KCk7XG4gIHZhciBvdmVybGFwQW1vdW50ID0gbmV3IEFycmF5KDIpO1xuICB2YXIgY2xpcFBvaW50cyA9IG5ldyBBcnJheSg0KTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGRpc3RhbmNlU3F1YXJlZDtcbiAgdmFyIGRpc3RhbmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZVg7XG4gIHZhciByZXB1bHNpb25Gb3JjZVk7XG5cbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSAvLyB0d28gbm9kZXMgb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBzZXBhcmF0aW9uIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnNcbiAgICAgIElHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAyLjApO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSAyICogb3ZlcmxhcEFtb3VudFswXTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IDIgKiBvdmVybGFwQW1vdW50WzFdO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIChub2RlQS5ub09mQ2hpbGRyZW4gKyBub2RlQi5ub09mQ2hpbGRyZW4pO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2Rlc1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgfSBlbHNlIC8vIG5vIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGlzdGFuY2VcblxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgbm9kZUEuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIG5vZGVCLmdldENoaWxkKCkgPT0gbnVsbCkgLy8gc2ltcGx5IGJhc2UgcmVwdWxzaW9uIG9uIGRpc3RhbmNlIG9mIG5vZGUgY2VudGVyc1xuICAgICAgICB7XG4gICAgICAgICAgZGlzdGFuY2VYID0gcmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKTtcbiAgICAgICAgfSBlbHNlIC8vIHVzZSBjbGlwcGluZyBwb2ludHNcbiAgICAgICAge1xuICAgICAgICAgIElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24ocmVjdEEsIHJlY3RCLCBjbGlwUG9pbnRzKTtcblxuICAgICAgICAgIGRpc3RhbmNlWCA9IGNsaXBQb2ludHNbMl0gLSBjbGlwUG9pbnRzWzBdO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IGNsaXBQb2ludHNbM10gLSBjbGlwUG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vIHJlcHVsc2lvbiByYW5nZS4gRlIgZ3JpZCB2YXJpYW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWCA9IElNYXRoLnNpZ24oZGlzdGFuY2VYKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWSkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VZID0gSU1hdGguc2lnbihkaXN0YW5jZVkpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQpO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZSA9IHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgKiBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyBkaXN0YW5jZVNxdWFyZWQ7XG5cbiAgICAgIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2RlcyAgICBcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgb3duZXJHcmFwaDtcbiAgdmFyIG93bmVyQ2VudGVyWDtcbiAgdmFyIG93bmVyQ2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGFic0Rpc3RhbmNlWDtcbiAgdmFyIGFic0Rpc3RhbmNlWTtcbiAgdmFyIGVzdGltYXRlZFNpemU7XG4gIG93bmVyR3JhcGggPSBub2RlLmdldE93bmVyKCk7XG5cbiAgb3duZXJDZW50ZXJYID0gKG93bmVyR3JhcGguZ2V0UmlnaHQoKSArIG93bmVyR3JhcGguZ2V0TGVmdCgpKSAvIDI7XG4gIG93bmVyQ2VudGVyWSA9IChvd25lckdyYXBoLmdldFRvcCgpICsgb3duZXJHcmFwaC5nZXRCb3R0b20oKSkgLyAyO1xuICBkaXN0YW5jZVggPSBub2RlLmdldENlbnRlclgoKSAtIG93bmVyQ2VudGVyWDtcbiAgZGlzdGFuY2VZID0gbm9kZS5nZXRDZW50ZXJZKCkgLSBvd25lckNlbnRlclk7XG4gIGFic0Rpc3RhbmNlWCA9IE1hdGguYWJzKGRpc3RhbmNlWCkgKyBub2RlLmdldFdpZHRoKCkgLyAyO1xuICBhYnNEaXN0YW5jZVkgPSBNYXRoLmFicyhkaXN0YW5jZVkpICsgbm9kZS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgaWYgKG5vZGUuZ2V0T3duZXIoKSA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIC8vIGluIHRoZSByb290IGdyYXBoXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWTtcbiAgICAgIH1cbiAgICB9IGVsc2UgLy8gaW5zaWRlIGEgY29tcG91bmRcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVggKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaXNDb252ZXJnZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb252ZXJnZWQ7XG4gIHZhciBvc2NpbGF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIC8gMykge1xuICAgIG9zY2lsYXRpbmcgPSBNYXRoLmFicyh0aGlzLnRvdGFsRGlzcGxhY2VtZW50IC0gdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCkgPCAyO1xuICB9XG5cbiAgY29udmVyZ2VkID0gdGhpcy50b3RhbERpc3BsYWNlbWVudCA8IHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG5cbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQ7XG5cbiAgcmV0dXJuIGNvbnZlcmdlZCB8fCBvc2NpbGF0aW5nO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCAmJiAhdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmICh0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9PSB0aGlzLmFuaW1hdGlvblBlcmlvZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH1cbn07XG5cbi8vVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuICh3ZWlnaHQpIGZvciBhbGwgbm9kZXNcbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgbm9kZS5ub09mQ2hpbGRyZW4gPSBub2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogRlItR3JpZCBWYXJpYW50IFJlcHVsc2lvbiBGb3JjZSBDYWxjdWxhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmlkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgdmFyIHNpemVYID0gMDtcbiAgdmFyIHNpemVZID0gMDtcblxuICBzaXplWCA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0UmlnaHQoKSAtIGdyYXBoLmdldExlZnQoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHNpemVZID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRCb3R0b20oKSAtIGdyYXBoLmdldFRvcCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICB2YXIgZ3JpZCA9IG5ldyBBcnJheShzaXplWCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZ3JpZFtpXSA9IG5ldyBBcnJheShzaXplWSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVZOyBqKyspIHtcbiAgICAgIGdyaWRbaV1bal0gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hZGROb2RlVG9HcmlkID0gZnVuY3Rpb24gKHYsIGxlZnQsIHRvcCkge1xuXG4gIHZhciBzdGFydFggPSAwO1xuICB2YXIgZmluaXNoWCA9IDA7XG4gIHZhciBzdGFydFkgPSAwO1xuICB2YXIgZmluaXNoWSA9IDA7XG5cbiAgc3RhcnRYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkud2lkdGggKyB2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHN0YXJ0WSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkuaGVpZ2h0ICsgdi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8PSBmaW5pc2hYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gc3RhcnRZOyBqIDw9IGZpbmlzaFk7IGorKykge1xuICAgICAgdGhpcy5ncmlkW2ldW2pdLnB1c2godik7XG4gICAgICB2LnNldEdyaWRDb29yZGluYXRlcyhzdGFydFgsIGZpbmlzaFgsIHN0YXJ0WSwgZmluaXNoWSk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBub2RlQTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcblxuICB0aGlzLmdyaWQgPSB0aGlzLmNhbGNHcmlkKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG5cbiAgLy8gcHV0IGFsbCBub2RlcyB0byBwcm9wZXIgZ3JpZCBjZWxsc1xuICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5hZGROb2RlVG9HcmlkKG5vZGVBLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0TGVmdCgpLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0VG9wKCkpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlID0gZnVuY3Rpb24gKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQgfHwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuICAgIHZhciBzdXJyb3VuZGluZyA9IG5ldyBTZXQoKTtcbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBub2RlQjtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIGZvciAodmFyIGkgPSBub2RlQS5zdGFydFggLSAxOyBpIDwgbm9kZUEuZmluaXNoWCArIDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IG5vZGVBLnN0YXJ0WSAtIDE7IGogPCBub2RlQS5maW5pc2hZICsgMjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPCAwIHx8IGogPCAwIHx8IGkgPj0gZ3JpZC5sZW5ndGggfHwgaiA+PSBncmlkWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyaWRbaV1bal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIG5vZGVCID0gZ3JpZFtpXVtqXVtrXTtcblxuICAgICAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIFxuICAgICAgICAgICAgLy8gb3IgYm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIHNraXAuXG4gICAgICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpIHx8IG5vZGVBID09IG5vZGVCKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVwdWxzaW9uIGZvcmNlIGJldHdlZW5cbiAgICAgICAgICAgIC8vIG5vZGVBIGFuZCBub2RlQiBoYXMgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZVNldC5oYXMobm9kZUIpICYmICFzdXJyb3VuZGluZy5oYXMobm9kZUIpKSB7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJYKCkgLSBub2RlQi5nZXRDZW50ZXJYKCkpIC0gKG5vZGVBLmdldFdpZHRoKCkgLyAyICsgbm9kZUIuZ2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWSgpIC0gbm9kZUIuZ2V0Q2VudGVyWSgpKSAtIChub2RlQS5nZXRIZWlnaHQoKSAvIDIgKyBub2RlQi5nZXRIZWlnaHQoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVBIGFuZCBub2RlQiBcbiAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGVuIGNhbGN1bGF0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZVggPD0gdGhpcy5yZXB1bHNpb25SYW5nZSAmJiBkaXN0YW5jZVkgPD0gdGhpcy5yZXB1bHNpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgbm9kZUIgdG8gc3Vycm91bmRpbmcgb2Ygbm9kZUFcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZy5hZGQobm9kZUIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHN1cnJvdW5kaW5nKSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVBLnN1cnJvdW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVBLnN1cnJvdW5kaW5nW2ldKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDAuMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0RWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xuICB0aGlzLmlkZWFsTGVuZ3RoID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbn1cblxuRkRMYXlvdXRFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEVkZ2UucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMRWRnZSkge1xuICBGRExheW91dEVkZ2VbcHJvcF0gPSBMRWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gRkRMYXlvdXROb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vIGFsdGVybmF0aXZlIGNvbnN0cnVjdG9yIGlzIGhhbmRsZWQgaW5zaWRlIExOb2RlXG4gIExOb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xuICAvL1NwcmluZywgcmVwdWxzaW9uIGFuZCBncmF2aXRhdGlvbmFsIGZvcmNlcyBhY3Rpbmcgb24gdGhpcyBub2RlXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICAvL0Ftb3VudCBieSB3aGljaCB0aGlzIG5vZGUgaXMgdG8gYmUgbW92ZWQgaW4gdGhpcyBpdGVyYXRpb25cbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcblxuICAvL1N0YXJ0IGFuZCBmaW5pc2ggZ3JpZCBjb29yZGluYXRlcyB0aGF0IHRoaXMgbm9kZSBpcyBmYWxsZW4gaW50b1xuICB0aGlzLnN0YXJ0WCA9IDA7XG4gIHRoaXMuZmluaXNoWCA9IDA7XG4gIHRoaXMuc3RhcnRZID0gMDtcbiAgdGhpcy5maW5pc2hZID0gMDtcblxuICAvL0dlb21ldHJpYyBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gIHRoaXMuc3Vycm91bmRpbmcgPSBbXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTE5vZGUucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMTm9kZSkge1xuICBGRExheW91dE5vZGVbcHJvcF0gPSBMTm9kZVtwcm9wXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZS5zZXRHcmlkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoX3N0YXJ0WCwgX2ZpbmlzaFgsIF9zdGFydFksIF9maW5pc2hZKSB7XG4gIHRoaXMuc3RhcnRYID0gX3N0YXJ0WDtcbiAgdGhpcy5maW5pc2hYID0gX2ZpbmlzaFg7XG4gIHRoaXMuc3RhcnRZID0gX3N0YXJ0WTtcbiAgdGhpcy5maW5pc2hZID0gX2ZpbmlzaFk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Tm9kZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBEaW1lbnNpb25EKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxufVxuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gIHRoaXMubWFwID0ge307XG4gIHRoaXMua2V5cyA9IFtdO1xufVxuXG5IYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB7XG4gICAgdGhpcy5tYXBbdGhlSWRdID0gdmFsdWU7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgfVxufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFtrZXldICE9IG51bGw7XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFt0aGVJZF07XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5rZXlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hTZXQoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59XG47XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkgdGhpcy5zZXRbdGhlSWRdID0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICBkZWxldGUgdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV07XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV0gPT0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG4vL2NvbmNhdHMgdGhpcy5zZXQgdG8gdGhlIGdpdmVuIGxpc3Rcbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbFRvID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldCk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0aGlzLnNldFtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHMgPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgdiA9IGxpc3RbaV07XG4gICAgdGhpcy5hZGQodik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFNldDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgY2xhc3NpYyBRdWlja3NvcnQgYWxnb3JpdGhtIHdpdGggSG9hcmUncyBwYXJ0aXRpb25cbiAqIC0gV29ya3MgYWxzbyBvbiBMaW5rZWRMaXN0IG9iamVjdHNcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFF1aWNrc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWlja3NvcnQoQSwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja3NvcnQpO1xuXG4gICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gIT09IG51bGwgfHwgY29tcGFyZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQpIHRoaXMuY29tcGFyZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENvbXBhcmVGdW5jdGlvbjtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICBpZiAoQSBpbnN0YW5jZW9mIExpbmtlZExpc3QpIGxlbmd0aCA9IEEuc2l6ZSgpO2Vsc2UgbGVuZ3RoID0gQS5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIDAsIGxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhRdWlja3NvcnQsIFt7XG4gICAgICAgIGtleTogJ19xdWlja3NvcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3F1aWNrc29ydChBLCBwLCByKSB7XG4gICAgICAgICAgICBpZiAocCA8IHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHRoaXMuX3BhcnRpdGlvbihBLCBwLCByKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcCwgcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIHEgKyAxLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3BhcnRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFydGl0aW9uKEEsIHAsIHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fZ2V0KEEsIHApO1xuICAgICAgICAgICAgdmFyIGkgPSBwO1xuICAgICAgICAgICAgdmFyIGogPSByO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wYXJlRnVuY3Rpb24oeCwgdGhpcy5fZ2V0KEEsIGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfXdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih0aGlzLl9nZXQoQSwgaSksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9aWYgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXAoQSwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KG9iamVjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSByZXR1cm4gb2JqZWN0LmdldF9vYmplY3RfYXQoaW5kZXgpO2Vsc2UgcmV0dXJuIG9iamVjdFtpbmRleF07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIG9iamVjdC5zZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSk7ZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zd2FwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zd2FwKEEsIGksIGopIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZ2V0KEEsIGkpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KEEsIGksIHRoaXMuX2dldChBLCBqKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaiwgdGVtcCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiID4gYTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja3NvcnQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVpY2tzb3J0O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogICBOZWVkbGVtYW4tV3Vuc2NoIGFsZ29yaXRobSBpcyBhbiBwcm9jZWR1cmUgdG8gY29tcHV0ZSB0aGUgb3B0aW1hbCBnbG9iYWwgYWxpZ25tZW50IG9mIHR3byBzdHJpbmdcbiAqICAgc2VxdWVuY2VzIGJ5IFMuQi5OZWVkbGVtYW4gYW5kIEMuRC5XdW5zY2ggKDE5NzApLlxuICpcbiAqICAgQXNpZGUgZnJvbSB0aGUgaW5wdXRzLCB5b3UgY2FuIGFzc2lnbiB0aGUgc2NvcmVzIGZvcixcbiAqICAgLSBNYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBzYW1lLlxuICogICAtIE1pc21hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIGRpZmZlcmVudC5cbiAqICAgLSBJbnNlcnRpb24vRGVsZXRpb24oZ2Fwcyk6IFRoZSBiZXN0IGFsaWdubWVudCBpbnZvbHZlcyBvbmUgbGV0dGVyIGFsaWduaW5nIHRvIGEgZ2FwIGluIHRoZSBvdGhlciBzdHJpbmcuXG4gKi9cblxudmFyIE5lZWRsZW1hbld1bnNjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZWVkbGVtYW5XdW5zY2goc2VxdWVuY2UxLCBzZXF1ZW5jZTIpIHtcbiAgICAgICAgdmFyIG1hdGNoX3Njb3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgbWlzbWF0Y2hfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogLTE7XG4gICAgICAgIHZhciBnYXBfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogLTE7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5lZWRsZW1hbld1bnNjaCk7XG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZTEgPSBzZXF1ZW5jZTE7XG4gICAgICAgIHRoaXMuc2VxdWVuY2UyID0gc2VxdWVuY2UyO1xuICAgICAgICB0aGlzLm1hdGNoX3Njb3JlID0gbWF0Y2hfc2NvcmU7XG4gICAgICAgIHRoaXMubWlzbWF0Y2hfcGVuYWx0eSA9IG1pc21hdGNoX3BlbmFsdHk7XG4gICAgICAgIHRoaXMuZ2FwX3BlbmFsdHkgPSBnYXBfcGVuYWx0eTtcblxuICAgICAgICAvLyBKdXN0IHRoZSByZW1vdmUgcmVkdW5kYW5jeVxuICAgICAgICB0aGlzLmlNYXggPSBzZXF1ZW5jZTEubGVuZ3RoICsgMTtcbiAgICAgICAgdGhpcy5qTWF4ID0gc2VxdWVuY2UyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgLy8gR3JpZCBtYXRyaXggb2Ygc2NvcmVzXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRbaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjZWJhY2sgbWF0cml4ICgyRCBhcnJheSwgZWFjaCBjZWxsIGlzIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzIGZvciBbYERpYWdgLCBgVXBgLCBgTGVmdGBdIHBvc2l0aW9ucylcbiAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmlNYXg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHRoaXMuak1heDsgX2orKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV1bX2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGFsaWduZWQgc2VxdWVuY2VzIChyZXR1cm4gbXVsdGlwbGUgcG9zc2liaWxpdGllcylcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgLy8gRmluYWwgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgIHRoaXMuc2NvcmUgPSAtMTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGFuZCB0cmFjZWJhY2tzXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyaWRzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5lZWRsZW1hbld1bnNjaCwgW3tcbiAgICAgICAga2V5OiBcImdldFNjb3JlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29yZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxpZ25tZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxpZ25tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIGR5bmFtaWMgcHJvZ3JhbW1pbmcgcHJvY2VkdXJlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wdXRlR3JpZHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVHcmlkcygpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFswXVtqXSA9IHRoaXMuZ3JpZFswXVtqIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFswXVtqXSA9IFtmYWxzZSwgZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bMF0gPSB0aGlzLmdyaWRbaSAtIDFdWzBdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbaV1bMF0gPSBbZmFsc2UsIHRydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB0aGUgcmVzdCBvZiB0aGUgZ3JpZFxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5pTWF4OyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDE7IF9qMiA8IHRoaXMuak1heDsgX2oyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4IHNjb3JlKHMpIGFtb25nIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlMVtfaTIgLSAxXSA9PT0gdGhpcy5zZXF1ZW5jZTJbX2oyIC0gMV0pIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1hdGNoX3Njb3JlO2Vsc2UgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWlzbWF0Y2hfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXAgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5ncmlkW19pMl1bX2oyIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBtdWx0aXBsZSBtYXggdmFsdWVzLCBjYXB0dXJlIHRoZW0gZm9yIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhPZiA9IFtkaWFnLCB1cCwgbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5hcnJheUFsbE1heEluZGV4ZXMobWF4T2YpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBHcmlkc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRbX2kyXVtfajJdID0gbWF4T2ZbaW5kaWNlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaTJdW19qMl0gPSBbaW5kaWNlcy5pbmNsdWRlcygwKSwgaW5kaWNlcy5pbmNsdWRlcygxKSwgaW5kaWNlcy5pbmNsdWRlcygyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5ncmlkW3RoaXMuaU1heCAtIDFdW3RoaXMuak1heCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgcG9zc2libGUgdmFsaWQgc2VxdWVuY2UgY29tYmluYXRpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbGlnbm1lbnRUcmFjZWJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWdubWVudFRyYWNlYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBpblByb2Nlc3NBbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW3RoaXMuc2VxdWVuY2UxLmxlbmd0aCwgdGhpcy5zZXF1ZW5jZTIubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBzZXExOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcTI6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5Qcm9jZXNzQWxpZ25tZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5Qcm9jZXNzQWxpZ25tZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IHRoaXMudHJhY2ViYWNrR3JpZFtjdXJyZW50LnBvc1swXV1bY3VycmVudC5wb3NbMV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6ICctJyArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0sIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiAnLScgKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBvc1swXSA9PT0gMCAmJiBjdXJyZW50LnBvc1sxXSA9PT0gMCkgdGhpcy5hbGlnbm1lbnRzLnB1c2goeyBzZXF1ZW5jZTE6IGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyOiBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsbEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbEluZGV4ZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gYXJyLmluZGV4T2YodmFsLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXJyYXlBbGxNYXhJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheUFsbE1heEluZGV4ZXMoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbEluZGV4ZXMoYXJyYXksIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmVlZGxlbWFuV3Vuc2NoO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZWRsZW1hbld1bnNjaDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGF5b3V0QmFzZSA9IGZ1bmN0aW9uIGxheW91dEJhc2UoKSB7XG4gIHJldHVybjtcbn07XG5cbmxheW91dEJhc2UuRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xubGF5b3V0QmFzZS5GRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmxheW91dEJhc2UuRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5sYXlvdXRCYXNlLkRpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbmxheW91dEJhc2UuSGFzaE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubGF5b3V0QmFzZS5IYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5sYXlvdXRCYXNlLklHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5sYXlvdXRCYXNlLklNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmxheW91dEJhc2UuSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xubGF5b3V0QmFzZS5Qb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xubGF5b3V0QmFzZS5Qb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xubGF5b3V0QmFzZS5SYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5sYXlvdXRCYXNlLlJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmxheW91dEJhc2UuVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5sYXlvdXRCYXNlLlVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5sYXlvdXRCYXNlLlF1aWNrc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xubGF5b3V0QmFzZS5MaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5sYXlvdXRCYXNlLkxHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5sYXlvdXRCYXNlLkxFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmxheW91dEJhc2UuTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5sYXlvdXRCYXNlLkxOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmxheW91dEJhc2UuTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5sYXlvdXRCYXNlLk5lZWRsZW1hbld1bnNjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn1cblxudmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcblxucC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdGhpcy5saXN0ZW5lcnMucHVzaCh7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbnAucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGwgPSB0aGlzLmxpc3RlbmVyc1tpXTtcblxuICAgIGlmIChsLmV2ZW50ID09PSBldmVudCAmJiBsLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxucC5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGV2ZW50ID09PSBsLmV2ZW50KSB7XG4gICAgICBsLmNhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwidmFsdWUiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiTGF5b3V0Q29uc3RhbnRzIiwiUVVBTElUWSIsIkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCIsIkRFRkFVTFRfSU5DUkVNRU5UQUwiLCJERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQiLCJERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUIiwiREVGQVVMVF9BTklNQVRJT05fUEVSSU9EIiwiREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyIsIkRFRkFVTFRfR1JBUEhfTUFSR0lOIiwiTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTIiwiU0lNUExFX05PREVfU0laRSIsIlNJTVBMRV9OT0RFX0hBTEZfU0laRSIsIkVNUFRZX0NPTVBPVU5EX05PREVfU0laRSIsIk1JTl9FREdFX0xFTkdUSCIsIldPUkxEX0JPVU5EQVJZIiwiSU5JVElBTF9XT1JMRF9CT1VOREFSWSIsIldPUkxEX0NFTlRFUl9YIiwiV09STERfQ0VOVEVSX1kiLCJMR3JhcGhPYmplY3QiLCJJR2VvbWV0cnkiLCJJTWF0aCIsIkxFZGdlIiwic291cmNlIiwidGFyZ2V0IiwidkVkZ2UiLCJpc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQiLCJ2R3JhcGhPYmplY3QiLCJiZW5kcG9pbnRzIiwiY3JlYXRlIiwicHJvcCIsImdldFNvdXJjZSIsImdldFRhcmdldCIsImlzSW50ZXJHcmFwaCIsImdldExlbmd0aCIsImxlbmd0aCIsImdldEJlbmRwb2ludHMiLCJnZXRMY2EiLCJsY2EiLCJnZXRTb3VyY2VJbkxjYSIsInNvdXJjZUluTGNhIiwiZ2V0VGFyZ2V0SW5MY2EiLCJ0YXJnZXRJbkxjYSIsImdldE90aGVyRW5kIiwibm9kZSIsImdldE90aGVyRW5kSW5HcmFwaCIsImdyYXBoIiwib3RoZXJFbmQiLCJnZXRHcmFwaE1hbmFnZXIiLCJnZXRSb290IiwiZ2V0T3duZXIiLCJnZXRQYXJlbnQiLCJ1cGRhdGVMZW5ndGgiLCJjbGlwUG9pbnRDb29yZGluYXRlcyIsIkFycmF5IiwiZ2V0SW50ZXJzZWN0aW9uIiwiZ2V0UmVjdCIsImxlbmd0aFgiLCJsZW5ndGhZIiwiTWF0aCIsImFicyIsInNpZ24iLCJzcXJ0IiwidXBkYXRlTGVuZ3RoU2ltcGxlIiwiZ2V0Q2VudGVyWCIsImdldENlbnRlclkiLCJJbnRlZ2VyIiwiUmVjdGFuZ2xlRCIsIlJhbmRvbVNlZWQiLCJQb2ludEQiLCJMTm9kZSIsImdtIiwibG9jIiwic2l6ZSIsInZOb2RlIiwiZ3JhcGhNYW5hZ2VyIiwiZXN0aW1hdGVkU2l6ZSIsIk1JTl9WQUxVRSIsImluY2x1c2lvblRyZWVEZXB0aCIsIk1BWF9WQUxVRSIsImVkZ2VzIiwicmVjdCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJnZXRFZGdlcyIsImdldENoaWxkIiwiY2hpbGQiLCJvd25lciIsImdldFdpZHRoIiwic2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJzZXRIZWlnaHQiLCJnZXRDZW50ZXIiLCJnZXRMb2NhdGlvbiIsImdldERpYWdvbmFsIiwiZ2V0SGFsZlRoZURpYWdvbmFsIiwic2V0UmVjdCIsInVwcGVyTGVmdCIsImRpbWVuc2lvbiIsInNldENlbnRlciIsImN4IiwiY3kiLCJzZXRMb2NhdGlvbiIsIm1vdmVCeSIsImR4IiwiZHkiLCJnZXRFZGdlTGlzdFRvTm9kZSIsInRvIiwiZWRnZUxpc3QiLCJlZGdlIiwic2VsZiIsImZvckVhY2giLCJwdXNoIiwiZ2V0RWRnZXNCZXR3ZWVuIiwib3RoZXIiLCJnZXROZWlnaGJvcnNMaXN0IiwibmVpZ2hib3JzIiwiU2V0IiwiYWRkIiwid2l0aENoaWxkcmVuIiwid2l0aE5laWdoYm9yc0xpc3QiLCJjaGlsZE5vZGUiLCJjaGlsZHJlbiIsIm5vZGVzIiwiZ2V0Tm9kZXMiLCJnZXROb09mQ2hpbGRyZW4iLCJub09mQ2hpbGRyZW4iLCJnZXRFc3RpbWF0ZWRTaXplIiwiY2FsY0VzdGltYXRlZFNpemUiLCJzY2F0dGVyIiwicmFuZG9tQ2VudGVyWCIsInJhbmRvbUNlbnRlclkiLCJtaW5YIiwibWF4WCIsIm5leHREb3VibGUiLCJtaW5ZIiwibWF4WSIsInVwZGF0ZUJvdW5kcyIsImNoaWxkR3JhcGgiLCJnZXRMZWZ0IiwiZ2V0VG9wIiwiZ2V0UmlnaHQiLCJnZXRCb3R0b20iLCJsYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJsYWJlbFBvcyIsImdldEluY2x1c2lvblRyZWVEZXB0aCIsInRyYW5zZm9ybSIsInRyYW5zIiwibGVmdCIsInRvcCIsImxlZnRUb3AiLCJ2TGVmdFRvcCIsImludmVyc2VUcmFuc2Zvcm1Qb2ludCIsImdldFgiLCJnZXRZIiwic2V0WCIsInNldFkiLCJnZXREaWZmZXJlbmNlIiwicHQiLCJEaW1lbnNpb25EIiwiZ2V0Q29weSIsInRyYW5zbGF0ZSIsImRpbSIsIkxHcmFwaE1hbmFnZXIiLCJQb2ludCIsIkxpbmtlZExpc3QiLCJMR3JhcGgiLCJwYXJlbnQiLCJvYmoyIiwidkdyYXBoIiwibWFyZ2luIiwiaXNDb25uZWN0ZWQiLCJMYXlvdXQiLCJyaWdodCIsImJvdHRvbSIsIm9iajEiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIm5ld05vZGUiLCJpbmRleE9mIiwibmV3RWRnZSIsInJlbW92ZSIsIm9iaiIsImVkZ2VzVG9CZVJlbW92ZWQiLCJzbGljZSIsImluZGV4Iiwic3BsaWNlIiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInVwZGF0ZUxlZnRUb3AiLCJub2RlVG9wIiwibm9kZUxlZnQiLCJsTm9kZSIsInBhZGRpbmdMZWZ0IiwidW5kZWZpbmVkIiwicmVjdXJzaXZlIiwibm9kZVJpZ2h0Iiwibm9kZUJvdHRvbSIsImJvdW5kaW5nUmVjdCIsImNhbGN1bGF0ZUJvdW5kcyIsInVwZGF0ZUNvbm5lY3RlZCIsInF1ZXVlIiwidmlzaXRlZCIsImN1cnJlbnROb2RlIiwibmVpZ2hib3JFZGdlcyIsImN1cnJlbnROZWlnaGJvciIsImNoaWxkcmVuT2ZOb2RlIiwic2hpZnQiLCJuZWlnaGJvckVkZ2UiLCJoYXMiLCJjaGlsZHJlbk9mTmVpZ2hib3IiLCJub09mVmlzaXRlZEluVGhpc0dyYXBoIiwidmlzaXRlZE5vZGUiLCJsYXlvdXQiLCJncmFwaHMiLCJhZGRSb290IiwibmdyYXBoIiwibmV3R3JhcGgiLCJubm9kZSIsInNldFJvb3RHcmFwaCIsInJvb3RHcmFwaCIsInBhcmVudE5vZGUiLCJzb3VyY2VHcmFwaCIsInRhcmdldEdyYXBoIiwibE9iaiIsImNvbmNhdCIsIm5vZGVzVG9CZVJlbW92ZWQiLCJnZXRHcmFwaHMiLCJnZXRBbGxOb2RlcyIsImFsbE5vZGVzIiwibm9kZUxpc3QiLCJyZXNldEFsbE5vZGVzIiwicmVzZXRBbGxFZGdlcyIsImFsbEVkZ2VzIiwicmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiZ2V0QWxsRWRnZXMiLCJnZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsInNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiZ2V0TGF5b3V0IiwiaXNPbmVBbmNlc3Rvck9mT3RoZXIiLCJmaXJzdE5vZGUiLCJzZWNvbmROb2RlIiwib3duZXJHcmFwaCIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMiLCJzb3VyY2VBbmNlc3RvckdyYXBoIiwidGFyZ2V0QW5jZXN0b3JHcmFwaCIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvciIsImZpcnN0T3duZXJHcmFwaCIsInNlY29uZE93bmVyR3JhcGgiLCJjYWxjSW5jbHVzaW9uVHJlZURlcHRocyIsImRlcHRoIiwiaW5jbHVkZXNJbnZhbGlkRWRnZSIsIkZETGF5b3V0Q29uc3RhbnRzIiwiTUFYX0lURVJBVElPTlMiLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9TUFJJTkdfU1RSRU5HVEgiLCJERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCIsIkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCIsIkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04iLCJERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT04iLCJERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIiwiQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiIsIkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCIsIkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCIsIk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCIsIk1BWF9OT0RFX0RJU1BMQUNFTUVOVCIsIk1JTl9SRVBVTFNJT05fRElTVCIsIkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCIsIlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IiLCJHUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCIsImNhbGNTZXBhcmF0aW9uQW1vdW50IiwicmVjdEEiLCJyZWN0QiIsIm92ZXJsYXBBbW91bnQiLCJzZXBhcmF0aW9uQnVmZmVyIiwiaW50ZXJzZWN0cyIsImRpcmVjdGlvbnMiLCJkZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyIsIm1pbiIsIm1heCIsInNsb3BlIiwibW92ZUJ5WSIsIm1vdmVCeVgiLCJnZXRJbnRlcnNlY3Rpb24yIiwicmVzdWx0IiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwidG9wTGVmdEF4IiwidG9wTGVmdEF5IiwidG9wUmlnaHRBeCIsImJvdHRvbUxlZnRBeCIsImJvdHRvbUxlZnRBeSIsImJvdHRvbVJpZ2h0QXgiLCJoYWxmV2lkdGhBIiwiZ2V0V2lkdGhIYWxmIiwiaGFsZkhlaWdodEEiLCJnZXRIZWlnaHRIYWxmIiwidG9wTGVmdEJ4IiwidG9wTGVmdEJ5IiwidG9wUmlnaHRCeCIsImJvdHRvbUxlZnRCeCIsImJvdHRvbUxlZnRCeSIsImJvdHRvbVJpZ2h0QngiLCJoYWxmV2lkdGhCIiwiaGFsZkhlaWdodEIiLCJjbGlwUG9pbnRBRm91bmQiLCJjbGlwUG9pbnRCRm91bmQiLCJzbG9wZUEiLCJzbG9wZUIiLCJzbG9wZVByaW1lIiwiY2FyZGluYWxEaXJlY3Rpb25BIiwiY2FyZGluYWxEaXJlY3Rpb25CIiwidGVtcFBvaW50QXgiLCJ0ZW1wUG9pbnRBeSIsInRlbXBQb2ludEJ4IiwidGVtcFBvaW50QnkiLCJnZXRDYXJkaW5hbERpcmVjdGlvbiIsImxpbmUiLCJzMSIsInMyIiwiZjEiLCJmMiIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsIng0IiwieTQiLCJhMSIsImEyIiwiYjEiLCJiMiIsImMxIiwiYzIiLCJkZW5vbSIsImFuZ2xlT2ZWZWN0b3IiLCJDeCIsIkN5IiwiTngiLCJOeSIsIkNfYW5nbGUiLCJhdGFuIiwiUEkiLCJUV09fUEkiLCJPTkVfQU5EX0hBTEZfUEkiLCJIQUxGX1BJIiwiZG9JbnRlcnNlY3QiLCJwMSIsInAyIiwicDMiLCJwNCIsImEiLCJiIiwicSIsInIiLCJkZXQiLCJsYW1iZGEiLCJnYW1tYSIsIlRIUkVFX1BJIiwiZmxvb3IiLCJjZWlsIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIndyaXRhYmxlIiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIm5vZGVGcm9tIiwibmV4dCIsInByZXYiLCJsaXN0IiwiaGVhZCIsInRhaWwiLCJfcmVtb3ZlIiwidmFscyIsIl90aGlzIiwidiIsImluc2VydEJlZm9yZSIsInZhbCIsIm90aGVyTm9kZSIsImluc2VydEFmdGVyIiwiaW5zZXJ0Tm9kZUJlZm9yZSIsImluc2VydE5vZGVBZnRlciIsInVuc2hpZnQiLCJwb3AiLCJwb3BOb2RlIiwic2hpZnROb2RlIiwiZ2V0X29iamVjdF9hdCIsImN1cnJlbnQiLCJzZXRfb2JqZWN0X2F0IiwiY29uc3RydWN0b3IiLCJwYXJzZUludCIsIm1vdmUiLCJlcXVhbHMiLCJ0b1N0cmluZyIsImdldE1pblgiLCJnZXRNYXhYIiwiZ2V0TWluWSIsImdldE1heFkiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJVbmlxdWVJREdlbmVyZXRvciIsImxhc3RJRCIsImNyZWF0ZUlEIiwiaXNQcmltaXRpdmUiLCJ1bmlxdWVJRCIsImdldFN0cmluZyIsImlkIiwiYXJnIiwidHlwZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsImlzQXJyYXkiLCJhcnIyIiwiZnJvbSIsIlRyYW5zZm9ybSIsIkVtaXR0ZXIiLCJpc1JlbW90ZVVzZSIsImxheW91dFF1YWxpdHkiLCJjcmVhdGVCZW5kc0FzTmVlZGVkIiwiaW5jcmVtZW50YWwiLCJhbmltYXRpb25PbkxheW91dCIsImFuaW1hdGlvbkR1cmluZ0xheW91dCIsImFuaW1hdGlvblBlcmlvZCIsInVuaWZvcm1MZWFmTm9kZVNpemVzIiwiZWRnZVRvRHVtbXlOb2RlcyIsIk1hcCIsImlzTGF5b3V0RmluaXNoZWQiLCJpc1N1YkxheW91dCIsIlJBTkRPTV9TRUVEIiwibmV3R3JhcGhNYW5hZ2VyIiwiY2hlY2tMYXlvdXRTdWNjZXNzIiwicnVuTGF5b3V0IiwidGlsaW5nUHJlTGF5b3V0IiwiaW5pdFBhcmFtZXRlcnMiLCJpc0xheW91dFN1Y2Nlc3NmdWxsIiwiQU5JTUFURSIsImRvUG9zdExheW91dCIsInRpbGluZ1Bvc3RMYXlvdXQiLCJ1cGRhdGUiLCJ1cGRhdGUyIiwiY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzIiwibmV3TGVmdFRvcCIsInNldFdvcmxkT3JnWCIsInNldFdvcmxkT3JnWSIsInNldERldmljZU9yZ1giLCJzZXREZXZpY2VPcmdZIiwicG9zaXRpb25Ob2Rlc1JhbmRvbWx5IiwiZ2V0RmxhdEZvcmVzdCIsImZsYXRGb3Jlc3QiLCJpc0ZvcmVzdCIsImlzRmxhdCIsInRvQmVWaXNpdGVkIiwicGFyZW50cyIsInVuUHJvY2Vzc2VkTm9kZXMiLCJzZXQiLCJ0ZW1wIiwiY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMiLCJkdW1teU5vZGVzIiwiZHVtbXlOb2RlIiwiRGltZW5zaW9uIiwiZHVtbXlFZGdlIiwia2V5cyIsImsiLCJsRWRnZSIsInBhdGgiLCJlYnAiLCJzbGlkZXJWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm1pbkRpdiIsIm1heE11bCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJmaW5kQ2VudGVyT2ZUcmVlIiwicmVtb3ZlZE5vZGVzIiwicmVtYWluaW5nRGVncmVlcyIsImZvdW5kQ2VudGVyIiwiY2VudGVyTm9kZSIsImRlZ3JlZSIsInRlbXBMaXN0IiwidGVtcExpc3QyIiwibmVpZ2hib3VycyIsIm5laWdoYm91ciIsIm90aGVyRGVncmVlIiwibmV3RGVncmVlIiwic2V0R3JhcGhNYW5hZ2VyIiwic2VlZCIsInNpbiIsImx3b3JsZE9yZ1giLCJsd29ybGRPcmdZIiwibGRldmljZU9yZ1giLCJsZGV2aWNlT3JnWSIsImx3b3JsZEV4dFgiLCJsd29ybGRFeHRZIiwibGRldmljZUV4dFgiLCJsZGV2aWNlRXh0WSIsImdldFdvcmxkT3JnWCIsIndveCIsImdldFdvcmxkT3JnWSIsIndveSIsImdldFdvcmxkRXh0WCIsInNldFdvcmxkRXh0WCIsIndleCIsImdldFdvcmxkRXh0WSIsInNldFdvcmxkRXh0WSIsIndleSIsImdldERldmljZU9yZ1giLCJkb3giLCJnZXREZXZpY2VPcmdZIiwiZG95IiwiZ2V0RGV2aWNlRXh0WCIsInNldERldmljZUV4dFgiLCJkZXgiLCJnZXREZXZpY2VFeHRZIiwic2V0RGV2aWNlRXh0WSIsImRleSIsInRyYW5zZm9ybVgiLCJ4RGV2aWNlIiwid29ybGRFeHRYIiwidHJhbnNmb3JtWSIsInlEZXZpY2UiLCJ3b3JsZEV4dFkiLCJpbnZlcnNlVHJhbnNmb3JtWCIsInhXb3JsZCIsImRldmljZUV4dFgiLCJpbnZlcnNlVHJhbnNmb3JtWSIsInlXb3JsZCIsImRldmljZUV4dFkiLCJpblBvaW50Iiwib3V0UG9pbnQiLCJGRExheW91dCIsInVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24iLCJpZGVhbEVkZ2VMZW5ndGgiLCJzcHJpbmdDb25zdGFudCIsInJlcHVsc2lvbkNvbnN0YW50IiwiZ3Jhdml0eUNvbnN0YW50IiwiY29tcG91bmRHcmF2aXR5Q29uc3RhbnQiLCJncmF2aXR5UmFuZ2VGYWN0b3IiLCJjb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciIsImRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUiLCJjb29saW5nRmFjdG9yIiwiaW5pdGlhbENvb2xpbmdGYWN0b3IiLCJ0b3RhbERpc3BsYWNlbWVudCIsIm9sZFRvdGFsRGlzcGxhY2VtZW50IiwibWF4SXRlcmF0aW9ucyIsImFyZ3VtZW50cyIsInRvdGFsSXRlcmF0aW9ucyIsIm5vdEFuaW1hdGVkSXRlcmF0aW9ucyIsInVzZUZSR3JpZFZhcmlhbnQiLCJncmlkIiwiY2FsY0lkZWFsRWRnZUxlbmd0aHMiLCJsY2FEZXB0aCIsInNpemVPZlNvdXJjZUluTGNhIiwic2l6ZU9mVGFyZ2V0SW5MY2EiLCJpZGVhbExlbmd0aCIsImluaXRTcHJpbmdFbWJlZGRlciIsIm1heE5vZGVEaXNwbGFjZW1lbnQiLCJ0b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCIsInJlcHVsc2lvblJhbmdlIiwiY2FsY1JlcHVsc2lvblJhbmdlIiwiY2FsY1NwcmluZ0ZvcmNlcyIsImxFZGdlcyIsImNhbGNTcHJpbmdGb3JjZSIsImNhbGNSZXB1bHNpb25Gb3JjZXMiLCJncmlkVXBkYXRlQWxsb3dlZCIsImZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUiLCJqIiwibm9kZUEiLCJub2RlQiIsImxOb2RlcyIsInByb2Nlc3NlZE5vZGVTZXQiLCJ1cGRhdGVHcmlkIiwiY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlIiwiY2FsY1JlcHVsc2lvbkZvcmNlIiwiY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMiLCJjYWxjR3Jhdml0YXRpb25hbEZvcmNlIiwibW92ZU5vZGVzIiwic3ByaW5nRm9yY2UiLCJzcHJpbmdGb3JjZVgiLCJzcHJpbmdGb3JjZVkiLCJjbGlwUG9pbnRzIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwiZGlzdGFuY2VTcXVhcmVkIiwiZGlzdGFuY2UiLCJyZXB1bHNpb25Gb3JjZSIsInJlcHVsc2lvbkZvcmNlWCIsInJlcHVsc2lvbkZvcmNlWSIsImNoaWxkcmVuQ29uc3RhbnQiLCJvd25lckNlbnRlclgiLCJvd25lckNlbnRlclkiLCJhYnNEaXN0YW5jZVgiLCJhYnNEaXN0YW5jZVkiLCJncmF2aXRhdGlvbkZvcmNlWCIsImdyYXZpdGF0aW9uRm9yY2VZIiwiaXNDb252ZXJnZWQiLCJjb252ZXJnZWQiLCJvc2NpbGF0aW5nIiwiYW5pbWF0ZSIsImNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyIsImNhbGNHcmlkIiwic2l6ZVgiLCJzaXplWSIsImFkZE5vZGVUb0dyaWQiLCJzdGFydFgiLCJmaW5pc2hYIiwic3RhcnRZIiwiZmluaXNoWSIsInNldEdyaWRDb29yZGluYXRlcyIsInN1cnJvdW5kaW5nIiwiRkRMYXlvdXRFZGdlIiwiRkRMYXlvdXROb2RlIiwiZGlzcGxhY2VtZW50WCIsImRpc3BsYWNlbWVudFkiLCJfc3RhcnRYIiwiX2ZpbmlzaFgiLCJfc3RhcnRZIiwiX2ZpbmlzaFkiLCJIYXNoTWFwIiwibWFwIiwicHV0IiwidGhlSWQiLCJjb250YWlucyIsImtleVNldCIsIkhhc2hTZXQiLCJjbGVhciIsImlzRW1wdHkiLCJhZGRBbGxUbyIsImFkZEFsbCIsIlF1aWNrc29ydCIsIkEiLCJjb21wYXJlRnVuY3Rpb24iLCJfZGVmYXVsdENvbXBhcmVGdW5jdGlvbiIsIl9xdWlja3NvcnQiLCJfcGFydGl0aW9uIiwiX2dldCIsIl9zd2FwIiwiX3NldCIsIk5lZWRsZW1hbld1bnNjaCIsInNlcXVlbmNlMSIsInNlcXVlbmNlMiIsIm1hdGNoX3Njb3JlIiwibWlzbWF0Y2hfcGVuYWx0eSIsImdhcF9wZW5hbHR5IiwiaU1heCIsImpNYXgiLCJ0cmFjZWJhY2tHcmlkIiwiX2kiLCJfaiIsImFsaWdubWVudHMiLCJzY29yZSIsImNvbXB1dGVHcmlkcyIsImdldFNjb3JlIiwiZ2V0QWxpZ25tZW50cyIsIl9pMiIsIl9qMiIsImRpYWciLCJ1cCIsIm1heE9mIiwiaW5kaWNlcyIsImFycmF5QWxsTWF4SW5kZXhlcyIsImluY2x1ZGVzIiwiYWxpZ25tZW50VHJhY2ViYWNrIiwiaW5Qcm9jZXNzQWxpZ25tZW50cyIsInBvcyIsInNlcTEiLCJzZXEyIiwiZ2V0QWxsSW5kZXhlcyIsImluZGV4ZXMiLCJhcnJheSIsImFwcGx5IiwibGF5b3V0QmFzZSIsImxpc3RlbmVycyIsImFkZExpc3RlbmVyIiwiZXZlbnQiLCJjYWxsYmFjayIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/layout-base/layout-base.js\n");

/***/ })

};
;
{"version":3,"file":"app/api/webdav/[...path]/route.js","mappings":"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","sources":["webpack://_N_E/external commonjs \"node:async_hooks\"","webpack://_N_E/external commonjs \"node:buffer\"","webpack://_N_E/./app/api/webdav/[...path]/route.ts","webpack://_N_E/./app/api/webdav/[...path]/route.ts?edcf","webpack://_N_E/?fe73","webpack://_N_E/<anon>"],"sourcesContent":["module.exports = require(\"node:async_hooks\");","module.exports = require(\"node:buffer\");","import { NextRequest, NextResponse } from \"next/server\";\nimport { STORAGE_KEY, internalAllowedWebDavEndpoints } from \"../../../constant\";\nimport { getServerSideConfig } from \"@/app/config/server\";\n\nconst config = getServerSideConfig();\n\nconst mergedAllowedWebDavEndpoints = [\n  ...internalAllowedWebDavEndpoints,\n  ...config.allowedWebDavEndpoints,\n].filter((domain) => Boolean(domain.trim()));\n\nconst normalizeUrl = (url: string) => {\n  try {\n    return new URL(url);\n  } catch (err) {\n    return null;\n  }\n};\n\nasync function handle(\n  req: NextRequest,\n  { params }: { params: { path: string[] } },\n) {\n  if (req.method === \"OPTIONS\") {\n    return NextResponse.json({ body: \"OK\" }, { status: 200 });\n  }\n  const folder = STORAGE_KEY;\n  const fileName = `${folder}/backup.json`;\n\n  const requestUrl = new URL(req.url);\n  let endpoint = requestUrl.searchParams.get(\"endpoint\");\n  let proxy_method = requestUrl.searchParams.get(\"proxy_method\") || req.method;\n\n  // Validate the endpoint to prevent potential SSRF attacks\n  if (\n    !endpoint ||\n    !mergedAllowedWebDavEndpoints.some((allowedEndpoint) => {\n      const normalizedAllowedEndpoint = normalizeUrl(allowedEndpoint);\n      const normalizedEndpoint = normalizeUrl(endpoint as string);\n\n      return (\n        normalizedEndpoint &&\n        normalizedEndpoint.hostname === normalizedAllowedEndpoint?.hostname &&\n        normalizedEndpoint.pathname.startsWith(\n          normalizedAllowedEndpoint.pathname,\n        )\n      );\n    })\n  ) {\n    return NextResponse.json(\n      {\n        error: true,\n        msg: \"Invalid endpoint\",\n      },\n      {\n        status: 400,\n      },\n    );\n  }\n\n  if (!endpoint?.endsWith(\"/\")) {\n    endpoint += \"/\";\n  }\n\n  const endpointPath = params.path.join(\"/\");\n  const targetPath = `${endpoint}${endpointPath}`;\n\n  // only allow MKCOL, GET, PUT\n  if (\n    proxy_method !== \"MKCOL\" &&\n    proxy_method !== \"GET\" &&\n    proxy_method !== \"PUT\"\n  ) {\n    return NextResponse.json(\n      {\n        error: true,\n        msg: \"you are not allowed to request \" + targetPath,\n      },\n      {\n        status: 403,\n      },\n    );\n  }\n\n  // for MKCOL request, only allow request ${folder}\n  if (proxy_method === \"MKCOL\" && !targetPath.endsWith(folder)) {\n    return NextResponse.json(\n      {\n        error: true,\n        msg: \"you are not allowed to request \" + targetPath,\n      },\n      {\n        status: 403,\n      },\n    );\n  }\n\n  // for GET request, only allow request ending with fileName\n  if (proxy_method === \"GET\" && !targetPath.endsWith(fileName)) {\n    return NextResponse.json(\n      {\n        error: true,\n        msg: \"you are not allowed to request \" + targetPath,\n      },\n      {\n        status: 403,\n      },\n    );\n  }\n\n  //   for PUT request, only allow request ending with fileName\n  if (proxy_method === \"PUT\" && !targetPath.endsWith(fileName)) {\n    return NextResponse.json(\n      {\n        error: true,\n        msg: \"you are not allowed to request \" + targetPath,\n      },\n      {\n        status: 403,\n      },\n    );\n  }\n\n  const targetUrl = targetPath;\n\n  const method = proxy_method || req.method;\n  const shouldNotHaveBody = [\"get\", \"head\"].includes(\n    method?.toLowerCase() ?? \"\",\n  );\n\n  const fetchOptions: RequestInit = {\n    headers: {\n      authorization: req.headers.get(\"authorization\") ?? \"\",\n    },\n    body: shouldNotHaveBody ? null : req.body,\n    redirect: \"manual\",\n    method,\n    // @ts-ignore\n    duplex: \"half\",\n  };\n\n  let fetchResult;\n\n  try {\n    fetchResult = await fetch(targetUrl, fetchOptions);\n  } finally {\n    console.log(\n      \"[Any Proxy]\",\n      targetUrl,\n      {\n        method: method,\n      },\n      {\n        status: fetchResult?.status,\n        statusText: fetchResult?.statusText,\n      },\n    );\n  }\n\n  return fetchResult;\n}\n\nexport const PUT = handle;\nexport const GET = handle;\nexport const OPTIONS = handle;\n\nexport const runtime = \"edge\";\n","import { AppRouteRouteModule } from \"next/dist/server/future/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/future/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"/Volumes/D/github/ChatGPT-Next-Web/app/api/webdav/[...path]/route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/webdav/[...path]/route\",\n        pathname: \"/api/webdav/[...path]\",\n        filename: \"route\",\n        bundlePath: \"app/api/webdav/[...path]/route\"\n    },\n    resolvedPagePath: \"/Volumes/D/github/ChatGPT-Next-Web/app/api/webdav/[...path]/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/webdav/[...path]/route\";\nfunction patchFetch() {\n    return _patchFetch({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\nexport { routeModule, requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout, originalPathname, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","import { EdgeRouteModuleWrapper } from \"next/dist/server/web/edge-route-module-wrapper\";\n// Import the userland code.\nimport * as module from \"next-app-loader?name=app%2Fapi%2Fwebdav%2F%5B...path%5D%2Froute&page=%2Fapi%2Fwebdav%2F%5B...path%5D%2Froute&pagePath=private-next-app-dir%2Fapi%2Fwebdav%2F%5B...path%5D%2Froute.ts&appDir=%2FVolumes%2FD%2Fgithub%2FChatGPT-Next-Web%2Fapp&appPaths=%2Fapi%2Fwebdav%2F%5B...path%5D%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!private-next-app-dir/api/webdav/[...path]/route.ts?__next_edge_ssr_entry__\";\nexport const ComponentMod = module;\nexport default EdgeRouteModuleWrapper.wrap(module.routeModule);\n\n//# sourceMappingURL=edge-app-route.js.map"],"names":["module","exports","require","config","getServerSideConfig","mergedAllowedWebDavEndpoints","internalAllowedWebDavEndpoints","allowedWebDavEndpoints","filter","Boolean","domain","trim","normalizeUrl","URL","url","err","handle","req","params","fetchResult","method","NextResponse","json","body","status","folder","STORAGE_KEY","fileName","requestUrl","endpoint","searchParams","get","proxy_method","some","normalizedAllowedEndpoint","allowedEndpoint","normalizedEndpoint","hostname","pathname","startsWith","error","msg","endsWith","endpointPath","path","join","targetPath","shouldNotHaveBody","includes","toLowerCase","fetchOptions","headers","authorization","redirect","duplex","fetch","console","log","statusText","PUT","GET","OPTIONS","runtime","routeModule","module_compiled","AppRouteRouteModule","definition","kind","route_kind","x","APP_ROUTE","page","filename","bundlePath","resolvedPagePath","nextConfigOutput","userland","route_namespaceObject","requestAsyncStorage","staticGenerationAsyncStorage","serverHooks","headerHooks","staticGenerationBailout","originalPathname","patchFetch","patch_fetch","XH","ComponentMod","route_next_edge_ssr_entry_namespaceObject","next_edge_app_route_loaderabsolutePagePath_private_next_app_dir_2Fapi_2Fwebdav_2F_5B_path_5D_2Froute_ts_page_2Fapi_2Fwebdav_2F_5B_path_5D_2Froute_appDirLoader_bmV4dC1hcHAtbG9hZGVyP25hbWU9YXBwJTJGYXBpJTJGd2ViZGF2JTJGJTVCLi4ucGF0aCU1RCUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGd2ViZGF2JTJGJTVCLi4ucGF0aCU1RCUyRnJvdXRlJnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGd2ViZGF2JTJGJTVCLi4ucGF0aCU1RCUyRnJvdXRlLnRzJmFwcERpcj0lMkZWb2x1bWVzJTJGRCUyRmdpdGh1YiUyRkNoYXRHUFQtTmV4dC1XZWIlMkZhcHAmYXBwUGF0aHM9JTJGYXBpJTJGd2ViZGF2JTJGJTVCLi4ucGF0aCU1RCUyRnJvdXRlJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCE_3D_nextConfigOutput_standalone_preferredRegion_middlewareConfig_e30_3D_","edge_route_module_wrapper","a","wrap"],"sourceRoot":""}